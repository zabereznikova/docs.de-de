<Type Name="SortedList&lt;TKey,TValue&gt;" FullName="System.Collections.Generic.SortedList&lt;TKey,TValue&gt;">
  <TypeSignature Language="C#" Value="public class SortedList&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedList`2&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.SortedList`2" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_DictionaryDebugView`2))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Der Typ der Schlüssel in der Auflistung.</typeparam>
    <typeparam name="TValue">Der Typ der Werte in der Auflistung.</typeparam>
    <summary>Stellt eine Auflistung von Schlüssel-Wert-Paaren dar, die auf Grundlage der zugeordneten <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung nach den Schlüsseln sortiert sind.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.SortedList%602> generische Klasse ist ein Array von Schlüssel/Wert-Paaren mit O (Log `n`) abrufen, wobei n die Anzahl der Elemente im Wörterbuch vorhanden ist. In dieser Hinsicht ähnelt der <xref:System.Collections.Generic.SortedDictionary%602> generische Klasse. Die beiden Klassen haben ähnliche Objektmodelle und beide verfügen über O (Log `n`) abrufen. Die beiden Klassen, in denen besteht darin, im Speicher und schnelle Einfüge-und Entfernvorgänge:  
  
-   <xref:System.Collections.Generic.SortedList%602>benötigt weniger Arbeitsspeicher als <xref:System.Collections.Generic.SortedDictionary%602>.  
  
-   <xref:System.Collections.Generic.SortedDictionary%602>ist schneller einfügen und Entfernen von Vorgängen für unsortierte Daten O (Log `n`) im Gegensatz zu O (`n`) für <xref:System.Collections.Generic.SortedList%602>.  
  
-   Wenn die Liste alle auf einmal mit sortierten Daten aufgefüllt ist <xref:System.Collections.Generic.SortedList%602> ist schneller als <xref:System.Collections.Generic.SortedDictionary%602>.  
  
 Ein weiterer Unterschied zwischen der <xref:System.Collections.Generic.SortedDictionary%602> und <xref:System.Collections.Generic.SortedList%602> Klassen ist, die <xref:System.Collections.Generic.SortedList%602> effizienten indizierten Abruf von Schlüsseln und Werten über die Sammlungen zurückgegebenes unterstützt die <xref:System.Collections.Generic.SortedList%602.Keys%2A> und <xref:System.Collections.Generic.SortedList%602.Values%2A> Eigenschaften. Es ist nicht notwendig, die Listen generieren, wenn Sie die Eigenschaften zugegriffen werden, da die Listen nur als Wrapper für die internen Arrays von Schlüsseln und Werten sind. Der folgende Code zeigt die Verwendung der <xref:System.Collections.Generic.SortedList%602.Values%2A> Eigenschaft für den indizierten Abruf von Werten aus einer sortierten Liste von Zeichenfolgen:  
  
 [!code-cpp[Generic.SortedList#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#11)]
 [!code-csharp[Generic.SortedList#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#11)]
 [!code-vb[Generic.SortedList#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#11)]  
  
 <xref:System.Collections.Generic.SortedList%602>wird als ein Array von Schlüssel/Wert-Paare, anhand des Schlüssels sortiert implementiert.  Jedes Element abgerufen werden kann, als ein <xref:System.Collections.Generic.KeyValuePair%602> Objekt.  
  
 Schlüsselobjekte müssen unveränderlich sein, solange sie als Schlüssel verwendet werden die <xref:System.Collections.Generic.SortedList%602>. Jeder Schlüssel im einem <xref:System.Collections.Generic.SortedList%602> muss eindeutig sein. Ein Schlüssel kann nicht `null`, jedoch kann ein Wert, wenn der Typ der Werte in der Liste `TValue`, einen Referenztyp darstellt.  
  
 <xref:System.Collections.Generic.SortedList%602>erfordert eine Vergleichs-Implementierung zu sortieren und zu vergleichen.  Die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Schlüsseltyp `TKey` implementiert <xref:System.IComparable%601?displayProperty=nameWithType> und, dass diese Implementierung verwendet, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Schlüsseltyp `TKey` implementiert <xref:System.IComparable?displayProperty=nameWithType>.  Wenn der Schlüsseltyp `TKey` ist keine Schnittstellen implementiert, können Sie angeben, eine <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> Implementierung in einer Überladung des Konstruktors, die akzeptiert eine `comparer` Parameter.  
  
 Die Kapazität einer <xref:System.Collections.Generic.SortedList%602> ist die Anzahl der Elemente der <xref:System.Collections.Generic.SortedList%602> aufnehmen kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Generic.SortedList%602>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich. Die Kapazität kann verringert werden, durch den Aufruf <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> oder durch Festlegen der <xref:System.Collections.Generic.SortedList%602.Capacity%2A> Eigenschaft explizit. Verringern der Kapazität Arbeitsspeicher zuordnet, und kopiert alle Elemente in der <xref:System.Collections.Generic.SortedList%602>.  
  
 Für sehr große <xref:System.Collections.Generic.SortedList%602> Objekte aufweist, können Sie die maximale Kapazität auf 2 Milliarden Elemente auf einem 64-Bit-System erhöhen, indem die `enabled` Attribut des Konfigurationselements auf `true` in der Umgebung zur Laufzeit.  
  
 Die `foreach` -Anweisung der Programmiersprache c# (`for each` in C++ `For Each` in Visual Basic) ein Objekt des Typs der Elemente in der Auflistung zurück. Da die Elemente von der <xref:System.Collections.Generic.SortedList%602> sind Schlüssel/Wert-Paare der Elementtyp ist nicht der Typ des Schlüssels oder den Typ des Werts. Stattdessen der Elementtyp ist <xref:System.Collections.Generic.KeyValuePair%602>. Zum Beispiel:  
  
 [!code-cpp[Generic.SortedList#12](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#12)]
 [!code-csharp[Generic.SortedList#12](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#12)]
 [!code-vb[Generic.SortedList#12](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#12)]  
  
 Die `foreach` Anweisung ist ein Wrapper um den Enumerator, der nur das Lesen aus nicht das Schreiben auf die Auflistung zulässt.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein leeres <xref:System.Collections.Generic.SortedList%602> von Zeichenfolgen mit Zeichenfolgenschlüssel und verwendet die <xref:System.Collections.Generic.SortedList%602.Add%2A> Methode, um einige Elemente hinzuzufügen. Das Beispiel zeigt, dass die <xref:System.Collections.Generic.SortedList%602.Add%2A> -Methode löst eine <xref:System.ArgumentException> beim Versuch, einen doppelten Schlüssel hinzuzufügen.  
  
 Im Beispiel wird die <xref:System.Collections.Generic.SortedList%602.Item%2A> -Eigenschaft (Indexer in c#) zum Abrufen von Werten, die veranschaulichen, dass eine <xref:System.Collections.Generic.KeyNotFoundException> wird ausgelöst, wenn ein angeforderte Schlüssel nicht vorhanden ist und zeigt, dass der Wert mit einem Schlüssel zugeordneten ersetzt werden kann.  
  
 Im Beispiel wird gezeigt, wie mithilfe der <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> Methode als eine effizientere Methode zum Abrufen der Werte, wenn ein Programm häufig muss versuchen Schlüsselwerte, die nicht in der sortierten Liste enthalten sind, und es zeigt, wie die <xref:System.Collections.Generic.SortedList%602.ContainsKey%2A> Methode zu testen, ob ein Schlüssel vorhanden ist, vor dem Aufrufen der <c5/> Methode.  
  
 Im Beispiel wird gezeigt, wie die Schlüssel und Werte in der sortierten Liste aufgelistet werden und wie Sie die Schlüssel auflisten und-Werte allein mithilfe der <xref:System.Collections.Generic.SortedList%602.Keys%2A> Eigenschaft und die <xref:System.Collections.Generic.SortedList%602.Values%2A> Eigenschaft.  
  
 Zum Schluss das Beispiel veranschaulicht die <xref:System.Collections.Generic.SortedList%602.Remove%2A> Methode.  
  
 [!code-cpp[Generic.SortedList#1](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#1)]
 [!code-csharp[Generic.SortedList#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#1)]
 [!code-vb[Generic.SortedList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind threadsicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
 Ein <see cref="T:System.Collections.Generic.SortedList`2" /> Unterstützung für mehrere Reader gleichzeitig, solange die Auflistung nicht geändert wird.  Deshalb ist die Enumeration einer Auflistung systemintern kein threadsicheres Verfahren.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.SortedList`2" />-Klasse mit der Standardanfangskapazität und dem Standard-<see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im einem <xref:System.Collections.Generic.SortedList%602> muss gemäß der Standardvergleich eindeutig sein.  
  
 Dieser Konstruktor verwendet den Standardwert für die anfängliche Kapazität der <xref:System.Collections.Generic.SortedList%602>. Verwenden Sie zum Festlegen der Anfangskapazität der <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Int32%29> Konstruktor. Wenn die endgültige Größe der Auflistung geschätzt werden kann, die anfängliche Kapazität angeben entfällt die Notwendigkeit einer Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen zum Ausführen der <xref:System.Collections.Generic.SortedList%602>.  
  
 Dieser Konstruktor verwendet den Standardvergleich für `TKey`. Verwenden Sie zum Angeben eines Vergleichs der <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IComparer%7B%600%7D%29> Konstruktor. Die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Schlüsseltyp `TKey` implementiert <xref:System.IComparable%601?displayProperty=nameWithType> und, dass diese Implementierung verwendet, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Schlüsseltyp `TKey` implementiert <xref:System.IComparable?displayProperty=nameWithType>.  Wenn der Schlüsseltyp `TKey` ist keine Schnittstellen implementiert, können Sie angeben, eine <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> Implementierung in einer Überladung des Konstruktors, die akzeptiert eine `comparer` Parameter.  
  
 Dieser Konstruktor ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein leeres <xref:System.Collections.Generic.SortedList%602> von Zeichenfolgen mit Zeichenfolgenschlüssel und verwendet die <xref:System.Collections.Generic.SortedList%602.Add%2A> Methode, um einige Elemente hinzuzufügen. Das Beispiel zeigt, dass die <xref:System.Collections.Generic.SortedList%602.Add%2A> -Methode löst eine <xref:System.ArgumentException> beim Versuch, einen doppelten Schlüssel hinzuzufügen.  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedList%602> Klasse.  
  
 [!code-cpp[Generic.SortedList#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#2)]
 [!code-csharp[Generic.SortedList#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#2)]
 [!code-vb[Generic.SortedList#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Collections.Generic.IComparer{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleich von Schlüsseln verwendet wird.  
  
 - oder -   
  
 <see langword="null" />, um den Standard-<see cref="T:System.Collections.Generic.Comparer`1" /> für den Schlüsseltyp zu verwenden.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.SortedList`2" />-Klasse mit der Standardanfangskapazität und dem angegebenen <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im einem <xref:System.Collections.Generic.SortedList%602> muss entsprechend des angegebenen Vergleichs eindeutig sein.  
  
 Dieser Konstruktor verwendet den Standardwert für die anfängliche Kapazität der <xref:System.Collections.Generic.SortedList%602>. Verwenden Sie zum Festlegen der Anfangskapazität der <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Konstruktor. Wenn die endgültige Größe der Auflistung geschätzt werden kann, die anfängliche Kapazität angeben entfällt die Notwendigkeit einer Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen zum Ausführen der <xref:System.Collections.Generic.SortedList%602>.  
  
 Dieser Konstruktor ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine sortierte Liste mit einem Vergleich Groß-/Kleinschreibung, für die aktuelle Kultur. Das Beispiel fügt vier Elemente enthalten, von einige mit Kleinbuchstaben Schlüsseln und einige mit Großbuchstaben Schlüsseln. Anschließend wird versucht, ein Element mit einem Schlüssel hinzuzufügen, der aus einem vorhandenen Schlüssel nur durch Fall unterscheidet die resultierende Ausnahme abgefangen, und zeigt eine Fehlermeldung an. Schließlich zeigt das Beispiel die Elemente in der Groß-/Kleinschreibung Sortierreihenfolge.  
  
 [!code-csharp[Generic.SortedList.ctor_IComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_IComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_IComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_IComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">Das <see cref="T:System.Collections.Generic.IDictionary`2" />, dessen Elemente in das neue <see cref="T:System.Collections.Generic.SortedList`2" /> kopiert werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.SortedList`2" />-Klasse, die aus dem angegebenen <see cref="T:System.Collections.Generic.IDictionary`2" /> kopierte Elemente enthält, über eine der Anzahl der kopierten Elemente entsprechende Kapazität verfügt sowie den Standard-<see cref="T:System.Collections.Generic.IComparer`1" /> verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im einem <xref:System.Collections.Generic.SortedList%602> muss gemäß der Standardeinstellung eindeutig sein Comparer; ebenso alle Schlüssel in der Quelle `dictionary` muss auch gemäß der Standardvergleich eindeutig sein.  
  
 Die Kapazität des neuen <xref:System.Collections.Generic.SortedList%602> festgelegt ist, um die Anzahl der Elemente im `dictionary`, sodass keine größenanpassung stattfindet, während die Liste aufgefüllt wird.  
  
 Dieser Konstruktor verwendet den Standardvergleich für `TKey`. Verwenden Sie zum Angeben eines Vergleichs der <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Konstruktor. Die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Schlüsseltyp `TKey` implementiert <xref:System.IComparable%601?displayProperty=nameWithType> und, dass diese Implementierung verwendet, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Schlüsseltyp `TKey` implementiert <xref:System.IComparable?displayProperty=nameWithType>.  Wenn der Schlüsseltyp `TKey` ist keine Schnittstellen implementiert, können Sie angeben, eine <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> Implementierung in einer Überladung des Konstruktors, die akzeptiert eine `comparer` Parameter.  
  
 Wenn die Daten in `dictionary` sind sortiert, dieser Konstruktor ist eine O (`n`)-Vorgang, in dem `n` ist die Anzahl der Elemente im `dictionary`. Andernfalls handelt es sich um eine O (`n`*`n`) Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Collections.Generic.SortedList%602> zum Erstellen einer sortierten Kopie der Informationen in einer <xref:System.Collections.Generic.Dictionary%602>, durch Übergeben der <xref:System.Collections.Generic.Dictionary%602> auf die <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%29> Konstruktor.  
  
 [!code-csharp[Generic.SortedList.ctor_IDic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_IDic/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_IDic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_IDic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dictionary" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="dictionary" /> enthält mindestens einen doppelten Schlüssel.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die anfängliche Anzahl von Elementen, die das <see cref="T:System.Collections.Generic.SortedList`2" /> enthalten kann.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.SortedList`2" />-Klasse mit der angegebenen anfänglichen Kapazität und dem Standard-<see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im einem <xref:System.Collections.Generic.SortedList%602> muss gemäß der Standardvergleich eindeutig sein.  
  
 Die Kapazität einer <xref:System.Collections.Generic.SortedList%602> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.SortedList%602> vor dem Ändern der Größe aufnehmen kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Generic.SortedList%602>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, die anfängliche Kapazität angeben entfällt die Notwendigkeit einer Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen zum Ausführen der <xref:System.Collections.Generic.SortedList%602>.  
  
 Die Kapazität kann verringert werden, durch den Aufruf <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> oder durch Festlegen der <xref:System.Collections.Generic.SortedList%602.Capacity%2A> Eigenschaft explizit. Verringern der Kapazität Arbeitsspeicher zuordnet, und kopiert alle Elemente in der <xref:System.Collections.Generic.SortedList%602>.  
  
 Dieser Konstruktor verwendet den Standardvergleich für `TKey`. Verwenden Sie zum Angeben eines Vergleichs der <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Konstruktor. Die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Schlüsseltyp `TKey` implementiert <xref:System.IComparable%601?displayProperty=nameWithType> und, dass diese Implementierung verwendet, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Schlüsseltyp `TKey` implementiert <xref:System.IComparable?displayProperty=nameWithType>.  Wenn der Schlüsseltyp `TKey` ist keine Schnittstellen implementiert, können Sie angeben, eine <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> Implementierung in einer Überladung des Konstruktors, die akzeptiert eine `comparer` Parameter.  
  
 Dieser Konstruktor ist eine O (`n`) Vorgang, wobei `n` ist `capacity`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine sortierte Liste mit einer Anfangskapazität von 4 erstellt und füllt sie mit 4 Einträge.  
  
 [!code-csharp[Generic.SortedList.ctor_Int32#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_Int32/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_Int32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_Int32/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary, class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IComparer{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">Das <see cref="T:System.Collections.Generic.IDictionary`2" />, dessen Elemente in das neue <see cref="T:System.Collections.Generic.SortedList`2" /> kopiert werden.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleich von Schlüsseln verwendet wird.  
  
 - oder -   
  
 <see langword="null" />, um den Standard-<see cref="T:System.Collections.Generic.Comparer`1" /> für den Schlüsseltyp zu verwenden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.SortedList`2" />-Klasse, die aus dem angegebenen <see cref="T:System.Collections.Generic.IDictionary`2" /> kopierte Elemente enthält, über eine der Anzahl der kopierten Elemente entsprechende Kapazität verfügt und den angegebenen <see cref="T:System.Collections.Generic.IComparer`1" /> verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im einem <xref:System.Collections.Generic.SortedList%602> muss entsprechend den Angaben eindeutig sein Comparer; ebenso alle Schlüssel in der Quelle `dictionary` muss auch entsprechend des angegebenen Vergleichs eindeutig sein.  
  
 Die Kapazität des neuen <xref:System.Collections.Generic.SortedList%602> festgelegt ist, um die Anzahl der Elemente im `dictionary`, sodass keine größenanpassung stattfindet, während die Liste aufgefüllt wird.  
  
 Wenn die Daten in `dictionary` sind sortiert, dieser Konstruktor ist eine O (`n`)-Vorgang, in dem `n` ist die Anzahl der Elemente im `dictionary`. Andernfalls handelt es sich um eine O (`n`*`n`) Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Collections.Generic.SortedList%602> zum Erstellen einer Groß-/Kleinschreibung sortiert Kopie der Informationen in einem Groß-/Kleinschreibung <xref:System.Collections.Generic.Dictionary%602>, durch das Übergeben der <xref:System.Collections.Generic.Dictionary%602> auf die <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Konstruktor. Sind in diesem Beispiel wird die Groß-/Kleinschreibung Vergleiche für die aktuelle Kultur.  
  
 [!code-csharp[Generic.SortedList.ctor_IDicIComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_IDicIComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_IDicIComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_IDicIComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dictionary" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="dictionary" /> enthält mindestens einen doppelten Schlüssel.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int capacity, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity">Die anfängliche Anzahl von Elementen, die das <see cref="T:System.Collections.Generic.SortedList`2" /> enthalten kann.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleich von Schlüsseln verwendet wird.  
  
 - oder -   
  
 <see langword="null" />, um den Standard-<see cref="T:System.Collections.Generic.Comparer`1" /> für den Schlüsseltyp zu verwenden.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.SortedList`2" />-Klasse mit der angegebenen Anfangskapazität und dem angegebenen <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im einem <xref:System.Collections.Generic.SortedList%602> muss entsprechend des angegebenen Vergleichs eindeutig sein.  
  
 Die Kapazität einer <xref:System.Collections.Generic.SortedList%602> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.SortedList%602> vor dem Ändern der Größe aufnehmen kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Generic.SortedList%602>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, die anfängliche Kapazität angeben entfällt die Notwendigkeit einer Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen zum Ausführen der <xref:System.Collections.Generic.SortedList%602>.  
  
 Die Kapazität kann verringert werden, durch den Aufruf <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> oder durch Festlegen der <xref:System.Collections.Generic.SortedList%602.Capacity%2A> Eigenschaft explizit. Verringern der Kapazität Arbeitsspeicher zuordnet, und kopiert alle Elemente in der <xref:System.Collections.Generic.SortedList%602>.  
  
 Dieser Konstruktor ist eine O (`n`) Vorgang, wobei `n` ist `capacity`.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine sortierte Liste mit einer Kapazität von 5 und einem Vergleich Groß-/Kleinschreibung für die aktuelle Kultur. Das Beispiel fügt vier Elemente enthalten, von einige mit Kleinbuchstaben Schlüsseln und einige mit Großbuchstaben Schlüsseln. Anschließend wird versucht, ein Element mit einem Schlüssel hinzuzufügen, der aus einem vorhandenen Schlüssel nur durch Fall unterscheidet die resultierende Ausnahme abgefangen, und zeigt eine Fehlermeldung an. Schließlich zeigt das Beispiel die Elemente in der Groß-/Kleinschreibung Sortierreihenfolge.  
  
 [!code-csharp[Generic.SortedList.ctor_Int32IComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_Int32IComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_Int32IComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_Int32IComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des hinzuzufügenden Elements.</param>
        <param name="value">Der Wert des hinzuzufügenden Elements. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Fügt dem <see cref="T:System.Collections.Generic.SortedList`2" /> ein Element mit dem angegebenen Schlüssel und Wert hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Schlüssel kann nicht `null`, jedoch kann ein Wert, wenn der Typ der Werte in der sortierten Liste `TValue`, einen Referenztyp darstellt.  
  
 Sie können auch die <xref:System.Collections.Generic.SortedList%602.Item%2A> zum Hinzufügen neuer Elemente durch Festlegen des Werts eines Schlüssels, die Eigenschaft ist nicht vorhanden, der <xref:System.Collections.Generic.SortedList%602>, z. B. `myCollection["myNonexistentKey"] = myValue`. Jedoch, wenn der angegebene Schlüssel bereits vorhanden ist die <xref:System.Collections.Generic.SortedList%602>wird durch das Festlegen der <xref:System.Collections.Generic.SortedList%602.Item%2A> Eigenschaft überschreibt den alten Wert. Im Gegensatz dazu die <xref:System.Collections.Generic.SortedList%602.Add%2A> Methode vorhandene Elemente nicht geändert.  
  
 Wenn <xref:System.Collections.Generic.SortedList%602.Count%2A> bereits gleich <xref:System.Collections.Generic.SortedList%602.Capacity%2A>, die Kapazität der <xref:System.Collections.Generic.SortedList%602> wird von automatisch Neuzuordnen des internen Arrays erhöht und die vorhandenen Elemente werden in das neue Array kopiert, bevor das neue Element hinzugefügt wird.  
  
 Diese Methode ist eine O (`n`) Vorgang für unsortierte Daten, wobei `n` ist <xref:System.Collections.Generic.SortedList%602.Count%2A>. Es ist eine O (Log `n`) Vorgang, wenn das neue Element am Ende der Liste hinzugefügt wird. Wenn die Einfügung eine Größe verursacht, wird der Vorgang ist O (`n`).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein leeres <xref:System.Collections.Generic.SortedList%602> von Zeichenfolgen mit Zeichenfolgenschlüssel und verwendet die <xref:System.Collections.Generic.SortedList%602.Add%2A> Methode, um einige Elemente hinzuzufügen. Das Beispiel zeigt, dass die <xref:System.Collections.Generic.SortedList%602.Add%2A> -Methode löst eine <xref:System.ArgumentException> beim Versuch, einen doppelten Schlüssel hinzuzufügen.  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedList%602> Klasse.  
  
 [!code-cpp[Generic.SortedList#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#2)]
 [!code-csharp[Generic.SortedList#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#2)]
 [!code-vb[Generic.SortedList#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">In <see cref="T:System.Collections.Generic.SortedList`2" /> ist bereits ein Element mit demselben Schlüssel enthalten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente ab, die die <see cref="T:System.Collections.Generic.SortedList`2" /> enthalten kann, oder legt diese fest.</summary>
        <value>Die anfängliche Anzahl von Elementen, die die <see cref="T:System.Collections.Generic.SortedList`2" /> enthalten kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A>ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.SortedList%602> speichern können. <xref:System.Collections.Generic.SortedList%602.Count%2A>ist die Anzahl der Elemente, die tatsächlich in der <xref:System.Collections.Generic.SortedList%602>.  
  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A>ist immer größer als oder gleich <xref:System.Collections.Generic.SortedList%602.Count%2A>. Wenn <xref:System.Collections.Generic.SortedList%602.Count%2A> überschreitet <xref:System.Collections.Generic.SortedList%602.Capacity%2A> beim Hinzufügen von Elementen, die Kapazität erhöht wird, indem automatisch Neuzuordnen des internen Arrays vor dem Kopieren der alten Elemente und das Hinzufügen neuer Elemente.  
  
 Die Kapazität kann verringert werden, durch den Aufruf <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> oder durch Festlegen der <xref:System.Collections.Generic.SortedList%602.Capacity%2A> Eigenschaft explizit. Wenn der Wert des <xref:System.Collections.Generic.SortedList%602.Capacity%2A> explizit festgelegt ist, des internen Arrays ist auch zugewiesen, um die angegebene Kapazität aufzunehmen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang. Festlegen der Eigenschaft ist eine O (`n`) Vorgang, wobei `n` ist die neue Kapazität.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Collections.Generic.SortedList`2.Capacity" /> ist auf einen Wert festgelegt, der kleiner als <see cref="P:System.Collections.Generic.SortedList`2.Count" /> ist.</exception>
        <exception cref="T:System.OutOfMemoryException">Im System ist nicht genügend Arbeitsspeicher verfügbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus der <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedList%602.Count%2A>ist auf 0 (null) festgelegt, und Verweise auf andere Objekte von Elementen in der Auflistung werden ebenfalls freigegeben.  
  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A>bleibt unverändert. Die Kapazität des Zurücksetzen der <xref:System.Collections.Generic.SortedList%602>, rufen Sie <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> , oder legt die <xref:System.Collections.Generic.SortedList%602.Capacity%2A> Eigenschaft direkt. Indem Sie eine leere <xref:System.Collections.Generic.SortedList%602> legt die Kapazität der <xref:System.Collections.Generic.SortedList%602> auf die festgelegte Standardkapazität.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Collections.Generic.IComparer`1" /> für die sortierte Liste ab.</summary>
        <value>Der <see cref="T:System.IComparable`1" /> für die aktuelle <see cref="T:System.Collections.Generic.SortedList`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der im <see cref="T:System.Collections.Generic.SortedList`2" /> zu suchende Schlüssel.</param>
        <summary>Stellt fest, ob der <see cref="T:System.Collections.Generic.SortedList`2" /> einen bestimmten Schlüssel enthält.</summary>
        <returns>
          <see langword="true" />, wenn das <see cref="T:System.Collections.Generic.SortedList`2" /> ein Element mit dem angegebenen Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine O (Log `n`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Collections.Generic.SortedList%602.ContainsKey%2A> Methode zu testen, ob ein Schlüssel vorhanden, vor dem Aufruf ist der <xref:System.Collections.Generic.SortedList%602.Add%2A> Methode. Außerdem wird gezeigt, wie die <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> Methode zum Abrufen von Werten, die ist eine effiziente Möglichkeit zum Abrufen der Werte, wenn eine Anwendung häufig Schlüssel versucht, die nicht in der sortierten Liste enthalten sind. Schließlich zeigt es der am wenigsten effizienten Methode zum Testen, ob der Schlüssel vorhanden sind, mithilfe der <xref:System.Collections.Generic.SortedList%602.Item%2A> -Eigenschaft (Indexer in c#).  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedList%602> Klasse.  
  
 [!code-cpp[Generic.SortedList#6](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#6)]
 [!code-csharp[Generic.SortedList#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#6)]
 [!code-vb[Generic.SortedList#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#6)]  
[!code-cpp[Generic.SortedList#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#5)]
[!code-csharp[Generic.SortedList#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#5)]
[!code-vb[Generic.SortedList#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#5)]  
[!code-cpp[Generic.SortedList#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#4)]
[!code-csharp[Generic.SortedList#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#4)]
[!code-vb[Generic.SortedList#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public bool ContainsValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">Der im <see cref="T:System.Collections.Generic.SortedList`2" /> zu suchende Wert. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Ermittelt, ob die <see cref="T:System.Collections.Generic.SortedList`2" /> einen bestimmten Wert enthält.</summary>
        <returns>
          <see langword="true" />, wenn das <see cref="T:System.Collections.Generic.SortedList`2" /> ein Element mit dem angegebenen Wert enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt mithilfe des Standardcomparers Gleichheit <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> für den Werttyp `TValue`.  <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>überprüft, ob der Werttyp `TValue` implementiert <xref:System.IComparable%601?displayProperty=nameWithType> und, dass diese Implementierung verwendet, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Werttyp `TValue` implementiert <xref:System.IComparable?displayProperty=nameWithType>.  Wenn der Werttyp `TValue` keine implementiert eine Schnittstelle, die diese Methode verwendet <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Diese Methode führt eine lineare Suche. aus diesem Grund ist die durchschnittliche Ausführungszeit proportional zur <xref:System.Collections.Generic.SortedList%602.Count%2A>. Diese Methode ist, also eine O (`n`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Schlüssel-Wert-Paare im <see cref="T:System.Collections.Generic.SortedList`2" /> ab.</summary>
        <value>Die Anzahl der Schlüssel-Wert-Paare im <see cref="T:System.Collections.Generic.SortedList`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A>ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.SortedList%602> speichern können. <xref:System.Collections.Generic.SortedList%602.Count%2A>ist die Anzahl der Elemente, die tatsächlich in der <xref:System.Collections.Generic.SortedList%602>.  
  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A>ist immer größer als oder gleich <xref:System.Collections.Generic.SortedList%602.Count%2A>. Wenn <xref:System.Collections.Generic.SortedList%602.Count%2A> überschreitet <xref:System.Collections.Generic.SortedList%602.Capacity%2A> beim Hinzufügen von Elementen, die Kapazität erhöht wird, indem automatisch Neuzuordnen des internen Arrays vor dem Kopieren der alten Elemente und das Hinzufügen neuer Elemente.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der die <see cref="T:System.Collections.Generic.SortedList`2" /> durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerator`1" /> vom Typ <see cref="T:System.Collections.Generic.KeyValuePair`2" /> für die <see cref="T:System.Collections.Generic.SortedList`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach` -Anweisung der Programmiersprache c# (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren.  Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Das Wörterbuch wird in einer sortierten Reihenfolge mithilfe einer internen Struktur beibehalten. Die richtige Sortierposition jedes neue Element positioniert ist, und die Struktur wird angepasst, um die Sortierreihenfolge zu gewährleisten, wenn ein Element entfernt wird. Beim Aufzählen von ist, wird die Sortierreihenfolge beibehalten.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.Generic.IEnumerator%601.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.Generic.IEnumerator%601.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false`. Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgeben `false`. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType> sind nicht synchronisiert.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfKey">
      <MemberSignature Language="C#" Value="public int IndexOfKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.IndexOfKey(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der im <see cref="T:System.Collections.Generic.SortedList`2" /> zu suchende Schlüssel.</param>
        <summary>Sucht den angegebenen Schlüssel und gibt den nullbasierten Index innerhalb der gesamten <see cref="T:System.Collections.Generic.SortedList`2" /> zurück.</summary>
        <returns>Der nullbasierte Index des <paramref name="key" /> innerhalb der gesamten <see cref="T:System.Collections.Generic.SortedList`2" />, sofern er gefunden wird, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt eine binäre Suche; Diese Methode ist daher eine O (Log `n`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOfValue">
      <MemberSignature Language="C#" Value="public int IndexOfValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">Der im <see cref="T:System.Collections.Generic.SortedList`2" /> zu suchende Wert.  Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Sucht den angegebenen Wert und gibt den nullbasierten Index des ersten Vorkommens innerhalb der gesamten <see cref="T:System.Collections.Generic.SortedList`2" /> zurück.</summary>
        <returns>Der nullbasierte Index des ggf. ersten Vorkommens von <paramref name="value" /> in der gesamten <see cref="T:System.Collections.Generic.SortedList`2" />, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt mithilfe des Standardcomparers Gleichheit <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> für den Werttyp `TValue`.  <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>überprüft, ob der Werttyp `TValue` implementiert <xref:System.IComparable%601?displayProperty=nameWithType> und, dass diese Implementierung verwendet, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Werttyp `TValue` implementiert <xref:System.IComparable?displayProperty=nameWithType>.  Wenn der Werttyp `TValue` keine implementiert eine Schnittstelle, die diese Methode verwendet <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Diese Methode führt eine lineare Suche. aus diesem Grund ist die durchschnittliche Ausführungszeit proportional zur <xref:System.Collections.Generic.SortedList%602.Count%2A>. Diese Methode ist, also eine O (`n`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Item(`0)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel, dessen Wert abgerufen oder festgelegt werden soll.</param>
        <summary>Ruft den Wert ab, der dem angegebenen Schlüssel zugeordnet ist, oder legt diesen fest.</summary>
        <value>Der dem angegebenen Schlüssel zugeordnete Wert. Wenn der angegebene Schlüssel nicht gefunden wird, löst ein Get-Vorgang eine <see cref="T:System.Collections.Generic.KeyNotFoundException" /> aus, und durch einen Set-Vorgang wird ein neues Element mit dem angegebenen Schlüssel erstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht den Zugriff auf ein bestimmtes Element in der Auflistung mithilfe folgender Syntax: `myCollection[key]`.  
  
 Ein Schlüssel kann nicht `null`, jedoch kann ein Wert, wenn der Typ der Werte in der Liste `TValue`, einen Referenztyp darstellt.  
  
 Wenn der Schlüssel nicht gefunden wird, wenn ein Wert abgerufen wird, <xref:System.Collections.Generic.KeyNotFoundException> ausgelöst wird. Wenn der Schlüssel nicht gefunden wird Wenn ein Wert festgelegt wird, werden die Schlüssel und Wert hinzugefügt.  
  
 Sie können auch die <xref:System.Collections.Generic.SortedList%602.Item%2A> zum Hinzufügen neuer Elemente durch Festlegen des Werts eines Schlüssels, die Eigenschaft ist nicht vorhanden, der <xref:System.Collections.Generic.SortedList%602>, z. B. `myCollection["myNonexistentKey"] = myValue`. Jedoch, wenn der angegebene Schlüssel bereits vorhanden ist die <xref:System.Collections.Generic.SortedList%602>wird durch das Festlegen der <xref:System.Collections.Generic.SortedList%602.Item%2A> Eigenschaft überschreibt den alten Wert. Im Gegensatz dazu die <xref:System.Collections.Generic.SortedList%602.Add%2A> Methode vorhandene Elemente nicht geändert.  
  
 Die Programmiersprache c# verwendet das Schlüsselwort der Indexer definieren die <xref:System.Collections.Generic.SortedList%602.Item%2A> Eigenschaft. Visual Basic implementiert <xref:System.Collections.Generic.SortedList%602.Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 Das Abrufen des Werts dieser Eigenschaft ist eine O (Log `n`) Vorgang, wobei n ist <xref:System.Collections.Generic.SortedList%602.Count%2A>. Festlegen der Eigenschaft ist eine O (Log `n`) Vorgang, wenn der Schlüssel bereits in der <xref:System.Collections.Generic.SortedList%602>. Wenn der Schlüssel nicht in der Liste enthalten ist, Festlegen der Eigenschaft ist eine O (`n`) Vorgang für unsortierte Daten oder O (Log `n`) Wenn das neue Element am Ende der Liste hinzugefügt wird. Wenn die Einfügung eine Größe verursacht, wird der Vorgang ist O (`n`).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Collections.Generic.SortedList%602.Item%2A> -Eigenschaft (Indexer in c#) zum Abrufen von Werten, die veranschaulichen, dass eine <xref:System.Collections.Generic.KeyNotFoundException> wird ausgelöst, wenn ein angeforderte Schlüssel nicht vorhanden ist und zeigt, dass der Wert mit einem Schlüssel zugeordneten ersetzt werden kann.  
  
 Außerdem wird gezeigt, wie Sie die <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> Methode als eine effizientere Methode zum Abrufen der Werte, wenn eine Anwendung häufig Schlüsselwerte, die nicht in der sortierten Liste enthalten sind.  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedList%602> Klasse.  
  
 [!code-cpp[Generic.SortedList#3](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#3)]
 [!code-csharp[Generic.SortedList#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#3)]
 [!code-vb[Generic.SortedList#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#3)]  
[!code-cpp[Generic.SortedList#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#4)]
[!code-csharp[Generic.SortedList#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#4)]
[!code-vb[Generic.SortedList#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#4)]  
[!code-cpp[Generic.SortedList#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#5)]
[!code-csharp[Generic.SortedList#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#5)]
[!code-vb[Generic.SortedList#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Die Eigenschaft wird abgerufen und <paramref name="key" /> in der Auflistung nicht vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;TKey&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;!TKey&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung mit den Schlüsseln in der <see cref="T:System.Collections.Generic.SortedList`2" /> in sortierter Reihenfolge auf.</summary>
        <value>Eine <see cref="T:System.Collections.Generic.IList`1" />, die die Schlüssel im <see cref="T:System.Collections.Generic.SortedList`2" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der Schlüssel in der <xref:System.Collections.Generic.IList%601> unterscheidet sich die Reihenfolge, in der <xref:System.Collections.Generic.SortedList%602>.  
  
 Das zurückgegebene <xref:System.Collections.Generic.IList%601> ist keine statische Kopie; stattdessen die <xref:System.Collections.Generic.IList%601> verweist auf die Schlüssel in der ursprünglichen <xref:System.Collections.Generic.SortedList%602>. Daher ändert sich in der <xref:System.Collections.Generic.SortedList%602> im berücksichtigt werden weiterhin die <xref:System.Collections.Generic.IList%601>.  
  
 Die zurückgegebene Auflistung der <xref:System.Collections.Generic.SortedList%602.Keys%2A> Eigenschaft ermöglicht eine effiziente Möglichkeit zum Abrufen von Schlüsseln über einen Index. Es ist nicht erforderlich, um die Liste neu generieren, wenn die Eigenschaft zugegriffen wird, da die Liste nur als Wrapper für das interne Array von Schlüssel ist. Der folgende Code zeigt die Verwendung der <xref:System.Collections.Generic.SortedList%602.Keys%2A> Eigenschaft für den indizierten Abruf von Schlüsseln aus einer sortierten Liste von Elementen mit Zeichenfolgenschlüssel:  
  
 [!code-cpp[Generic.SortedList#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#11)]
 [!code-csharp[Generic.SortedList#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#11)]
 [!code-vb[Generic.SortedList#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#11)]  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie beim Auflisten der Schlüssel in der sortierten Liste mithilfe der <xref:System.Collections.Generic.SortedList%602.Keys%2A> -Eigenschaft, und wie die Schlüssel und Werte in der sortierten Liste aufgelistet werden.  
  
 Außerdem wird gezeigt, wie Sie die <xref:System.Collections.Generic.SortedList%602.Keys%2A> -Eigenschaft für effiziente indizierten Abruf von Schlüsseln.  
  
 Dieser Code ist Teil eines größeren Beispiels, das kompiliert und ausgeführt werden kann. Siehe <xref:System.Collections.Generic.SortedList%602>.  
  
 [!code-cpp[Generic.SortedList#9](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#9)]
 [!code-csharp[Generic.SortedList#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#9)]
 [!code-vb[Generic.SortedList#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#9)]  
[!code-cpp[Generic.SortedList#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#7)]
[!code-csharp[Generic.SortedList#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#7)]
[!code-vb[Generic.SortedList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu entfernenden Elements.</param>
        <summary>Entfernt das Element mit dem angegebenen Schlüssel aus dem <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <returns>
          <see langword="true" />, wenn das Element erfolgreich entfernt wurde, andernfalls <see langword="false" />.  Diese Methode gibt auch dann <see langword="false" /> zurück, wenn <paramref name="key" /> nicht im ursprünglichen <see cref="T:System.Collections.Generic.SortedList`2" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt eine binäre Suche; jedoch die Elemente nach oben verschoben öffnen vor Ort ausfüllen, daher ist diese Methode eine O (`n`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die sortierte Liste mit Schlüssel/Wert-Paar Aufheben der <xref:System.Collections.Generic.SortedList%602.Remove%2A> Methode.  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedList%602> Klasse.  
  
 [!code-cpp[Generic.SortedList#10](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#10)]
 [!code-csharp[Generic.SortedList#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#10)]
 [!code-vb[Generic.SortedList#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des zu entfernenden Elements.</param>
        <summary>Entfernt das Element am angegebenen Index aus der <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt eine binäre Suche; jedoch die Elemente nach oben verschoben öffnen vor Ort ausfüllen, daher ist diese Methode eine O (`n`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als Null.  
  
 - oder -   
  
 <paramref name="index" /> ist größer oder gleich <see cref="P:System.Collections.Generic.SortedList`2.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="arrayIndex">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.ICollection" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index im <c>Array</c> an dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die Elemente der <see cref="T:System.Collections.ICollection" /> in ein <see cref="T:System.Array" />, beginnend bei einem bestimmten <see cref="T:System.Array" />-Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn der Typ der Quelle <xref:System.Collections.ICollection> kann nicht automatisch in den Typ des Ziels umgewandelt werden `array`, die nicht generische Implementierungen von <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> auslösen <xref:System.InvalidCastException>, während die Implementierungen die generischen auslösen <xref:System.ArgumentException>.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="array" />verfügt nicht über nullbasierter Indizierung.  
  
 - oder -   
  
 Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.ICollection" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />.  
  
 - oder -   
  
 Der Typ des Quell-<see cref="T:System.Collections.ICollection" />s kann nicht automatisch in den Typ des Ziel-<paramref name="array" />s umgewandelt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#ICollection#IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist.</summary>
        <value>
          <see langword="true" />, wenn der Zugriff auf das <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.SortedList`2" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType> sind nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Die <xref:System.Collections.ICollection.SyncRoot%2A> Eigenschaft gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt zu sperren, bevor der Zugriff auf die Auflistung.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#ICollection#SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.  In der Standardimplementierung der <see cref="T:System.Collections.Generic.SortedList`2" /> gibt diese Eigenschaft immer die aktuelle Instanz zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType> sind nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren. Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Die <xref:System.Collections.ICollection.SyncRoot%2A> Eigenschaft gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt zu sperren, bevor der Zugriff auf die Auflistung. Der folgende Code zeigt die Verwendung der <xref:System.Collections.ICollection.SyncRoot%2A> -Eigenschaft für c#, C++ und Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Das <see cref="T:System.Object" />, das als Schlüssel für das hinzuzufügende Element verwendet werden soll.</param>
        <param name="value">Das <see cref="T:System.Object" />, das als Wert für das hinzuzufügende Element verwendet werden soll.</param>
        <summary>Fügt der <see cref="T:System.Collections.IDictionary" />-Schnittstelle ein Element mit dem angegebenen Schlüssel und Wert hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch die <xref:System.Collections.IDictionary.Item%2A> Eigenschaft zum Hinzufügen neuer Elemente durch Festlegen der Wert eines Schlüssels, der nicht vorhanden ist, im Wörterbuch enthalten z. B. `myCollection["myNonexistentKey"] = myValue`. Wenn der angegebene Schlüssel bereits im Wörterbuch vorhanden ist, jedoch durch Festlegen der <xref:System.Collections.IDictionary.Item%2A> Eigenschaft überschreibt den alten Wert. Im Gegensatz dazu die <xref:System.Collections.IDictionary.Add%2A> Methode vorhandene Elemente nicht geändert.  
  
 Diese Methode ist eine O (`n`) Vorgang für unsortierte Daten, wobei `n` ist <xref:System.Collections.Generic.SortedList%602.Count%2A>. Es ist eine O (Log `n`) Vorgang, wenn das neue Element am Ende der Liste hinzugefügt wird. Wenn die Einfügung eine Größe verursacht, wird der Vorgang ist O (`n`).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie den Zugriff auf die <xref:System.Collections.Generic.SortedList%602> -Klasse über die <xref:System.Collections.IDictionary?displayProperty=nameWithType> Schnittstelle. Das Codebeispiel erstellt ein leeres <xref:System.Collections.Generic.SortedList%602> von Zeichenfolgen mit Zeichenfolgenschlüssel und verwendet die <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> Methode, um einige Elemente hinzuzufügen. Das Beispiel zeigt, dass die <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> -Methode löst eine <xref:System.ArgumentException> beim Versuch, einen doppelten Schlüssel hinzuzufügen, oder wenn ein Schlüssel oder Wert, der den falschen Datentyp angegeben wird.  
  
 Das Codebeispiel veranschaulicht die Verwendung anderer Member des der <xref:System.Collections.IDictionary?displayProperty=nameWithType> Schnittstelle.  
  
 [!code-csharp[Generic.SortedList.IDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.IDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" />verfügt über einen Typ, der nicht zugeordnet werden kann, um den Typ des Schlüssels ist <paramref name="TKey" /> von der <see cref="T:System.Collections.IDictionary" />.  
  
 - oder -   
  
 <paramref name="value" />verfügt über einen Typ, der nicht zugeordnet werden, kann dem Werttyp ist <paramref name="TValue" /> von der <see cref="T:System.Collections.IDictionary" />.  
  
 - oder -   
  
 In <see cref="T:System.Collections.IDictionary" /> ist bereits ein Element mit demselben Schlüssel enthalten.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der im <see cref="T:System.Collections.IDictionary" /> zu suchende Schlüssel.</param>
        <summary>Ermittelt, ob das <see cref="T:System.Collections.IDictionary" /> ein Element mit dem angegebenen Schlüssel enthält.</summary>
        <returns>
          <see langword="true" />, wenn das <see cref="T:System.Collections.IDictionary" /> ein Element mit dem Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `false` Wenn `key` verfügt über einen Typ, der nicht zugeordnet werden kann, um den Typ des Schlüssels ist `TKey` von der <xref:System.Collections.Generic.SortedList%602>.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Contains%2A> Methode der <xref:System.Collections.IDictionary?displayProperty=nameWithType> eine Verbindung mit einer <xref:System.Collections.Generic.SortedList%602>. Im Beispiel wird veranschaulicht, dass der Methodenrückgabe `false` , wenn ein Schlüssel über den falschen Datentyp angegeben wird.  
  
 Das Codebeispiel ist Teil eines umfangreicheren Beispiels, einschließlich der Ausgabe, für die <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> Methode.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#6)]
[!code-vb[Generic.SortedList.IDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#6)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Collections.IDictionaryEnumerator" /> für das <see cref="T:System.Collections.IDictionary" /> zurück.</summary>
        <returns>Ein <see cref="T:System.Collections.IDictionaryEnumerator" /> für das <see cref="T:System.Collections.IDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach` -Anweisung der Programmiersprache c# (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren.  Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist <xref:System.Collections.IDictionaryEnumerator.Entry%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IDictionaryEnumerator.Entry%2A> gelesen werden kann.  
  
 <xref:System.Collections.IDictionaryEnumerator.Entry%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IDictionaryEnumerator.Entry%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false`. Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <xref:System.Collections.IEnumerator.MoveNext%2A> auch zurückgeben `false`. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IDictionaryEnumerator.Entry%2A> ist nicht definiert. Um <xref:System.Collections.IDictionaryEnumerator.Entry%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType> sind nicht synchronisiert.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Aufzählen von Schlüssel/Wert-Paare in der sortierten Liste mithilfe der `foreach` Anweisung (`For Each` in Visual Basic `for each` in C++), der die Verwendung des Enumerators verborgen. Beachten Sie insbesondere, dass der Enumerator für die <xref:System.Collections.IDictionary?displayProperty=nameWithType> -Schnittstelle gibt <xref:System.Collections.DictionaryEntry> Objekte anstelle <xref:System.Collections.Generic.KeyValuePair%602> Objekte.  
  
 Das Codebeispiel ist Teil eines umfangreicheren Beispiels, einschließlich der Ausgabe, für die <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> Methode.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedList.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.IDictionary" /> eine feste Größe aufweist.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="T:System.Collections.IDictionary" /> eine feste Größe aufweist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.SortedList`2" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Auflistung mit fester Größe lässt das Hinzufügen oder Entfernen von Elementen nach dem Erstellen der Auflistung nicht zu. Vorhandene Elemente können jedoch geändert werden.  
  
 Eine Auflistung mit fester Größe ist einfach eine Auflistung mit einem Wrapper, der verhindert, dass hinzufügen und Entfernen von Elementen. Deshalb spiegelt die Auflistung mit fester Größe zum Änderungen vorgenommen werden, auf die zugrunde liegende Auflistung, z. B. das Hinzufügen oder Entfernen von Elementen, die Änderungen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.IDictionary" /> schreibgeschützt ist.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="T:System.Collections.IDictionary" /> schreibgeschützt ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.SortedList`2" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist eine Auflistung mit einem Wrapper, der verhindert, dass die Auflistung ändern; Wenn Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, spiegelt die schreibgeschützte Auflistung daher diese Änderungen wider.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Item(System.Object)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des Elements, das abgerufen oder festgelegt werden soll.</param>
        <summary>Ruft das Element mit dem angegebenen Schlüssel ab oder legt dieses fest.</summary>
        <value>Das Element mit dem angegebenen Schlüssel oder <see langword="null" />, wenn <paramref name="key" /> nicht im Wörterbuch enthalten ist oder <paramref name="key" /> einen Typ aufweist, der dem Schlüsseltyp <paramref name="TKey" /> des <see cref="T:System.Collections.Generic.SortedList`2" /> nicht zugeordnet werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `null` Wenn `key` verfügt über einen Typ, der nicht zugeordnet werden kann, um den Typ des Schlüssels ist `TKey` von der <xref:System.Collections.Generic.SortedList%602>.  
  
 Diese Eigenschaft ermöglicht den Zugriff auf ein bestimmtes Element in der Auflistung mithilfe folgender Syntax: `myCollection[key]`.  
  
 Sie können auch die <xref:System.Collections.IDictionary.Item%2A> Eigenschaft zum Hinzufügen neuer Elemente durch Festlegen der Wert eines Schlüssels, der nicht vorhanden ist, im Wörterbuch enthalten z. B. `myCollection["myNonexistentKey"] = myValue`. Wenn der angegebene Schlüssel bereits im Wörterbuch vorhanden ist, jedoch durch Festlegen der <xref:System.Collections.IDictionary.Item%2A> Eigenschaft überschreibt den alten Wert. Im Gegensatz dazu die <xref:System.Collections.IDictionary.Add%2A> Methode vorhandene Elemente nicht geändert.  
  
 Die C#-Sprache verwendet die [dies](~/docs/csharp/language-reference/keywords/this.md) -Schlüsselwort zum Definieren der Indexer anstatt zu implementieren die <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A> Eigenschaft. Visual Basic implementiert <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 Das Abrufen des Werts dieser Eigenschaft ist eine O (Log `n`) Vorgang, wobei n ist <xref:System.Collections.Generic.SortedList%602.Count%2A>. Festlegen der Eigenschaft ist eine O (Log `n`) Vorgang, wenn der Schlüssel bereits in der <xref:System.Collections.Generic.SortedList%602>. Wenn der Schlüssel nicht in der Liste enthalten ist, Festlegen der Eigenschaft ist eine O (`n`) Vorgang für unsortierte Daten oder O (Log `n`) Wenn das neue Element am Ende der Liste hinzugefügt wird. Wenn die Einfügung eine Größe verursacht, wird der Vorgang ist O (`n`).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A> -Eigenschaft (Indexer in c#) des der <xref:System.Collections.IDictionary?displayProperty=nameWithType> eine Verbindung mit einer <xref:System.Collections.Generic.SortedList%602>, und weisen die Eigenschaft unterscheidet sich von der <xref:System.Collections.Generic.SortedList%602.Item%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wie im Beispiel wird gezeigt, dass die <xref:System.Collections.Generic.SortedList%602.Item%2A?displayProperty=nameWithType> -Eigenschaft, die <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> Eigenschaft kann einen vorhandenen Schlüssel zugeordneten Wert ändern und können verwendet werden, um ein neues Schlüssel/Wert-Paar hinzuzufügen, wenn der angegebene Schlüssel nicht in der sortierten Liste enthalten ist. Außerdem wird gezeigt, die im Gegensatz zu den <xref:System.Collections.Generic.SortedList%602.Item%2A?displayProperty=nameWithType> -Eigenschaft, die <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> Eigenschaft löst keine Ausnahme aus, wenn `key` nicht in der sortierten Liste gibt einen null-Verweis stattdessen. Schließlich im Beispiel wird veranschaulicht, dass beim Abrufen der <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> Eigenschaft gibt einen null-Verweis zurück, wenn `key` ist nicht der richtigen Datentyp und das Festlegen der Eigenschaft löst eine Ausnahme aus, wenn `key` ist nicht der richtigen Datentyp hin.  
  
 Das Codebeispiel ist Teil eines umfangreicheren Beispiels, einschließlich der Ausgabe, für die <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> Methode.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#3)]
[!code-vb[Generic.SortedList.IDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#3)]  
[!code-csharp[Generic.SortedList.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedList.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#4)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ein Wert zugewiesen wird, und <paramref name="key" /> verfügt über einen Typ, der nicht zugeordnet werden kann, um den Typ des Schlüssels ist <paramref name="TKey" /> von der <see cref="T:System.Collections.Generic.SortedList`2" />.  
  
 - oder -   
  
 Ein Wert zugewiesen wird, und <paramref name="value" /> verfügt über einen Typ, der nicht zugeordnet werden, kann dem Werttyp ist <paramref name="TValue" /> von der <see cref="T:System.Collections.Generic.SortedList`2" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Collections.ICollection" /> ab, die die Schlüssel des <see cref="T:System.Collections.IDictionary" /> enthält.</summary>
        <value>Eine <see cref="T:System.Collections.ICollection" />, die die Schlüssel des <see cref="T:System.Collections.IDictionary" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der Schlüssel in der <xref:System.Collections.ICollection> unterscheidet sich die Reihenfolge, in der <xref:System.Collections.Generic.SortedList%602>.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Collections.IDictionary.Keys%2A> Eigenschaft von der <xref:System.Collections.IDictionary?displayProperty=nameWithType> eine Verbindung mit einer <xref:System.Collections.Generic.SortedDictionary%602>, um die Liste der Schlüssel im Wörterbuch. Im Beispiel wird gezeigt, wie die Schlüssel/Wert-Paare in der sortierten Liste aufgezählt; Beachten Sie, dass der Enumerator für die <xref:System.Collections.IDictionary?displayProperty=nameWithType> -Schnittstelle gibt <xref:System.Collections.DictionaryEntry> Objekte statt <xref:System.Collections.Generic.KeyValuePair%602> Objekte.  
  
 Das Codebeispiel ist Teil eines umfangreicheren Beispiels, einschließlich der Ausgabe, für die <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> Methode.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#9)]
[!code-vb[Generic.SortedList.IDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#9)]  
[!code-csharp[Generic.SortedList.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedList.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu entfernenden Elements.</param>
        <summary>Entfernt das Element mit dem angegebenen Schlüssel aus dem <see cref="T:System.Collections.IDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt eine binäre Suche; jedoch die Elemente nach oben verschoben öffnen vor Ort ausfüllen, daher ist diese Methode eine O (`n`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Remove%2A> von der <xref:System.Collections.IDictionary?displayProperty=nameWithType> eine Verbindung mit einem <xref:System.Collections.Generic.SortedList%602>.  
  
 Das Codebeispiel ist Teil eines umfangreicheren Beispiels, einschließlich der Ausgabe, für die <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> Methode.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#10)]
[!code-vb[Generic.SortedList.IDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#10)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Collections.ICollection" /> ab, die die Werte im <see cref="T:System.Collections.IDictionary" /> enthält.</summary>
        <value>Eine <see cref="T:System.Collections.ICollection" />, die die Werte im <see cref="T:System.Collections.IDictionary" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der Werte in der <xref:System.Collections.ICollection> unterscheidet sich die Reihenfolge, in der <xref:System.Collections.Generic.SortedList%602>.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Values%2A> Eigenschaft von der <xref:System.Collections.IDictionary?displayProperty=nameWithType> eine Verbindung mit einer <xref:System.Collections.Generic.SortedList%602>, um die Liste der Werte in der sortierten Liste. Im Beispiel wird gezeigt, wie die Schlüssel/Wert-Paare in der sortierten Liste aufgezählt; Beachten Sie, dass der Enumerator für die <xref:System.Collections.IDictionary?displayProperty=nameWithType> -Schnittstelle gibt <xref:System.Collections.DictionaryEntry> Objekte statt <xref:System.Collections.Generic.KeyValuePair%602> Objekte.  
  
 Das Codebeispiel ist Teil eines umfangreicheren Beispiels, einschließlich der Ausgabe, für die <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> Methode.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#8)]
[!code-vb[Generic.SortedList.IDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#8)]  
[!code-csharp[Generic.SortedList.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedList.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach` -Anweisung der Programmiersprache c# (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren.  Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist <xref:System.Collections.IEnumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false`. Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <xref:System.Collections.IEnumerator.MoveNext%2A> auch zurückgeben `false`. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType> sind nicht synchronisiert.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.TrimExcess" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt die Kapazität auf die Anzahl der tatsächlich im <see cref="T:System.Collections.Generic.SortedList`2" /> befindlichen Elemente fest, sofern diese Anzahl unter 90 Prozent der aktuellen Kapazität liegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um Speicher für eine Auflistung Mehraufwand zu minimieren, wenn die Auflistung keine neuen Elemente hinzugefügt werden. Die Kosten erneut zugewiesen werden, und Kopieren einer großen <xref:System.Collections.Generic.SortedList%602> jedoch sehr aufwändig sein kann daher die <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> Methode bewirkt nichts, wenn die Liste an mehr als 90 % der Kapazität ist. Dadurch wird vermieden, für einen relativ kleinen zu großen neuzuordnungen Kosten anfallen.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 Zurücksetzen einer <xref:System.Collections.Generic.SortedList%602> Aufrufen auf ihren ursprünglichen Zustand der <xref:System.Collections.Generic.SortedList%602.Clear%2A> Methode vor dem Aufruf <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> Methode. Indem Sie eine leere <xref:System.Collections.Generic.SortedList%602> legt die Kapazität der <xref:System.Collections.Generic.SortedList%602> auf die festgelegte Standardkapazität.  
  
 Die Kapazität kann auch festgelegt werden mithilfe der <xref:System.Collections.Generic.SortedList%602.Capacity%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.TryGetValue(`0,`1@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel, dessen Wert abgerufen werden soll.</param>
        <param name="value">Bei der Rückgabe dieser Methode den zugeordneten Wert mit dem angegebenen Schlüssel, wenn der Schlüssel gefunden wird; andernfalls der Standardwert für den Typ der <c>Wert</c> Parameter. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Ruft den dem angegebenen Schlüssel zugeordneten Wert ab.</summary>
        <returns>
          <see langword="true" />, wenn das <see cref="T:System.Collections.Generic.SortedList`2" /> ein Element mit dem angegebenen Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kombiniert die Funktionalität der <xref:System.Collections.Generic.SortedList%602.ContainsKey%2A> Methode und die <xref:System.Collections.Generic.SortedList%602.Item%2A> Eigenschaft.  
  
 Wenn der Schlüssel nicht gefunden wird, und klicken Sie dann die `value` Parameter Ruft den entsprechenden Standardwert für den Werttyp `TValue`; z. B. 0 (null) für ganzzahlige Typen, `false` für boolesche Typen und `null` für Verweistypen.  
  
 Diese Methode führt eine binäre Suche; Diese Methode ist daher eine O (Log `n`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 Im Beispiel wird gezeigt, wie mithilfe der <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> Methode als eine effizientere Methode zum Abrufen von Werten in einem Programm, das häufig Schlüssel versucht, die nicht in der sortierten Liste enthalten sind. Im Beispiel wird auch gezeigt, wie die <xref:System.Collections.Generic.SortedList%602.Item%2A> -Eigenschaft (Indexer in c#) löst Ausnahmen aus, wenn beim Abrufen von nicht vorhandenen Schlüssel.  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedList%602> Klasse.  
  
 [!code-cpp[Generic.SortedList#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#5)]
 [!code-csharp[Generic.SortedList#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#5)]
 [!code-vb[Generic.SortedList#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#5)]  
[!code-cpp[Generic.SortedList#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#4)]
[!code-csharp[Generic.SortedList#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#4)]
[!code-vb[Generic.SortedList#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;TValue&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;!TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung ab, die die Werte im <see cref="T:System.Collections.Generic.SortedList`2" /> enthält.</summary>
        <value>Eine <see cref="T:System.Collections.Generic.IList`1" />, die die Werte im <see cref="T:System.Collections.Generic.SortedList`2" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der Werte in der <xref:System.Collections.Generic.IList%601> unterscheidet sich die Reihenfolge, in der <xref:System.Collections.Generic.SortedList%602>.  
  
 Das zurückgegebene <xref:System.Collections.Generic.IList%601> ist keine statische Kopie; stattdessen die <xref:System.Collections.Generic.IList%601> verweist auf die Werte in der ursprünglichen <xref:System.Collections.Generic.SortedList%602>. Daher ändert sich in der <xref:System.Collections.Generic.SortedList%602> im berücksichtigt werden weiterhin die <xref:System.Collections.Generic.IList%601>.  
  
 Die zurückgegebene Auflistung der <xref:System.Collections.Generic.SortedList%602.Values%2A> Eigenschaft ermöglicht eine effiziente Möglichkeit, Werte nach Index abzurufen. Es ist nicht erforderlich, um die Liste neu generieren, wenn die Eigenschaft zugegriffen wird, da die Liste nur als Wrapper für die interne Wertearray ist. Der folgende Code zeigt die Verwendung der <xref:System.Collections.Generic.SortedList%602.Values%2A> Eigenschaft für den indizierten Abruf von Werten aus einer sortierten Liste von Zeichenfolgen:  
  
 [!code-cpp[Generic.SortedList#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#11)]
 [!code-csharp[Generic.SortedList#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#11)]
 [!code-vb[Generic.SortedList#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#11)]  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Dieses Codebeispiel zeigt, wie Sie die Werte in der sortierten Liste mit Auflisten der <xref:System.Collections.Generic.SortedList%602.Values%2A> -Eigenschaft, und wie die Schlüssel und Werte in der sortierten Liste aufgelistet werden.  
  
 Außerdem wird gezeigt, wie Sie die <xref:System.Collections.Generic.SortedList%602.Values%2A> -Eigenschaft für effiziente indizierten Abruf von Werten.  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedList%602> Klasse.  
  
 [!code-cpp[Generic.SortedList#8](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#8)]
 [!code-csharp[Generic.SortedList#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#8)]
 [!code-vb[Generic.SortedList#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#8)]  
[!code-cpp[Generic.SortedList#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#7)]
[!code-csharp[Generic.SortedList#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#7)]
[!code-vb[Generic.SortedList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
