<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Der Typ der Elemente in der Liste.</typeparam>
    <summary>Stellt eine stark typisierte Liste von Objekten dar, auf die über einen Index zugegriffen werden kann. Stellt Methoden zum Durchsuchen, Sortieren und Bearbeiten von Listen bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die .NET Framework-Quellcodes für diesen Typ finden Sie unter der [Verweisquelle](http://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs#cf7f4095e4de7646). Sie können den Quellcode online Durchsuchen, Referenz für die Offlineanzeige herunterladen und schrittweise durchlaufen (inklusive Patches und Updates) während des Debuggens; finden Sie unter [Anweisungen](http://referencesource.microsoft.com/).  
  
 Die <xref:System.Collections.Generic.List%601> Klasse ist die generische Entsprechung der der <xref:System.Collections.ArrayList> Klasse. Implementiert die <xref:System.Collections.Generic.IList%601> generische Schnittstelle mithilfe eines Arrays, dessen dynamisch als vergrößert wird, erforderlich.  
  
 Können Sie Elemente zum Hinzufügen einer <xref:System.Collections.Generic.List%601> mithilfe der <xref:System.Collections.Generic.List%601.Add%2A> oder <xref:System.Collections.Generic.List%601.AddRange%2A> Methoden.  
  
 Die <xref:System.Collections.Generic.List%601> Klasse verwendet einen Gleichheitsvergleich und einen reihenfolgenvergleich.  
  
-   Methoden, z. B. <xref:System.Collections.Generic.List%601.Contains%2A>, <xref:System.Collections.Generic.List%601.IndexOf%2A>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A>, und <xref:System.Collections.Generic.Dictionary%602.Remove%2A> verwenden einen Gleichheitsvergleich für die Listenelemente. Der Standardgleichheitsvergleich für den Typ `T` wird wie folgt bestimmt. Wenn Typ `T` implementiert die <xref:System.IEquatable%601> generische Schnittstelle, dann ist der Gleichheitsvergleich die <xref:System.IEquatable%601.Equals%28%600%29> -Methode dieser Schnittstelle; andernfalls der Standardgleichheitsvergleich ist <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.  
  
-   Methoden, z. B. <xref:System.Collections.Generic.List%601.BinarySearch%2A> und <xref:System.Collections.Generic.List%601.Sort%2A> verwenden einen reihenfolgenvergleich für Listenelemente. Der Standardvergleich für den Typ `T` wird wie folgt bestimmt.  Wenn Typ `T` implementiert die <xref:System.IComparable%601> generische Schnittstelle, und klicken Sie dann auf die standardmäßige Vergleichsfunktion ist die <xref:System.IComparable%601.CompareTo%28%600%29> -Methode dieser Schnittstelle; andernfalls, wenn Typ `T` implementiert die nicht generische <xref:System.IComparable> -Schnittstelle, und klicken Sie dann auf die Standardeinstellung Vergleich der <xref:System.IComparable.CompareTo%28System.Object%29> -Methode dieser Schnittstelle. Wenn Typ `T` keine Schnittstelle implementiert wird, gibt es keinen Standardvergleich, und ein Vergleich oder ein Vergleichsdelegat muss explizit angegeben werden.  
  
 Die <xref:System.Collections.Generic.List%601> ist nicht garantiert werden.  Sie sortieren, müssen die <xref:System.Collections.Generic.List%601> vor dem Ausführen von Vorgängen (z. B. <xref:System.Collections.Generic.List%601.BinarySearch%2A>), erfordern die <xref:System.Collections.Generic.List%601> sortiert werden.  
  
 Elemente in dieser Auflistung können über einen Ganzzahlenindex zugegriffen werden.  In dieser Auflistung Indizes sind nullbasiert.  
  
 Für sehr große <xref:System.Collections.Generic.List%601> Objekte aufweist, können Sie die maximale Kapazität auf 2 Milliarden Elemente auf einem 64-Bit-System erhöhen, indem die `enabled` Attribut des Konfigurationselements auf `true` in der Umgebung zur Laufzeit.  
  
 <xref:System.Collections.Generic.List%601>akzeptiert `null` als ein gültiger Wert für Referenztypen und doppelte Elemente lässt.  
  
 Eine unveränderliche Version der <xref:System.Collections.Generic.List%601> Klasse, finden Sie unter <xref:System.Collections.Immutable.ImmutableList%601>.  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Bei der Entscheidung, ob verwendet die <xref:System.Collections.Generic.List%601> oder <xref:System.Collections.ArrayList> Klasse, die beide über ähnliche Funktionen verfügen, beachten Sie, dass die <xref:System.Collections.Generic.List%601> Klasse bietet eine bessere Leistung in den meisten Fällen und typsicher ist. Wenn ein Verweistyp, für den Typ verwendet wird `T` von der <xref:System.Collections.Generic.List%601> -Klasse, die das Verhalten der beiden Klassen ist identisch. Jedoch, wenn ein Werttyp, für den Typ verwendet wird `T`, Implementierung und Boxing Probleme berücksichtigt werden müssen.  
  
 Wenn ein Werttyp, für den Typ verwendet wird `T`, generiert der Compiler eine Implementierung von der <xref:System.Collections.Generic.List%601> -Klasse speziell für diesen Wert. Bedeutet, dass ein Listenelement von einem <xref:System.Collections.Generic.List%601> Objekt keinen geschachtelt werden, bevor das Element kann verwendet werden, nach dem Erstellen von ca. 500 Listenelemente der Arbeitsspeicher nicht boxing Listenelemente gespeichert ist und größer als der Arbeitsspeicher verwendet, um die Implementierung der Klasse zu generieren.  
  
 Vergewissern Sie sich den Werttyp, der für den Typ verwendet `T` implementiert die <xref:System.IEquatable%601> generische Schnittstelle. Wenn nicht, Methoden, z. B. <xref:System.Collections.Generic.List%601.Contains%2A> aufrufen, müssen die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> -Methode, die das betreffende Listenelement schachtelt. Wenn der Werttyp implementiert die <xref:System.IComparable> -Schnittstelle, und Sie besitzen, den Quellcode, implementieren Sie zusätzlich die <xref:System.IComparable%601> generischen Schnittstelle, um zu verhindern, dass die <xref:System.Collections.Generic.List%601.BinarySearch%2A> und <xref:System.Collections.Generic.List%601.Sort%2A> Methoden aus den Listenelementen boxing. Wenn Sie den Quellcode nicht besitzen, übergeben Sie ein <xref:System.Collections.Generic.IComparer%601> -Objekt an die <xref:System.Collections.Generic.List%601.BinarySearch%2A> und <xref:System.Collections.Generic.List%601.Sort%2A> Methoden  
  
 Es ist von Vorteil, die Typ-spezifische Implementierung der verwenden die <xref:System.Collections.Generic.List%601> Klasse anstelle der <xref:System.Collections.ArrayList> Klasse oder eine Auflistung von stark typisierten Wrapper selbst schreiben. Der Grund ist Ihre Implementierung müssen .NET Framework bereits für Sie erledigt, und die common Language Runtime Microsoft intermediate Language-Code und Metadaten, die Ihre Implementierung nicht freigeben.  
  
## <a name="f-considerations"></a>F#-Überlegungen  
 Die <xref:System.Collections.Generic.List%601> Klasse dient nur selten in f#-Code.  Stattdessen [listet](http://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d), sind unveränderlich, einfach verknüpfte Listen, werden in der Regel bevorzugt. Eine Liste von f# stellt eine geordnete, unveränderliche Reihe von Werten und wird für die Verwendung in funktionalen Stil-Entwicklung unterstützt. Bei Verwendung von f#, die <xref:System.Collections.Generic.List%601> Klasse in der Regel verweist auf die [ResizeArray\<' t >](https://msdn.microsoft.com/library/ee353447.aspx) -typabkürzung um Namenskonflikte mit F#-Listen zu vermeiden  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Hinzufügen, entfernen, und fügen Sie ein einfaches Geschäftsobjekt in einem <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
  
 Das folgende Beispiel zeigt verschiedene Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generische Klasse vom Typzeichenfolge. (Ein Beispiel für eine <xref:System.Collections.Generic.List%601> mit komplexen Typen finden Sie unter der <xref:System.Collections.Generic.List%601.Contains%2A> Methode.)  
  
 Der Standardkonstruktor wird verwendet, um eine Liste von Zeichenfolgen mit der Standardkapazität zu erstellen. Die <xref:System.Collections.Generic.List%601.Capacity%2A> -Eigenschaft wird angezeigt, und klicken Sie dann die <xref:System.Collections.Generic.List%601.Add%2A> Methode wird verwendet, um mehrere Elemente hinzuzufügen. Sind die Elemente aufgeführt, und die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft wird angezeigt, zusammen mit der <xref:System.Collections.Generic.List%601.Count%2A> -Eigenschaft, um anzugeben, dass die Kapazität nach Bedarf erhöht wurde.  
  
 Die <xref:System.Collections.Generic.List%601.Contains%2A> Methode wird verwendet, um das Vorhandensein eines Elements in der Liste Testen der <xref:System.Collections.Generic.List%601.Insert%2A> Methode wird verwendet, um ein neues Element in der Mitte der Liste einfügen, und der Inhalt der Liste wird erneut angezeigt.  
  
 Die Standardeinstellung <xref:System.Collections.Generic.List%601.Item%2A> -Eigenschaft (Indexer in c#) wird verwendet, um ein Element abgerufen werden die <xref:System.Collections.Generic.List%601.Remove%2A> Methode wird verwendet, um die erste Instanz des zuvor hinzugefügten doppelten Elements entfernt, und der Inhalt wird erneut angezeigt. Die <xref:System.Collections.Generic.List%601.Remove%2A> -Methode immer die erste gefundene Instanz entfernt.  
  
 Die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode wird verwendet, um die Kapazität entsprechend der Anzahl reduzieren und die <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaften werden angezeigt. Wenn die nicht verwendete Kapazität weniger als 10 Prozent der Gesamtkapazität hätte, würde die Größe die Liste nicht geändert wurde.  
  
 Schließlich die <xref:System.Collections.Generic.List%601.Clear%2A> Methode wird verwendet, um alle Elemente aus der Liste zu entfernen und die <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaften werden angezeigt.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind threadsicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
 Es ist sicherer, die für mehrere Lesevorgänge Ausführen einer <see cref="T:System.Collections.Generic.List`1" />, jedoch Probleme können auftreten, wenn die Auflistung geändert wird, während sie gelesen wird. Um Threadsicherheit zu gewährleisten, Sperren Sie die Auflistung während eines Lesevorgangs oder Schreibvorgang. Damit kann eine Auflistung durch mehrere Threads zum Lesen und Schreiben zugegriffen werden kann, müssen Sie eine eigene Synchronisierung implementieren. Sammlungen mit integrierten Synchronisierung, finden Sie unter den Klassen in der <see cref="N:System.Collections.Concurrent" /> Namespace. Eine Alternative grundsätzlich Thread-sichere finden Sie unter der <see cref="T:System.Collections.Immutable.ImmutableList`1" /> Klasse.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.List`1" />-Klasse, die die Standardanfangskapazität aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.List%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.List%601> aufnehmen kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Generic.List%601>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, mithilfe der <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> Konstruktor und die Angabe der anfänglichen Kapazität entfällt die Notwendigkeit einer Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen zum Ausführen der <xref:System.Collections.Generic.List%601>.  
  
 Die Kapazität kann verringert werden, durch Aufrufen der <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode oder durch Festlegen der <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft explizit. Verringern der Kapazität Arbeitsspeicher zuordnet, und kopiert alle Elemente in der <xref:System.Collections.Generic.List%601>.  
  
 Dieser Konstruktor ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht den Standardkonstruktor, der die <xref:System.Collections.Generic.List%601> generische Klasse. Der Standardkonstruktor erstellt eine Liste mit der Standardkapazität ein, wie durch Anzeigen der <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft.  
  
 Im Beispiel fügt, fügt ein und entfernt die Elemente, die angezeigt wird, wie die Kapazität ändert, werden diese Methoden verwendet werden.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, deren Elemente in die neue Liste kopiert werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.List`1" />-Klasse, die aus der angegebenen Auflistung kopierte Elemente enthält und eine ausreichende Kapazität für die Anzahl der kopierten Elemente aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente kopiert werden, auf die <xref:System.Collections.Generic.List%601> in der gleichen Reihenfolge, die sie vom Enumerator der Auflistung gelesen werden.  
  
 Dieser Konstruktor ist eine O (*n*) Vorgang, wobei * n * ist die Anzahl der Elemente im `collection`.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.%23ctor%2A> Konstruktor und die verschiedenen Methoden des der <xref:System.Collections.Generic.List%601> -Klasse, die für Bereiche verwendet. Ein Array von Zeichenfolgen erstellt und übergeben des Konstruktors und Auffüllen der Liste mit den Elementen des Arrays. Die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft wird dann angezeigt, um anzuzeigen, dass die anfängliche Kapazität genau ist, welcher zum Speichern der Eingabeelemente erforderlich ist.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die Anzahl von Elementen, die anfänglich in der neuen Liste gespeichert werden können.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.List`1" />-Klasse, die die angegebene Anfangskapazität aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.List%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.List%601> aufnehmen kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Generic.List%601>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, die anfängliche Kapazität angeben entfällt die Notwendigkeit einer Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen zum Ausführen der <xref:System.Collections.Generic.List%601>.  
  
 Die Kapazität kann verringert werden, durch Aufrufen der <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode oder durch Festlegen der <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft explizit. Verringern der Kapazität Arbeitsspeicher zuordnet, und kopiert alle Elemente in der <xref:System.Collections.Generic.List%601>.  
  
 Dieser Konstruktor ist eine O (*n*) Vorgang, wobei * n * ist `capacity`.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> Konstruktor. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen mit einer Kapazität von 4, wird erstellt, da die endgültige Größe der Liste genau 4 bekannt ist. Die Liste wird mit vier Zeichenfolgen aufgefüllt und eine schreibgeschützte Kopie wird erstellt, mit der <xref:System.Collections.Generic.List%601.AsReadOnly%2A> Methode.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das Objekt, das am Ende der <see cref="T:System.Collections.Generic.List`1" /> hinzugefügt werden soll. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Fügt am Ende der <see cref="T:System.Collections.Generic.List`1" /> ein Objekt hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>akzeptiert `null` als ein gültiger Wert für Referenztypen und doppelte Elemente lässt.  
  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> bereits gleich <xref:System.Collections.Generic.List%601.Capacity%2A>, die Kapazität der <xref:System.Collections.Generic.List%601> wird von automatisch Neuzuordnen des internen Arrays erhöht und die vorhandenen Elemente werden in das neue Array kopiert, bevor das neue Element hinzugefügt wird.  
  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> ist kleiner als <xref:System.Collections.Generic.List%601.Capacity%2A>, diese Methode ist ein o(1)-Vorgang. Wenn die Kapazität für das neue Element erhöht werden muss, wird diese Methode eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Hinzufügen, entfernen, und fügen Sie ein einfaches Geschäftsobjekt in einem <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
  
 Das folgende Beispiel zeigt verschiedene Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generischen Klasse, einschließlich der <xref:System.Collections.Generic.List%601.Add%2A> Methode. Der Standardkonstruktor wird verwendet, um eine Liste von Zeichenfolgen mit einer Kapazität von 0 zu erstellen. Die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft wird angezeigt, und klicken Sie dann die <xref:System.Collections.Generic.List%601.Add%2A> Methode wird verwendet, um mehrere Elemente hinzuzufügen. Sind die Elemente aufgeführt, und die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft wird angezeigt, zusammen mit der <xref:System.Collections.Generic.List%601.Count%2A> -Eigenschaft, um anzugeben, dass die Kapazität nach Bedarf erhöht wurde.  
  
 Andere Eigenschaften und Methoden werden zum Suchen, einfügen und Entfernen von Elementen aus der Liste, und schließlich auf die Liste zu löschen.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Die Sammlung, deren Elemente am Ende der <see cref="T:System.Collections.Generic.List`1" /> hinzugefügt werden sollen. Die Auflistung selbst kann nicht <see langword="null" />, es kann jedoch Elemente enthalten, die <see langword="null" />, wenn Typ <c>T</c> einen Referenztyp darstellt.</param>
        <summary>Fügt die Elemente der angegebenen Auflistung am Ende von <see cref="T:System.Collections.Generic.List`1" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der Elemente in der Auflistung wird beibehalten, der <xref:System.Collections.Generic.List%601>.  
  
 Wenn die neue <xref:System.Collections.Generic.List%601.Count%2A> (das aktuelle <xref:System.Collections.Generic.List%601.Count%2A> plus die Größe der Auflistung) größer als <xref:System.Collections.Generic.List%601.Capacity%2A>, die Kapazität der <xref:System.Collections.Generic.List%601> wird erhöht, indem automatisch Neuzuordnen des internen Arrays an die neuen Elemente und die vorhandene Elemente werden in das neue Array kopiert, bevor die neuen Elemente hinzugefügt werden.  
  
 Wenn die <xref:System.Collections.Generic.List%601> die neuen Elemente aufnehmen kann, ohne Erhöhung der <xref:System.Collections.Generic.List%601.Capacity%2A>, diese Methode ist eine O (*n*)-Vorgang, in dem * n * ist die Anzahl der Elemente, die hinzugefügt werden sollen. Wenn die Kapazität erhöht werden, um die neuen Elemente aufnehmen muss, wird diese Methode eine O (*n* + *m*) Vorgang, wobei * n * ist die Anzahl der Elemente hinzugefügt werden und *m* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.AddRange%2A> -Methode und die verschiedenen Methoden des der <xref:System.Collections.Generic.List%601> -Klasse, die für Bereiche verwendet. Ein Array von Zeichenfolgen erstellt und übergeben des Konstruktors und Auffüllen der Liste mit den Elementen des Arrays. Die <xref:System.Collections.Generic.List%601.AddRange%2A> -Methode aufgerufen wird, mit der Liste als Argument. Das Ergebnis ist, dass die aktuellen Elemente der Liste bis zum Ende der Liste alle Elemente duplizieren hinzugefügt werden.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen schreibgeschützten <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />-Wrapper für die aktuelle Auflistung zurück.</summary>
        <returns>Ein Objekt, das als nur-Lese Wrapper um die aktuelle fungiert <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu verhindern, dass alle Änderungen an der <xref:System.Collections.Generic.List%601> Objekt, das nur über diesen Wrapper verfügbar gemacht. Ein <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> Objekt macht Methoden, die die Auflistung zu ändern. Jedoch wenn Änderungen, auf die zugrunde liegende vorgenommen werden <xref:System.Collections.Generic.List%601> -Objekt, die schreibgeschützte Auflistung gibt die Änderungen wieder.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.AsReadOnly%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen mit einer Kapazität von 4, wird erstellt, da die endgültige Größe der Liste genau 4 bekannt ist. Die Liste wird mit vier Zeichenfolgen aufgefüllt und die <xref:System.Collections.Generic.List%601.AsReadOnly%2A> Methode wird verwendet, um ein schreibgeschütztes abrufen <xref:System.Collections.Generic.IList%601> Implementierung der generischen Schnittstelle, die die ursprüngliche Liste umschließt.  
  
 Auf "Coelophysis" ein Element der ursprünglichen Liste festgelegt wird, mithilfe der <xref:System.Collections.Generic.List%601.Item%2A> -Eigenschaft (Indexer in c#), und die Inhalte der schreibgeschützten Liste werden erneut angezeigt, dass sie einfach ein Wrapper für die ursprüngliche Liste ist.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Durchsucht mithilfe des Standardcomparers die gesamte sortierte <see cref="T:System.Collections.Generic.List`1" /> nach einem Element und gibt den nullbasierten Index des Elements zurück.</summary>
        <returns>Der nullbasierte Index von <paramref name="item" /> in der sortierten <see cref="T:System.Collections.Generic.List`1" />, sofern <paramref name="item" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="item" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> für Typ `T` bestimmt die Reihenfolge der Listenelemente. Die <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> -Eigenschaft überprüft, ob der Typ `T` implementiert die <xref:System.IComparable%601> generische Schnittstelle und, dass diese Implementierung verwendet, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable> Schnittstelle.  Wenn Typ `T` implementiert nicht die beiden Schnittstellen <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> löst eine <xref:System.InvalidOperationException>.  
  
 Die <xref:System.Collections.Generic.List%601> muss bereits entsprechend die Vergleichs-Implementierung; sortiert werden, andernfalls ist das Ergebnis falsch.  
  
 Vergleichen von `null` mit einem beliebigen Verweistyp ist zulässig und löst keine Ausnahme aus, bei Verwendung der <xref:System.IComparable%601> generische Schnittstelle. Beim Sortieren `null` gilt als kleiner als ein anderes Objekt sein.  
  
 Wenn die <xref:System.Collections.Generic.List%601> enthält mehr als ein Element mit dem gleichen Wert gibt die Methode nur einen vorkommen und eine vorkommen, allerdings nicht unbedingt das erste Schema zurückgeben kann.  
  
 Wenn die <xref:System.Collections.Generic.List%601> enthält keinen den angegebenen Wert gibt die Methode eine negative ganze Zahl zurück. Sie können die bitweise Komplementoperation (~) anwenden, auf diese negative ganze Zahl, um den Index des ersten Elements abzurufen, die größer als der gesuchte Wert ist. Beim Einfügen des Werts in der <xref:System.Collections.Generic.List%601>, dieser Index sollte als die Einfügemarke verwendet werden, um die Sortierreihenfolge zu verwalten.  
  
 Diese Methode ist eine O (Log * n *)-Vorgang, in dem * n * ist die Anzahl der Elemente im Bereich.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort> -methodenüberladung und die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> methodenüberladung. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit vier Zeichenfolgen, ohne bestimmte Reihenfolge gefüllt ist. Die Liste wird angezeigt, sortiert und erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> methodenüberladung wird dann verwendet, um zwei Zeichenfolgen zu suchen, die nicht in der Liste enthalten sind und die <xref:System.Collections.Generic.List%601.Insert%2A> Methode dient zum Einfügen. Der Rückgabewert der <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> Methode ist in jedem Fall negativ, da die Zeichenfolgen nicht in der Liste enthalten sind. Dem bitweisen Komplement (der ~-Operator in c# und Visual C++ `Xor` -1 in Visual Basic) dieses negative Zahl wird der Index des ersten Elements in der Liste, die größer als die Suchzeichenfolge und Einfügen an dieser Stelle ist beibehalten sortieren Reihenfolge. Die zweite Suchzeichenfolge ist größer als ein Element in der Liste, daher ist die Position der Einfügemarke am Ende der Liste.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Standardvergleich <see cref="P:System.Collections.Generic.Comparer`1.Default" /> eine Implementierung von kann nicht gefunden werden. die <see cref="T:System.IComparable`1" /> generische Schnittstelle oder die <see cref="T:System.IComparable" /> -Schnittstelle für den Typ <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
 - oder -   
  
 <see langword="null" /> zur Verwendung des Standardcomparers <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Durchsucht mithilfe des angegebenen Comparers die gesamte sortierte <see cref="T:System.Collections.Generic.List`1" /> nach einem Element und gibt den nullbasierten Index des Elements zurück.</summary>
        <returns>Der nullbasierte Index von <paramref name="item" /> in der sortierten <see cref="T:System.Collections.Generic.List`1" />, sofern <paramref name="item" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="item" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich wird bestimmt, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer> -Instanz wie der Vergleich, der Groß-/Kleinschreibung Zeichenfolgensuchen ausgeführt werden.  
  
 Wenn `comparer` angegeben wird, werden die Elemente der <xref:System.Collections.Generic.List%601> verglichen werden, auf den angegebenen Wert mit dem angegebenen <xref:System.Collections.Generic.IComparer%601> Implementierung.  
  
 Wenn `comparer` ist `null`, die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable%601> generische Schnittstelle und, dass diese Implementierung verwendet, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable> Schnittstelle.  Wenn Typ `T` implementiert nicht die beiden Schnittstellen <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> löst <xref:System.InvalidOperationException>.  
  
 Die <xref:System.Collections.Generic.List%601> muss bereits entsprechend die Vergleichs-Implementierung; sortiert werden, andernfalls ist das Ergebnis falsch.  
  
 Vergleichen von `null` mit einem beliebigen Verweistyp ist zulässig und löst keine Ausnahme aus, bei Verwendung der <xref:System.IComparable%601> generische Schnittstelle. Beim Sortieren `null` gilt als kleiner als ein anderes Objekt sein.  
  
 Wenn die <xref:System.Collections.Generic.List%601> enthält mehr als ein Element mit dem gleichen Wert gibt die Methode nur einen vorkommen und eine vorkommen, allerdings nicht unbedingt das erste Schema zurückgeben kann.  
  
 Wenn die <xref:System.Collections.Generic.List%601> enthält keinen den angegebenen Wert gibt die Methode eine negative ganze Zahl zurück. Sie können die bitweise Komplementoperation (~) anwenden, auf diese negative ganze Zahl, um den Index des ersten Elements abzurufen, die größer als der gesuchte Wert ist. Beim Einfügen des Werts in der <xref:System.Collections.Generic.List%601>, dieser Index sollte als die Einfügemarke verwendet werden, um die Sortierreihenfolge zu verwalten.  
  
 Diese Methode ist eine O (Log * n *)-Vorgang, in dem * n * ist die Anzahl der Elemente im Bereich.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> -methodenüberladung und die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> methodenüberladung.  
  
 Im Beispiel wird einen alternativen Vergleich für DinoCompare implementiert-Zeichenfolgen definiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich funktioniert wie folgt: zunächst der verglichenen Elemente getestet werden `null`, und ein null-Verweis als kleiner als ein Wert ungleich Null behandelt wird. Zweitens die Zeichenfolgenlängen verglichen werden, und die Zeichenfolge längere ist als größer werden. Wenn die Länge gleich sind, wird im dritten gewöhnliche Zeichenfolgenvergleich verwendet.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit vier Zeichenfolgen, ohne bestimmte Reihenfolge gefüllt ist. Die Liste ist, mit dem alternativen Vergleich sortiert und angezeigten erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> methodenüberladung wird dann verwendet, um mehrere Zeichenfolgen zu suchen, die nicht in der Liste den alternativen Vergleich eingefügt werden. Die <xref:System.Collections.Generic.List%601.Insert%2A> Methode verwendet, um die Zeichenfolgen einzufügen. Diese beiden Methoden befinden sich in der Funktion mit dem Namen `SearchAndInsert`, zusammen mit Code, das bitweise Komplement (der ~-Operator in c# und Visual C++ `Xor` -1 in Visual Basic) für die zurückgegebene negative Zahl <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> und verwenden es als ein Index für Einfügen der neuen Zeichenfolge an.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> eine Implementierung von kann nicht gefunden werden. die <see cref="T:System.IComparable`1" /> generische Schnittstelle oder die <see cref="T:System.IComparable" /> -Schnittstelle für den Typ <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des zu durchsuchenden Bereichs.</param>
        <param name="count">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="item">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, wenn der Standardvergleich <see cref="P:System.Collections.Generic.Comparer`1.Default" /> verwendet werden soll.</param>
        <summary>Durchsucht mithilfe des angegebenen Vergleichs einen Bereich von Elementen in der sortierten <see cref="T:System.Collections.Generic.List`1" /> nach einem Element und gibt den nullbasierten Index des Elements zurück.</summary>
        <returns>Der nullbasierte Index von <paramref name="item" /> in der sortierten <see cref="T:System.Collections.Generic.List`1" />, sofern <paramref name="item" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="item" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich wird bestimmt, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer> -Instanz wie der Vergleich, der Groß-/Kleinschreibung Zeichenfolgensuchen ausgeführt werden.  
  
 Wenn `comparer` angegeben wird, werden die Elemente der <xref:System.Collections.Generic.List%601> verglichen werden, auf den angegebenen Wert mit dem angegebenen <xref:System.Collections.Generic.IComparer%601> Implementierung.  
  
 Wenn `comparer` ist `null`, die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable%601> generische Schnittstelle und, dass diese Implementierung verwendet, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable> Schnittstelle.  Wenn Typ `T` implementiert nicht die beiden Schnittstellen <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> löst <xref:System.InvalidOperationException>.  
  
 Die <xref:System.Collections.Generic.List%601> muss bereits entsprechend die Vergleichs-Implementierung; sortiert werden, andernfalls ist das Ergebnis falsch.  
  
 Vergleichen von `null` mit einem beliebigen Verweistyp ist zulässig und löst keine Ausnahme aus, bei Verwendung der <xref:System.IComparable%601> generische Schnittstelle. Beim Sortieren `null` gilt als kleiner als ein anderes Objekt sein.  
  
 Wenn die <xref:System.Collections.Generic.List%601> enthält mehr als ein Element mit dem gleichen Wert gibt die Methode nur einen vorkommen und eine vorkommen, allerdings nicht unbedingt das erste Schema zurückgeben kann.  
  
 Wenn die <xref:System.Collections.Generic.List%601> enthält keinen den angegebenen Wert gibt die Methode eine negative ganze Zahl zurück. Sie können die bitweise Komplementoperation (~) anwenden, auf diese negative ganze Zahl, um den Index des ersten Elements abzurufen, die größer als der gesuchte Wert ist. Beim Einfügen des Werts in der <xref:System.Collections.Generic.List%601>, dieser Index sollte als die Einfügemarke verwendet werden, um die Sortierreihenfolge zu verwalten.  
  
 Diese Methode ist eine O (Log * n *)-Vorgang, in dem * n * ist die Anzahl der Elemente im Bereich.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> -methodenüberladung und die <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> methodenüberladung.  
  
 Im Beispiel wird einen alternativen Vergleich für DinoCompare implementiert-Zeichenfolgen definiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich funktioniert wie folgt: zunächst der verglichenen Elemente getestet werden `null`, und ein null-Verweis als kleiner als ein Wert ungleich Null behandelt wird. Zweitens die Zeichenfolgenlängen verglichen werden, und die Zeichenfolge längere ist als größer werden. Wenn die Länge gleich sind, wird im dritten gewöhnliche Zeichenfolgenvergleich verwendet.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit den Namen der fünf pflanzenfressenden Dinosauriern und drei zur Dinosaurier aufgefüllt wird. In jedem von zwei Gruppen sind die Namen nicht in der Sortierreihenfolge vor. Die Liste wird angezeigt, die Gruppe der Pflanzenfresser wird mit dem alternativen Vergleich sortiert und die Liste wird erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> methodenüberladung wird dann verwendet, um nur die Gruppe der Pflanzenfresser "Brachiosaurus" suchen. Die Zeichenfolge nicht gefunden wird, und das bitweise Komplement (der ~-Operator in c# und Visual C++ `Xor` -1 in Visual Basic) für die zurückgegebene negative Zahl der <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Methode dient als Index zum Einfügen der neuen Zeichenfolge.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> eine Implementierung von kann nicht gefunden werden. die <see cref="T:System.IComparable`1" /> generische Schnittstelle oder die <see cref="T:System.IComparable" /> -Schnittstelle für den Typ <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtzahl der Elemente ab, die die interne Datenstruktur ohne Änderung der Größe aufnehmen kann, oder legt diese Anzahl fest.</summary>
        <value>Die Anzahl der Elemente, die <see cref="T:System.Collections.Generic.List`1" /> enthalten kann, bevor eine Größenanpassung erforderlich ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A>ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.List%601> können speichern, bevor eine größenanpassung erforderlich ist, ist dagegen <xref:System.Collections.Generic.List%601.Count%2A> ist die Anzahl der Elemente, die tatsächlich in der <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A>ist immer größer als oder gleich <xref:System.Collections.Generic.List%601.Count%2A>. Wenn <xref:System.Collections.Generic.List%601.Count%2A> überschreitet <xref:System.Collections.Generic.List%601.Capacity%2A> beim Hinzufügen von Elementen, die Kapazität erhöht wird, indem automatisch Neuzuordnen des internen Arrays vor dem Kopieren der alten Elemente und das Hinzufügen neuer Elemente.  
  
 Wenn die Kapazität wesentlich größer als die Anzahl ist und Sie die Speicherverwendung durch verringern möchten die <xref:System.Collections.Generic.List%601>, können Sie die Kapazität verringern, durch Aufrufen der <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode oder durch Festlegen der <xref:System.Collections.Generic.List%601.Capacity%2A> -Eigenschaft explizit auf einen niedrigeren Wert. Wenn der Wert des <xref:System.Collections.Generic.List%601.Capacity%2A> explizit des internen Arrays ist auch zugewiesen, um die angegebene Kapazität aufzunehmen und kopiert alle Elemente festgelegt ist.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang. Festlegen der Eigenschaft ist eine O (*n*) Vorgang, wobei * n * ist die neue Kapazität.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Kapazität und die Anzahl der zu überprüfen einer <xref:System.Collections.Generic.List%601> enthält ein einfaches Geschäftsobjekt und veranschaulicht die Verwendung der <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode, um zusätzliche Kapazität zu entfernen.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft an verschiedene Positionen in der Lebensdauer einer Liste. Der Standardkonstruktor wird verwendet, um eine Liste von Zeichenfolgen mit einer Kapazität von 0 (null) erstellen und die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft wird angezeigt, um dies zu demonstrieren. Nach der <xref:System.Collections.Generic.List%601.Add%2A> -Methode wurde verwendet, um mehrere Elemente hinzuzufügen, die Elemente aufgelistet, und klicken Sie dann die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft angezeigt wird erneut zusammen mit der <xref:System.Collections.Generic.List%601.Count%2A> -Eigenschaft, um anzugeben, dass die Kapazität nach Bedarf erhöht wurde.  
  
 Die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft wird erneut angezeigt, nachdem die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode wird verwendet, um die Kapazität entsprechend der Anzahl reduzieren. Schließlich die <xref:System.Collections.Generic.List%601.Clear%2A> Methode wird verwendet, um alle Elemente aus der Liste zu entfernen und die <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaften werden erneut angezeigt.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Collections.Generic.List`1.Capacity" /> ist auf einen Wert festgelegt, der kleiner als <see cref="P:System.Collections.Generic.List`1.Count" /> ist.</exception>
        <exception cref="T:System.OutOfMemoryException">Im System ist nicht genügend Arbeitsspeicher verfügbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus der <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A>ist auf 0 festgelegt, und Verweise auf andere Objekte von Elementen in der Auflistung werden ebenfalls freigegeben.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A>bleibt unverändert. Zum Zurücksetzen der Kapazität des der <xref:System.Collections.Generic.List%601>, rufen Sie die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode bzw. einer Gruppe die <xref:System.Collections.Generic.List%601.Capacity%2A> -Eigenschaft direkt. Verringern der Kapazität Arbeitsspeicher zuordnet, und kopiert alle Elemente in der <xref:System.Collections.Generic.List%601>. Indem Sie eine leere <xref:System.Collections.Generic.List%601> legt die Kapazität der <xref:System.Collections.Generic.List%601> auf die festgelegte Standardkapazität.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Clear%2A> -Methode und verschiedene andere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generische Klasse. Die <xref:System.Collections.Generic.List%601.Clear%2A> Methode am Ende des Programms verwendet, um alle Elemente aus der Liste zu entfernen und die <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> anschließend werden Eigenschaften angezeigt.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Bestimmt, ob sich ein Element in <see cref="T:System.Collections.Generic.List`1" /> befindet.</summary>
        <returns>
          <see langword="true" />, wenn das <paramref name="item" /> in der <see cref="T:System.Collections.Generic.List`1" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt Gleichheit mithilfe des Standardgleichheitsvergleichs, gemäß der Implementierung des Objekts der <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> Methode zum `T` (der Typ der Werte in der Liste).  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Contains%2A> und <xref:System.Collections.Generic.List%601.Exists%2A> Methoden auf einen <xref:System.Collections.Generic.List%601> , enthält ein einfaches Geschäftsobjekt, das implementiert <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Das folgende Beispiel enthält eine Liste von komplexen Objekten des Typs `Cube`. Die `Cube` -Klasse implementiert die <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> Methode, damit zwei Cubes werden als gleich betrachtet, wenn ihre Dimensionen identisch sind. In diesem Beispiel wird die <xref:System.Collections.Generic.List%601.Contains%2A> -Methode zurückkehrt `true`, weil ein Cube, der die angegebenen Dimensionen wurde bereits in der Auflistung vorhanden ist.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Der Typ der Elemente des Zielarrays.</typeparam>
        <param name="converter">Ein <see cref="T:System.Converter`2" />-Delegat, der jedes Element von einem Typ in einen anderen Typ konvertiert.</param>
        <summary>Konvertiert die Elemente in der aktuellen <see cref="T:System.Collections.Generic.List`1" /> in einen anderen Typ und gibt eine Liste der konvertierten Elemente zurück.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.List`1" /> des Zieltyps, die die konvertierten Elemente aus der aktuellen <see cref="T:System.Collections.Generic.List`1" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Converter%602> ist ein Delegat für eine Methode, die ein Objekt in den Zieltyp konvertiert.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> einzeln übergeben werden, um die <xref:System.Converter%602> Delegat und die konvertierten Elemente werden in der neuen gespeichert <xref:System.Collections.Generic.List%601>.  
  
 Die aktuelle <xref:System.Collections.Generic.List%601> bleibt unverändert.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine Methode namens `PointFToPoint` , konvertiert ein <xref:System.Drawing.PointF> -Struktur in eine <xref:System.Drawing.Point> Struktur. Im Beispiel wird erstellt eine <xref:System.Collections.Generic.List%601> von <xref:System.Drawing.PointF> um Datenstrukturen handelt, erstellt eine `Converter\<PointF, Point>` delegieren (`Converter(Of PointF, Point)` in Visual Basic) zur Darstellung der `PointFToPoint` -Methode, und übergibt den Delegaten an den < xref:System.Collections.Generic.List `1.ConvertAll``1*> method. The <xref:System.Collections.Generic.List`1.ConvertAll''1* >-Methode übergibt jedes Element der Eingabeliste an die `PointFToPoint` Methode und legt die konvertierten Elemente in eine neue Liste mit <xref:System.Drawing.Point> Strukturen. Beide Listen werden angezeigt.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="converter" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.List`1" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <summary>Kopiert die gesamte <see cref="T:System.Collections.Generic.List`1" /> in ein kompatibles eindimensionales Array, wobei am Anfang des Zielarrays begonnen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Copy%2A?displayProperty=nameWithType> die Elemente kopiert.  
  
 Die Elemente kopiert werden, um die <xref:System.Array> in der gleichen Reihenfolge, in dem sich der Enumerator durchläuft, die <xref:System.Collections.Generic.List%601>.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.CopyTo%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit 5 Zeichenfolgen gefüllt ist. Ein leeres Zeichenfolgenarray 15 Elemente wird erstellt, und die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> methodenüberladung wird verwendet, um alle Elemente der Liste auf das Array, beginnend auf das erste Element des Arrays zu kopieren. Die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> methodenüberladung wird verwendet, um alle Elemente der Liste, um das Array, beginnend am Arrayindex 6 (bleibt leer, Index 5) zu kopieren. Schließlich die <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um 3 Elemente aus der Liste, beginnend mit dem Index 2 kopieren, damit das Array, beginnend am Array index 12 (bleibt Index 11-leer). Anschließend werden der Inhalt des Arrays angezeigt.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Generic.List`1" /> ist größer als die Anzahl von Elementen, die das Ziel-<paramref name="array" /> enthalten kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.List`1" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index im <c>Array</c> an dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die gesamte <see cref="T:System.Collections.Generic.List`1" /> in ein kompatibles eindimensionales Array, beginnend am angegebenen Index des Zielarrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Copy%2A?displayProperty=nameWithType> die Elemente kopiert.  
  
 Die Elemente kopiert werden, um die <xref:System.Array> in der gleichen Reihenfolge, in dem sich der Enumerator durchläuft, die <xref:System.Collections.Generic.List%601>.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.CopyTo%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit 5 Zeichenfolgen gefüllt ist. Ein leeres Zeichenfolgenarray 15 Elemente wird erstellt, und die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> methodenüberladung wird verwendet, um alle Elemente der Liste auf das Array, beginnend auf das erste Element des Arrays zu kopieren. Die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> methodenüberladung wird verwendet, um alle Elemente der Liste, um das Array, beginnend am Arrayindex 6 (bleibt leer, Index 5) zu kopieren. Schließlich die <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um 3 Elemente aus der Liste, beginnend mit dem Index 2 kopieren, damit das Array, beginnend am Array index 12 (bleibt Index 11-leer). Anschließend werden der Inhalt des Arrays angezeigt.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Generic.List`1" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index in der Quell-<see cref="T:System.Collections.Generic.List`1" />, ab dem mit dem Kopieren begonnen wird.</param>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.List`1" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index im <c>Array</c> an dem der Kopiervorgang beginnt.</param>
        <param name="count">Die Anzahl der zu kopierenden Elemente.</param>
        <summary>Kopiert einen Bereich von Elementen aus der <see cref="T:System.Collections.Generic.List`1" /> in ein kompatibles eindimensionales Array, beginnend ab dem angegebenen Index im Zielarray.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Copy%2A?displayProperty=nameWithType> die Elemente kopiert.  
  
 Die Elemente kopiert werden, um die <xref:System.Array> in der gleichen Reihenfolge, in dem sich der Enumerator durchläuft, die <xref:System.Collections.Generic.List%601>.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist `count`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.CopyTo%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit 5 Zeichenfolgen gefüllt ist. Ein leeres Zeichenfolgenarray 15 Elemente wird erstellt, und die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> methodenüberladung wird verwendet, um alle Elemente der Liste auf das Array, beginnend auf das erste Element des Arrays zu kopieren. Die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> methodenüberladung wird verwendet, um alle Elemente der Liste, um das Array, beginnend am Arrayindex 6 (bleibt leer, Index 5) zu kopieren. Schließlich die <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um 3 Elemente aus der Liste, beginnend mit dem Index 2 kopieren, damit das Array, beginnend am Array index 12 (bleibt Index 11-leer). Anschließend werden der Inhalt des Arrays angezeigt.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="arrayIndex" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> ist gleich oder größer als die <see cref="P:System.Collections.Generic.List`1.Count" /> der Quell-<see cref="T:System.Collections.Generic.List`1" />.  
  
 - oder -   
  
 Die Anzahl der Elemente vom <paramref name="index" /> bis zum Ende der Quell-<see cref="T:System.Collections.Generic.List`1" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente ab, die in <see cref="T:System.Collections.Generic.List`1" /> enthalten sind.</summary>
        <value>Die Anzahl der Elemente, die in <see cref="T:System.Collections.Generic.List`1" /> enthalten sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A>ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.List%601> speichern können, bevor eine größenanpassung erforderlich ist. <xref:System.Collections.Generic.List%601.Count%2A>ist die Anzahl der Elemente, die tatsächlich in der <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A>ist immer größer als oder gleich <xref:System.Collections.Generic.List%601.Count%2A>. Wenn <xref:System.Collections.Generic.List%601.Count%2A> überschreitet <xref:System.Collections.Generic.List%601.Capacity%2A> beim Hinzufügen von Elementen, die Kapazität erhöht wird, indem automatisch Neuzuordnen des internen Arrays vor dem Kopieren der alten Elemente und das Hinzufügen neuer Elemente.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Kapazität und die Anzahl der zu überprüfen einer <xref:System.Collections.Generic.List%601> enthält ein einfaches Geschäftsobjekt und veranschaulicht die Verwendung der <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode, um zusätzliche Kapazität zu entfernen.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Das folgende Beispiel zeigt den Wert der <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaft an verschiedenen Punkten während der Lebensdauer einer Liste. Nachdem die Liste erstellt und gefüllt wurde und die Elemente angezeigt, die <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaften werden angezeigt. Diese Eigenschaften werden erneut angezeigt, nachdem die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode wurde aufgerufen, und erneut, nachdem der Inhalt der Liste gelöscht.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Bestimmt, ob die <see cref="T:System.Collections.Generic.List`1" /> Elemente enthält, die mit den vom angegebenen Prädikat definierten Bedingungen übereinstimmen.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Collections.Generic.List`1" /> ein oder mehr Elemente enthält, die die durch das angegebene Prädikat definierten Bedingungen erfüllen; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> einzeln übergeben werden, um die <xref:System.Predicate%601> Delegat und die Verarbeitung wird angehalten, wenn eine Übereinstimmung gefunden wird.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Contains%2A> und <xref:System.Collections.Generic.List%601.Exists%2A> Methoden auf einen <xref:System.Collections.Generic.List%601> , enthält ein einfaches Geschäftsobjekt, das implementiert <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Exists%2A> -Methode und andere Methoden verwenden, die <xref:System.Predicate%601> generischen Delegaten.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt wird, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden. Im Beispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.  
  
 Die <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, und <xref:System.Collections.Generic.List%601.FindAll%2A> Methoden werden verwendet, um die Liste der mit der Suche, durchsuchen und dann die <xref:System.Collections.Generic.List%601.RemoveAll%2A> Methode wird verwendet, um alle Einträge mit "Saurus" entfernt.  
  
 Schließlich die <xref:System.Collections.Generic.List%601.Exists%2A> -Methode aufgerufen wird. Es durchläuft die Liste von Anfang an und übergibt die einzelnen Elemente an die `EndsWithSaurus` Methode. Die Suche beendet und die Methode gibt `true` Wenn die `EndsWithSaurus` -Methode zurückkehrt `true` für ein bestimmtes Element. Die <xref:System.Collections.Generic.List%601.Exists%2A> -Methode zurückkehrt `false` da alle Elemente entfernt wurden.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das erste Vorkommen im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Das erste Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> einzeln übergeben werden, um die <xref:System.Predicate%601> -Delegaten vorrücken bei der <xref:System.Collections.Generic.List%601>, beginnend mit dem ersten Element und endend mit dem letzten Element.  Die Verarbeitung wird beendet, wenn eine Übereinstimmung gefunden wird.  
  
> [!IMPORTANT]
>  Wenn eine Liste mit Typen mit Werten zu suchen, stellen Sie sicher, dass der Standardwert für den Typ der Suche Prädikat nicht erfüllt. Andernfalls besteht keine Möglichkeit zur Unterscheidung zwischen einer Standardeinstellung Wert gibt an, dass keine Übereinstimmung gefunden wurde und ein Listenelement, die zufällig zur der Standardwert für den Typ haben. Wenn der Standardwert der Search-Prädikat erfüllt, verwenden Sie die <xref:System.Collections.Generic.List%601.FindIndex%2A> Methode stattdessen.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Find%2A> Methode auf eine <xref:System.Collections.Generic.List%601> , die ein einfaches komplexe Objekt enthält.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Das folgende Beispiel veranschaulicht die Suchen von Methoden für die <xref:System.Collections.Generic.List%601> Klasse. Im Beispiel für die <xref:System.Collections.Generic.List%601> Klasse enthält `book` Objekte der Klasse `Book`, mit den Daten aus der [XML-Beispieldatei: Bücher (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die `FillList` -Methode im Beispiel verwendet [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) analysiert die Werte aus der XML-Eigenschaftswerten von der `book` Objekte.  
  
 Die folgende Tabelle beschreibt die Beispiele für die Find-Methoden.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht nach einem Buch mithilfe einer ID der `IDToFind` Prädikat Delegaten.<br /><br /> C#-Beispiel wird ein anonymes Delegaten verwendet.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen Sie alle Bücher, deren `Genre` Eigenschaft ist "Computer" mit der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung, die ein Veröffentlichungsdatum vor 2001, mit der `PubBefore2001` Prädikat Delegaten.<br /><br /> C#-Beispiel wird ein anonymes Delegaten verwendet.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buch verwenden die `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buch mithilfe der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des ersten Computerbuchs in der zweiten Hälfte der Auflistung mit den `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des letzten Computer Buch in der zweiten Hälfte der Auflistung mit den `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Ruft alle Elemente ab, die die vom angegebenen Prädikat definierten Bedingungen erfüllen.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.List`1" /> mit allen Elementen, die ggf. die durch das angegebene Prädikat definierten Bedingungen erfüllen, andernfalls eine leere <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> einzeln übergeben werden, um die <xref:System.Predicate%601> Delegat sowie Elemente, die Bedingungen erfüllen, werden gespeichert in der zurückgegebenen <xref:System.Collections.Generic.List%601>.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Suchen von Methoden für die <xref:System.Collections.Generic.List%601> Klasse. Im Beispiel für die <xref:System.Collections.Generic.List%601> Klasse enthält `book` Objekte der Klasse `Book`, mit den Daten aus der [XML-Beispieldatei: Bücher (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die `FillList` -Methode im Beispiel verwendet [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) analysiert die Werte aus der XML-Eigenschaftswerten von der `book` Objekte.  
  
 Die folgende Tabelle beschreibt die Beispiele für die Find-Methoden.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht nach einem Buch mithilfe einer ID der `IDToFind` Prädikat Delegaten.<br /><br /> C#-Beispiel wird ein anonymes Delegaten verwendet.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen Sie alle Bücher, deren `Genre` Eigenschaft ist "Computer" mit der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung, die ein Veröffentlichungsdatum vor 2001, mit der `PubBefore2001` Prädikat Delegaten.<br /><br /> C#-Beispiel wird ein anonymes Delegaten verwendet.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buch verwenden die `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buch mithilfe der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des ersten Computerbuchs in der zweiten Hälfte der Auflistung mit den `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des letzten Computer Buch in der zweiten Hälfte der Auflistung mit den `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> vorwärts beginnend mit dem ersten Element und endet beim letzten Element durchsucht wird.  
  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> einzeln übergeben werden, um die <xref:System.Predicate%601> delegieren. Der Delegat hat die Signatur:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `Employee` Klasse mit zwei Feldern `Name` und `Id`. Er definiert außerdem eine `EmployeeSearch` Klasse mit einer einzelnen Methode `StartsWith`, Wert, der angibt, ob die `Employee.Name` Feld beginnt mit einer angegebenen Teilzeichenfolge, die an die `EmployeeSearch` Klassenkonstruktor. Beachten Sie die Signatur dieser Methode  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 entspricht der Signatur des Delegaten, die übergeben werden kann die <xref:System.Collections.Generic.List%601.FindIndex%2A> Methode. Im Beispiel wird instanziiert einen `List<Employee>` Objekt, fügt eine Anzahl von `Employee` Objekten auf ihn, und ruft dann die <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> Methode zum Durchsuchen der gesamten Auflistung, erstmalig für die erste zweimal `Employee` Objekt, dessen `Name` Feld beginnt mit "J", und das zweite Mal für das erste `Employee` Objekt, dessen `Name` Feld beginnt mit "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der vom angegebenen Index bis zum letzten Element reicht.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> vorwärts beginnenden durchsucht `startIndex` beginnt und mit dem letzten Element.  
  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> einzeln übergeben werden, um die <xref:System.Predicate%601> delegieren. Der Delegat hat die Signatur:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist die Anzahl von Elementen aus `startIndex` bis zum Ende der <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `Employee` Klasse mit zwei Feldern `Name` und `Id`. Er definiert außerdem eine `EmployeeSearch` Klasse mit einer einzelnen Methode `StartsWith`, Wert, der angibt, ob die `Employee.Name` Feld beginnt mit einer angegebenen Teilzeichenfolge, die an die `EmployeeSearch` Klassenkonstruktor. Beachten Sie die Signatur dieser Methode  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 entspricht der Signatur des Delegaten, die übergeben werden kann die <xref:System.Collections.Generic.List%601.FindIndex%2A> Methode. Im Beispiel wird instanziiert einen `List<Employee>` Objekt, fügt eine Anzahl von `Employee` Objekten auf ihn, und ruft dann die <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> Methode zweimal, um der Auflistung, beginnend mit der fünfte Element (d. h. das Element am Index 4) zu suchen. Erstmals ausführen, sucht das erste `Employee` Objekt, dessen `Name` Feld beginnt mit "J"; das zweite Mal sucht das erste `Employee` Objekt, dessen `Name` Feld beginnt mit "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der am angegebenen Index beginnt und die angegebene Anzahl von Elementen umfasst.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> vorwärts beginnenden durchsucht `startIndex` und endet bei `startIndex` plus `count` minus 1, wenn `count` ist größer als 0.  
  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> einzeln übergeben werden, um die <xref:System.Predicate%601> delegieren. Der Delegat hat die Signatur:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist `count`.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `Employee` Klasse mit zwei Feldern `Name` und `Id`. Er definiert außerdem eine `EmployeeSearch` Klasse mit einer einzelnen Methode `StartsWith`, Wert, der angibt, ob die `Employee.Name` Feld beginnt mit einer angegebenen Teilzeichenfolge, die an die `EmployeeSearch` Klassenkonstruktor. Beachten Sie die Signatur dieser Methode  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 entspricht der Signatur des Delegaten, die übergeben werden kann die <xref:System.Collections.Generic.List%601.FindIndex%2A> Methode. Im Beispiel wird instanziiert eine `List<Employee>` Objekt, fügt eine Anzahl von `Employee` Objekten auf ihn, und ruft dann die <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> Methode zweimal, um die gesamte Auflistung suchen (d. h. die Elemente von Index 0 bis Index <xref:System.Collections.Generic.List%601.Count%2A> - 1). Erstmals ausführen, sucht das erste `Employee` Objekt, dessen `Name` Feld beginnt mit "J"; das zweite Mal sucht das erste `Employee` Objekt, dessen `Name` Feld beginnt mit "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.  
  
 - oder -   
  
 <paramref name="count" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="startIndex" />und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das letzte Vorkommen im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Das letzte Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> einzeln übergeben werden, um die <xref:System.Predicate%601> -Delegaten rückwärts verschieben, der <xref:System.Collections.Generic.List%601>, beginnend mit dem letzten Element und endend mit dem ersten Element.  Die Verarbeitung wird beendet, wenn eine Übereinstimmung gefunden wird.  
  
> [!IMPORTANT]
>  Wenn eine Liste mit Typen mit Werten zu suchen, stellen Sie sicher, dass der Standardwert für den Typ der Suche Prädikat nicht erfüllt. Andernfalls besteht keine Möglichkeit zur Unterscheidung zwischen einer Standardeinstellung Wert gibt an, dass keine Übereinstimmung gefunden wurde und ein Listenelement, die zufällig zur der Standardwert für den Typ haben. Wenn der Standardwert der Search-Prädikat erfüllt, verwenden Sie die <xref:System.Collections.Generic.List%601.FindLastIndex%2A> Methode stattdessen.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Suchen von Methoden für die <xref:System.Collections.Generic.List%601> Klasse. Im Beispiel für die <xref:System.Collections.Generic.List%601> Klasse enthält `book` Objekte der Klasse `Book`, mit den Daten aus der [XML-Beispieldatei: Bücher (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die `FillList` -Methode im Beispiel verwendet [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) analysiert die Werte aus der XML-Eigenschaftswerten von der `book` Objekte.  
  
 Die folgende Tabelle beschreibt die Beispiele für die Find-Methoden.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht nach einem Buch mithilfe einer ID der `IDToFind` Prädikat Delegaten.<br /><br /> C#-Beispiel wird ein anonymes Delegaten verwendet.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen Sie alle Bücher, deren `Genre` Eigenschaft ist "Computer" mit der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung, die ein Veröffentlichungsdatum vor 2001, mit der `PubBefore2001` Prädikat Delegaten.<br /><br /> C#-Beispiel wird ein anonymes Delegaten verwendet.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buch verwenden die `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buch mithilfe der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des ersten Computerbuchs in der zweiten Hälfte der Auflistung mit den `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des letzten Computer Buch in der zweiten Hälfte der Auflistung mit den `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> rückwärts beginnend mit dem letzten Element und endet mit dem ersten Element gesucht wird.  
  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> einzeln übergeben werden, um die <xref:System.Predicate%601> delegieren.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Suchen von Methoden für die <xref:System.Collections.Generic.List%601> Klasse. Im Beispiel für die <xref:System.Collections.Generic.List%601> Klasse enthält `book` Objekte der Klasse `Book`, mit den Daten aus der [XML-Beispieldatei: Bücher (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die `FillList` -Methode im Beispiel verwendet [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) analysiert die Werte aus der XML-Eigenschaftswerten von der `book` Objekte.  
  
 Die folgende Tabelle beschreibt die Beispiele für die Find-Methoden.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht nach einem Buch mithilfe einer ID der `IDToFind` Prädikat Delegaten.<br /><br /> C#-Beispiel wird ein anonymes Delegaten verwendet.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen Sie alle Bücher, deren `Genre` Eigenschaft ist "Computer" mit der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung, die ein Veröffentlichungsdatum vor 2001, mit der `PubBefore2001` Prädikat Delegaten.<br /><br /> C#-Beispiel wird ein anonymes Delegaten verwendet.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buch verwenden die `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buch mithilfe der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des ersten Computerbuchs in der zweiten Hälfte der Auflistung mit den `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des letzten Computer Buch in der zweiten Hälfte der Auflistung mit den `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der vom ersten Element bis zum angegeben Index reicht.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> ist der gesuchte Rückwärtsrichtung `startIndex` beginnt und mit dem ersten Element.  
  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> einzeln übergeben werden, um die <xref:System.Predicate%601> delegieren.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*) Vorgang, in denen * n * ist die Anzahl der Elemente vom Anfang der <xref:System.Collections.Generic.List%601> auf `startIndex`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der die angegebene Anzahl von Elementen umfasst und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> ist der gesuchte Rückwärtsrichtung `startIndex` und endet bei `startIndex` minus `count` plus 1, wenn `count` ist größer als 0.  
  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> einzeln übergeben werden, um die <xref:System.Predicate%601> delegieren.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist `count`.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Suchen von Methoden für die <xref:System.Collections.Generic.List%601> Klasse. Im Beispiel für die <xref:System.Collections.Generic.List%601> Klasse enthält `book` Objekte der Klasse `Book`, mit den Daten aus der [XML-Beispieldatei: Bücher (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die `FillList` -Methode im Beispiel verwendet [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) analysiert die Werte aus der XML-Eigenschaftswerten von der `book` Objekte.  
  
 Die folgende Tabelle beschreibt die Beispiele für die Find-Methoden.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht nach einem Buch mithilfe einer ID der `IDToFind` Prädikat Delegaten.<br /><br /> C#-Beispiel wird ein anonymes Delegaten verwendet.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen Sie alle Bücher, deren `Genre` Eigenschaft ist "Computer" mit der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung, die ein Veröffentlichungsdatum vor 2001, mit der `PubBefore2001` Prädikat Delegaten.<br /><br /> C#-Beispiel wird ein anonymes Delegaten verwendet.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buch verwenden die `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buch mithilfe der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des ersten Computerbuchs in der zweiten Hälfte der Auflistung mit den `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des letzten Computer Buch in der zweiten Hälfte der Auflistung mit den `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.  
  
 - oder -   
  
 <paramref name="count" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="startIndex" />und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="action">Der <see cref="T:System.Action`1" />-Delegat, der für jedes Element von <see cref="T:System.Collections.Generic.List`1" /> ausgeführt werden soll.</param>
        <summary>Führt die angegebene Aktion für jedes Element der <see cref="T:System.Collections.Generic.List`1" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Action%601> ein Delegaten an eine Methode, die eine Aktion, für das Objekt ausführt übergeben wird.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> einzeln übergeben werden, um die <xref:System.Action%601> delegieren.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Ändern der zugrunde liegenden Auflistung im Hauptteil der <xref:System.Action%601> Delegat wird nicht unterstützt und nicht definiertes Verhalten.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.Action%601> Delegaten zum Drucken des Inhalts von einem <xref:System.Collections.Generic.List%601> Objekt. In diesem Beispiel wird die `Print` Methode wird verwendet, um den Inhalt der Liste auf der Konsole angezeigt.  
  
> [!NOTE]
>  Zusätzlich zum Anzeigen des Inhalts mit der `Print` -Methode, die C#-Beispiel veranschaulicht die Verwendung von zum Anzeigen der Ergebnisse an die Konsole.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Element in der Auflistung wurde geändert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der die <see cref="T:System.Collections.Generic.List`1" /> durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.List`1.Enumerator" /> für die <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach` -Anweisung der Programmiersprache c# (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist die <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> Eigenschaft ist nicht definiert. Sie müssen daher rufen die <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> Methode, um den Enumerator auf das erste Element der Auflistung vor dem Lesen des Werts von <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>.  
  
 Die <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> Eigenschaft gibt das gleiche Objekt bis <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> legt <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> gibt `false`. Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> auch zurückgeben `false`. Wenn der letzte Aufruf <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte <see cref="T:System.Collections.Generic.List`1" />-Index, an dem der Bereich beginnt.</param>
        <param name="count">Die Anzahl der Elemente im Bereich.</param>
        <summary>Erstellt eine flache Kopie eines Bereichs von Elementen in der Quell-<see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Eine flache Kopie eines Bereichs von Elementen in der Quell-<see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine flache Kopie einer Auflistung von Verweistypen oder eine Teilmenge dieser Sammlung enthält nur die Verweise auf die Elemente der Auflistung. Die Objekte selbst werden nicht kopiert. Zeigen Sie die Verweise in der neuen Liste auf die gleichen Objekte wie die Verweise in der ursprünglichen Liste.  
  
 Eine flache Kopie einer Auflistung von Werttypen oder eine Teilmenge dieser Sammlung enthält die Elemente der Auflistung. Wenn die Elemente der Auflistung Verweise auf andere Objekte enthalten, werden diese Objekte jedoch nicht kopiert. Die Verweise in den Elementen der neuen Sammlung zeigen Sie auf die gleichen Objekte wie die Verweise in den Elementen der ursprünglichen Auflistung.  
  
 Im Gegensatz dazu eine tiefe Kopie einer Auflistung kopiert die Elemente aus, und alles, was durch die Elemente direkt oder indirekt verweist.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist `count`.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.GetRange%2A> -Methode und andere Methoden der <xref:System.Collections.Generic.List%601> -Klasse, die für Bereiche verwendet. Am Ende des Beispiels die <xref:System.Collections.Generic.List%601.GetRange%2A> Methode wird verwendet, um drei Elemente aus der Liste ab Indexposition 2 abgerufen. Die <xref:System.Collections.Generic.List%601.ToArray%2A> Methode wird aufgerufen, für die resultierende <xref:System.Collections.Generic.List%601>, erstellen ein Array von drei Elementen. Die Elemente des Arrays werden angezeigt.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" />und <paramref name="count" /> keinen gültigen Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des ersten Vorkommens innerhalb der gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des ggf. ersten Vorkommens von <paramref name="item" /> in der gesamten <see cref="T:System.Collections.Generic.List`1" />, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> vorwärts beginnend mit dem ersten Element und endet beim letzten Element durchsucht wird.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standardgleichheitsvergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, der Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.IndexOf%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen wird erstellt, mit einem Eintrag, der zur Indexposition 0 und Indexposition 5 zweimal angezeigt. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> -methodenüberladung, sucht die Liste ab und sucht das erste Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> methodenüberladung wird verwendet, um den Anfang der Liste mit Indexposition 3 und bis zum Ende der Liste fortsetzen suchen, und sucht das zweite Vorkommen der Zeichenfolge. Schließlich die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um einen Bereich mit zwei Einträgen, beginnend bei Indexposition zwei suchen; es gibt-1 zurück, da keine Instanzen der Suchzeichenfolge in diesem Bereich vorhanden sind.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Suche. 0 (null) ist in einer leeren Liste gültig.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der sich vom angegebenen Index bis zum letzten Element erstreckt.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" />, der sich von <paramref name="index" /> bis zum letzten Element erstreckt, sofern gefunden, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> vorwärts beginnenden durchsucht `index` beginnt und mit dem letzten Element.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standardgleichheitsvergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, der Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist die Anzahl von Elementen aus `index` bis zum Ende der <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.IndexOf%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen wird erstellt, mit einem Eintrag, der zur Indexposition 0 und Indexposition 5 zweimal angezeigt. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> -methodenüberladung, sucht die Liste ab und sucht das erste Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> methodenüberladung wird verwendet, um den Anfang der Liste mit Indexposition 3 und bis zum Ende der Liste fortsetzen suchen, und sucht das zweite Vorkommen der Zeichenfolge. Schließlich die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um einen Bereich mit zwei Einträgen, beginnend bei Indexposition zwei suchen; es gibt-1 zurück, da keine Instanzen der Suchzeichenfolge in diesem Bereich vorhanden sind.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Suche. 0 (null) ist in einer leeren Liste gültig.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der am angegebenen Index beginnt und die angegebene Anzahl von Elementen enthält.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" />, der am <paramref name="index" /> beginnt und <paramref name="count" /> Anzahl von Elementen enthält, sofern gefunden, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> vorwärts beginnenden durchsucht `index` und endet bei `index` plus `count` minus 1, wenn `count` ist größer als 0.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standardgleichheitsvergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, der Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist `count`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.IndexOf%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen wird erstellt, mit einem Eintrag, der zur Indexposition 0 und Indexposition 5 zweimal angezeigt. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> -methodenüberladung, sucht die Liste ab und sucht das erste Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> methodenüberladung wird verwendet, um den Anfang der Liste mit Indexposition 3 und bis zum Ende der Liste fortsetzen suchen, und sucht das zweite Vorkommen der Zeichenfolge. Schließlich die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um einen Bereich mit zwei Einträgen, beginnend bei Indexposition zwei suchen; es gibt-1 zurück, da keine Instanzen der Suchzeichenfolge in diesem Bereich vorhanden sind.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.  
  
 - oder -   
  
 <paramref name="count" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="index" />und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem <c>Element</c> eingefügt werden soll.</param>
        <param name="item">Das einzufügende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Fügt am angegebenen Index ein Element in die <see cref="T:System.Collections.Generic.List`1" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>akzeptiert `null` als ein gültiger Wert für Referenztypen und doppelte Elemente lässt.  
  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> bereits gleich <xref:System.Collections.Generic.List%601.Capacity%2A>, die Kapazität der <xref:System.Collections.Generic.List%601> wird von automatisch Neuzuordnen des internen Arrays erhöht und die vorhandenen Elemente werden in das neue Array kopiert, bevor das neue Element hinzugefügt wird.  
  
 Wenn `index` gleich <xref:System.Collections.Generic.List%601.Count%2A>, `item` wird am Ende hinzugefügt <xref:System.Collections.Generic.List%601>.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Hinzufügen, entfernen, und fügen Sie ein einfaches Geschäftsobjekt in einem <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Insert%2A> -Methode, zusammen mit verschiedenen Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generische Klasse. Nachdem die Liste erstellt wurde, werden Elemente hinzugefügt. Die <xref:System.Collections.Generic.List%601.Insert%2A> Methode wird verwendet, um ein Element in der Mitte der Liste eingefügt. Das Element eingefügt ist ein Duplikat, die später entfernt wurde, mithilfe der <xref:System.Collections.Generic.List%601.Remove%2A> Methode.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="index" /> ist größer als <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem neue Elemente eingefügt werden sollen.</param>
        <param name="collection">Die Sammlung, deren Elemente in die <see cref="T:System.Collections.Generic.List`1" /> eingefügt werden sollen. Die Auflistung selbst kann nicht <see langword="null" />, es kann jedoch Elemente enthalten, die <see langword="null" />, wenn Typ <c>T</c> einen Referenztyp darstellt.</param>
        <summary>Fügt die Elemente einer Auflistung am angegebenen Index in die <see cref="T:System.Collections.Generic.List`1" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>akzeptiert `null` als ein gültiger Wert für Referenztypen und doppelte Elemente lässt.  
  
 Wenn die neue <xref:System.Collections.Generic.List%601.Count%2A> (das aktuelle <xref:System.Collections.Generic.List%601.Count%2A> plus die Größe der Auflistung) größer als <xref:System.Collections.Generic.List%601.Capacity%2A>, die Kapazität der <xref:System.Collections.Generic.List%601> wird erhöht, indem automatisch Neuzuordnen des internen Arrays an die neuen Elemente und die vorhandene Elemente werden in das neue Array kopiert, bevor die neuen Elemente hinzugefügt werden.  
  
 Wenn `index` gleich <xref:System.Collections.Generic.List%601.Count%2A>, werden die Elemente am Ende hinzugefügt <xref:System.Collections.Generic.List%601>.  
  
 Die Reihenfolge der Elemente in der Auflistung wird beibehalten, der <xref:System.Collections.Generic.List%601>.  
  
 Diese Methode ist eine O (*n* + *m*) Vorgang, wobei * n * ist die Anzahl der Elemente hinzugefügt werden und *m * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, <xref:System.Collections.Generic.List%601.InsertRange%2A> -Methode und verschiedene andere Methoden, die von der <xref:System.Collections.Generic.List%601> -Klasse, die für Bereiche verwendet. Nachdem die Liste erstellt und aufgefüllt, die mit den Namen der mehrere friedlichen Werk Essen Dinosaurier, wurde die <xref:System.Collections.Generic.List%601.InsertRange%2A> Methode wird verwendet, um ein Array von drei ertragreiche Fleisch Essen Dinosaurier fügen Sie der Liste am Index 3 ab.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="index" /> ist größer als <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des Elements, das abgerufen oder festgelegt werden soll.</param>
        <summary>Ruft das Element am angegebenen Index ab oder legt dieses fest.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>akzeptiert `null` als ein gültiger Wert für Referenztypen und doppelte Elemente lässt.  
  
 Diese Eigenschaft ermöglicht den Zugriff auf ein bestimmtes Element in der Auflistung mithilfe folgender Syntax: `myCollection[index]`.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang. Festlegen der Eigenschaft ist auch ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im Beispiel in diesem Abschnitt wird veranschaulicht, die <xref:System.Collections.Generic.List%601.Item%2A> -Eigenschaft (Indexer in c#) und verschiedene andere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generische Klasse. Nachdem die Liste wurde erstellt und gefüllt, mit der <xref:System.Collections.Generic.List%601.Add%2A> -Methode, ein Element abgerufen und angezeigt, mit der <xref:System.Collections.Generic.List%601.Item%2A> Eigenschaft. (Ein Beispiel, verwendet der <xref:System.Collections.Generic.List%601.Item%2A> -Eigenschaft zum Festlegen des Werts eines Elements Liste finden Sie unter <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, c# und in C++ haben Sie die Syntax für den Zugriff auf die <xref:System.Collections.Generic.List%601.Item%2A> Eigenschaft ohne Verwendung des Namens. Stattdessen die Variable mit dem <xref:System.Collections.Generic.List%601> wird verwendet, als handele es sich um ein Array.  
  
 Die Programmiersprache c# verwendet das Schlüsselwort der Indexer definieren die <xref:System.Collections.Generic.List%601.Item%2A> Eigenschaft. Visual Basic implementiert <xref:System.Collections.Generic.List%601.Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="index" /> ist größer oder gleich <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des letzten Vorkommens innerhalb der gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des ggf. letzten Vorkommens von <paramref name="item" /> in der gesamten <see cref="T:System.Collections.Generic.List`1" />, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> rückwärts beginnend mit dem letzten Element und endet mit dem ersten Element gesucht wird.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standardgleichheitsvergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, der Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.LastIndexOf%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen wird erstellt, mit einem Eintrag, der zur Indexposition 0 und Indexposition 5 zweimal angezeigt. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> methodenüberladung durchsucht die gesamte Liste vom Ende aus und sucht das zweite Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> methodenüberladung wird verwendet, um die Suchliste rückwärts Indexposition 3 beginnt und am Anfang der Liste fortsetzen, damit das erste Vorkommen der Zeichenfolge in der Liste gefunden. Schließlich die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um einen Bereich von vier Einträge, beginnend bei Indexposition 4 und rückwärts erweitern suchen (d. h. er sucht die Elemente an Stellen 4, 3, 2 und 1); diese Suche wird – 1 zurückgegeben, da keine Instanzen der Suche vorhanden sind die Zeichenfolge in diesem Bereich.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der sich vom angegebenen Index bis zum letzten Element erstreckt.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" />, der sich vom ersten Element bis <paramref name="index" /> erstreckt, sofern gefunden, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> ist der gesuchte Rückwärtsrichtung `index` beginnt und mit dem ersten Element.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standardgleichheitsvergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, der Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*) Vorgang, in denen * n * ist die Anzahl der Elemente vom Anfang der <xref:System.Collections.Generic.List%601> auf `index`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.LastIndexOf%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen wird erstellt, mit einem Eintrag, der zur Indexposition 0 und Indexposition 5 zweimal angezeigt. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> methodenüberladung durchsucht die gesamte Liste vom Ende aus und sucht das zweite Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> methodenüberladung wird verwendet, um die Suchliste rückwärts Indexposition 3 beginnt und am Anfang der Liste fortsetzen, damit das erste Vorkommen der Zeichenfolge in der Liste gefunden. Schließlich die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um einen Bereich von vier Einträge, beginnend bei Indexposition 4 und rückwärts erweitern suchen (d. h. er sucht die Elemente an Stellen 4, 3, 2 und 1); diese Suche wird – 1 zurückgegeben, da keine Instanzen der Suche vorhanden sind die Zeichenfolge in diesem Bereich.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der die angegebene Anzahl von Elementen enthält und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" />, der <paramref name="count" /> Anzahl von Elementen enthält und am <paramref name="index" /> endet, sofern gefunden, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> ist der gesuchte Rückwärtsrichtung `index` und endet bei `index` minus `count` plus 1, wenn `count` ist größer als 0.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standardgleichheitsvergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, der Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist `count`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.LastIndexOf%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen wird erstellt, mit einem Eintrag, der zur Indexposition 0 und Indexposition 5 zweimal angezeigt. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> methodenüberladung durchsucht die gesamte Liste vom Ende aus und sucht das zweite Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> methodenüberladung wird verwendet, um die Suchliste rückwärts Indexposition 3 beginnt und am Anfang der Liste fortsetzen, damit das erste Vorkommen der Zeichenfolge in der Liste gefunden. Schließlich die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um einen Bereich von 4 Einträge, beginnend bei Indexposition 4 und rückwärts erweitern suchen (d. h. er sucht die Elemente an Stellen 4, 3, 2 und 1); diese Suche wird – 1 zurückgegeben, da keine Instanzen der Suche vorhanden sind die Zeichenfolge in diesem Bereich.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.  
  
 - oder -   
  
 <paramref name="count" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="index" />und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das aus der <see cref="T:System.Collections.Generic.List`1" /> zu entfernende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Entfernt das erste Vorkommen eines angegebenen Objekts aus der <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>
          <see langword="true" />, wenn das <paramref name="item" /> erfolgreich entfernt wurde; andernfalls <see langword="false" />.  Diese Methode gibt auch dann <see langword="false" /> zurück, wenn das <paramref name="item" /> nicht in der <see cref="T:System.Collections.Generic.List`1" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Typ `T` implementiert die <xref:System.IEquatable%601> generische Schnittstellen, die der Gleichheitsvergleich ist die <xref:System.IEquatable%601.Equals%2A> -Methode dieser Schnittstelle; andernfalls der Standardgleichheitsvergleich ist <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Hinzufügen, entfernen, und fügen Sie ein einfaches Geschäftsobjekt in einem <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
  
 Das folgende Beispiel zeigt <xref:System.Collections.Generic.List%601.Remove%2A> Methode. Mehrere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generische Klasse hinzufügen, einfügen und suchen Sie in der Liste verwendet werden. Nachdem diese Vorgänge enthält die Liste ein Duplikat. Die <xref:System.Collections.Generic.List%601.Remove%2A> Methode wird verwendet, um die erste Instanz des doppelten Elements entfernt, und der Inhalt wird angezeigt. Die <xref:System.Collections.Generic.List%601.Remove%2A> -Methode immer die erste gefundene Instanz entfernt.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für die Elemente definiert, die entfernt werden sollen.</param>
        <summary>Entfernt alle Elemente, die die vom angegebenen Prädikat definierten Bedingungen erfüllen.</summary>
        <returns>Die Anzahl der aus der <see cref="T:System.Collections.Generic.List`1" /> entfernten Elemente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an übergeben der <xref:System.Predicate%601> Delegaten und Elemente, die Bedingungen erfüllen, aus entfernt die <xref:System.Collections.Generic.List%601>.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.RemoveAll%2A> -Methode und andere Methoden verwenden, die <xref:System.Predicate%601> generischen Delegaten.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt wird, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden. Im Beispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.  
  
 Die <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, und <xref:System.Collections.Generic.List%601.FindAll%2A> Methoden werden verwendet, um die Liste der mit dem Prädikat Suchmethode durchsuchen.  
  
 Die <xref:System.Collections.Generic.List%601.RemoveAll%2A> Methode wird verwendet, um alle Einträge mit "Saurus" entfernt. Es durchläuft die Liste von Anfang an und übergibt die einzelnen Elemente an die `EndsWithSaurus` Methode. Das Element wird entfernt, wenn die `EndsWithSaurus` -Methode zurückkehrt `true`.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.  
  
 Schließlich die <xref:System.Collections.Generic.List%601.Exists%2A> Methode überprüft, dass es keine Zeichenfolgen in der Liste, die mit "Saurus" enden.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des zu entfernenden Elements.</param>
        <summary>Entfernt das Element am angegebenen Index aus der <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufruf <xref:System.Collections.Generic.List%601.RemoveAt%2A> um ein Element zu entfernen, werden die verbleibenden Elemente in der Liste um das entfernte Element ersetzen neu nummeriert. Wenn Sie das Element am Index 3 entfernen, wird das Element am Index 4 an Position 3 verschoben. Darüber hinaus die Anzahl der Elemente in der Liste (dargestellt durch die <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaft) wird um 1 verringert.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Hinzufügen, entfernen, und fügen Sie ein einfaches Geschäftsobjekt in einem <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="index" /> ist größer oder gleich <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des zu entfernenden Bereichs von Elementen.</param>
        <param name="count">Die Anzahl der zu entfernenden Elemente.</param>
        <summary>Entfernt einen Bereich von Elementen aus der <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente entfernt werden und die Elemente, die für die folgenden Elemente in der <xref:System.Collections.Generic.List%601> die Indizes endhost `count`.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.RemoveRange%2A> -Methode und die verschiedenen Methoden des der <xref:System.Collections.Generic.List%601> -Klasse, die für Bereiche verwendet. Nachdem die Liste erstellt und geändert haben, wurde die <xref:System.Collections.Generic.List%601.RemoveRange%2A> Methode wird verwendet, um zwei Elemente aus der Liste, beginnend am Index 2 zu entfernen.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" />und <paramref name="count" /> keinen gültigen Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kehrt die Reihenfolge der Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Reverse%2A?displayProperty=nameWithType> um die Reihenfolge der Elemente umzukehren.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht beide Überladungen der der <xref:System.Collections.Generic.List%601.Reverse%2A> Methode. Das Beispiel erstellt eine <xref:System.Collections.Generic.List%601> von Zeigern auf Zeichenfolgen und sechs Zeichenfolgen hinzugefügt. Die <xref:System.Collections.Generic.List%601.Reverse> methodenüberladung wird verwendet, um die Liste umkehren und dann die <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um die Mitte der Liste, beginnend mit 1 Element und umfasst vier Elemente umkehren.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des Bereichs, in dem die Reihenfolge umgekehrt werden soll.</param>
        <param name="count">Die Anzahl der Elemente im Bereich, in dem die Reihenfolge umgekehrt werden soll.</param>
        <summary>Kehrt die Reihenfolge der Elemente im angegebenen Bereich um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Reverse%2A?displayProperty=nameWithType> um die Reihenfolge der Elemente umzukehren.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht beide Überladungen der der <xref:System.Collections.Generic.List%601.Reverse%2A> Methode. Das Beispiel erstellt eine <xref:System.Collections.Generic.List%601> von Zeigern auf Zeichenfolgen und sechs Zeichenfolgen hinzugefügt. Die <xref:System.Collections.Generic.List%601.Reverse> methodenüberladung wird verwendet, um die Liste umkehren und dann die <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um die Mitte der Liste, beginnend mit 1 Element und umfasst vier Elemente umkehren.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" />und <paramref name="count" /> keinen gültigen Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortiert die Elemente in der <see cref="T:System.Collections.Generic.List`1" /> bzw. in einem Teil davon.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="overloaded-method-syntax"></a>Überladene Methodensyntax  
 Die <xref:System.Collections.Generic.List%601.Sort%2A> Methoden ermöglichen es Ihnen, mit der Standardvergleich für den Objekttyp in der Liste zu sortieren, oder geben Sie eine Kunden-Sort-Methode.  
  
 [Liste\<T >. Sort()](xref:System.Collections.Generic.List`1.Sort*) sortiert die Elemente in der gesamten Liste mithilfe des Standardcomparers des Objekttyps frei, die in der Liste.  
  
 [Liste\<T >. Sortieren M (Vergleich\<T > Vergleich)](xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29) sortiert die Elemente in der gesamten Liste mithilfe des angegebenen Comparers.  
  
 [Liste\<T >. Sortierung (IComparer\<T > Comparer)](xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29) sortiert die Elemente in der gesamten Liste unter Verwendung des angegebenen <xref:System.Comparison%601?displayProperty=nameWithType>.  
  
 [Liste\<T >. Sortierung (Int32-Index, Int32-Anzahl IComparer\<T > Comparer)](xref:System.Collections.Generic.List%601.Sort%28System.Int32,System.Int32,System.Collections.Generic.IComparer%7B%600%7D%29) sortiert die Elemente in einem Bereich von Elementen in der Liste mithilfe des angegebenen Comparers.  
  
## <a name="parameters"></a>Parameter  
  
|Parameter|Typ|Beschreibung|  
|---------------|----------|-----------------|  
|`comparison`|<xref:System.Comparison%601>|Die Delegatmethode, verwenden Sie beim Vergleichen von Elementen|  
|comparer|<xref:System.Collections.Generic.IComparer%601>|Die <xref:System.Collections.Generic.IComparer%601> -Implementierung, die beim Vergleichen von Elementen verwenden, oder null, um die Verwendung des Standardcomparers <xref:System.Collections.Generic.Comparer%601.Default>.|  
|`index`|<xref:System.Int32>|Der nullbasierte Startindex des zu sortierenden Bereichs.|  
|`count`|<xref:System.Int32>|Die Länge des zu sortierenden Bereichs.|  
  
## <a name="exceptions"></a>Ausnahmen  
  
|Ausnahme|Bedingung|  
|---------------|---------------|  
|<xref:System.InvalidOperationException>|`comparer`nicht angegeben oder `null`, und der Standardcomparer <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Implementierung kann nicht gefunden werden. die <xref:System.IComparable%601?displayProperty=nameWithType> generische Schnittstelle oder die <xref:System.IComparable?displayProperty=nameWithType> -Schnittstelle für den Typ t|  
|<xref:System.ArgumentNullException>|`comparison` ist `null`.|  
|<xref:System.ArgumentException>|Die Implementierung der `comparison` oder `comparer` hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt `comparison` beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.<br /><br /> - oder - <br /><br /> `index` und `count` geben keinen gültigen Bereich in der <xref:System.Collections.Generic.List%601> an.|  
|<xref:System.ArgumentOutOfRangeException>|`index`ist kleiner als 0 oder `count` ist kleiner als 0.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sortiert die Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> mithilfe des Standardcomparers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> für Typ `T` bestimmt die Reihenfolge der Listenelemente. Die <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> -Eigenschaft überprüft, ob der Typ `T` implementiert die <xref:System.IComparable%601> generische Schnittstelle und, dass diese Implementierung verwendet, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable> Schnittstelle.  Wenn Typ `T` implementiert nicht die beiden Schnittstellen <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> löst eine <xref:System.InvalidOperationException>.  
  
 Diese Methode verwendet die <xref:System.Array.Sort%2A?displayProperty=nameWithType> -Methode, die die introspective Sortierreihenfolge wie folgt angewendet:  
  
-   Wenn die Größe der Partition Elemente weniger als 16 ist, wird eine Einfügung Sortieralgorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 Protokoll überschreitet * n *, wobei * n * ist der Bereich des Eingabearrays, verwendet es einen Heapsort-Algorithmus.  
  
-   Andernfalls verwendet es einen Quicksort-Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Im Durchschnitt ist diese Methode eine O (* n * Protokoll * n *)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>; im schlimmsten Fall ist ein O ( * n * <sup>2</sup>) Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einige Objektnamen eine `List<String>` -Objekt, zeigt die Liste in unsortierter Reihenfolge ruft der <xref:System.Collections.Generic.List%601.Sort%2A> -Methode, und zeigt dann die sortierte Liste.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort> und <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> Überladungen der Methode für ein einfaches Geschäftsobjekt. Aufrufen der <xref:System.Collections.Generic.List%601.Sort> Methode führt die Verwendung der Standardvergleich für den Typ des Teils, und die <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> Methode mit einer anonymen Methode implementiert wird.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort> -methodenüberladung und die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> methodenüberladung. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit vier Zeichenfolgen, ohne bestimmte Reihenfolge gefüllt ist. Die Liste wird angezeigt, sortiert und erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> methodenüberladung wird dann verwendet, um zwei Zeichenfolgen zu suchen, die nicht in der Liste enthalten sind und die <xref:System.Collections.Generic.List%601.Insert%2A> Methode dient zum Einfügen. Der Rückgabewert der <xref:System.Collections.Generic.List%601.BinarySearch%2A> Methode ist in jedem Fall negativ, da die Zeichenfolgen nicht in der Liste enthalten sind. Dem bitweisen Komplement (der ~-Operator in c# und Visual C++ `Xor` -1 in Visual Basic) dieses negative Zahl wird der Index des ersten Elements in der Liste, die größer als die Suchzeichenfolge und Einfügen an dieser Stelle ist beibehalten sortieren Reihenfolge. Die zweite Suchzeichenfolge ist größer als ein Element in der Liste, daher ist die Position der Einfügemarke am Ende der Liste.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Standardvergleich <see cref="P:System.Collections.Generic.Comparer`1.Default" /> eine Implementierung von kann nicht gefunden werden. die <see cref="T:System.IComparable`1" /> generische Schnittstelle oder die <see cref="T:System.IComparable" /> -Schnittstelle für den Typ <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, wenn der Standardvergleich <see cref="P:System.Collections.Generic.Comparer`1.Default" /> verwendet werden soll.</param>
        <summary>Sortiert die Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> mithilfe des angegebenen Comparers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` angegeben wird, werden die Elemente der <xref:System.Collections.Generic.List%601> sortiert sind, unter Verwendung des angegebenen <xref:System.Collections.Generic.IComparer%601> Implementierung.  
  
 Wenn `comparer` ist `null`, die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable%601> generische Schnittstelle und, dass diese Implementierung verwendet, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable> Schnittstelle.  Wenn Typ `T` implementiert nicht die beiden Schnittstellen <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> löst eine <xref:System.InvalidOperationException>.  
  
 Diese Methode verwendet die <xref:System.Array.Sort%2A?displayProperty=nameWithType> -Methode, die die introspective Sortierreihenfolge wie folgt angewendet:  
  
-   Wenn die Größe der Partition Elemente weniger als 16 ist, wird eine Einfügung Sortieralgorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 Protokoll überschreitet * n *, wobei * n * ist der Bereich des Eingabearrays, verwendet es einen Heapsort-Algorithmus.  
  
-   Andernfalls verwendet es einen Quicksort-Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Im Durchschnitt ist diese Methode eine O (* n * Protokoll * n *)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>; im schlimmsten Fall ist ein O ( * n * <sup>2</sup>) Vorgang.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> -methodenüberladung und die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> methodenüberladung.  
  
 Im Beispiel wird einen alternativen Vergleich für DinoCompare implementiert-Zeichenfolgen definiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich funktioniert wie folgt: zunächst der verglichenen Elemente getestet werden `null`, und ein null-Verweis als kleiner als ein Wert ungleich Null behandelt wird. Zweitens die Zeichenfolgenlängen verglichen werden, und die Zeichenfolge längere ist als größer werden. Wenn die Länge gleich sind, wird im dritten gewöhnliche Zeichenfolgenvergleich verwendet.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit vier Zeichenfolgen, ohne bestimmte Reihenfolge gefüllt ist. Die Liste ist, mit dem alternativen Vergleich sortiert und angezeigten erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> methodenüberladung wird dann verwendet, um mehrere Zeichenfolgen zu suchen, die nicht in der Liste den alternativen Vergleich eingefügt werden. Die <xref:System.Collections.Generic.List%601.Insert%2A> Methode verwendet, um die Zeichenfolgen einzufügen. Diese beiden Methoden befinden sich in der Funktion mit dem Namen `SearchAndInsert`, zusammen mit Code, das bitweise Komplement (der ~-Operator in c# und Visual C++ `Xor` -1 in Visual Basic) für die zurückgegebene negative Zahl <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> und verwenden es als ein Index für Einfügen der neuen Zeichenfolge an.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> nicht finden.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">Die <see cref="T:System.Comparison`1" />, die beim Vergleich von Elementen verwendet werden soll.</param>
        <summary>Sortiert die Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> mithilfe des angegebenen <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparison` angegeben wird, werden die Elemente der <xref:System.Collections.Generic.List%601> mithilfe der durch den Delegaten dargestellten Methode sortiert sind.  
  
 Wenn `comparison` ist `null`, wird eine <xref:System.ArgumentNullException> ausgelöst wird.  
  
 Diese Methode verwendet <xref:System.Array.Sort%2A?displayProperty=nameWithType>, den gilt der introspective Sortierreihenfolge wie folgt:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet einen Sortieralgorithmus einfügen  
  
-   Überschreitet die Anzahl der Partitionen 2 Protokoll * n *, wobei * n * ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](http://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es einen Quicksort-Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Im Durchschnitt ist diese Methode eine O (* n * Protokoll * n *)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>; im schlimmsten Fall ist ein O ( * n * <sup>2</sup>) Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort%2A> und <xref:System.Collections.Generic.List%601.Sort%2A> Überladungen der Methode für ein einfaches Geschäftsobjekt. Aufrufen der <xref:System.Collections.Generic.List%601.Sort%2A> Methode führt die Verwendung der Standardvergleich für den Typ des Teils, und die <xref:System.Collections.Generic.List%601.Sort%2A> Methode wird mit einer anonymen Methode implementiert.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> -methodenüberladung.  
  
 Im Beispiel definiert eine alternative Vergleichsmethode für Zeichenfolgen, die mit dem Namen `CompareDinosByLength`. Diese Methode funktioniert wie folgt: zunächst der verglichenen Elemente getestet werden `null`, und ein null-Verweis als kleiner als ein Wert ungleich Null behandelt wird. Zweitens die Zeichenfolgenlängen verglichen werden, und die Zeichenfolge längere ist als größer werden. Wenn die Länge gleich sind, wird im dritten gewöhnliche Zeichenfolgenvergleich verwendet.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit vier Zeichenfolgen, ohne bestimmte Reihenfolge gefüllt ist. Die Liste enthält auch eine leere Zeichenfolge und ein null-Verweis. Die Liste wird angezeigt, sortiert, mit einem <xref:System.Comparison%601> generischer Delegat darstellt der `CompareDinosByLength` -Methode, und erneut angezeigt.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="comparison" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparison" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparison" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des zu sortierenden Bereichs.</param>
        <param name="count">Die Länge des zu sortierenden Bereichs.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, wenn der Standardvergleich <see cref="P:System.Collections.Generic.Comparer`1.Default" /> verwendet werden soll.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> mithilfe des angegebenen Vergleichs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` angegeben wird, werden die Elemente der <xref:System.Collections.Generic.List%601> sortiert sind, unter Verwendung des angegebenen <xref:System.Collections.Generic.IComparer%601> Implementierung.  
  
 Wenn `comparer` ist `null`, die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable%601> generische Schnittstelle und, dass diese Implementierung verwendet, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable> Schnittstelle.  Wenn Typ `T` implementiert nicht die beiden Schnittstellen <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> löst eine <xref:System.InvalidOperationException>.  
  
 Diese Methode verwendet <xref:System.Array.Sort%2A?displayProperty=nameWithType>, den gilt der introspective Sortierreihenfolge wie folgt:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet einen Sortieralgorithmus einfügen  
  
-   Überschreitet die Anzahl der Partitionen 2 Protokoll * n *, wobei * n * ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](http://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es einen Quicksort-Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Im Durchschnitt ist diese Methode eine O (* n * Protokoll * n *)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>; im schlimmsten Fall ist ein O ( * n * <sup>2</sup>) Vorgang.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> -methodenüberladung und die <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> methodenüberladung.  
  
 Im Beispiel wird einen alternativen Vergleich für DinoCompare implementiert-Zeichenfolgen definiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich funktioniert wie folgt: zunächst der verglichenen Elemente getestet werden `null`, und ein null-Verweis als kleiner als ein Wert ungleich Null behandelt wird. Zweitens die Zeichenfolgenlängen verglichen werden, und die Zeichenfolge längere ist als größer werden. Wenn die Länge gleich sind, wird im dritten gewöhnliche Zeichenfolgenvergleich verwendet.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit den Namen der fünf pflanzenfressenden Dinosauriern und drei zur Dinosaurier aufgefüllt wird. In jedem von zwei Gruppen sind die Namen nicht in der Sortierreihenfolge vor. Die Liste wird angezeigt, die Gruppe der Pflanzenfresser wird mit dem alternativen Vergleich sortiert und die Liste wird erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> methodenüberladung wird dann verwendet, um nur die Gruppe der Pflanzenfresser "Brachiosaurus" suchen. Die Zeichenfolge nicht gefunden wird, und das bitweise Komplement (der ~-Operator in c# und Visual C++ `Xor` -1 in Visual Basic) für die zurückgegebene negative Zahl der <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Methode dient als Index zum Einfügen der neuen Zeichenfolge.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in der <see cref="T:System.Collections.Generic.List`1" /> an.  
  
 - oder -   
  
 Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> nicht finden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.Generic.ICollection`1" /> schreibgeschützt ist.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="T:System.Collections.Generic.ICollection`1" /> schreibgeschützt ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist eine Auflistung mit einem Wrapper, der verhindert, dass die Auflistung ändern; Wenn Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, spiegelt die schreibgeschützte Auflistung daher diese Änderungen wider.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerator`1" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach` -Anweisung der Programmiersprache c# (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist die <xref:System.Collections.Generic.IEnumerator%601.Current%2A> Eigenschaft ist nicht definiert. Sie müssen daher rufen die <xref:System.Collections.IEnumerator.MoveNext%2A> Methode, um den Enumerator auf das erste Element der Auflistung vor dem Lesen des Werts von <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 Die <xref:System.Collections.Generic.IEnumerator%601.Current%2A> Eigenschaft gibt das gleiche Objekt bis <xref:System.Collections.IEnumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.Generic.IEnumerator%601.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false`. Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <xref:System.Collections.IEnumerator.MoveNext%2A> auch zurückgeben `false`. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.ICollection" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index im <c>Array</c> an dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die Elemente der <see cref="T:System.Collections.ICollection" /> in ein <see cref="T:System.Array" />, beginnend bei einem bestimmten <see cref="T:System.Array" />-Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn der Typ der Quelle <xref:System.Collections.ICollection> kann nicht automatisch in den Typ des Ziels umgewandelt werden `array`, die nicht generischen Implementierungen von <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> auslösen <xref:System.InvalidCastException>, während die Implementierungen die generischen auslösen <xref:System.ArgumentException>.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="array" />verfügt nicht über nullbasierter Indizierung.  
  
 - oder -   
  
 Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.ICollection" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />.  
  
 - oder -   
  
 Der Typ des Quell-<see cref="T:System.Collections.ICollection" />s kann nicht automatisch in den Typ des Ziel-<paramref name="array" />s umgewandelt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist.</summary>
        <value>
          <see langword="true" />, wenn der Zugriff auf das <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  In seltenen Fällen, in denen Enumeration mit Schreibzugriff konkurriert, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A>Gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt zu sperren, bevor der Zugriff auf die Auflistung.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.  In der Standardimplementierung der <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer die aktuelle Instanz zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A>Gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt zu sperren, bevor der Zugriff auf die Auflistung. Der folgende Code zeigt die Verwendung der <xref:System.Collections.ICollection.SyncRoot%2A> -Eigenschaft für c#, C++ und Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach` -Anweisung der Programmiersprache c# (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist die <xref:System.Collections.IEnumerator.Current%2A> Eigenschaft ist nicht definiert. Sie müssen daher rufen die <xref:System.Collections.IEnumerator.MoveNext%2A> Methode, um den Enumerator auf das erste Element der Auflistung vor dem Lesen des Werts von <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Die <xref:System.Collections.IEnumerator.Current%2A> Eigenschaft gibt das gleiche Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false`. Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <xref:System.Collections.IEnumerator.MoveNext%2A> auch zurückgeben `false`. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das <see cref="T:System.Object" />, das in <see cref="T:System.Collections.IList" /> eingefügt werden soll.</param>
        <summary>Fügt der <see cref="T:System.Collections.IList" /> ein Element hinzu.</summary>
        <returns>Die Position, an der das neue Element eingefügt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> ist kleiner als <xref:System.Collections.Generic.List%601.Capacity%2A>, diese Methode ist ein o(1)-Vorgang. Wenn die Kapazität für das neue Element erhöht werden muss, wird diese Methode eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" />verfügt über einen Typ, der nicht zugeordnet werden kann, ist die <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das <see cref="T:System.Object" />, das in der <see cref="T:System.Collections.IList" /> gesucht werden soll.</param>
        <summary>Ermittelt, ob die <see cref="T:System.Collections.IList" /> einen bestimmten Wert enthält.</summary>
        <returns>
          <see langword="true" />, wenn das <paramref name="item" /> in der <see cref="T:System.Collections.IList" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt die Gleichheit mithilfe des Standardgleichheitsvergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, der Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.IList" /> zu suchende Objekt.</param>
        <summary>Bestimmt den Index eines bestimmten Elements in der <see cref="T:System.Collections.IList" />.</summary>
        <returns>Der Index von <paramref name="item" />, wenn das Element in der Liste gefunden wird, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt die Gleichheit mithilfe des Standardgleichheitsvergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, der Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" />verfügt über einen Typ, der nicht zugeordnet werden kann, ist die <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem <c>Element</c> eingefügt werden soll.</param>
        <param name="item">Das in die <see cref="T:System.Collections.IList" /> einzufügende Objekt.</param>
        <summary>Fügt am angegebenen Index ein Element in die <see cref="T:System.Collections.IList" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `index` gleich der Anzahl der Elemente in <xref:System.Collections.IList> ist, wird `item` am Ende angefügt.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kein gültiger Index in <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" />verfügt über einen Typ, der nicht zugeordnet werden kann, ist die <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.IList" /> eine feste Größe aufweist.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="T:System.Collections.IList" /> eine feste Größe aufweist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Auflistung mit fester Größe lässt das Hinzufügen oder Entfernen von Elementen nach dem Erstellen der Auflistung nicht zu. Vorhandene Elemente können jedoch geändert werden.  
  
 Eine Auflistung mit fester Größe ist einfach eine Auflistung mit einem Wrapper, der verhindert, dass hinzufügen und Entfernen von Elementen. Deshalb spiegelt die Auflistung mit fester Größe zum Änderungen vorgenommen werden, auf die zugrunde liegende Auflistung, z. B. das Hinzufügen oder Entfernen von Elementen, die Änderungen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.IList" /> schreibgeschützt ist.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="T:System.Collections.IList" /> schreibgeschützt ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist eine Auflistung mit einem Wrapper, der verhindert, dass die Auflistung ändern; Wenn Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, spiegelt die schreibgeschützte Auflistung daher diese Änderungen wider.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des Elements, das abgerufen oder festgelegt werden soll.</param>
        <summary>Ruft das Element am angegebenen Index ab oder legt dieses fest.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die C#-Sprache verwendet die [dies](~/docs/csharp/language-reference/keywords/this.md) -Schlüsselwort zum Definieren der Indexer anstatt zu implementieren die <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> Eigenschaft. Visual Basic implementiert <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang. Festlegen der Eigenschaft ist auch ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kein gültiger Index in <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">Die Eigenschaft festgelegt ist und <paramref name="value" /> verfügt über einen Typ, der nicht zugeordnet werden kann, ist die <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das aus der <see cref="T:System.Collections.IList" /> zu entfernende Objekt.</param>
        <summary>Entfernt das erste Vorkommen eines angegebenen Objekts aus der <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt die Gleichheit mithilfe des Standardgleichheitsvergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, der Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" />verfügt über einen Typ, der nicht zugeordnet werden kann, ist die <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die Elemente der <see cref="T:System.Collections.Generic.List`1" /> in ein neues Array.</summary>
        <returns>Ein Array, das Kopien der Elemente aus <see cref="T:System.Collections.Generic.List`1" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente kopiert werden, mithilfe von <xref:System.Array.Copy%2A?displayProperty=nameWithType>, also eine O (*n*)-Vorgang, in dem * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.ToArray%2A> -Methode und andere Methoden der <xref:System.Collections.Generic.List%601> -Klasse, die für Bereiche verwendet. Am Ende des Beispiels die <xref:System.Collections.Generic.List%601.GetRange%2A> Methode wird verwendet, um drei Elemente aus der Liste ab Indexposition 2 abgerufen. Die <xref:System.Collections.Generic.List%601.ToArray%2A> Methode wird aufgerufen, für die resultierende <xref:System.Collections.Generic.List%601>, erstellen ein Array von drei Elementen. Die Elemente des Arrays werden angezeigt.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt die Kapazität auf die Anzahl der tatsächlich in der <see cref="T:System.Collections.Generic.List`1" /> befindlichen Elemente fest, sofern diese Anzahl unter dem Schwellenwert liegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um Speicher für eine Auflistung Mehraufwand zu minimieren, wenn die Auflistung keine neuen Elemente hinzugefügt werden. Die Kosten erneut zugewiesen werden, und Kopieren einer großen <xref:System.Collections.Generic.List%601> jedoch sehr aufwändig sein kann daher die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode bewirkt nichts, wenn die Liste an mehr als 90 % der Kapazität ist. Dadurch wird vermieden, für einen relativ kleinen zu großen neuzuordnungen Kosten anfallen.  
  
> [!NOTE]
>  Der aktuelle Schwellenwert von 90 Prozent möglicherweise in zukünftigen Versionen ändern.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Zurücksetzen einer <xref:System.Collections.Generic.List%601> Aufrufen auf ihren ursprünglichen Zustand der <xref:System.Collections.Generic.List%601.Clear%2A> Methode vor dem Aufruf der <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode. Indem Sie eine leere <xref:System.Collections.Generic.List%601> legt die Kapazität der <xref:System.Collections.Generic.List%601> auf die festgelegte Standardkapazität.  
  
 Die Kapazität kann auch festgelegt werden mithilfe der <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Kapazität und die Anzahl der zu überprüfen einer <xref:System.Collections.Generic.List%601> enthält ein einfaches Geschäftsobjekt und veranschaulicht die Verwendung der <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode, um zusätzliche Kapazität zu entfernen.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode. Mehrere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> Klasse hinzufügen, einfügen und Entfernen von Elementen aus einer Liste von Zeichenfolgen verwendet werden. Die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode wird verwendet, um die Kapazität entsprechend der Anzahl reduzieren und die <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaften werden angezeigt. Wenn die nicht verwendete Kapazität weniger als 10 Prozent der Gesamtkapazität hätte, würde die Größe die Liste nicht geändert wurde. Zum Schluss werden der Inhalt der Liste gelöscht.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen definiert, auf die die Elemente geprüft werden sollen.</param>
        <summary>Bestimmt, ob jedes Element in der <see cref="T:System.Collections.Generic.List`1" /> die vom angegebenen Prädikat definierten Bedingungen erfüllt.</summary>
        <returns>
          <see langword="true" />, wenn jedes Element in der <see cref="T:System.Collections.Generic.List`1" /> die vom angegebenen Prädikat definierten Bedingungen erfüllt; andernfalls <see langword="false" />. Wenn die Liste über keine Elemente verfügt, ist der Rückgabewert <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> einzeln übergeben werden, um die <xref:System.Predicate%601> Delegat und die Verarbeitung wird beendet, wenn der Delegat zurückgegeben `false` für ein bestimmtes Element. Die Elemente werden nacheinander verarbeitet, und alle Aufrufe werden in einem einzelnen Thread.  
  
 Diese Methode ist eine O (*n*) Vorgang, wobei * n * ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.TrueForAll%2A> -Methode und andere Methoden verwenden, <xref:System.Predicate%601> generischen Delegaten.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt wird, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden. Im Beispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.  
  
 Die <xref:System.Collections.Generic.List%601.TrueForAll%2A> Methode durchläuft die Liste von Anfang an und übergibt die einzelnen Elemente an die `EndsWithSaurus` Methode. Die Suche angehalten wird, wenn die `EndsWithSaurus` -Methode zurückkehrt `false`.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
