<Type Name="NativeWindow" FullName="System.Windows.Forms.NativeWindow">
  <TypeSignature Language="C#" Value="public class NativeWindow : MarshalByRefObject, System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi NativeWindow extends System.MarshalByRefObject implements class System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.NativeWindow" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Forms.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Kapselung auf niedriger Ebene, ein Fensterhandle und eine Fensterprozedur bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse verwaltet automatisch erstellen und die Registrierung.  
  
 Ein Fenster ist nicht für die Garbagecollection geeignet, wenn sie ein Fensterhandle zugeordnet ist. Um sicherzustellen, dass die Garbagecollection, Handles müssen entweder zerstört manuell mit <xref:System.Windows.Forms.NativeWindow.DestroyHandle%2A> oder freigegeben werden, mithilfe von <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A>.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Methode wird aufgerufen, wenn die WM_NCDESTROY-Meldung verarbeitet wird. Dies bedeutet, es gibt Fälle, in das bei Sie nicht manuell aufrufen müssen <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A>, aber es empfiehlt sich zu diesem Zweck ist.  
  
 Die <xref:System.Windows.Forms.NativeWindow> Klasse enthält die folgenden Eigenschaften und Methoden zum Verwalten von Handles: <xref:System.Windows.Forms.NativeWindow.Handle%2A>, <xref:System.Windows.Forms.NativeWindow.CreateHandle%2A>, <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A>, <xref:System.Windows.Forms.NativeWindow.DestroyHandle%2A>, und <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, abgefangen Betriebssystem fenstermeldungen in eine Fensterprozedur auf, und erstellen ein Fenster mit einem bestimmten Betriebssystem Fensterklassennamen. Das Beispiel erstellt zwei Klassen, die von erben <xref:System.Windows.Forms.NativeWindow> , die dieses Ziel erreichen.  
  
 Die `MyNativeWindowListener` Klasse hooks in die Fensterprozedur des Formulars an den Konstruktor übergeben und überschreibt die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode zum Abfangen der `WM_ACTIVATEAPP` fenstermeldung. Die Klasse veranschaulicht die Verwendung von der <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A> und <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Methoden, um das Fensterhandle identifizieren die <xref:System.Windows.Forms.NativeWindow> verwendet. Das Handle ist zuweisen, die auf Grundlage der <xref:System.Windows.Forms.Control.HandleCreated?displayProperty=nameWithType> und <xref:System.Windows.Forms.Control.HandleDestroyed?displayProperty=nameWithType> Ereignisse. Wenn die `WM_ACTIVATEAPP` fenstermeldung empfangen wird, die Klasse ruft der `form1.ApplicationActivated` Methode.  
  
 Die `MyNativeWindow` Klasse erstellt ein neues Fenster mit den <xref:System.Windows.Forms.CreateParams.ClassName%2A> festgelegt `BUTTON`. Die Klasse veranschaulicht die Verwendung der <xref:System.Windows.Forms.NativeWindow.CreateHandle%2A> -Methode und überschreiben die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode, um die Intercept-fenstermeldungen, die empfangen werden.  
  
 [!code-cpp[NativeWindow#1](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#1)]
 [!code-csharp[NativeWindow#1](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#1)]
 [!code-vb[NativeWindow#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NativeWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine Instanz der <see cref="T:System.Windows.Forms.NativeWindow" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die Standardeinstellung <xref:System.Windows.Forms.NativeWindow.%23ctor%2A> Konstruktors vom Compiler bereitgestellt. Die <xref:System.Windows.Forms.NativeWindow> -Klasse verfügt auch über einen statischen Konstruktor, der Anwendung domänenweite Meldungshandler und Hashtabellen initialisiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssignHandle">
      <MemberSignature Language="C#" Value="public void AssignHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AssignHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Das Handle für dieses Fenster zuweisen.</param>
        <summary>Dieses Fenster wird ein Handle zugewiesen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.NativeWindow.WndProc%2A>fängt fenstermeldungen gesendet, um die `handle` Parameter. Verwendung <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Fensterprozedur auf das Handle an die Standardfensterprozedur zurücksetzen.  
  
 Die <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A> Methodenaufrufe der <xref:System.Windows.Forms.NativeWindow.OnHandleChange%2A> Methode, um anzugeben, dass der Wert des der <xref:System.Windows.Forms.NativeWindow.Handle%2A> -Eigenschaft geändert hat.  
  
> [!NOTE]
>  In einem anderen Anwendungsprozess darf nicht das Handle zugewiesen sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, abgefangen Betriebssystem fenstermeldungen in eine Fensterprozedur. Das Beispiel erstellt eine Klasse, die von erben <xref:System.Windows.Forms.NativeWindow> , dies zu erreichen.  
  
 Die `MyNativeWindowListener` Klasse hooks in die Fensterprozedur des Formulars an den Konstruktor übergeben und überschreibt die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> -Methode fängt die `WM_ACTIVATEAPP` fenstermeldung. Die Klasse veranschaulicht die Verwendung von der <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A> und <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Behandeln von Methoden zum Bestimmen der <xref:System.Windows.Forms.NativeWindow> verwenden. Das Handle zugewiesen ist, basierend auf den <xref:System.Windows.Forms.Control.HandleCreated?displayProperty=nameWithType> und <xref:System.Windows.Forms.Control.HandleDestroyed?displayProperty=nameWithType> Ereignisse. Wenn die `WM_ACTIVATEAPP` fenstermeldung empfangen wird, die Klasse ruft der `form1.ApplicationActivated` Methode.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.NativeWindow> -Klassenübersicht. Code ist für die Übersichtlichkeit nicht dargestellt. Finden Sie unter <xref:System.Windows.Forms.NativeWindow> für das gesamte Codelisting.  
  
 [!code-cpp[NativeWindow#2](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#2)]
 [!code-csharp[NativeWindow#2](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#2)]
 [!code-vb[NativeWindow#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Dieses Fenster ist bereits ein Handle.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Die Windows-Prozedur für das zugeordnete systemeigene Fenster konnte nicht abgerufen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="public virtual void CreateHandle (System.Windows.Forms.CreateParams cp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateHandle(class System.Windows.Forms.CreateParams cp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cp" Type="System.Windows.Forms.CreateParams" />
      </Parameters>
      <Docs>
        <param name="cp">Ein <see cref="T:System.Windows.Forms.CreateParams" /> , der die Erstellungsparameter für dieses Fenster angibt.</param>
        <summary>Erstellt ein Fenster und dessen Handle mit der angegebenen Erstellungsparameter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `cp` Parameter gibt die Werte, die an die systemeigenen Win32 übergeben werden `CreateWindowEx` Methode, um ein Fenster und dessen Handle zu erstellen.  
  
 Wenn die <xref:System.Windows.Forms.CreateParams.ClassName%2A> Feld ist nicht `null`, das neu erstellte Fensterhandle von der angegebenen Klasse erbt. Z. B. wenn <xref:System.Windows.Forms.CreateParams.ClassName%2A> festgelegt ist, um `BUTTON`, das neu erstellte Fenster basiert auf die Win32 `BUTTON` Fensterklasse. Die <xref:System.Windows.Forms.CreateParams.Param%2A> Eigenschaft von der <xref:System.Windows.Forms.CreateParams.ClassName%2A> Objekt muss entweder `null` oder Verweis auf eine Instanz einer Klasse, die als Struktur deklariert wurde.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.NativeWindow> -Klassenübersicht. Code ist für die Übersichtlichkeit nicht dargestellt. Finden Sie unter <xref:System.Windows.Forms.NativeWindow> für das gesamte Codelisting.  
  
> [!NOTE]
>  Der bereitgestellte Klassenname ist mit dem Betriebssystem registriert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Erstellen ein Fenster mit einem bestimmten Betriebssystem Fensterklassennamen. Das Beispiel erstellt eine Klasse, die von erben <xref:System.Windows.Forms.NativeWindow> , dies zu erreichen.  
  
 Die `MyNativeWindow` Klasse erstellt ein neues Fenster mit den <xref:System.Windows.Forms.CreateParams.ClassName%2A> festgelegt `BUTTON`. Dadurch wird ein Win32-Schaltfläche-Fenster erstellt. Die Position und Größe der Schaltfläche festgelegt ist, zusammen mit zusätzlichen Fensterstile angeben. Die Klasse veranschaulicht, wie die <xref:System.Windows.Forms.NativeWindow.CreateHandle%2A> -Methode und überschreiben die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode, um die Intercept-fenstermeldungen, die empfangen werden. Obwohl das Beispiel für die Nachricht WM_ACTIVATEAPP aussieht, kann dieser in ein echtes Programm mit Windows-Meldungen, die spezifisch für den erstellten Typ ersetzt werden.  
  
> [!NOTE]
>  Einige Steuerelementtypen senden ihre Windows-Nachrichten an das übergeordnete Fenster, anstatt das Fenster. Finden Sie in der Windows-Plattform-SDK für Weitere Informationen.  
  
 [!code-cpp[NativeWindow#3](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#3)]
 [!code-csharp[NativeWindow#3](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#3)]
 [!code-vb[NativeWindow#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Das Betriebssystem war nicht genügend Ressourcen, beim Versuch, das systemeigene Fenster erstellen.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Die systemeigenen Win32-API konnte des angegebenen Fensters nicht erstellt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Das Handle des aktuellen systemeigenen Fensters wird bereits zugewiesen. in der Erläuterung der <see cref="P:System.Windows.Forms.NativeWindow.Handle" /> Eigenschaft ist nicht gleich <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Um ein Fenster oberster Ebene zu erstellen. Durch diese Berechtigung wird nur dann gefordert, wenn der Fensterstil nicht untergeordnet ist oder wenn das Fenster nicht über ein übergeordnetes Element verfügt. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="public void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Die Meldung, die gerade verarbeitet wird.</param>
        <summary>Ruft die standardmäßige Fensterprozedur auf diesem Fenster zugeordnet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel nur rufen Sie die <xref:System.Windows.Forms.NativeWindow.DefWndProc%2A> Methode, wenn fenstermeldungen abfangen sind und die standardmäßige Fensterprozedur auf, die Nachricht behandeln möchten. <xref:System.Windows.Forms.NativeWindow.DefWndProc%2A>sollte nicht aufgerufen werden, um eine fenstermeldung an das Fenster zu senden. Rufen Sie die Win32 `SendMessage` stattdessen-Funktion.  
  
 Es ist ein Fehler auf, rufen Sie <xref:System.Windows.Forms.NativeWindow.DefWndProc%2A> bei der <xref:System.Windows.Forms.NativeWindow.Handle%2A> Eigenschaft ist 0.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Überschreiben Sie diese Methode in einer abgeleiteten Klasse zum Implementieren von benutzerdefinierten generalisierte Meldungsbehandlung für einen bestimmten systemeigene Fenster oder .NET Windows Forms <see cref="T:System.Windows.Forms.Control" />. Benutzerdefinierte Verarbeitung kann ausgeführt werden, vor, nach oder statt einen Aufruf der basisklassenimplementierung dieser Methode, die standard-Nachrichtenverarbeitung ausführt.  
  
 Im Gegensatz dazu Hinzufügen benutzerdefinierter Nachrichtenbehandlung für eine Anwendung über durchgeführt werden, kann die <see cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" /> Methode der <see cref="T:System.Windows.Forms.Application" /> Klasse.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DestroyHandle">
      <MemberSignature Language="C#" Value="public virtual void DestroyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DestroyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zerstört das Fenster und dessen Handle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zerstört, die zugeordnete Fenster die <xref:System.Windows.Forms.NativeWindow.Handle%2A>, legt der <xref:System.Windows.Forms.NativeWindow.Handle%2A> Eigenschaft auf 0 und der Aufrufe der <xref:System.Windows.Forms.NativeWindow.OnHandleChange%2A> Methode, um die Änderung zu übernehmen. In der Regel nur aufrufen <xref:System.Windows.Forms.NativeWindow.DestroyHandle%2A> Wenn Sie das systemeigene Fenster fertig sind.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.NativeWindow> -Klasse automatisch zerstört das zugeordnete Fenster und Freigeben der Ressourcen in der Antwort an eine WM_DESTROY-Meldung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~NativeWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Die diesem Fenster zugeordneten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.NativeWindow.Finalize%2A> Methode entfernt die abgeleitete Win32-Klasse, die mit dem aktuellen gehört <xref:System.Windows.Forms.NativeWindow> Instanz, die das Handle freigegeben und sendet eine WM_CLOSE-Meldung an das zugeordnete Fenster.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.NativeWindow FromHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.NativeWindow FromHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.FromHandle(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.NativeWindow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Handle für ein Fenster.</param>
        <summary>Ruft das dem angegebenen Handle zugeordnete Fenster ab.</summary>
        <returns>Die <see cref="T:System.Windows.Forms.NativeWindow" /> verknüpft sind, mit dem angegebenen Handle. Diese Methode gibt <see langword="null" /> Wenn das Handle nicht Fenster zugeordnet haben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Handle von einer anderen Methode erhalten, verwenden Sie diese Methode, um das Fenster, die dem Handle zugeordneten abzurufen. Das Handle muss bereits im Besitz eines anderen <xref:System.Windows.Forms.NativeWindow> im aktuellen Prozess ist, andernfalls `null` zurückgegeben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.NativeWindow.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Handle für dieses Fenster ab.</summary>
        <value>Bei Erfolg ein <see cref="T:System.IntPtr" /> , das Handle für das zugeordnete systemeigene Win32-Fenster; darstellt, andernfalls 0, wenn kein Handle Fenster zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode beim Aufrufen von Windows-API-Methoden, die ein Handle für ein Fenster oder ein Steuerelement zu erfordern.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Erstellen ein Fenster mit einem bestimmten Betriebssystem Fensterklassennamen. Das Beispiel erstellt eine Klasse, die von erben <xref:System.Windows.Forms.NativeWindow> , dies zu erreichen. Auch das Beispiel veranschaulicht das Überschreiben der <xref:System.Windows.Forms.NativeWindow.OnHandleChange%2A> Methode Wenn benachrichtigt werden, die <xref:System.Windows.Forms.NativeWindow.Handle%2A> ändert.  
  
 Die `MyNativeWindow` Klasse erstellt ein neues Fenster mit den <xref:System.Windows.Forms.CreateParams.ClassName%2A> legen Sie auf die Schaltfläche. Dadurch wird ein Win32-Schaltfläche-Fenster erstellt. Die Position und Größe der Schaltfläche festgelegt ist, zusammen mit zusätzlichen Fensterstile angeben. Die Klasse veranschaulicht, wie die <xref:System.Windows.Forms.NativeWindow.CreateHandle%2A> -Methode und überschreiben die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode, um die Intercept-fenstermeldungen, die empfangen werden. Obwohl das Beispiel für die Nachricht WM_ACTIVATEAPP aussieht, konnte dieser in ein echtes Programm mit Windows-Meldungen, die spezifisch für den erstellten Typ ersetzt werden.  
  
> [!NOTE]
>  Einige Steuerelementtypen senden ihre Windows-Nachrichten an das übergeordnete Fenster, anstatt das Fenster. Finden Sie in der Windows-Plattform-SDK für Weitere Informationen.  
  
 [!code-cpp[NativeWindow#3](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#3)]
 [!code-csharp[NativeWindow#3](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#3)]
 [!code-vb[NativeWindow#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleChange">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleChange ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.OnHandleChange" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Benachrichtigungsmethode, die aufgerufen wird, wenn das Handle für ein Fenster geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn der Wert des der <xref:System.Windows.Forms.NativeWindow.Handle%2A> -Eigenschaft geändert hat.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Erstellen ein Fenster mit einem bestimmten Betriebssystem Fensterklassennamen. Das Beispiel erstellt eine Klasse, die von erben <xref:System.Windows.Forms.NativeWindow> , dies zu erreichen. Auch das Beispiel veranschaulicht das Überschreiben der <xref:System.Windows.Forms.NativeWindow.OnHandleChange%2A> Methode Wenn benachrichtigt werden, die <xref:System.Windows.Forms.NativeWindow.Handle%2A> ändert.  
  
 Die `MyNativeWindow` Klasse erstellt ein neues Fenster mit den <xref:System.Windows.Forms.CreateParams.ClassName%2A> festgelegt `BUTTON`. Dadurch wird ein Win32-Schaltfläche-Fenster erstellt. Die Position und Größe der Schaltfläche festgelegt ist, zusammen mit zusätzlichen Fensterstile angeben. Die Klasse veranschaulicht, wie die <xref:System.Windows.Forms.NativeWindow.CreateHandle%2A> -Methode und überschreiben die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode, um die Intercept-fenstermeldungen, die empfangen werden. Obwohl das Beispiel für die Nachricht WM_ACTIVATEAPP aussieht, kann dieser in ein echtes Programm mit Windows-Meldungen, die spezifisch für den erstellten Typ ersetzt werden.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.NativeWindow> -Klassenübersicht. Code ist für die Übersichtlichkeit nicht dargestellt. Finden Sie unter <xref:System.Windows.Forms.NativeWindow> für das gesamte Codelisting.  
  
> [!NOTE]
>  Einige Steuerelementtypen senden ihre Windows-Nachrichten an das übergeordnete Fenster, anstatt das Fenster. Finden Sie in der Windows-Plattform-SDK für Weitere Informationen.  
  
 [!code-cpp[NativeWindow#3](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#3)]
 [!code-csharp[NativeWindow#3](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#3)]
 [!code-vb[NativeWindow#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Überschreiben Sie diese Methode zum Nachverfolgen von Änderungen, die an das Fensterhandle vorgenommen werden.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="protected virtual void OnThreadException (Exception e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnThreadException(class System.Exception e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.OnThreadException(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="e">Eine <see cref="T:System.Exception" /> , die die nicht behandelte Threadausnahme angibt.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse wird eine nicht behandelte Threadausnahme verwaltet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel <xref:System.Windows.Forms.Application.OnThreadException%2A> Handles thread Ausnahmen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="public virtual void ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das Handle, das diesem Fenster zugeordneten frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zerstört nicht das Fensterhandle. Stattdessen wird das Handle Fensterprozedur an die Standardfensterprozedur. Es legt die <xref:System.Windows.Forms.NativeWindow.Handle%2A> Eigenschaft auf 0 fest und ruft <xref:System.Windows.Forms.NativeWindow.OnHandleChange%2A> um die Änderung zu übernehmen.  
  
 Ein Fenster ruft diese Methode automatisch, wenn sie eine systemeigene WM_NCDESTROY-Win32-Nachricht empfängt, gibt an, dass Windows das Handle zerstört wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, abgefangen Betriebssystem fenstermeldungen in eine Fensterprozedur. Das Beispiel erstellt eine Klasse, die von erben <xref:System.Windows.Forms.NativeWindow> , dies zu erreichen.  
  
 Die `MyNativeWindowListener` Klasse hooks in die Fensterprozedur des Formulars an den Konstruktor übergeben und überschreibt die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> -Methode fängt die `WM_ACTIVATEAPP` fenstermeldung. Die Klasse veranschaulicht die Verwendung von der <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A> und <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Methoden, um das Fensterhandle identifizieren die <xref:System.Windows.Forms.NativeWindow> verwendet. Das Handle ist zuweisen, die auf Grundlage der <xref:System.Windows.Forms.Control.HandleCreated?displayProperty=nameWithType> und <xref:System.Windows.Forms.Control.HandleDestroyed?displayProperty=nameWithType> Ereignisse. Wenn die `WM_ACTIVATEAPP` fenstermeldung empfangen wird, die Klasse ruft der `form1.ApplicationActivated` Methode.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.NativeWindow> -Klassenübersicht. Code ist für die Übersichtlichkeit nicht dargestellt. Finden Sie unter <xref:System.Windows.Forms.NativeWindow> für das gesamte Codelisting.  
  
 [!code-cpp[NativeWindow#2](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#2)]
 [!code-csharp[NativeWindow#2](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#2)]
 [!code-vb[NativeWindow#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected virtual void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.WndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Ein <see cref="T:System.Windows.Forms.Message" /> , die aktuellen Windows-Meldung zugeordnet ist.</param>
        <summary>Ruft die standardmäßige Fensterprozedur auf diesem Fenster zugeordnet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn eine Meldung an das Handle des Fensters gesendet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, abgefangen Betriebssystem fenstermeldungen in eine Fensterprozedur. Das Beispiel erstellt eine Klasse, die von erben <xref:System.Windows.Forms.NativeWindow> , dies zu erreichen.  
  
 Die `MyNativeWindowListener` Klasse hooks in die Fensterprozedur des Formulars an den Konstruktor übergeben und überschreibt die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode zum Abfangen der `WM_ACTIVATEAPP` fenstermeldung. Die Klasse veranschaulicht die Verwendung von der <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A> und <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Methoden, um das Fensterhandle identifizieren die <xref:System.Windows.Forms.NativeWindow> verwendet. Das Handle zugewiesen ist, basierend auf den <xref:System.Windows.Forms.Control.HandleCreated?displayProperty=nameWithType> und <xref:System.Windows.Forms.Control.HandleDestroyed?displayProperty=nameWithType> Ereignisse. Wenn die `WM_ACTIVATEAPP` fenstermeldung empfangen wird, die Klasse ruft der `form1.ApplicationActivated` Methode.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.NativeWindow> -Klassenübersicht. Code ist für die Übersichtlichkeit nicht dargestellt. Finden Sie unter <xref:System.Windows.Forms.NativeWindow> für das gesamte Codelisting.  
  
 [!code-cpp[NativeWindow#2](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#2)]
 [!code-csharp[NativeWindow#2](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#2)]
 [!code-vb[NativeWindow#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Überschreiben Sie diese Methode, um die Verarbeitung von bestimmten Nachrichten implementieren. Rufen Sie <c>Basis. WndProc</c> für nicht verarbeitete Nachrichten.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
