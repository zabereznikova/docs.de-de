<Type Name="BindingSource" FullName="System.Windows.Forms.BindingSource">
  <TypeSignature Language="C#" Value="public class BindingSource : System.ComponentModel.Component, System.Collections.IList, System.ComponentModel.IBindingListView, System.ComponentModel.ICancelAddNew, System.ComponentModel.ISupportInitializeNotification, System.ComponentModel.ITypedList, System.Windows.Forms.ICurrencyManagerProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingSource extends System.ComponentModel.Component implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.ComponentModel.IBindingList, class System.ComponentModel.IBindingListView, class System.ComponentModel.ICancelAddNew, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.ComponentModel.ITypedList, class System.Windows.Forms.ICurrencyManagerProvider" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.BindingSource" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IBindingListView</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ICancelAddNew</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ITypedList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.ICurrencyManagerProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.ComplexBindingProperties("DataSource", "DataMember")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("CurrentChanged")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("DataSource")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.BindingSourceDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Kapselt die Datenquelle für ein Formular.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource> Komponente dient vielen Zwecken. Zunächst wird die Binden von Steuerelementen in einem Formular an Daten vereinfacht, indem währungsverwaltung, änderungsbenachrichtigung und andere Dienste zwischen Windows Forms-Steuerelemente und Datenquellen. Dies erfolgt durch Anfügen der <xref:System.Windows.Forms.BindingSource> -Komponente an die Datenquelle mit dem <xref:System.Windows.Forms.BindingSource.DataSource%2A> Eigenschaft. Bei komplexen Bindungsszenarios Sie optional Festlegen der <xref:System.Windows.Forms.BindingSource.DataMember%2A> Eigenschaft, um eine bestimmte Spalte oder Liste in der Datenquelle. Anschließend binden Sie Steuerelemente an die <xref:System.Windows.Forms.BindingSource>. Alle weiteren Interaktionen mit den Daten erfolgt durch Aufrufe der <xref:System.Windows.Forms.BindingSource> Komponente. Beispiele, wie sich die <xref:System.Windows.Forms.BindingSource> des Bindungsvorgangs vereinfachen können, finden Sie unter [Vorgehensweise: Binden von Windows Forms-Steuerelementen an DBNull-Datenbankwerte](~/docs/framework/winforms/controls/how-to-bind-windows-forms-controls-to-dbnull-database-values.md) und [wie: Behandeln von Fehlern und Ausnahmen, auftreten, mit der Datenbindung](~/docs/framework/winforms/controls/how-to-handle-errors-and-exceptions-that-occur-with-databinding.md). Navigation und Aktualisierung der Datenquelle erfolgt durch Methoden wie z. B. <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveLast%2A>, und <xref:System.Windows.Forms.BindingSource.Remove%2A>. Werden Vorgänge wie das Sortieren und Filtern von behandelt die <xref:System.Windows.Forms.BindingSource.Sort%2A> und <xref:System.Windows.Forms.BindingSource.Filter%2A> Eigenschaften. Weitere Informationen zum Sortieren und Filtern mit der <xref:System.Windows.Forms.BindingSource>, finden Sie unter [wie: Sortieren und Filtern von ADO.NET-Daten mit der BindingSource-Komponente in Windows Forms](~/docs/framework/winforms/controls/sort-and-filter-ado-net-data-with-wf-bindingsource-component.md).  
  
 Darüber hinaus die <xref:System.Windows.Forms.BindingSource> Komponente als Quelle für eine stark typisierte Daten fungieren kann. Der Typ der zugrunde liegenden Datenquelle wird in der Regel über einen der folgenden Mechanismen wurden behoben:  
  
-   Verwenden der <xref:System.Windows.Forms.BindingSource.Add%2A> Methode zum Hinzufügen eines Elements auf der <xref:System.Windows.Forms.BindingSource> Komponente.  
  
-   Legen Sie die <xref:System.Windows.Forms.BindingSource.DataSource%2A> Eigenschaft, um eine Liste, einzelnes Objekt oder Typ.  
  
 Beide Mechanismen erstellen eine stark typisierte Liste. Weitere Informationen zum Verwenden der <xref:System.Windows.Forms.BindingSource> zum Binden an einen Typ finden Sie unter [Vorgehensweise: Binden eines Windows Forms-Steuerelements an einen Typ](~/docs/framework/winforms/controls/how-to-bind-a-windows-forms-control-to-a-type.md). Sie können auch die <xref:System.Windows.Forms.BindingSource> , die Steuerelemente an ein Factoryobjekt binden. Weitere Informationen hierzu finden Sie unter [Vorgehensweise: Binden eines Windows Forms-Steuerelements an ein Factoryobjekt](~/docs/framework/winforms/controls/how-to-bind-a-windows-forms-control-to-a-factory-object.md).  
  
> [!NOTE]
>  Da eine <xref:System.Windows.Forms.BindingSource> Handles sowohl einfache und komplexe Datenquellen Terminologie ist problematisch. In dieser Klassendokumentation der Begriff *Liste* bezieht sich auf einer Datensammlung innerhalb der gehosteten Datenquelle und *Element* ein einzelnes Element kennzeichnet. Wenn Abstimmung der Funktionalität komplexen Datenquellen zugeordnet, die entsprechenden Begriffe *Tabelle* und *Zeile* verwendet werden.  
  
 <xref:System.Windows.Forms.BindingSource>stellt Member bereit, für den Zugriff auf die zugrunde liegenden Daten. Das aktuelle Element abgerufen werden kann, über die <xref:System.Windows.Forms.BindingSource.Current%2A> -Eigenschaft und die gesamte Liste kann über abgerufen werden die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft. Bearbeitungsvorgänge werden unterstützt, auf das aktuelle Element über <xref:System.Windows.Forms.BindingSource.Current%2A> und <xref:System.Windows.Forms.BindingSource.RemoveCurrent%2A>, <xref:System.Windows.Forms.BindingSource.EndEdit%2A>, <xref:System.Windows.Forms.BindingSource.CancelEdit%2A> und <xref:System.Windows.Forms.BindingSource.Add%2A> und <xref:System.Windows.Forms.BindingSource.AddNew%2A> Methoden. Obwohl währungsverwaltung automatisch für alle zugrunde liegenden Datenquellentypen behandelt wird, stellt diese Klasse eine Anzahl von Ereignissen, wie z. B. <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> und <xref:System.Windows.Forms.BindingSource.DataSourceChanged>, mit denen für die Anpassung.  
  
 Datenquellen, die gebunden sind eine <xref:System.Windows.Forms.BindingSource> Komponente auch navigiert und verwaltet werden kann mit der <xref:System.Windows.Forms.BindingNavigator> Klasse, die eine Videorecorder-ähnliche Benutzeroberfläche (UI) für die Navigation in Elemente in einer Liste bereitstellt. Obwohl <xref:System.Windows.Forms.BindingNavigator> gebunden werden kann für jede Datenquelle, es wurde entworfen, um integriert einen <xref:System.Windows.Forms.BindingSource> -Komponente über seine <xref:System.Windows.Forms.BindingNavigator.BindingSource%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die Standardeigenschaft für die <xref:System.Windows.Forms.BindingSource> Klasse ist <xref:System.Windows.Forms.BindingSource.DataSource%2A>. Das Standardereignis ist <xref:System.Windows.Forms.BindingSource.CurrentChanged>.  
  
> [!CAUTION]
>  Viele der Elemente der <xref:System.Windows.Forms.BindingSource> Klasse ausgeführt werden, auf die zugrunde liegende Liste dargestellt werden, indem Sie die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft, und verweisen Sie einfach den Vorgang auf die zugrunde liegende Liste. Aus diesem Grund, dass bei der <xref:System.Windows.Forms.BindingSource> gebunden ist, um eine benutzerdefinierte Implementierung von <xref:System.Collections.IList>, das genaue Verhalten dieser Member unterscheidet sich vom Verhalten in der Klassendokumentation beschrieben. Z. B. die <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> Methodenaufrufe <xref:System.Collections.IList.RemoveAt%2A?displayProperty=nameWithType>. Die <xref:System.Windows.Forms.BindingSource> Dokumentation wird beschrieben, die <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> Methode Voraussetzung ist, die die <xref:System.Collections.IList.RemoveAt%2A> Methode für das zugrunde liegende <xref:System.Collections.IList> ordnungsgemäß implementiert wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, eine <xref:System.Windows.Forms.ListBox> gebunden werden, um eine <xref:System.Windows.Forms.BindingSource>. Die <xref:System.Windows.Forms.BindingSource> gebunden ist, um eine <xref:System.ComponentModel.BindingList%601> , die eine Liste von Schriftarten enthält.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#0)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Windows.Forms.BindingSource" /> Klasse, um die Standardwerte für die Eigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle zeigt die <xref:System.Windows.Forms.BindingSource> Eigenschaftswerte, die von diesem Konstruktor initialisiert.  
  
|Eigenschaft|Standardwert|  
|--------------|-------------------|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.DataMember%2A>|<xref:System.String.Empty>|  
|<xref:System.Windows.Forms.BindingSource.Sort%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.Filter%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A>|`true`|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor(System.ComponentModel.IContainer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">Die <see cref="T:System.ComponentModel.IContainer" /> hinzuzufügende aktuellen <see cref="T:System.Windows.Forms.BindingSource" /> an.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Windows.Forms.BindingSource" /> -Klasse und fügt die <see cref="T:System.Windows.Forms.BindingSource" /> für den angegebenen Container.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird der Standardkonstruktor aufgerufen, und fügt dann das aktuelle <xref:System.Windows.Forms.BindingSource> auf den angegebenen Container. Es wird nicht in der Regel vom Lösungsprogrammierer, sondern vom Autor während der Entwurfszeit-Umgebungen verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource (object dataSource, string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object dataSource, string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor(System.Object,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource">Die Datenquelle für die <see cref="T:System.Windows.Forms.BindingSource" />.</param>
        <param name="dataMember">Der Name der bestimmten Spalte oder Liste innerhalb der Datenquelle, an die gebunden werden soll.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Windows.Forms.BindingSource" /> -Klasse mit der angegebenen Datenquelle und Datenmember.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual int Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Ein <see cref="T:System.Object" /> der internen Liste hinzugefügt werden.</param>
        <summary>Fügt der internen Liste ein vorhandenes Element hinzu.</summary>
        <returns>Der nullbasierte Index, an dem <paramref name="value" /> wurde hinzugefügt, um die zugrunde liegende Liste dargestellt durch die <see cref="P:System.Windows.Forms.BindingSource.List" /> Eigenschaft.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.Add%2A> Methode leitet den Aufruf an der zugrunde liegende Liste `Add` Methode.  
  
 Die interne Liste muss homogene Typen enthalten. Wenn die <xref:System.Windows.Forms.BindingSource.DataSource%2A> Eigenschaft wurde nicht festgelegt wurde, und klicken Sie dann das erste Objekt, das der Liste hinzugefügt, definiert den Typ der Liste.  
  
 Diese Methode löst die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Windows.Forms.BindingSource.Add%2A> Methode. Um dieses Beispiel auszuführen, fügen Sie den Code in ein Windows Form, und rufen die `PopulateBindingSourceWithFonts` Methode aus den Konstruktor des Formulars.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" />unterscheidet sich in den Typ von vorhandenen Elementen in der zugrunde liegenden Liste.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddingNew">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AddingNewEventHandler AddingNew;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AddingNewEventHandler AddingNew" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.AddingNew" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AddingNewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, bevor der zugrunde liegenden Liste ein Element hinzugefügt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.AddingNew> Ereignis tritt auf, bevor ein neues Objekt, auf die zugrunde liegende Liste dargestellt hinzugefügt wird durch die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft. Dieses Ereignis wird ausgelöst, nachdem die <xref:System.Windows.Forms.BindingSource.AddNew%2A> Methode wird aufgerufen, aber bevor das neue Element erstellt und der zugrunde liegenden Liste hinzugefügt. Durch die Behandlung dieses Ereignisses an, die Programmierer kann benutzerdefinierte Elementvorlagen erstellen und angeben Einfügeverhalten ohne forced Ableitung der <xref:System.Windows.Forms.BindingSource> Klasse. Dies erfolgt im Ereignishandler durch Festlegen der <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> Eigenschaft von der <xref:System.ComponentModel.AddingNewEventArgs?displayProperty=nameWithType> Parameter für das neue Element. Das neue Objekt erstellt, der <xref:System.Windows.Forms.BindingSource.AddingNew> Ereignis muss denselben Typ wie in der Liste enthaltene Typ oder eine Ausnahme ausgelöst wird. Kann nicht festgelegt werden die <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> Eigenschaft, die bei der Bindung an eine <xref:System.Data.DataView> oder <xref:System.Data.DataTable> da Sie ein neues hinzufügen können <xref:System.Data.DataRowView> der Liste.  
  
 Weitere Informationen zum Angeben von benutzerdefinierten Funktionen für neue Elemente finden Sie unter der <xref:System.Windows.Forms.BindingSource.AddNew%2A> Methode. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit einem <xref:System.Windows.Forms.BindingSource> -Komponente zum Binden einer Liste, um eine <xref:System.Windows.Forms.DataGridView> Steuerelement. Neue Elemente werden hinzugefügt, um die Liste nach der <xref:System.Windows.Forms.BindingSource.AddingNew> -Ereignishandler. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels [wie: Anpassen der Hinzufügung mit der BindingSource in Windows Forms](~/docs/framework/winforms/controls/how-to-customize-item-addition-with-the-windows-forms-bindingsource.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.AddingNewEventArgs.NewObject" />ist nicht denselben Typ wie der Typ, der in der Liste enthalten sind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddNew">
      <MemberSignature Language="C#" Value="public virtual object AddNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.AddNew" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fügt der zugrunde liegenden Liste ein neues Element hinzu.</summary>
        <returns>Die <see cref="T:System.Object" /> , erstellt und zur Liste hinzugefügt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.AddNew%2A> Methode fügt ein neues Element auf die zugrunde liegende Liste dargestellt durch die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft. Diese Methode richtet die nachstehend beschriebenen Aktionen aus:  
  
1.  Die <xref:System.Windows.Forms.BindingSource.EndEdit%2A> Methode wird automatisch aufgerufen, um alle ausstehenden Bearbeitungsvorgänge einen Commit auszuführen.  
  
2.  Die <xref:System.Windows.Forms.BindingSource.AddingNew> Ereignis wird automatisch ausgelöst. Dieses Ereignis kann programmgesteuert behandelt werden, um das neue Element zu erstellen. Dies erfolgt im Ereignishandler durch Festlegen der <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> Eigenschaft von der <xref:System.ComponentModel.AddingNewEventArgs?displayProperty=nameWithType> Parameter für das neue Element. Das neue Objekt erstellt, der <xref:System.Windows.Forms.BindingSource.AddingNew> Ereignis muss denselben Typ wie in der Liste enthaltene Typ oder eine Ausnahme ausgelöst wird.  
  
     Wenn die <xref:System.Windows.Forms.BindingSource.AddingNew> Ereignis wird nicht verarbeitet werden, und die zugrunde liegende Liste eine <xref:System.ComponentModel.IBindingList>, und klicken Sie dann die Anforderung, um der Liste übergeben wird <xref:System.ComponentModel.IBindingList.AddNew%2A?displayProperty=nameWithType> Methode. Wenn die zugrunde liegende Liste keine <xref:System.ComponentModel.IBindingList> ist, wird das Element automatisch über seinen öffentlichen Standardkonstruktor erstellt. In beiden Fällen wird das neue Element am Ende der Liste hinzugefügt.  
  
3.  Das neue Element wird der internen Liste sofort hinzugefügt, es sei denn, die Datenquelle implementiert die <xref:System.ComponentModel.IEditableObject> Schnittstelle. In diesem Fall das neue Element wird nicht ausgeführt bis ein expliziter Aufruf von <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23EndNew%2A> vorgenommen wird oder bis ein neue listenvorgang initiiert wird. Bevor eine Zusicherung erfolgt ist, das neue Element kann ein Rollback durch Aufrufen von <xref:System.Windows.Forms.BindingSource.CancelEdit%2A>, in diesem Fall das neue Element verworfen wird.  
  
 Diese Methode löst die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit einem <xref:System.Windows.Forms.BindingSource> -Komponente zum Binden einer Liste, um eine <xref:System.Windows.Forms.DataGridView> Steuerelement. Neue Elemente werden hinzugefügt, um die Liste nach der <xref:System.Windows.Forms.BindingSource.AddingNew> -Ereignishandler. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels [wie: Anpassen der Hinzufügung mit der BindingSource in Windows Forms](~/docs/framework/winforms/controls/how-to-customize-item-addition-with-the-windows-forms-bindingsource.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Windows.Forms.BindingSource.AllowNew" />-Eigenschaft ist auf <see langword="false" /> festgelegt.  
  
 - oder -   
  
 Ein öffentlichen Standardkonstruktor konnte für den aktuellen Typ nicht gefunden werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowEdit">
      <MemberSignature Language="C#" Value="public virtual bool AllowEdit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowEdit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowEdit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Elemente in der zugrunde liegenden Liste bearbeitet werden können.</summary>
        <value>
          <see langword="true" />um Listenelemente anzugeben bearbeitet werden können. andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.AllowEdit%2A> Eigenschaft wird in der Regel von anderen Komponenten verwendet, um festzustellen, ob die Bearbeitung von Elementen in der Liste zulässig ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowNew">
      <MemberSignature Language="C#" Value="public virtual bool AllowNew { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowNew" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowNew" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob die <see cref="M:System.Windows.Forms.BindingSource.AddNew" /> Methode kann verwendet werden, um die Elemente der Liste hinzuzufügen.</summary>
        <value>
          <see langword="true" />Wenn <see cref="M:System.Windows.Forms.BindingSource.AddNew" /> kann das Hinzufügen von Elementen der Liste, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für die <xref:System.Windows.Forms.BindingSource.AllowNew%2A> Eigenschaft hängt von den zugrunde liegenden Datenquellentyp. Wenn die zugrunde liegende Liste implementiert die <xref:System.ComponentModel.IBindingList> -Schnittstelle, wird diese Eigenschaft auf die zugrunde liegende Liste delegieren. Andernfalls gibt diese Eigenschaft zurück `false` , wenn die zugrunde liegende Liste eine der folgenden Merkmale aufweist:  
  
-   Er eine feste Größe hat, als durch die <xref:System.Collections.IList.IsFixedSize%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Es ist schreibgeschützt, gemäß der <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Das Element-Typ weist keinen Standardkonstruktor auf.  
  
> [!NOTE]
>  Sobald der Wert dieser Eigenschaft festgelegt ist, verweist der Getter für eine nicht mehr den Aufruf von der zugrunde liegenden Liste. Stattdessen einfach den Wert zurück, die zuvor bis festgelegt wurde die <xref:System.Windows.Forms.BindingSource.ResetAllowNew%2A> -Methode aufgerufen wird.  
  
 Einstellung, die diese Eigenschaft löst die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis "mit" <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> festgelegt <xref:System.ComponentModel.ListChangedType?displayProperty=nameWithType>.  
  
 Wenn Sie festlegen, die <xref:System.Windows.Forms.BindingSource.AllowNew%2A> Eigenschaft `true` und der zugrunde liegenden Listentyp nicht über einen Standardkonstruktor verfügt, müssen Sie behandeln die <xref:System.Windows.Forms.BindingSource.AddingNew> Ereignis und den entsprechenden Typ erstellen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Windows.Forms.BindingSource.AllowNew%2A> Eigenschaft von der <xref:System.Windows.Forms.BindingSource> Komponente, bei dem Benutzer neue Elemente hinzufügen das <xref:System.Windows.Forms.BindingSource> Komponente zugrunde liegenden Liste. Wenn diese Eigenschaft auf `true` bewirkt, dass die Grenze <xref:System.Windows.Forms.DataGridView> Steuerelement, um die Zeile für neue Datensätze anzuzeigen.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wird festgelegt, um <see langword="true" /> Wenn die zugrunde liegende Liste dargestellt, durch die <see cref="P:System.Windows.Forms.BindingSource.List" /> Eigenschaft eine feste Größe aufweist oder schreibgeschützt ist.</exception>
        <exception cref="T:System.MissingMethodException">Die Eigenschaft wird festgelegt, um <see langword="true" /> und <see cref="E:System.Windows.Forms.BindingSource.AddingNew" /> Ereignis nicht behandelt, wenn der zugrunde liegenden Listentyp nicht über einen Standardkonstruktor verfügt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowRemove">
      <MemberSignature Language="C#" Value="public virtual bool AllowRemove { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowRemove" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowRemove" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Elemente aus der zugrunde liegenden Liste entfernt werden können.</summary>
        <value>
          <see langword="true" />um anzugeben, dass können Elemente aus der Liste entfernt werden; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.AllowRemove%2A> Eigenschaft wird in der Regel von anderen Komponenten verwendet, um festzustellen, ob die Bearbeitung von Elementen in der Liste zulässig ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplySort">
      <MemberSignature Language="C#" Value="public virtual void ApplySort (System.ComponentModel.ListSortDescriptionCollection sorts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplySort(class System.ComponentModel.ListSortDescriptionCollection sorts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ApplySort(System.ComponentModel.ListSortDescriptionCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sorts" Type="System.ComponentModel.ListSortDescriptionCollection" />
      </Parameters>
      <Docs>
        <param name="sorts">Ein <see cref="T:System.ComponentModel.ListSortDescriptionCollection" /> , enthält die sortierbeschreibungen, um auf die Datenquelle anzuwenden.</param>
        <summary>Sortiert die Datenquelle mit den angegebenen Sortierbeschreibungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.IBindingListView>implementiert die mehrspaltige Sortierung als Satz von Eigenschaftendeskriptor-Richtung-Paaren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Datenquelle ist ein <see cref="T:System.ComponentModel.IBindingListView" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplySort">
      <MemberSignature Language="C#" Value="public virtual void ApplySort (System.ComponentModel.PropertyDescriptor property, System.ComponentModel.ListSortDirection sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplySort(class System.ComponentModel.PropertyDescriptor property, valuetype System.ComponentModel.ListSortDirection sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="sort" Type="System.ComponentModel.ListSortDirection" />
      </Parameters>
      <Docs>
        <param name="property">Ein <see cref="T:System.ComponentModel.PropertyDescriptor" /> , der die Eigenschaft, nach denen sortiert der Datenquelle beschreibt.</param>
        <param name="sort">Ein <see cref="T:System.ComponentModel.ListSortDirection" /> , der angibt, wie die Liste sortiert werden sollen.</param>
        <summary>Sortiert die Datenquelle mit dem angegebenen Eigenschaftendeskriptor und der Sortierreihenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.IBindingList> implementiert die einzelne spaltensortierung mit einer <xref:System.ComponentModel.PropertyDescriptor> an, dass eine Eigenschaft, um nach zu sortieren und eine <xref:System.ComponentModel.ListSortDirection> , der angibt, ob der Inhalt der Eigenschaft in aufsteigender oder absteigender Reihenfolge sortiert werden sollen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Datenquelle ist ein <see cref="T:System.ComponentModel.IBindingList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BindingComplete">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.BindingCompleteEventHandler BindingComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.BindingCompleteEventHandler BindingComplete" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.BindingComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingCompleteEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn alle Clients an diese gebunden wurden <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.BindingComplete> Ereignis tritt auf, nachdem alle Clients in der Regel Steuerelemente gebunden wurden mit dem aktuellen <xref:System.Windows.Forms.BindingSource>. Der Handler für dieses Ereignis kann die entsprechende Aktion basierend auf den Erfolg, Fehler oder Ausnahmen des Bindungsvorgangs durch Untersuchen der <xref:System.Windows.Forms.BindingCompleteEventArgs.BindingCompleteState%2A> Eigenschaft von der <xref:System.Windows.Forms.BindingCompleteEventArgs> Parameter.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Behandlung der <xref:System.Windows.Forms.BindingSource.BindingComplete> Ereignis. Um diesen Code auszuführen, fügen Sie ihn in einer leeren Codedatei.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelEdit">
      <MemberSignature Language="C#" Value="public void CancelEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.CancelEdit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht den aktuellen Bearbeitungsvorgang ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwirft die Änderungen an Daten seit der letzten Speichern oder laden Vorgang aus, wenn beide der folgenden Bedingungen erfüllt sind:  
  
-   Die Datenquelle implementiert die <xref:System.ComponentModel.IEditableObject> Schnittstelle.  
  
-   Die <xref:System.Windows.Forms.BindingSource.EndEdit%2A> Methode noch nicht aufgerufen wurde.  
  
 Diese Methode ruft die <xref:System.Windows.Forms.CurrencyManager.CancelCurrentEdit%2A> Methode des zugrunde liegenden <xref:System.Windows.Forms.CurrencyManager>, und auf Zeilenebene Änderungen begrenzt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus der Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.Clear%2A> -Methode entfernt alle Elemente aus der zugrunde liegenden Liste dargestellt durch die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft und legt die <xref:System.Windows.Forms.BindingSource.Count%2A> Eigenschaft auf 0 (null).  
  
 Diese Methode löst die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Die <see cref="T:System.Object" /> , suchen Sie in der zugrunde liegenden Liste dargestellt durch die <see cref="P:System.Windows.Forms.BindingSource.List" /> Eigenschaft. Der Wert kann <see langword="null" /> sein.</param>
        <summary>Bestimmt, ob es sich bei einem Objekt um ein Element in der Liste handelt.</summary>
        <returns>
          <see langword="true" />Wenn die <paramref name="value" /> Parameter wurde gefunden, der <see cref="P:System.Windows.Forms.BindingSource.List" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl die Implementierung der zugrunde liegenden Liste abhängt `Contains` -Methode, in der Regel die folgenden Merkmale treffen:  
  
-   <xref:System.Windows.Forms.BindingSource.List%2A>wird durchsucht, beginnend ab dem ersten Element und endet beim letzten Element.  
  
-   Die zugrunde liegende Methode führt eine lineare Suche; Daher ist die durchschnittliche Ausführungszeit proportional zum Wert der <xref:System.Windows.Forms.BindingSource.Count%2A> Eigenschaft.  
  
-   Die zugrunde liegende Methode bestimmt die Gleichheit durch Aufrufen der <xref:System.Object.Equals%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="arr">Das Zielarray.</param>
        <param name="index">Der Index im Zielarray, ab dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert den Inhalt der <see cref="P:System.Windows.Forms.BindingSource.List" /> in das angegebene Array, beginnend am angegebenen Index-Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, Kombinieren von Elementen aus mehreren Quellen in ein einzelnes Array.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtanzahl der Elemente in der zugrunde liegenden Liste berücksichtigt den aktuellen <see cref="P:System.Windows.Forms.BindingSource.Filter" /> Wert berücksichtigt.</summary>
        <value>Die Gesamtanzahl der gefilterten Elemente in der zugrunde liegenden Liste.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.Count%2A> -Eigenschaft ruft die Anzahl der Elemente in der zugrunde liegenden Liste dargestellt durch die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft durch den Wert des geänderten der <xref:System.Windows.Forms.BindingSource.Filter%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Windows.Forms.BindingSource.List%2A>, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>, und <xref:System.Windows.Forms.BindingSource.Count%2A> Elemente. Um dieses Beispiel auszuführen, fügen Sie den Code in ein Formular, enthält ein <xref:System.Windows.Forms.BindingSource> mit dem Namen `BindingSource1`, zwei Bezeichnungen, die mit dem Namen `label1` und `label2`, und eine Schaltfläche mit dem Namen `button1`. Zuordnen der `button1_Click` Methode mit dem <xref:System.Windows.Forms.Control.Click> -Ereignis für `button1`. Visual Basic-Benutzer müssen einen Verweis auf "System.Data.dll" hinzufügen.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrencyManager">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.CurrencyManager CurrencyManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CurrencyManager CurrencyManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.CurrencyManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CurrencyManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die datensatzzeigerverwaltung zugeordnete <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <value>Das dieser <see cref="T:System.Windows.Forms.CurrencyManager" /> zugeordnete <see cref="T:System.Windows.Forms.BindingSource" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die datensatzzeigerverwaltung für eine andere Bindung für die Verwendung der gleichen Datenmember zugreifen möchten die <xref:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public object Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das aktuelle Element in der Liste ab.</summary>
        <value>Ein <see cref="T:System.Object" /> , die das aktuelle Element in der zugrunde liegenden Liste dargestellte darstellt der <see cref="P:System.Windows.Forms.BindingSource.List" /> Eigenschaft oder <see langword="null" /> , wenn die Liste keine Elemente enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Forms.BindingSource.Current%2A> Eigenschaft das aktuelle Element zuzugreifen, verwenden Sie jedoch die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft, um die gesamte Liste abzurufen. Um den Typ des aktuellen Objekts zu ermitteln, verwenden die <xref:System.Object.GetType%2A>, oder <xref:System.Object.ToString%2A> Methoden.  
  
 Um das aktuelle Element zu ändern, legen die <xref:System.Windows.Forms.BindingSource.Position%2A> Eigenschaft, um eine neue ganzzahligen Wert, oder verwenden Sie eine der Navigationsmethoden, z. B. <xref:System.Windows.Forms.BindingSource.MoveNext%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Windows.Forms.BindingSource.Current%2A> Eigenschaft. Um dieses Beispiel auszuführen, fügen Sie den Code in ein Formular, und rufen die `PopulateBindingSourceWithFonts` Methode aus des Formulars <xref:System.Windows.Forms.Form.Load> Methode für die Ereignisbehandlung.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CurrentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.CurrentChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das derzeit gebundene Element geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.CurrentChanged> Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.BindingSource.Current%2A> eigenschaftsänderungen für einen der folgenden Gründe:  
  
-   Die aktuelle Position der <xref:System.Windows.Forms.BindingSource.List%2A> ändert.  
  
-   Die <xref:System.Windows.Forms.BindingSource.DataSource%2A> oder <xref:System.Windows.Forms.BindingSource.DataMember%2A> Eigenschaften ändern.  
  
-   Die Mitgliedschaft der zugrunde liegenden <xref:System.Windows.Forms.BindingSource.List%2A> geändert wird, wodurch <xref:System.Windows.Forms.BindingSource.Position%2A> zum Verweisen auf ein anderes Element. Beispiele: Hinzufügen oder Löschen eines Elements vor dem aktuellen Element, löschen oder verschieben das aktuelle Element selbst oder Verschieben eines Elements an der aktuellen Position.  
  
-   Die zugrunde liegende Liste wird durch eine neue Sortierung oder Filterung Vorgang aktualisiert.  
  
 Wenn dieses Ereignis ausgelöst wird, die <xref:System.Windows.Forms.BindingSource.Current%2A> Eigenschaft wird den neuen Wert bereits enthalten.  
  
 <xref:System.Windows.Forms.BindingSource.CurrentChanged>ist das Standardereignis für die <xref:System.Windows.Forms.BindingSource> Klasse.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentItemChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CurrentItemChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentItemChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Eigenschaftswert, der die <see cref="P:System.Windows.Forms.BindingSource.Current" /> -Eigenschaft geändert hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> Ereignis wird ausgelöst, als Antwort auf alle in den Fällen, die Auslösen der <xref:System.Windows.Forms.BindingSource.CurrentChanged> Ereignis. Darüber hinaus <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> wird auch ausgelöst, wenn der Wert einer der Eigenschaften des <xref:System.Windows.Forms.BindingSource.Current%2A> geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataError">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.BindingManagerDataErrorEventHandler DataError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.BindingManagerDataErrorEventHandler DataError" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataError" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerDataErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Ausnahme Currency-bezogene im Hintergrund durch behandelt wird die <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis dient zu Informationszwecken und meldet nur CLS-kompatible Ausnahmen. Um zu bestimmen, welche Art von Ausnahme ist aufgetreten, behandeln Sie dieses Ereignis, und überprüfen Sie die <xref:System.Windows.Forms.BindingManagerDataErrorEventArgs.Exception%2A> Eigenschaft von der <xref:System.Windows.Forms.BindingManagerDataErrorEventArgs>.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataMember">
      <MemberSignature Language="C#" Value="public string DataMember { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataMember" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.DataMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.DataMemberListEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die bestimmte Liste in der Datenquelle ab, zu der derzeit eine Bindung besteht, oder legt diese fest.</summary>
        <value>Der Name einer Liste (oder Zeile) in der <see cref="P:System.Windows.Forms.BindingSource.DataSource" />. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.BindingSource.DataSource%2A> enthält mehrere Listen (oder Tabellen) von Daten, Sie sollten Festlegen der <xref:System.Windows.Forms.BindingSource.DataMember%2A> Eigenschaft, um den Namen einer der Quellen.  
  
 Diese Eigenschaft löst Einstellung der <xref:System.Windows.Forms.BindingSource.DataMemberChanged> Ereignis  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataMemberChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DataMemberChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataMemberChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.BindingSource.DataMember" />-Eigenschaftswert geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.DataMemberChanged> Ereignis tritt auf, nachdem die <xref:System.Windows.Forms.BindingSource.DataMember%2A> -Eigenschaft ändert.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSource">
      <MemberSignature Language="C#" Value="public object DataSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.DataSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AttributeProvider(typeof(System.ComponentModel.IListSource))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Datenquelle ab, mit der eine Bindung besteht, oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Object" /> , die als Datenquelle fungiert. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.DataSource%2A> Eigenschaft kann festgelegt werden, um eine Anzahl von Datenquellen, einschließlich Typen, Objekte und Listen von Typen. Die resultierende Datenquelle wird als Liste verfügbar gemacht werden. Die folgende Tabelle zeigt einige der allgemeinen Datenquellen und die resultierende Liste Auswertung.  
  
|DataSource-Eigenschaft|Listenergebnissen|  
|-------------------------|------------------|  
|`null`|Ein leeres <xref:System.ComponentModel.IBindingList> von Objekten. Hinzufügen eines Elements wird die Liste in den Typ des hinzugefügten Elements.|  
|`null`mit <xref:System.Windows.Forms.BindingSource.DataMember%2A> festlegen|Nicht unterstützt, löst <xref:System.ArgumentException>.|  
|Nicht-Listentyp oder Objekt vom Typ "T"|Leere <xref:System.ComponentModel.IBindingList> vom Typ "T".|  
|Array-Instanz|<xref:System.ComponentModel.IBindingList>enthält die Elemente des Arrays.|  
|<xref:System.Collections.IEnumerable>Instanz|Ein <xref:System.ComponentModel.IBindingList> , enthält die <xref:System.Collections.IEnumerable> Elemente.|  
|Liste der Instanz, die mit Typ "T"|<xref:System.ComponentModel.IBindingList>die Instanz, die Typ "T" enthält.|  
  
 Darüber hinaus <xref:System.Windows.Forms.BindingSource.DataSource%2A> kann auf andere Listentypen festgelegt werden, z. B. <xref:System.ComponentModel.IListSource> und <xref:System.ComponentModel.ITypedList> und <xref:System.Windows.Forms.BindingSource> entsprechend behandelt wird. In diesem Fall sollte in der Liste enthaltene Typ einen Standardkonstruktor verfügen.  
  
 Wenn Sie eine Datenquelle festlegen, wenn der angegebene Verweis mehr als eine Liste oder Tabelle enthält, müssen Sie festlegen der <xref:System.Windows.Forms.BindingSource.DataMember%2A> Eigenschaft, um eine Zeichenfolge, die in der Liste an gebunden wird. Diese Eigenschaft löst Einstellung der <xref:System.Windows.Forms.BindingSource.DataSourceChanged> Ereignis.  
  
> [!NOTE]
>  Wenn Sie alle Änderungen an den stellen die <xref:System.Windows.Forms.BindingSource.DataSource%2A> Eigenschaftswert, sollten Sie dies tun auf dem Benutzerthread Benutzeroberfläche (UI), um sicherzustellen, dass die Benutzeroberfläche die Änderungen wiedergibt.  
  
 Die <xref:System.Windows.Forms.BindingSource.DataSource%2A> Eigenschaft ist die Standardeigenschaft für die <xref:System.Windows.Forms.BindingSource> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Liste mit Kunden zugewiesen der <xref:System.Windows.Forms.BindingSource.DataSource%2A> von einem <xref:System.Windows.Forms.BindingSource> Komponente. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels unter [wie: Auslösen von Änderungsbenachrichtigungen mithilfe der ResetItem-Methode](~/docs/framework/winforms/controls/how-to-raise-change-notifications-using-the-bindingsource-resetitem-method.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSourceChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DataSourceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataSourceChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.BindingSource.DataSource" />-Eigenschaftswert geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.DataSourceChanged> Ereignis tritt auf, nachdem die <xref:System.Windows.Forms.BindingSource.DataSource%2A> -Eigenschaft ändert.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Windows.Forms.BindingSource" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, der öffentlich `Dispose` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose`Ruft die geschützte `Dispose(Boolean)` Methode mit dem `disposing` Parametersatz auf `true`. <xref:System.Object.Finalize%2A>Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn die `disposing` Parameter ist "true", gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte, die von diesem <xref:System.Windows.Forms.BindingSource> Verweise. Diese Methode ruft die `Dispose`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Zum Überschreiben <see langword="Dispose(Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die einen früheren Aufruf freigegeben wurden <see langword="Dispose" />. Weitere Informationen zum Implementieren <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndEdit">
      <MemberSignature Language="C#" Value="public void EndEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.EndEdit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wendet anstehende Änderungen auf die zugrunde liegende Datenquelle an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.BindingSource.EndEdit%2A> -Methode aufgerufen wird, werden alle ausstehenden Änderungen an der zugrunde liegenden Datenquelle angewendet.  
  
 Diese Methode hat keine Auswirkungen, es sei denn, die von der Datenquelle enthaltenen Objekte implementieren die <xref:System.ComponentModel.IEditableObject> Schnittstelle. Wenn die Objekte nicht implementieren die <xref:System.ComponentModel.IEditableObject> -Schnittstelle, Änderungen an den Daten in der zugrunde liegenden Datenquelle sofort nach jeder Änderung kopiert werden.  
  
 Diese Methode löst die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public virtual string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Ausdruck ab, mit dem die anzuzeigenden Zeilen gefiltert werden, oder legt diesen fest.</summary>
        <value>Eine Zeichenfolge, die angibt, wie Zeilen gefiltert werden sollen. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel in komplexen Datenbindungsszenarien verwendet die <xref:System.Windows.Forms.BindingSource.Filter%2A> -Eigenschaft können Sie eine Teilmenge der Anzeigen der <xref:System.Windows.Forms.BindingSource.DataSource%2A>. Nur den zugrunde liegenden Listen implementiert, die <xref:System.ComponentModel.IBindingListView> -Schnittstelle Unterstützung filtern.  
  
 Wenn <xref:System.Windows.Forms.BindingSource.Filter%2A> nicht `null`die <xref:System.Windows.Forms.BindingSource> übergibt diese Eigenschaft auf die zugrunde liegende Liste. Wenn Sie diese Eigenschaft während der Initialisierung festgelegt, wird der Aufruf bis verschoben werden, nach dem Abschluss der Initialisierung.  
  
 Geben Sie den Namen einer Spalte, gefolgt von einem Operator und einen Wert, nach dem gefiltert, um einen Filterwert zu bilden. Die akzeptierte Filtersyntax hängt von der zugrunde liegenden Datenquelle ab. Wenn die zugrunde liegenden Datenquelle ist eine <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, oder <xref:System.Data.DataView>, können Sie angeben, boolesche Ausdrücken, die mit der Syntax für dokumentiert die <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Der Wert der <xref:System.Windows.Forms.BindingSource.Filter%2A> Eigenschaft wirkt sich auf den Wert des der <xref:System.Windows.Forms.BindingSource.Count%2A> Eigenschaft. Darüber hinaus die <xref:System.Windows.Forms.BindingSource.Filter%2A> Wert wird beibehalten, wenn die Datenquelle ändert. Zum Beenden der Filterung der <xref:System.Windows.Forms.BindingSource.DataSource%2A>, rufen Sie die <xref:System.Windows.Forms.BindingSource.RemoveFilter%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Forms.BindingSource.Filter%2A> Eigenschaft mit einem <xref:System.Data.DataView>. Um dieses Beispiel auszuführen, fügen Sie den Code in einem Windows Form, und rufen `PopulateDataViewAndFilter` aus den Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load> Ereignisbehandlungsmethode. Das Formular importieren sollte die <xref:System.Xml> und <xref:System.IO> Namespaces.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public virtual int Find (System.ComponentModel.PropertyDescriptor prop, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Find(class System.ComponentModel.PropertyDescriptor prop, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prop" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="prop">Die zu suchende <see cref="T:System.ComponentModel.PropertyDescriptor" />.</param>
        <param name="key">Der Wert der <c>Prop</c> übereinstimmen.</param>
        <summary>Sucht nach dem Index des Elements, das den angegebenen Eigenschaftenbezeichner hat.</summary>
        <returns>Der nullbasierte Index des Elements mit dem angegebenen Wert für <see cref="T:System.ComponentModel.PropertyDescriptor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird in der Regel in komplexen Datenbindungsszenarios verwendet, um die erste Zeile gesucht, in denen der Wert des Felds gemäß, den `prop` der Wert entspricht der `key` Parameter  
  
 Diese Methode leitet einfach die Anforderung an der zugrunde liegende Liste <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType> Methode. Beispielsweise wird die zugrunde liegenden Datenquelle eine <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, oder <xref:System.Data.DataView>, diese Methode ruft die <xref:System.Data.DataView.System%23ComponentModel%23IBindingList%23Find%2A?displayProperty=nameWithType> Methode. Das Verhalten des <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType>, z. B. der Wert zurückgegeben, wenn kein übereinstimmendes Element gefunden wird, hängt von der Implementierung der Methode in der zugrunde liegenden Liste.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Windows.Forms.BindingSource.Find%2A>-Methode verwenden. Das vollständige Beispiel finden Sie im Übersichtsthema.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die zugrunde liegende Liste ist nicht vom Typ <see cref="T:System.ComponentModel.IBindingList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string propertyName, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string propertyName, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Find(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="propertyName">Der Name der Eigenschaft, nach der gesucht werden soll.</param>
        <param name="key">Der Wert des Elements mit dem angegebenen <c>PropertyName</c> gefunden.</param>
        <summary>Gibt den Index des Elements in der Liste mit dem angegebenen Eigenschaftennamen und Eigenschaftswert zurück.</summary>
        <returns>Der nullbasierte Index des Elements mit dem angegebenen Namen und Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.Find%2A> Methode kann nur verwendet werden, wenn die zugrunde liegende Liste eine <xref:System.ComponentModel.IBindingList> Suche implementiert. Diese Methode leitet einfach die Anforderung an der zugrunde liegende Liste <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType> Methode. Z. B. wenn die zugrunde liegenden Datenquelle ist eine <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, oder <xref:System.Data.DataView>, diese Methode konvertiert `propertyName` auf eine <xref:System.ComponentModel.PropertyDescriptor> und ruft die <xref:System.Data.DataView.System%23ComponentModel%23IBindingList%23Find%2A> Methode. Das Verhalten des <xref:System.Windows.Forms.BindingSource.Find%2A>, z. B. der Wert zurückgegeben, wenn kein übereinstimmendes Element gefunden wird, hängt von der Implementierung der Methode in der zugrunde liegenden Liste.  
  
 Die Eigenschaft Name-Vergleich wird die Groß-/Kleinschreibung.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Forms.BindingSource.Find%2A> Methode mit einem <xref:System.Data.DataView>. Um dieses Beispiel auszuführen, fügen Sie den Code in einem Windows Form, und rufen `PopulateDataViewAndFind` aus den Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load> Ereignisbehandlungsmethode. Das Formular importieren sollte die <xref:System.Xml> und <xref:System.IO> Namespaces.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die zugrunde liegende Liste ist eine <see cref="T:System.ComponentModel.IBindingList" /> mit Suchfunktionen implementiert.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyName" />eine Eigenschaft in der Liste stimmt nicht überein.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Enumerator für die <see cref="P:System.Windows.Forms.BindingSource.List" />.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" /> für das <see cref="P:System.Windows.Forms.BindingSource.List" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProperties">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptorCollection GetItemProperties (System.ComponentModel.PropertyDescriptor[] listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.PropertyDescriptorCollection GetItemProperties(class System.ComponentModel.PropertyDescriptor[] listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetItemProperties(System.ComponentModel.PropertyDescriptor[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.ComponentModel.PropertyDescriptor[]" />
      </Parameters>
      <Docs>
        <param name="listAccessors">Ein Array von <see cref="T:System.ComponentModel.PropertyDescriptor" /> Objekten, die in der Liste als bindbar gesucht.</param>
        <summary>Ruft ein Array von <see cref="T:System.ComponentModel.PropertyDescriptor" /> Liste-Datenquellentyp für die Objekte, die die bindungsfähigen Eigenschaften der Daten darstellt.</summary>
        <returns>Ein Array von <see cref="T:System.ComponentModel.PropertyDescriptor" /> -Objekten, die die Eigenschaften für diesen Listentyp darstellt, die zum Binden von Daten verwendet.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetListName">
      <MemberSignature Language="C#" Value="public virtual string GetListName (System.ComponentModel.PropertyDescriptor[] listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetListName(class System.ComponentModel.PropertyDescriptor[] listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetListName(System.ComponentModel.PropertyDescriptor[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.ComponentModel.PropertyDescriptor[]" />
      </Parameters>
      <Docs>
        <param name="listAccessors">Ein Array von <see cref="T:System.ComponentModel.PropertyDescriptor" /> Objekten, die in der Liste als bindbar gesucht.</param>
        <summary>Ruft den Namen der Liste ab, die Daten für die Bindung bereitstellt.</summary>
        <returns>Der Name der Liste, die die Daten für die Bindung bereitstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelatedCurrencyManager">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.CurrencyManager GetRelatedCurrencyManager (string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.CurrencyManager GetRelatedCurrencyManager(string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CurrencyManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataMember">Der Name der Spalte oder Liste innerhalb der Datenquelle, für die die Datensatzzeigerverwaltung (Currency Manager) abgerufen werden soll.</param>
        <summary>Ruft die entsprechende Datensatzzeigerverwaltung für den angegebenen Datenmember ab.</summary>
        <returns>Der zugehörige <see cref="T:System.Windows.Forms.CurrencyManager" /> für den angegebenen Datenmember.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `dataMember` ist `null` oder eine leere Zeichenfolge (""), <xref:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager%2A> gibt die hauptwährung-Manager; Andernfalls überprüft, ob eine andere <xref:System.Windows.Forms.BindingSource> an den angegebenen Datenmember gebunden, und gibt seine Currency Manager zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Die <see cref="T:System.Object" /> , suchen Sie in der zugrunde liegenden Liste dargestellt durch die <see cref="P:System.Windows.Forms.BindingSource.List" /> Eigenschaft. Der Wert kann <see langword="null" /> sein.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des ersten Vorkommens innerhalb der gesamten Liste zurück.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens der <paramref name="value" /> -Parameter, andernfalls -1 Wenn <paramref name="value" /> befindet sich nicht in der Liste.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl die Implementierung der zugrunde liegenden Liste abhängt `IndexOf` -Methode, in der Regel die folgenden Merkmale treffen:  
  
-   Die <xref:System.Windows.Forms.BindingSource.List%2A> durchsucht wird, beginnend ab dem ersten Element und endet beim letzten Element.  
  
-   Die zugrunde liegende Methode führt eine lineare Suche; Daher ist die durchschnittliche Ausführungszeit proportional zum Wert der <xref:System.Windows.Forms.BindingSource.Count%2A> Eigenschaft.  
  
-   Die zugrunde liegende Methode bestimmt die Gleichheit durch Aufrufen der <xref:System.Object.Equals%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public virtual void Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem <c>Wert</c> eingefügt werden soll.</param>
        <param name="value">Der einzufügende <see cref="T:System.Object" />. Der Wert kann <see langword="null" /> sein.</param>
        <summary>Fügt ein Element am angegebenen Index in der Liste ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode löst die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />ist kleiner als 0 (null) oder größer als <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Liste schreibgeschützt ist oder eine feste Größe aufweist.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsBindingSuspended">
      <MemberSignature Language="C#" Value="public bool IsBindingSuspended { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBindingSuspended" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsBindingSuspended" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Listenbindung unterbrochen ist.</summary>
        <value>
          <see langword="true" />um anzugeben, dass die Bindung aufgehoben ist. andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die zugrunde liegende Liste eine feste Größe hat.</summary>
        <value>
          <see langword="true" />Wenn die zugrunde liegende Liste eine feste Größe aufweist; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Liste eine feste Größe verfügt, lässt nicht das Hinzufügen oder Entfernen von Elementen nach dem die Liste erstellt wurde, aber Sie können vorhandene Elemente ändern.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die zugrunde liegende Liste schreibgeschützt ist.</summary>
        <value>
          <see langword="true" />, wenn die Liste schreibgeschützt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste mit nur-Lese lässt das Hinzufügen, entfernen oder Ändern von Listenelementen nach der Erstellung der Liste nicht zu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSorted">
      <MemberSignature Language="C#" Value="public virtual bool IsSorted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSorted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsSorted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die Elemente in der zugrunde liegenden Liste sortiert werden.</summary>
        <value>
          <see langword="true" />Wenn die Liste ist ein <see cref="T:System.ComponentModel.IBindingList" /> und sortiert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.IsSorted%2A>Gibt immer `false` , wenn die Liste nicht ist ein <xref:System.ComponentModel.IBindingList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die Auflistung synchronisiert ist (threadsicher).</summary>
        <value>
          <see langword="true" />um anzugeben, dass die Liste synchronisiert ist. andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der auf 0 (null) basierende Index des abzurufenden Elements.</param>
        <summary>Ruft das Listenelement am angegebenen Index ab oder legt dieses fest.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.Item%2A> Eigenschaft darstellt, den Indexer für diese Klasse. Er akzeptiert `null` als gültigen Wert und lässt doppelte Elemente in der Liste.  
  
 Ein Wert löst festlegen die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />ist kleiner als 0 (null) oder ist größer als oder gleich <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="List">
      <MemberSignature Language="C#" Value="public System.Collections.IList List { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList List" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.List" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Liste ab, an die die Verbindung gebunden wird.</summary>
        <value>Ein <see cref="T:System.Collections.IList" /> , die die Liste darstellt, oder <see langword="null" /> es ist keine zugrunde liegende Liste zugeordnete <see cref="T:System.Windows.Forms.BindingSource" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource> Klasse einheitlich behandelt verschiedene Datenquellen. Im Idealfall der <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft sollte festgelegt werden, um eine allgemeine <xref:System.Collections.IList>. Jedoch kann manchmal notwendig, diese Eigenschaft auf einen spezifischeren Typ umgewandelt sein. Die folgende Tabelle zeigt den zugrunde liegenden "List", den Typ oder den Wert der Datenquelle abhängig.  
  
|Datenquellentyp|Beschreibung der zugrunde liegenden Liste|  
|----------------------|---------------------------------|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A>und <xref:System.Windows.Forms.BindingSource.DataMember%2A> sind`null`|Ein leerer <xref:System.Collections.ArrayList>.|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A>ist `null`, aber <xref:System.Windows.Forms.BindingSource.DataMember%2A> nicht`null`|None; Fehler beim Abrufen der <xref:System.Windows.Forms.BindingSource.List%2A> löst eine <xref:System.ArgumentException>.|  
|Ein <xref:System.Array> Instanz|Eine <xref:System.Array>.|  
|Ein <xref:System.ComponentModel.IListSource> Instanz|Der Rückgabewert eines Aufrufs der <xref:System.ComponentModel.IListSource.GetList%2A> -Methode dieses <xref:System.ComponentModel.IListSource> Instanz.|  
|Ein <xref:System.ComponentModel.IBindingList> Instanz|Eine <xref:System.ComponentModel.IBindingList>.|  
|Ein <xref:System.Collections.IList> Instanz|Eine <xref:System.Collections.IList>.|  
|Nicht<xref:System.Collections.IList> Instanz vom Typ "T"|Ein <xref:System.ComponentModel.BindingList%601> mit je einem Element.|  
|Ein <xref:System.ComponentModel.ICustomTypeDescriptor> Instanz|Ein <xref:System.Collections.ArrayList> mit je einem Element.|  
|ein<xref:System.Collections.IEnumerable>|Ein <xref:System.Collections.ArrayList> mit den Elementen, die kopiert haben.|  
|Die <xref:System.Array> mit geben <xref:System.Windows.Forms.BindingSource.DataMember%2A> des Elements geben Sie "T"|Ein <xref:System.ComponentModel.BindingList%601>.|  
|Ein <xref:System.Type> darstellt, die eine <xref:System.ComponentModel.IListSource> oder<xref:System.ComponentModel.ITypedList>|Eine Instanz erstellt, die durch einen Aufruf der <xref:System.Activator.CreateInstance%28System.Type%29> Methode der <xref:System.Activator> Klasse. Ein <xref:System.NotSupportedException> ausgelöst werden.|  
|Die <xref:System.Collections.IList> mit geben <xref:System.Windows.Forms.BindingSource.DataMember%2A> des Elements geben Sie "T"<br /><br /> - oder - <br /><br /> Nicht<xref:System.Collections.IList> Typ|Ein <xref:System.ComponentModel.BindingList%601>.|  
|Die <xref:System.ComponentModel.ICustomTypeDescriptor> Typ|None; Fehler beim Abrufen der <xref:System.Windows.Forms.BindingSource.List%2A> löst eine <xref:System.NotSupportedException>.|  
  
 Wenn der Typ abgerufen wird die <xref:System.Collections.IList> -Schnittstelle, die zugrunde liegende Auflistung kann komplexer sein und z. B. ein <xref:System.Collections.ArrayList> oder <xref:System.Data.DataView> Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Windows.Forms.BindingSource.List%2A>, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>, und <xref:System.Windows.Forms.BindingSource.Count%2A> Elemente. Um dieses Beispiel auszuführen, fügen Sie den Code in ein Formular, enthält ein <xref:System.Windows.Forms.BindingSource> mit dem Namen `BindingSource1`, zwei Bezeichnungen, die mit dem Namen `label1` und `label2`, und eine Schaltfläche mit dem Namen `button1`. Zuordnen der `button1_Click` Methode mit dem <xref:System.Windows.Forms.Control.Click> -Ereignis für `button1`. Visual Basic-Benutzer müssen einen Verweis auf "System.Data.dll" hinzufügen.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ListChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ListChangedEventHandler ListChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ListChangedEventHandler ListChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.ListChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die zugrunde liegende Liste oder ein Element in der Liste geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis tritt auf, wenn eine der Mitgliedschaft oder die Metadaten der zugrunde liegenden Liste dargestellt Änderung durch die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft. Dieses Ereignis wird beispielsweise ausgelöst, wenn Elemente hinzugefügt, entfernt oder verschoben, oder die <xref:System.Windows.Forms.BindingSource.DataSource%2A> oder <xref:System.Windows.Forms.BindingSource.DataMember%2A> Eigenschaften ändern. Die Werte der <xref:System.Windows.Forms.BindingSource.Sort%2A> und <xref:System.Windows.Forms.BindingSource.Filter%2A> Eigenschaften bleiben erhalten, wenn dieses Ereignis auftritt.  
  
 Dieses Ereignis kann vollständig unterdrückt werden, durch Festlegen der <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> Eigenschaft `false`. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Behandlung der <xref:System.Windows.Forms.BindingSource.ListChanged> -Ereignis für die <xref:System.Windows.Forms.BindingSource> Komponente feststellen, ob die <xref:System.Windows.Forms.BindingSource> zugrunde liegenden Komponentenliste geändert wird.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CPP/form1.cpp#9)]
 [!code-csharp[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CS/form1.cs#9)]
 [!code-vb[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFirst">
      <MemberSignature Language="C#" Value="public void MoveFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveFirst() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveFirst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wechselt zum ersten Element in der Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ändert den aktuellen Wert der <xref:System.Windows.Forms.BindingSource.Position%2A> -Eigenschaft auf 0, der das erste Element in der zugrunde liegenden Datenquelle.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>, und <xref:System.Windows.Forms.BindingSource.Position%2A> Elemente. Um dieses Beispiel auszuführen, fügen Sie den Code in ein Formular, importiert der <xref:System.Drawing.Drawing2D> Namespace und enthält eine <xref:System.Windows.Forms.BindingSource> mit dem Namen `BindingSource1` und eine Schaltfläche mit dem Namen `button1`. Zuordnen der `Form1_Load` und `Form1_Paint` Methoden mit den <xref:System.Windows.Forms.Form.Load> und <xref:System.Windows.Forms.Control.Paint> Ereignisse für das Formular, und ordnen die `button1_click` Methode mit der <xref:System.Windows.Forms.Control.Click> -Ereignis für `button1`. Visual Basic-Benutzer müssen einen Verweis auf "System.Data.dll" hinzufügen.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveLast">
      <MemberSignature Language="C#" Value="public void MoveLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveLast() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveLast" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wechselt zum letzten Element in der Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ändert den aktuellen Wert von der <xref:System.Windows.Forms.BindingSource.Position%2A> Eigenschaft auf den Index des letzten Elements in der zugrunde liegenden Datenquelle, die gleich dem Wert des ist die <xref:System.Windows.Forms.BindingSource.Count%2A> Eigenschaft minus 1.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public void MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveNext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wechselt zum nächsten Element in der Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ändert den aktuellen Wert der <xref:System.Windows.Forms.BindingSource.Position%2A> Eigenschaft zum nächsten Element in der zugrunde liegenden Datenquelle.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>, und <xref:System.Windows.Forms.BindingSource.Position%2A> Elemente. Um dieses Beispiel auszuführen, fügen Sie den Code in ein Formular, importiert der <xref:System.Drawing.Drawing2D> Namespace und enthält eine <xref:System.Windows.Forms.BindingSource> mit dem Namen `BindingSource1` und eine Schaltfläche mit dem Namen `button1`. Zuordnen der `Form1_Load` und `Form1_Paint` Methoden mit den <xref:System.Windows.Forms.Form.Load> und <xref:System.Windows.Forms.Control.Paint> Ereignisse für das Formular, und ordnen die `button1_click` Methode mit der <xref:System.Windows.Forms.Control.Click> -Ereignis für `button1`. Visual Basic-Benutzer müssen einen Verweis auf "System.Data.dll" hinzufügen.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MovePrevious">
      <MemberSignature Language="C#" Value="public void MovePrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MovePrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MovePrevious" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wechselt zum vorherigen Element in der Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ändert den aktuellen Wert der <xref:System.Windows.Forms.BindingSource.Position%2A> Eigenschaft zum vorherigen Element in der zugrunde liegenden Datenquelle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAddingNew">
      <MemberSignature Language="C#" Value="protected virtual void OnAddingNew (System.ComponentModel.AddingNewEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAddingNew(class System.ComponentModel.AddingNewEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.AddingNewEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.AddingNew" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnAddingNew%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBindingComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingComplete (System.Windows.Forms.BindingCompleteEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingComplete(class System.Windows.Forms.BindingCompleteEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.BindingCompleteEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.BindingCompleteEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.BindingComplete" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnBindingComplete%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnCurrentChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentItemChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentItemChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentItemChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnCurrentItemChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDataError">
      <MemberSignature Language="C#" Value="protected virtual void OnDataError (System.Windows.Forms.BindingManagerDataErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataError(class System.Windows.Forms.BindingManagerDataErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.BindingManagerDataErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.BindingManagerDataErrorEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.DataError" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnDataError%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDataMemberChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDataMemberChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataMemberChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnDataMemberChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.  
  
 Mit der <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDataSourceChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDataSourceChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataSourceChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnDataSourceChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnListChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnListChanged (System.ComponentModel.ListChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnListChanged(class System.ComponentModel.ListChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.ListChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.ListChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnListChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPositionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPositionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPositionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.ComponentModel.ListChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.PositionChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnPositionChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public int Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Index des aktuellen Elements in der zugrunde liegenden Liste ab oder legt diesen fest.</summary>
        <value>Ein nullbasierter Index, der die Position des aktuellen Elements in der zugrunde liegenden Liste angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Festlegen der <xref:System.Windows.Forms.BindingSource.Position%2A> Eigenschaft außerhalb des gültigen Bereichs Werte werden wie folgt behandelt:  
  
-   Negative Werte werden als 0 behandelt.  
  
-   Werte größer als oder gleich <xref:System.Windows.Forms.BindingSource.Count%2A> werden behandelt, als <xref:System.Windows.Forms.BindingSource.Count%2A> minus 1.  
  
 Ändern der <xref:System.Windows.Forms.BindingSource.Position%2A> Eigenschaft passt die <xref:System.Windows.Forms.BindingSource.Current%2A> Eigenschaft entsprechend.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>, und <xref:System.Windows.Forms.BindingSource.Position%2A> Elemente. Um dieses Beispiel auszuführen, fügen Sie den Code in ein Formular, importiert der <xref:System.Drawing.Drawing2D> Namespace und enthält eine <xref:System.Windows.Forms.BindingSource> mit dem Namen `BindingSource1` und eine Schaltfläche mit dem Namen `button1`. Zuordnen der `Form1_Load` und `Form1_Paint` Methoden mit den <xref:System.Windows.Forms.Form.Load> und <xref:System.Windows.Forms.Control.Paint> Ereignisse für das Formular, und ordnen die `button1_click` Methode mit der <xref:System.Windows.Forms.Control.Click> -Ereignis für `button1`. Visual Basic-Benutzer müssen einen Verweis auf "System.Data.dll" hinzufügen.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PositionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PositionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PositionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.PositionChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, nachdem der Wert, der die <see cref="P:System.Windows.Forms.BindingSource.Position" /> -Eigenschaft geändert hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.PositionChanged> Ereignis tritt auf, nachdem die <xref:System.Windows.Forms.BindingSource.Position%2A> -Eigenschaft geändert hat.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseListChangedEvents">
      <MemberSignature Language="C#" Value="public bool RaiseListChangedEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RaiseListChangedEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob <see cref="E:System.Windows.Forms.BindingSource.ListChanged" /> Ereignisse ausgelöst werden soll.</summary>
        <value>
          <see langword="true" />Wenn <see cref="E:System.Windows.Forms.BindingSource.ListChanged" /> Ereignisse ausgelöst werden soll; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> Eigenschaft `false`, angehalten, das Auslösen von <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignisse. Dieses Ereignis zeigt an, dass die gebundene Liste in irgendeiner Form, einschließlich hinzufügen, löschen, einfügen oder Ändern von Elementen geändert wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das Element, das aus der zugrunde liegenden Liste dargestellt durch Entfernen der <see cref="P:System.Windows.Forms.BindingSource.List" /> Eigenschaft.</param>
        <summary>Entfernt das angegebene Element aus der Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.Remove%2A> Methode bewirkt, dass die Liste zu suchende der `value` Parameter. Wenn Sie gefunden wurde, versucht diese Methode entfernt das Element aus der <xref:System.Windows.Forms.BindingSource.List%2A>. Dieser Versuch schlägt fehl, wenn die Liste eine feste Größe aufweist oder schreibgeschützt ist. Diese beiden Bedingungen getestet werden können, mit der <xref:System.Windows.Forms.BindingSource.IsFixedSize%2A> und <xref:System.Windows.Forms.BindingSource.IsReadOnly%2A> Eigenschaften bzw..  
  
 Diese Methode löst die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die zugrunde liegende Liste eine feste Größe aufweist oder schreibgeschützt ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des zu entfernenden Elements.</param>
        <summary>Entfernt das Element am angegebenen Index aus dieser Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese beiden Bedingungen getestet werden können, mit der <xref:System.Windows.Forms.BindingSource.IsFixedSize%2A> und <xref:System.Windows.Forms.BindingSource.IsReadOnly%2A> Eigenschaften bzw..  
  
 Diese Methode löst die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Windows.Forms.BindingSource.List%2A>, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>, und <xref:System.Windows.Forms.BindingSource.Count%2A> Elemente. Um dieses Beispiel auszuführen, fügen Sie den Code in ein Formular, enthält ein <xref:System.Windows.Forms.BindingSource> mit dem Namen `BindingSource1`, zwei Bezeichnungen, die mit dem Namen `label1` und `label2`, und eine Schaltfläche mit dem Namen `button1`. Zuordnen der `button1_Click` Methode mit dem <xref:System.Windows.Forms.Control.Click> -Ereignis für `button1`. Visual Basic-Benutzer müssen einen Verweis auf "System.Data.dll" hinzufügen.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />ist kleiner als 0 (null) oder größer als der Wert von der <see cref="P:System.Windows.Forms.BindingSource.Count" /> Eigenschaft.</exception>
        <exception cref="T:System.NotSupportedException">Die zugrunde liegende Liste dargestellt durch die <see cref="P:System.Windows.Forms.BindingSource.List" /> Eigenschaft ist schreibgeschützt oder eine feste Größe aufweist.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public void RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt das aktuelle Element aus der Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.RemoveCurrent%2A> Methode entspricht der <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Windows.Forms.BindingSource.AllowRemove" />-Eigenschaft ist <see langword="false" />.  
  
 - oder -   
  
 <see cref="P:System.Windows.Forms.BindingSource.Position" />ist kleiner als 0 (null) oder größer als <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">Die zugrunde liegende Liste dargestellt durch die <see cref="P:System.Windows.Forms.BindingSource.List" /> Eigenschaft ist schreibgeschützt oder eine feste Größe aufweist.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveFilter">
      <MemberSignature Language="C#" Value="public virtual void RemoveFilter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFilter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveFilter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt den Filter zugeordnete der <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.RemoveFilter%2A> Methode leitet die Anforderung an der zugrunde liegende Liste <xref:System.ComponentModel.IBindingListView.RemoveFilter%2A?displayProperty=nameWithType> Methode. Listet nur implementiert, <xref:System.ComponentModel.IBindingListView> Filtern zu unterstützen.  
  
 Standardmäßig wird ein Aufruf dieser Methode entspricht einem Festlegen der <xref:System.Windows.Forms.BindingSource.Filter%2A> Eigenschaft `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die zugrunde liegende Liste unterstützt keine Filterung.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveSort">
      <MemberSignature Language="C#" Value="public virtual void RemoveSort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveSort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveSort" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt die Sortierung zugeordneten der <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.RemoveSort%2A> Methode leitet die Anforderung an der zugrunde liegende Liste <xref:System.ComponentModel.IBindingList.RemoveSort%2A?displayProperty=nameWithType> Methode. Listet nur implementiert, <xref:System.ComponentModel.IBindingList> unterstützen die Sortierung.  
  
 Standardmäßig wird ein Aufruf dieser Methode entspricht einem Festlegen der <xref:System.Windows.Forms.BindingSource.Sort%2A> Eigenschaft `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die zugrunde liegende Liste unterstützt keine Sortierung.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAllowNew">
      <MemberSignature Language="C#" Value="public virtual void ResetAllowNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetAllowNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetAllowNew" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert die <see cref="P:System.Windows.Forms.BindingSource.AllowNew" /> Eigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.ResetAllowNew%2A> Methode initialisiert die <xref:System.Windows.Forms.BindingSource.AllowNew%2A> -Eigenschaft reflektiert den Wert des entsprechenden <xref:System.Windows.Forms.BindingSource.AllowNew%2A> Eigenschaft in der zugrunde liegenden Liste.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings (bool metadataChanged);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings(bool metadataChanged) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetBindings(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataChanged" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="metadataChanged">
          <see langword="true" />Wenn sich das Datenschema geändert hat <see langword="false" /> Wenn nur die Werte geändert haben.</param>
        <summary>Führt dazu, dass in ein an <see cref="T:System.Windows.Forms.BindingSource" /> gebundenes Steuerelement alle Elemente in der Liste erneut eingelesen und ihre angezeigten Werte aktualisiert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> Methode dass alle gebundenen Steuerelementen der <xref:System.Windows.Forms.BindingSource> , deren Werte zu aktualisieren. Hierfür durch das Auslösen die Methode der <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis mindestens einmal; das `metaDataChanged` Parameter gibt die Art der zugrunde liegenden Änderung an.  
  
-   Ein `metaDataChanged` Wert `true` gibt an, dass das Datenschema des <xref:System.Windows.Forms.BindingSource> hat sich geändert. Ein <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis wird mit <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> festgelegt <xref:System.ComponentModel.ListChangedType?displayProperty=nameWithType>.  
  
-   Ein `metaDataChanged` Wert `false` gibt an, dass nur die Werte von einem oder mehreren Elementen geändert haben.  
  
 Unabhängig vom Wert der `metaDataChanged`, <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis wird mit <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> festgelegt <xref:System.ComponentModel.ListChangedType?displayProperty=nameWithType>. Daher Aufrufen <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> mit einem Parameter des `true` löst zwei <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignisse.  
  
 <xref:System.Windows.Forms.BindingSource.ResetBindings%2A>wird automatisch aufgerufen werden, wenn ein weiteres Element wichtige Änderungen auf dem Datenbindung wie z. B. Einstellung verursacht die <xref:System.Windows.Forms.BindingSource.DataSource%2A> oder <xref:System.Windows.Forms.BindingSource.DataMember%2A> Eigenschaften. Allerdings kann der Programmierer diese Methode auch explizit aufrufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit einem <xref:System.Windows.Forms.BindingSource> -Komponente zum Binden von einer Arrayliste der keine änderungsbenachrichtigung bereitstellt. Ein Element aus der Liste entfernt wird, und die gebundene Steuerelemente werden durch Aufrufen der Änderung benachrichtigt die <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> Methode. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels [Vorgehensweise: widerspiegeln von Datenquellenaktualisierungen in einem Windows Forms-Steuerelement mit der BindingSource-Komponente](~/docs/framework/winforms/controls/reflect-data-source-updates-in-a-wf-control-with-the-bindingsource.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetCurrentItem">
      <MemberSignature Language="C#" Value="public void ResetCurrentItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetCurrentItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetCurrentItem" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass ein Steuerelement gebunden werden, um die <see cref="T:System.Windows.Forms.BindingSource" /> liest das aktuell ausgewählte Element und seine angezeigte Wert aktualisiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen dieser Methode führt dazu, dass die <xref:System.Windows.Forms.BindingSource.ListChanged> -Ereignis auftritt, wobei das geänderte Element an der aktuellen Position.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetItem">
      <MemberSignature Language="C#" Value="public void ResetItem (int itemIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetItem(int32 itemIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetItem(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="itemIndex">Der nullbasierte Index des geänderten Elements.</param>
        <summary>Bewirkt, dass ein Steuerelement gebunden werden, um die <see cref="T:System.Windows.Forms.BindingSource" /> liest das Element am angegebenen Index und der angezeigten Wert aktualisiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.ResetItem%2A> -Methode benachrichtigt alle Steuerelemente, die an das Element am angegebenen gebunden <xref:System.Windows.Forms.BindingSource.Position%2A> , deren Werte zu aktualisieren. Die Methode wird durch das Auslösen der <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis "mit" <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> festgelegt <xref:System.ComponentModel.ListChangedType?displayProperty=nameWithType>.  
  
 <xref:System.Windows.Forms.BindingSource.ResetItem%2A>wird automatisch aufgerufen, wenn der Wert eines einzelnen Elements geändert werden. Allerdings kann der Programmierer diese Methode auch explizit aufrufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit einem <xref:System.Windows.Forms.BindingSource> -Komponente zum Binden einer Liste, um eine <xref:System.Windows.Forms.DataGridView> Steuerelement. Die Liste löst keine änderungsbenachrichtigungen aus, damit die <xref:System.Windows.Forms.BindingSource.ResetItem%2A> Methode auf der <xref:System.Windows.Forms.BindingSource> dient zum Auslösen der <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels [wie: Auslösen von Änderungsbenachrichtigungen mithilfe der ResetItem-Methode](~/docs/framework/winforms/controls/how-to-raise-change-notifications-using-the-bindingsource-resetitem-method.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeBinding">
      <MemberSignature Language="C#" Value="public void ResumeBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResumeBinding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die Datenbindung fort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A>und <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> sind zwei Methoden, die die temporären Unterbrechung und Wiederaufnahme der Datenbindung in einem einfachen Datenbindungsszenario zu ermöglichen. Sie würden Datenbindung in der Regel anhalten, wenn der Benutzer zugelassen werden muss, um mehrere Änderungen an Datenfelder vorzunehmen, bevor die Überprüfung erfolgt. Z. B. würde Wenn ein Feld in Übereinstimmung mit einer Sekunde geändert werden muss, jedoch überprüft das erste Feld das zweite Feld fehlerhaft sein.  
  
> [!NOTE]
>  Mit <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> verhindert, dass Änderungen in der Datenquelle bis gepusht <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> aufgerufen wird, aber tatsächlich verhindert keine Ereignisse auftreten. Steuerelemente, die komplexe Datenbindung, z. B. verwenden die <xref:System.Windows.Forms.DataGridView> steuern, aktualisieren Sie ihre Werte basierend auf Change-Ereignissen, wie z. B. die <xref:System.Windows.Forms.CurrencyManager.ListChanged> Ereignis, deshalb wird beim Aufrufen <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> wird nicht verhindern, dass sie Änderungen an der Datenquelle empfangen. Aus diesem Grund dies <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> und <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> dienen zur Verwendung mit einfach gebundenen Steuerelementen, wie z. B. die <xref:System.Windows.Forms.TextBox> Steuerelement. Alternativ können diese Methoden in einem komplexen Datenbindungsszenario Wenn unterdrückt <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignisse durch Festlegen der <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> Eigenschaft `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public string Sort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Sort" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Sort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die zum Sortieren verwendeten Spaltennamen und die Sortierreihenfolge für die Anzeige der Zeilen in der Datenquelle ab oder legt diese fest.</summary>
        <value>Eine Zeichenfolge mit Berücksichtigung der Groß- und Kleinschreibung, die den Spaltennamen enthält, und auf die "ASC" (für aufsteigend) oder "DESC" (für absteigend) folgt. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.Sort%2A> Eigenschaft ist die Groß-/Kleinschreibung Zeichenfolge, der angibt, die Spaltennamen, die zum Sortieren der Zeilen sowie die Sortierreihenfolge an. Spalten werden standardmäßig in aufsteigender Reihenfolge sortiert. Mehrere Spalten können werden durch Kommas getrennt, z. B. `"State, ZipCode DESC"`.  
  
 Damit die Sortierung unterstützt, muss die zugrunde liegende Liste implementieren die <xref:System.ComponentModel.IBindingList> oder <xref:System.ComponentModel.IBindingListView> Schnittstellen. Diese Funktion kann abgefragt werden, über die <xref:System.Windows.Forms.BindingSource.SupportsSorting%2A> Eigenschaft. Die mehrspaltige Sortierung ist verfügbar, wenn die <xref:System.Windows.Forms.BindingSource.SupportsAdvancedSorting%2A> Eigenschaft ist `true`.  
  
 Festlegen der <xref:System.Windows.Forms.BindingSource.Sort%2A> Eigenschaft ändert sich je nach Typ die interne Liste:  
  
-   Wenn die Liste vom Typ <xref:System.ComponentModel.IBindingList>, <xref:System.ComponentModel.IBindingList.SortProperty%2A?displayProperty=nameWithType> und <xref:System.ComponentModel.IBindingList.SortDirection%2A?displayProperty=nameWithType> Eigenschaften werden in der internen Liste festgelegt.  
  
-   Wenn die Liste vom Typ <xref:System.ComponentModel.IBindingListView>die <xref:System.ComponentModel.IBindingListView.SortDescriptions%2A?displayProperty=nameWithType> festgelegt wird.  
  
 Sortiereigenschaften für die interne Liste werden nur geändert, wenn die Sortierzeichenfolge nicht `null`. Die `get` Accessor für diese Eigenschaft wird nicht den Sortierwert der internen Liste abgerufen werden; stattdessen wird zurückgegeben, die `set` Accessor-Wert. Der Wert, der die <xref:System.Windows.Forms.BindingSource.Sort%2A> Eigenschaft bleibt erhalten, wenn die Datenquelle ändert.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Forms.BindingSource.Sort%2A> Eigenschaft, um eine grundlegende Sortierung mit einem <xref:System.Data.DataView>. Um dieses Beispiel auszuführen, fügen Sie den Code in einem Windows Form, und rufen `PopulateDataViewAndSort` aus den Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load> Ereignisbehandlungsmethode. Das Formular importieren sollte die <xref:System.Xml> und <xref:System.IO> Namespaces.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#2)]  
  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Windows.Forms.BindingSource.Sort%2A> Eigenschaft auszuführenden erweiterte Sortierung mit einem <xref:System.Data.DataView>. Um dieses Beispiel auszuführen, fügen Sie den Code in einem Windows Form, und rufen `PopulateDataViewAndAdvancedSort` aus den Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load> Ereignisbehandlungsmethode. Das Formular importieren sollte die <xref:System.Xml> und <xref:System.IO> Namespaces.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortDescriptions">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ListSortDescriptionCollection SortDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ListSortDescriptionCollection SortDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortDescriptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListSortDescriptionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der auf die Datenquelle angewendeten Sortierbeschreibungen ab.</summary>
        <value>Wenn die Datenquelle ist ein <see cref="T:System.ComponentModel.IBindingListView" />, eine <see cref="T:System.ComponentModel.ListSortDescriptionCollection" /> , enthält die sortierbeschreibungen angewendet, um der Liste, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Liste nicht ist ein <xref:System.ComponentModel.IBindingListView>, die <xref:System.Windows.Forms.BindingSource.SortDescriptions%2A> gibt immer `null`.  
  
 Die <xref:System.ComponentModel.ListSortDescriptionCollection> ist eine schreibgeschützte Auflistung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortDirection">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ListSortDirection SortDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.ListSortDirection SortDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListSortDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Reihenfolge ab, in der die Elemente in der Liste sortiert werden.</summary>
        <value>Eines der <see cref="T:System.ComponentModel.ListSortDirection" /> Werte, die die Richtung angibt, die die Liste sortiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zugrunde liegende Liste kein <xref:System.ComponentModel.IBindingList>, die <xref:System.Windows.Forms.BindingSource.SortDirection%2A> -Eigenschaft gibt stets <xref:System.ComponentModel.ListSortDirection.Ascending>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortProperty">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptor SortProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.PropertyDescriptor SortProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.ComponentModel.PropertyDescriptor" /> , die zum Sortieren der Liste verwendet wird.</summary>
        <value>Wenn die Liste ist ein <see cref="T:System.ComponentModel.IBindingList" />, die <see cref="T:System.ComponentModel.PropertyDescriptor" /> , die für die Sortierung verwendet; andernfalls wird <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Liste nicht ist ein <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SortProperty%2A> gibt immer `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsAdvancedSorting">
      <MemberSignature Language="C#" Value="public virtual bool SupportsAdvancedSorting { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAdvancedSorting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsAdvancedSorting" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Datenquelle die mehrspaltige Sortierung unterstützt.</summary>
        <value>
          <see langword="true" />Wenn die Liste ist ein <see cref="T:System.ComponentModel.IBindingListView" /> und das mit mehreren Spalten sortieren unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Liste nicht ist ein <xref:System.ComponentModel.IBindingListView>, <xref:System.Windows.Forms.BindingSource.SupportsAdvancedSorting%2A> gibt immer `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsChangeNotification">
      <MemberSignature Language="C#" Value="public virtual bool SupportsChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsChangeNotification" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Datenquelle die Änderungsbenachrichtigung unterstützt.</summary>
        <value>
          <see langword="true" /> in allen Fällen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsFiltering">
      <MemberSignature Language="C#" Value="public virtual bool SupportsFiltering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsFiltering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsFiltering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Datenquelle die Filterung unterstützt.</summary>
        <value>
          <see langword="true" />Wenn die Liste ist ein <see cref="T:System.ComponentModel.IBindingListView" /> und unterstützt die Filterung von; anderenfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Liste nicht ist ein <xref:System.ComponentModel.IBindingListView>, <xref:System.Windows.Forms.BindingSource.SupportsFiltering%2A> gibt immer `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsSearching">
      <MemberSignature Language="C#" Value="public virtual bool SupportsSearching { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsSearching" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsSearching" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob Suchvorgänge mit die Datenquelle unterstützt die <see cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" /> Methode.</summary>
        <value>
          <see langword="true" />Wenn die Liste ist eine <see cref="T:System.ComponentModel.IBindingList" /> und unterstützt das Durchsuchen mit der <see cref="Overload:System.Windows.Forms.BindingSource.Find" /> Methode ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Datenquelle nicht ist ein <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SupportsSearching%2A> gibt immer `false`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.BindingSource.SupportsSearching%2A> Member. Das vollständige Beispiel finden Sie im Übersichtsthema.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsSorting">
      <MemberSignature Language="C#" Value="public virtual bool SupportsSorting { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsSorting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsSorting" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Datenquelle die Sortierung unterstützt.</summary>
        <value>
          <see langword="true" />Wenn die Datenquelle ist ein <see cref="T:System.ComponentModel.IBindingList" /> und unterstützt die Sortierung ist; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Datenquelle kein <xref:System.ComponentModel.IBindingList>, die <xref:System.Windows.Forms.BindingSource.SupportsSorting%2A> -Eigenschaft gibt immer `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuspendBinding">
      <MemberSignature Language="C#" Value="public void SuspendBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.SuspendBinding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterbricht die Datenbindung, sodass die gebundene Datenquelle nicht durch Änderungen aktualisiert werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A>und <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> sind zwei Methoden, die die temporären Unterbrechung und Wiederaufnahme der Datenbindung in einem einfachen Datenbindungsszenario zu ermöglichen. Sie würden Datenbindung in der Regel anhalten, wenn der Benutzer zugelassen werden muss, um mehrere Änderungen an Datenfelder vorzunehmen, bevor die Überprüfung erfolgt. Z. B. würde Wenn ein Feld in Übereinstimmung mit einer Sekunde geändert werden muss, jedoch überprüft das erste Feld das zweite Feld fehlerhaft sein.  
  
> [!NOTE]
>  Mit <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> und verhindert, dass Änderungen in der Datenquelle bis gepusht <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> aufgerufen wird, aber tatsächlich verhindert keine Ereignisse auftreten. Steuerelemente, die komplexe Datenbindung, z. B. verwenden die <xref:System.Windows.Forms.DataGridView> steuern, aktualisieren Sie ihre Werte basierend auf Change-Ereignissen, wie z. B. die <xref:System.Windows.Forms.CurrencyManager.ListChanged> Ereignis, deshalb wird beim Aufrufen <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> wird nicht verhindern, dass sie Änderungen an der Datenquelle empfangen. Aus diesem Grund dies <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> und <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> dienen zur Verwendung mit einfach gebundenen Steuerelementen, wie z. B. die <xref:System.Windows.Forms.TextBox> Steuerelement. Alternativ können diese Methoden in einem komplexen Datenbindungsszenario Wenn unterdrückt <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignisse durch Festlegen der <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> Eigenschaft `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf die zugrunde liegende Liste synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die zugrunde liegende Liste synchronisiert werden kann.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IBindingList.AddIndex">
      <MemberSignature Language="C#" Value="void IBindingList.AddIndex (System.ComponentModel.PropertyDescriptor property);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IBindingList.AddIndex(class System.ComponentModel.PropertyDescriptor property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#IBindingList#AddIndex(System.ComponentModel.PropertyDescriptor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="property">Die <see cref="T:System.ComponentModel.PropertyDescriptor" /> für die Suche verwendeten Indizes hinzu.</param>
        <summary>Fügt der <see cref="T:System.ComponentModel.PropertyDescriptor" /> auf die Indizes für die Suche verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zugrunde liegende Liste eine <xref:System.ComponentModel.IBindingList> Typ, der diese Methode wird hinzugefügt der <xref:System.ComponentModel.PropertyDescriptor> an den Indizes; andernfalls wird beim Aufrufen dieser Methode löst eine <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die zugrunde liegende Liste ist ein <see cref="T:System.ComponentModel.IBindingList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IBindingList.RemoveIndex">
      <MemberSignature Language="C#" Value="void IBindingList.RemoveIndex (System.ComponentModel.PropertyDescriptor prop);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IBindingList.RemoveIndex(class System.ComponentModel.PropertyDescriptor prop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#IBindingList#RemoveIndex(System.ComponentModel.PropertyDescriptor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prop" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="prop">Die <see cref="T:System.ComponentModel.PropertyDescriptor" /> So entfernen Sie die Indizes für die Suche verwendet.</param>
        <summary>Entfernt die <see cref="T:System.ComponentModel.PropertyDescriptor" /> von den Indizes, die für die Suche verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zugrunde liegende Liste keine <xref:System.ComponentModel.IBindingList?displayProperty=nameWithType>, diese Methode löst immer eine <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ICancelAddNew.CancelNew">
      <MemberSignature Language="C#" Value="void ICancelAddNew.CancelNew (int position);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ICancelAddNew.CancelNew(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#CancelNew(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Der Index des Elements, das der Auflistung hinzugefügt wurde.</param>
        <summary>Entfernt ein anstehendes neues Element aus der Auflistung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23CancelNew%2A> Methode Rollback für eine ausstehende Hinzufügung eines Elements, das zuvor hinzugefügt haben, an dem angegebenen Index in die Auflistung `position`. Die `position` -Parameter ist erforderlich, da mehrere neue Elemente gleichzeitig ausstehend sein können.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ICancelAddNew.EndNew">
      <MemberSignature Language="C#" Value="void ICancelAddNew.EndNew (int position);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ICancelAddNew.EndNew(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#EndNew(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Der Index des Elements, das der Auflistung hinzugefügt wurde.</param>
        <summary>Übergibt ein anstehendes neues Element an die Auflistung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23EndNew%2A> -Methode führt einen Commit für eine ausstehende Hinzufügung eines Elements, das zuvor hinzugefügt haben, an dem angegebenen Index in die Auflistung `position`. Die `position` -Parameter ist erforderlich, da mehrere neue Elemente gleichzeitig ausstehend sein können.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.BeginInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitialize#BeginInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Signalisiert dem <see cref="T:System.Windows.Forms.BindingSource" /> Start der Initialisierung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.EndInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitialize#EndInit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Signalisiert dem <see cref="T:System.Windows.Forms.BindingSource" /> , dass die Initialisierung abgeschlossen ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitializeNotification.IsInitialized">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.ISupportInitializeNotification.IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.ISupportInitializeNotification.IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitializeNotification#IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Windows.Forms.BindingSource" /> initialisiert ist.</summary>
        <value>
          <see langword="true" />um anzugeben, die <see cref="T:System.Windows.Forms.BindingSource" /> initialisiert wurde, andernfalls wird <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Forms.BindingSource>-Instanz in eine <xref:System.ComponentModel.ISupportInitializeNotification>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
