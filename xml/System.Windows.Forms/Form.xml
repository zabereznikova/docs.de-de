<Type Name="Form" FullName="System.Windows.Forms.Form">
  <TypeSignature Language="C#" Value="public class Form : System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Form extends System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Form" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.ContainerControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.FormDocumentDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Form")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InitializationEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms.Control.TopLevel")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Fenster oder ein Dialogfeld dar, das die Benutzeroberfläche einer Anwendung bildet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Forms.Form> ist eine Darstellung von einem beliebigen Fenster in der Anwendung angezeigt. Die <xref:System.Windows.Forms.Form> Klasse kann verwendet werden, um Standard, randlos, Tools und frei schwebenden Fenster erstellen. Sie können auch die <xref:System.Windows.Forms.Form> Klasse, z. B. ein Dialogfeld modale Fenster zu erstellen. Eine spezielle Art des Formulars, die Multiple Document Interface (MDI), kann andere Formen aufgerufen, untergeordnete MDI-Formulare enthalten. Ein MDI-Formular erstellt, indem die <xref:System.Windows.Forms.Form.IsMdiContainer%2A> Eigenschaft `true`. Untergeordnete MDI-Formulare werden erstellt, indem die <xref:System.Windows.Forms.Form.MdiParent%2A> Eigenschaft, um die übergeordneten MDI-Formulars, das das untergeordnete Formular enthält.  
  
 Indem Sie die Eigenschaften in der <xref:System.Windows.Forms.Form> -Klasse, Sie können die Darstellung, Größe, Farbe und Fenster-Verwaltungsfunktionen von Fenster oder Dialogfeld Feld erstelltem bestimmen. Die <xref:System.Windows.Forms.Control.Text%2A> -Eigenschaft können Sie die Beschriftung des Fensters in der Titelleiste angeben. Die <xref:System.Windows.Forms.Form.Size%2A> und <xref:System.Windows.Forms.Form.DesktopLocation%2A> Eigenschaften können Sie die Größe und Position des Fensters definieren, wenn er angezeigt wird. Sie können die <xref:System.Windows.Forms.Control.ForeColor%2A> Color-Eigenschaft so ändern Sie die Standardvordergrundfarbe aller Steuerelemente im Formular platziert. Die <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, und <xref:System.Windows.Forms.Form.MaximizeBox%2A> Eigenschaften können Sie steuern, ob das Formular minimiert, maximiert oder zur Laufzeit geändert werden kann.  
  
 Zusätzlich zu den Eigenschaften können Sie die Methoden der Klasse verwenden, um einem Formular zu bearbeiten. Beispielsweise können Sie die <xref:System.Windows.Forms.Form.ShowDialog%2A> Methode, um ein Formular als modales Dialogfeld anzeigen. Sie können die <xref:System.Windows.Forms.Form.SetDesktopLocation%2A> Methode, um das Formular zu positionieren, auf dem Desktop.  
  
 Die Ereignisse der <xref:System.Windows.Forms.Form> Klasse können Sie Aktionen für das Formular zu reagieren. Sie können die <xref:System.Windows.Forms.Form.Activated> Ereignis, um Vorgänge wie das Aktualisieren der Daten in die Steuerelemente des Formulars angezeigt, wenn das Formular aktiviert ist.  
  
 Sie können ein Formular in Ihrer Anwendung als Startklasse verwenden, platziert eine Methode namens `Main` in der Klasse. In der `Main` Methode fügen Sie Code zum Erstellen und das Formular anzuzeigen. Sie müssen auch hinzufügen der `STAThread` -Attribut auf die `Main` Methode in der Reihenfolge des Formulars ausgeführt. Wenn das Startformular geschlossen wird, wird die Anwendung ebenfalls geschlossen.  
  
 Wenn Sie festlegen, die <xref:System.Windows.Forms.Control.Enabled%2A> Eigenschaft, um `false` vor der <xref:System.Windows.Forms.Form> sichtbar ist (z. B. <xref:System.Windows.Forms.Control.Enabled%2A> auf "false" in der [!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)] Designer), die minimieren-, maximieren-, schließen und Systemschaltflächen aktiviert bleiben. Wenn Sie festlegen, <xref:System.Windows.Forms.Control.Enabled%2A> auf `false` nach der <xref:System.Windows.Forms.Form> wird angezeigt (z. B., wenn das Load-Ereignis auftritt), die Schaltflächen sind deaktiviert.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine neue Instanz von einem <xref:System.Windows.Forms.Form> und ruft die <xref:System.Windows.Forms.Form.ShowDialog%2A> Methode, um das Formular als Dialogfeld anzeigen. Im Beispiel wird die <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, und <xref:System.Windows.Forms.Form.StartPosition%2A> Eigenschaften, um die Darstellung und Funktionalität des Formulars in ein Dialogfeld zu ändern. Das Beispiel verwendet außerdem die <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> Methode im Format <xref:System.Windows.Forms.Control.Controls%2A> Auflistung hinzuzufügende zwei <xref:System.Windows.Forms.Button> Steuerelemente. Im Beispiel wird die <xref:System.Windows.Forms.Form.HelpButton%2A> -Eigenschaft auf eine Schaltfläche "Hilfe" in der Titelleiste des Dialogfelds angezeigt.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Form ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Form" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardgröße eines Formulars beträgt 300 Pixel hoch und 300 Pixel breit.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine neue Instanz von einem <xref:System.Windows.Forms.Form> und ruft die <xref:System.Windows.Forms.Form.ShowDialog%2A> Methode, um das Formular als Dialogfeld anzeigen. Im Beispiel wird die <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, und <xref:System.Windows.Forms.Form.StartPosition%2A> Eigenschaften, um die Darstellung und Funktionalität des Formulars in ein Dialogfeld zu ändern. Im Beispiel wird außerdem verwendet die <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> Methode im Format <xref:System.Windows.Forms.Control.Controls%2A> Auflistung hinzuzufügende zwei <xref:System.Windows.Forms.Button> Steuerelemente. Im Beispiel wird die <xref:System.Windows.Forms.Form.HelpButton%2A> -Eigenschaft auf eine Schaltfläche "Hilfe" in der Titelleiste des Dialogfelds angezeigt.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl AcceptButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl AcceptButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AcceptButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Schaltfläche im Formular ab, die beim Drücken der EINGABETASTE betätigt wird, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.IButtonControl" />, das die Schaltfläche darstellt, die als Bestätigungsschaltfläche für das Formular verwendet werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht Ihnen, eine Standardaktion, die auftreten, wenn der Benutzer die EINGABETASTE, in der Anwendung drückt festzulegen. Die Schaltfläche "dieser Eigenschaft zugewiesene" muss ein <xref:System.Windows.Forms.IButtonControl> , befindet sich auf das aktuelle Formular oder in einem Container auf das aktuelle Formular befindet.  
  
 Sie können diese Eigenschaft verwenden, damit der Benutzer schnell ein einfaches Formular navigieren, indem ihnen ermöglicht, einfach die EINGABETASTE drücken, wenn sie anstatt manuell auf die Schaltfläche "akzeptieren", mit dem Mauszeiger fertig sind.  
  
 Die Schaltfläche "Annehmen" kann nicht aktiviert werden, wenn das momentan ausgewählte Steuerelement im Formular die EINGABETASTE abfängt und diese verarbeitet. Beispielsweise ermöglicht ein mehrzeiliges Textfeld-Steuerelement die EINGABETASTE gedrückt, wenn er ausgewählt ist, um ein neue-Zeile-Zeichen in das Steuerelement eingefügt.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine neue Instanz von einem <xref:System.Windows.Forms.Form> und ruft die <xref:System.Windows.Forms.Form.ShowDialog%2A> Methode, um das Formular als Dialogfeld anzeigen. Im Beispiel wird die <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, und <xref:System.Windows.Forms.Form.StartPosition%2A> Eigenschaften, um die Darstellung und Funktionalität des Formulars in ein Dialogfeld zu ändern. Das Beispiel verwendet außerdem die <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> Methode im Format <xref:System.Windows.Forms.Control.Controls%2A> Auflistung hinzuzufügende zwei <xref:System.Windows.Forms.Button> Steuerelemente. Im Beispiel wird die <xref:System.Windows.Forms.Form.HelpButton%2A> -Eigenschaft auf eine Schaltfläche "Hilfe" in der Titelleiste des Dialogfelds angezeigt.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public void Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Activate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktiviert das Formular und übergibt diesem den Fokus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Formular aktivieren sie in den Vordergrund gebracht, wenn die aktive Anwendung sieht, oder es die fensterbeschriftung blinkt, ist dies nicht die aktive Anwendung. Das Formular muss für diese Methode wirkt sich nur sichtbar sein. Um das aktive Formular in einer Anwendung zu ermitteln, verwenden die <xref:System.Windows.Forms.Form.ActiveForm%2A> Eigenschaft oder die <xref:System.Windows.Forms.Form.ActiveMdiChild%2A> Eigenschaft, wenn die Formulare in einer Multiple Document Interface (MDI)-Anwendung sind.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Load> und <xref:System.Windows.Forms.Form.Activate%2A> Elemente. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular namens `Form1` aufgerufen, die eine Schaltfläche enthält `Button1` und zwei `Label` genannten Hoststeuerelemente `Label1` und `Label2`.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern des Fokus. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Activated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Formular im Code oder vom Benutzer aktiviert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn die Anwendung aktiv ist und mehrere Formulare aufweist, wird das aktive Formular das Formular mit den Eingabefokus besitzt. Ein Formular, das nicht angezeigt wird, darf nicht das aktive Formular sein. Die einfachste Methode zum Aktivieren eines Formulars angezeigten wird, klicken darauf, oder verwenden Sie eine entsprechende Tastenkombination.  
  
 Um ein Formular zur Laufzeit mithilfe von Code zu aktivieren, rufen Sie die <xref:System.Windows.Forms.Form.Activate%2A> Methode. Verwenden Sie dieses Ereignis für Aufgaben wie das Aktualisieren des Inhalts des Formulars basierend auf Änderungen an die Daten des Formulars, wenn das Formular nicht aktiviert wurde.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Closed>, <xref:System.Windows.Forms.Form.Load>, <xref:System.Windows.Forms.Form.Activated>, und <xref:System.Windows.Forms.Form.Activate%2A> Elemente. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular mit dem Namen Form1 ein <xref:System.Windows.Forms.Button> aufgerufen `Button1` und zwei <xref:System.Windows.Forms.Label> genannten Hoststeuerelemente `Label1` und `Label2`.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateMdiChild">
      <MemberSignature Language="C#" Value="protected void ActivateMdiChild (System.Windows.Forms.Form form);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ActivateMdiChild(class System.Windows.Forms.Form form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ActivateMdiChild(System.Windows.Forms.Form)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="form">Das zu aktivierende untergeordnete Formular.</param>
        <summary>Aktiviert das untergeordnete MDI-Element eines Formulars.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `form` Parameter ist bereits mit dem aktiven untergeordneten MDI-Formulars die <xref:System.Windows.Forms.Form.ActivateMdiChild%2A> einfach Methodenrückgabe. Wenn `form` nicht `null`, dann werden von aktiven untergeordneten MDI-Formulars festgelegt ist.  
  
 Ob die `form` Parameter ist `null` or not <xref:System.Windows.Forms.Form.ActivateMdiChild%2A> löst die <xref:System.Windows.Forms.Form.MdiChildActivate> Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveForm">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Form ActiveForm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.Form ActiveForm" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveForm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das momentan aktive Formular für diese Anwendung ab.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Form" />-Objekt, das das momentan aktive Formular darstellt, oder <see langword="null" />, wenn es kein aktives Formular gibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode können Sie einen Verweis auf das momentan aktive Formular für Aktionen auf die Form oder einem seiner Steuerelemente erhalten.  
  
 Wenn Ihre Anwendung eine Multiple Document Interface (MDI)-Anwendung ist, verwenden die <xref:System.Windows.Forms.Form.ActiveMdiChild%2A> Eigenschaft, die derzeit aktiven untergeordneten MDI-Formulars abgerufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das aktive Formular abgerufen und alle Steuerelemente im Formular deaktiviert. Im Beispiel wird die <xref:System.Windows.Forms.Control.Controls%2A> Auflistung des Formulars auf jedes Steuerelement im Formular durchlaufen, und deaktivieren die Steuerelemente.  
  
 [!code-cpp[Classic Form.ActiveForm Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveForm Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveForm Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveForm Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Anfordern eines Formulars an. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ActiveMdiChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form ActiveMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form ActiveMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveMdiChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das momentan aktive untergeordnete MDI (Multiple Document Interface)-Fenster ab.</summary>
        <value>Gibt ein <see cref="T:System.Windows.Forms.Form" />-Objekt zurück, das das momentan aktive untergeordnete MDI-Fenster darstellt, oder <see langword="null" />, wenn keine untergeordneten Fenster vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, um zu bestimmen, ob alle untergeordneten MDI-Formulare in der MDI-Anwendung geöffnet sind. Sie können diese Methode auch verwenden, zum Ausführen von Vorgängen für ein untergeordnetes MDI-Fenster aus seiner übergeordneten MDI-Formulars oder eine andere Form, die in der Anwendung angezeigt wird.  
  
 Wenn das momentan aktive Formular nicht über ein untergeordnetes MDI-Formular ist, können Sie mithilfe der <xref:System.Windows.Forms.Form.ActiveForm%2A> Eigenschaft, um einen Verweis darauf erhalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erhält einen Verweis auf das aktive untergeordnete MDI-Formular und durchläuft alle <xref:System.Windows.Forms.TextBox> Steuerelemente im Formular Zurücksetzen ihrer <xref:System.Windows.Forms.TextBoxBase.Text%2A> Eigenschaften. Dieses Beispiel benötigen Sie ein übergeordnetes MDI-Formular erstellt wurde, sodass der Aufruf dieser Methode wird von übergeordneten MDI-Formulars erfolgt.  
  
 [!code-cpp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwnedForm">
      <MemberSignature Language="C#" Value="public void AddOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm">Das <see cref="T:System.Windows.Forms.Form" />-Objekt, das in den Besitz dieses Formulars übergeht.</param>
        <summary>Fügt diesem Formular als Besitzer ein Formular hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Formular auf das Besitzerformular zugewiesen bleibt bis zum Besitzer der <xref:System.Windows.Forms.Form.RemoveOwnedForm%2A> -Methode aufgerufen wird. Sie können auch ein Formular, das im Besitz von einem anderen festlegen, die <xref:System.Windows.Forms.Form.Owner%2A> Eigenschaft mit einem Verweis auf das Besitzerformular.  
  
 Wenn eine andere Form ein Formulars Besitz befindet, ist es geschlossen oder ausgeblendet werden, zusammen mit dem Besitzerformular. Betrachten Sie beispielsweise ein Formular mit dem Namen `Form2` , deren Besitzer ein Formular mit dem Namen `Form1`. Wenn `Form1` geschlossen oder minimiert, `Form2` auch geschlossen oder ausgeblendet wird. Formulare werden ebenfalls nicht hinter dem Besitzerformular angezeigt. Sie können verwendet Formulare für Windows, z. B. Suchen und Ersetzen von Fenstern, bei denen hinter dem Besitzerformular nicht angezeigt werden soll, wenn das Besitzerformular ausgewählt ist.  
  
> [!NOTE]
>  Wenn das Formular ein Multiple Document Interface (MDI) übergeordnetes Formular ist, gibt diese Eigenschaft an, dass alle Formulare, die mit Ausnahme von untergeordneten MDI-Formulare angezeigt werden, die derzeit geöffnet. Verwenden Sie zum Abrufen der untergeordnete MDI-Formulare in einem übergeordneten MDI-Formulars geöffnet die <xref:System.Windows.Forms.Form.MdiChildren%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Form.AddOwnedForm%2A> Methode, um ein Formular als ein Formular mit einem anderen Formular angezeigt wird. Sobald das Formular angezeigt wird, können Sie das Besitzerformular minimieren und das zugehörige Formular wird minimiert, damit. Das Beispiel erfordert, dass der Code im Beispiel über ein anderes Ereignis oder Methode eines Formulars aufgerufen wird.  
  
 [!code-cpp[Form.AddOwnedForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AddOwnedForm/CPP/form1.cpp#1)]
 [!code-csharp[Form.AddOwnedForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AddOwnedForm/CS/form1.cs#1)]
 [!code-vb[Form.AddOwnedForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AddOwnedForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AdjustFormScrollbars">
      <MemberSignature Language="C#" Value="protected override void AdjustFormScrollbars (bool displayScrollbars);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void AdjustFormScrollbars(bool displayScrollbars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AdjustFormScrollbars(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="displayScrollbars" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="displayScrollbars">
          <see langword="true" />, um die Bildlaufleisten anzuzeigen, andernfalls <see langword="false" />.</param>
        <summary>Passt die Bildlaufleisten im Container anhand der aktuellen Positionen der Steuerelemente und des aktuell ausgewählten Steuerelements an.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowTransparency">
      <MemberSignature Language="C#" Value="public bool AllowTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AllowTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Durchlässigkeit des Formulars angepasst werden kann, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn die Deckkraft des Formulars geändert werden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird automatisch festgelegt, um `true` Wenn die `Opacity` geändert wird. Wenn die Deckkraft eines Formulars festgelegt ist, mit der `Opacity` -Eigenschaft, das Formular wird Überlagern von Objekten in das Formular. Wenn Sie festlegen, die <xref:System.Windows.Forms.Form.AllowTransparency%2A> Eigenschaft `false` des Formulars werden im Ebenen-Modus, der die Anzeige des Formulars verbessert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAutoScaling">
      <MemberSignature Language="C#" Value="protected void ApplyAutoScaling ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ApplyAutoScaling() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ApplyAutoScaling" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the ApplyAutoScaling method instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ändert die Größe des Formulars entsprechend dem aktuellen Wert der <see cref="P:System.Windows.Forms.Form.AutoScaleBaseSize" />-Eigenschaft und der Größe der aktuellen Schriftart.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt die Größe des Formulars, mit dem Wert von der <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> Eigenschaft und die <xref:System.Windows.Forms.Form.Size%2A> zurückgegebene Wert den <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScale">
      <MemberSignature Language="C#" Value="public bool AutoScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScale" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. Use the AutoScaleMode property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Größe des Formulars der Höhe der im Formular verwendeten Schriftart angepasst wird und die Steuerelemente des Formulars skaliert werden, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Formular und die darin befindlichen Steuerelemente automatisch entsprechend der aktuellen dem Formular zugewiesenen Schriftart skaliert werden, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Die <xref:System.Windows.Forms.Form.AutoScale%2A> ist veraltet und wurde für Abwärtskompatibilität beibehalten. Die nicht veraltete Alternative ist <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A?displayProperty=nameWithType>. Weitere Informationen zur automatischen Skalierung finden Sie unter [automatische Skalierung in Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 Sie können diese Eigenschaft verwenden, um das Formular zu ermöglichen, und seine Steuerelemente automatisch anpassen auf der Grundlage von Änderungen in der Schriftart. Dies kann hilfreich für Anwendungen, in dem die Schriftart erhöhen kann, oder verringern, die basierend auf der Sprache, die für die Verwendung von Windows angegeben sein.  
  
 Zum Abrufen der Größe des Formulars werden automatisch zu verwendende Skala der <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> Eigenschaft. Gegebenenfalls zur Bestimmung der Größe des Formulars automatisch vergrößert wird, basierend auf einer bestimmten Schriftart, verwenden die <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScaleBaseSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size AutoScaleBaseSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size AutoScaleBaseSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScaleBaseSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Grundgröße ab, die für die automatische Skalierung des Formulars verwendet wird, oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Drawing.Size" />, die die Grundgröße darstellt, die dieses Formular für die automatische Skalierung verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Dieser Member wurde für Abwärtskompatibilität beibehalten. Weitere Informationen zur automatischen Skalierung finden Sie unter [automatische Skalierung in Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 Der Wert, der die <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> Eigenschaft wird zum Zeitpunkt der Anzeige des Formulars verwendet, um den Faktor für die Skalierung für das Formular zu berechnen. Die Grundgröße wird vom Formular verwendeten als Grundlage für den Vergleich mit Schriftgrad für das System zum Ermitteln des anfallenden für die Skalierung des Formulars, wenn die automatische Skalierung verwendet wird. Wenn Sie die Größe bestimmen möchten, ein Formular werden automatisch skalieren basierend auf einer bestimmten Schriftart, verwenden die <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> Methode.  
  
> [!NOTE]
>  Der Wert dieser Eigenschaft wird verwendet, wenn das Formular erstmalig erstellt wird. Sobald die Eigenschaft festgelegt ist, kann er nicht geändert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScroll">
      <MemberSignature Language="C#" Value="public override bool AutoScroll { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScroll" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScroll" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Formular den automatischen Bildlauf ermöglicht, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, um den automatischen Bildlauf für das Formular zu aktivieren, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft, um festgelegt wird `true`, Bildlaufleisten werden auf dem Formular angezeigt, wenn alle Steuerelemente außerhalb der Formularbereich Client befinden. Darüber hinaus bei den automatischen Bildlauf aktiviert ist, führt einen Bildlauf durch den Clientbereich des Formulars automatisch um das Steuerelement mit Eingabefokus sichtbar zu machen.  
  
 Sie können diese Eigenschaft verwenden, um zu verhindern, dass Benutzer verlieren die Möglichkeit, die Steuerelemente anzuzeigen, wenn ihre Einstellungen für die Auflösung mit niedriger Auflösung festgelegt sind.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Form.AutoScroll%2A> Eigenschaft zum Aktivieren der Anzeige von Steuerelementen, die sich außerhalb des Clientbereichs eines Formulars sind. Das Beispiel erstellt ein neues Formular, und fügt eine <xref:System.Windows.Forms.Button> Steuerelement dem Formular. Die <xref:System.Windows.Forms.Button> Steuerelement befindet sich außerhalb des Clientbereichs des neuen Formulars. Die <xref:System.Windows.Forms.Form.AutoScroll%2A> Eigenschaftensatz wird auf "true", auf das Formular, um dem Benutzer ermöglichen, führen Sie einen Bildlauf an das Steuerelement Bildlaufleisten angezeigt werden sollen. Dieses Beispiel benötigen Sie, dass die in diesem Beispiel definierte Methode aus einem anderen Formular in einem Ereignishandler oder eine andere Methode aufgerufen wird.  
  
 [!code-cpp[Form.AutoScroll#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AutoScroll/CPP/form1.cpp#1)]
 [!code-csharp[Form.AutoScroll#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoScroll/CS/form1.cs#1)]
 [!code-vb[Form.AutoScroll#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoScroll/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ändern Sie die Größe des Formulars entsprechend der Einstellung von <see cref="P:System.Windows.Forms.Form.AutoSizeMode" />.</summary>
        <value>
          <see langword="true" />, wenn die Größe des Formulars automatisch geändert wird, <see langword="false" />, wenn die Größe manuell geändert werden muss.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Windows.Forms.Form.AutoSize%2A> erzwingen Sie ein Formular, um seinen Inhalt angepasst.  
  
 Ein Formular in der Visual Studio-Forms-Designer, unabhängig von den Werten der nicht automatisch angepasst werden die <xref:System.Windows.Forms.Form.AutoSize%2A> und <xref:System.Windows.Forms.Form.AutoSizeMode%2A> Eigenschaften. Größe des Formulars ändert ordnungsgemäß selbst zur Laufzeit nach den Werten dieser beiden Eigenschaften. Im Gegensatz dazu, eine benutzerdefinierte <xref:System.Windows.Forms.UserControl> automatisch selbst ändert sowohl zur Entwurfszeit und zur Laufzeit.  
  
 Bei Verwendung <xref:System.Windows.Forms.Form.AutoSize%2A>, <xref:System.Windows.Forms.Control.MinimumSize%2A> und <xref:System.Windows.Forms.Control.MaximumSize%2A> Eigenschaften werden berücksichtigt, aber der aktuelle Wert der die <xref:System.Windows.Forms.Control.Size%2A> Eigenschaft wird ignoriert. Mit <xref:System.Windows.Forms.Form.AutoSize%2A> und <xref:System.Windows.Forms.Form.AutoSizeMode%2A> auch rendert die <xref:System.Windows.Forms.Form.AutoScroll%2A> Eigenschaft überflüssig, wie es keine Möglichkeit zum Verkleinern des Formulars gibt, um die darin enthaltenen Steuerelemente aus der Ansicht ausgeblendet.  
  
 Finden Sie unter der <xref:System.Windows.Forms.AutoSizeMode> Enumeration Informationen wann verhält sich wie ein Formular <xref:System.Windows.Forms.Form.AutoSize%2A> ist `true`.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt ein Formular erstellt, mit Code, die Größe wird automatisch an seinen Inhalt angepasst. Bei der Ausführung des Formulars angezeigt ein <xref:System.Windows.Forms.Label>, <xref:System.Windows.Forms.TextBox> zum Eingeben einer URL und ein <xref:System.Windows.Forms.Button> für diese URL innerhalb des Benutzers Standard-Webbrowser anzuzeigen. Das Codebeispiel verwendet eine <xref:System.Windows.Forms.FlowLayoutPanel> um das Layout der enthaltenen Steuerelemente nacheinander. Außerdem wird die <xref:System.Windows.Forms.Control.AutoSize%2A> und <xref:System.Windows.Forms.AutoSizeMode> vergrößert und verkleinert werden, um den Inhalt des Formulars anzupassen.  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoSizeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich die <see cref="P:System.Windows.Forms.Form.AutoSize" />-Eigenschaft ändert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoSizeMode AutoSizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoSizeMode AutoSizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Modus ab, in dem das Formular seine Größe automatisch selbst ändert, oder legt diesen Modus fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.AutoSizeMode" />-Enumerationswert. Die Standardeinstellung ist <see cref="F:System.Windows.Forms.AutoSizeMode.GrowOnly" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen der <xref:System.Windows.Forms.Form.AutoSizeMode%2A> -Eigenschaft einen neuen Wert bewirkt, dass das Formular erneut angeordnet werden.  
  
 Ein Formular in der Visual Studio-Forms-Designer, unabhängig von den Werten der nicht automatisch angepasst werden die <xref:System.Windows.Forms.Form.AutoSize%2A> und <xref:System.Windows.Forms.Form.AutoSizeMode%2A> Eigenschaften. Größe des Formulars ändert ordnungsgemäß selbst zur Laufzeit nach den Werten dieser beiden Eigenschaften. Im Gegensatz dazu, eine benutzerdefinierte <xref:System.Windows.Forms.UserControl> automatisch selbst ändert sowohl zur Entwurfszeit und zur Laufzeit.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt ein Formular erstellt, mit Code, die Größe wird automatisch an seinen Inhalt angepasst. Bei Ausführung im Formular ein ein <xref:System.Windows.Forms.Label>, <xref:System.Windows.Forms.TextBox> zum Eingeben einer URL und ein <xref:System.Windows.Forms.Button> für diese URL innerhalb des Benutzers Standard-Webbrowser anzuzeigen. Das Codebeispiel verwendet eine <xref:System.Windows.Forms.FlowLayoutPanel> um das Layout der enthaltenen Steuerelemente nacheinander. Außerdem wird die <xref:System.Windows.Forms.Control.AutoSize%2A> und <xref:System.Windows.Forms.AutoSizeMode> vergrößert und verkleinert werden, um den Inhalt des Formulars anzupassen.  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der Wert ist kein gültiger <see cref="T:System.Windows.Forms.AutoSizeMode" /> Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="AutoValidate">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.AutoValidate AutoValidate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoValidate AutoValidate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoValidate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoValidate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Steuerelemente in diesem Container automatisch validiert werden, wenn der Fokus geändert wird, oder legt diesen Wert fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.AutoValidate" /> Enumerationswert, der angibt, ob enthaltene Steuerelemente bei Änderung des Fokus implizit validiert werden. Der Standardwert wird geerbt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoValidateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoValidateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoValidateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoValidateChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich die <see cref="P:System.Windows.Forms.Form.AutoValidate" />-Eigenschaft ändert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Hintergrundfarbe für das Steuerelement ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Drawing.Color" />, die die Hintergrundfarbe des Steuerelements darstellt. Der Standardwert ist der Wert der <see cref="P:System.Windows.Forms.Control.DefaultBackColor" />-Eigenschaft.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl CancelButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl CancelButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CancelButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Button-Steuerelement ab, das beim Drücken von ESC betätigt wird, oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.IButtonControl" />, das die Schaltfläche zum Abbrechen für das Formular darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Schaltfläche "Abbrechen", für ein Formular ist das Schaltflächen-Steuerelement, auf die geklickt wird, wenn der Benutzer die ESC-Taste drückt. Die Schaltfläche "dieser Eigenschaft zugewiesene" muss ein <xref:System.Windows.Forms.IButtonControl> , befindet sich auf das aktuelle Formular oder in einem Container auf das aktuelle Formular befindet.  
  
 Diese Eigenschaft ermöglicht Ihnen, eine Standardaktion, die auftreten, wenn der Benutzer die ESC-Taste, in der Anwendung drückt festzulegen. Sie können diese Eigenschaft verwenden, damit der Benutzer, ein einfaches Formular schnell zu navigieren, indem ihnen ermöglicht, drücken einfach die ESC-Taste, um ein Fenster zu schließen, ohne dass Änderungen, anstatt manuell auf die Schaltfläche "Abbrechen", mit dem Mauszeiger kann.  
  
 <xref:System.Windows.Forms.Form.CancelButton%2A>Möglicherweise funktioniert nicht, wenn ein anderes Steuerelement im Formular die ESC-TASTE abfängt. Angenommen, Sie haben eine <xref:System.Windows.Forms.ComboBox> auf das Formular geöffnet, ESC geschlossen wird die <xref:System.Windows.Forms.ComboBox> anstatt das Formular geschlossen.  
  
 Die <xref:System.Windows.Forms.IButtonControl> zugewiesene Objekt <xref:System.Windows.Forms.Form.CancelButton%2A> muss auf dem Formular angezeigt werden, da andernfalls die ESC-Taste drücken Schlüssel hat keine Auswirkungen.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine neue Instanz von einem <xref:System.Windows.Forms.Form> und ruft die <xref:System.Windows.Forms.Form.ShowDialog%2A> Methode, um das Formular als Dialogfeld anzeigen. Im Beispiel wird die <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, und <xref:System.Windows.Forms.Form.StartPosition%2A> Eigenschaften, um die Darstellung und Funktionalität des Formulars in ein Dialogfeld zu ändern. Das Beispiel verwendet außerdem die <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> Methode im Format <xref:System.Windows.Forms.Control.Controls%2A> Auflistung hinzuzufügende zwei <xref:System.Windows.Forms.Button> Steuerelemente. Im Beispiel wird die <xref:System.Windows.Forms.Form.HelpButton%2A> -Eigenschaft auf eine Schaltfläche "Hilfe" in der Titelleiste des Dialogfelds angezeigt.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterToParent">
      <MemberSignature Language="C#" Value="protected void CenterToParent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToParent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zentriert die Position des Formulars innerhalb der Begrenzungen des übergeordneten Formulars.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie nicht die <xref:System.Windows.Forms.Form.CenterToParent%2A> -Methode direkt aus dem Code. Legen Sie stattdessen die <xref:System.Windows.Forms.Form.StartPosition%2A> Eigenschaft <xref:System.Windows.Forms.FormStartPosition.CenterParent>.  
  
 Wenn das Formular oder Dialogfeld klicken Sie dann auf der obersten Ebene, ist <xref:System.Windows.Forms.Form.CenterToParent%2A> Zentriert das Formular in Bezug auf den Bildschirm oder den Desktop.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterToScreen">
      <MemberSignature Language="C#" Value="protected void CenterToScreen ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToScreen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToScreen" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zentriert das Formular für den aktuellen Bildschirm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie dies nicht direkt aus dem Code. Legen Sie stattdessen die <xref:System.Windows.Forms.Form.StartPosition%2A> Eigenschaft <xref:System.Windows.Forms.FormStartPosition.CenterScreen>.  
  
 Die <xref:System.Windows.Forms.Form.CenterToScreen%2A> Methode der folgenden Prioritätenliste verwendet, um zu bestimmen, den Bildschirm, um das Formular zentrieren verwendet:  
  
1.  Die <xref:System.Windows.Forms.Form.Owner%2A> -Eigenschaft des Formulars.  
  
2.  Der HWND-Besitzer des Formulars.  
  
3.  Der Bildschirm aufweist, das gegenwärtig den Cursor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ClientSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des Clientbereichs des Formulars ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Drawing.Size" />, die die Größe des Clientbereichs des Formulars darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Größe des Clientbereichs des Formulars wird die Größe des Formulars ohne Rahmen und der Titelleiste. Das den Clientbereich eines Formulars ist der Bereich innerhalb eines Formulars, in dem Steuerelemente platziert werden können. Sie können diese Eigenschaft verwenden, die richtigen Dimensionen bei Vorgängen für Grafiken oder beim Ändern der Größe und Positionierung der Steuerelemente im Formular ab. Verwenden Sie zum Abrufen der Größe des gesamten Formulars die <xref:System.Windows.Forms.Form.Size%2A> Eigenschaft oder die einzelnen Eigenschaften <xref:System.Windows.Forms.Control.Height%2A> und <xref:System.Windows.Forms.Control.Width%2A>.  
  
> [!NOTE]
>  Sie können nicht auf diese Eigenschaft, die mit den Anwendungseinstellungen derzeit binden. Weitere Informationen zu Anwendungseinstellungen, finden Sie unter [Übersicht über Anwendungseinstellungen](~/docs/framework/winforms/advanced/application-settings-overview.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Ereignishandler für das <xref:System.Windows.Forms.Control.Resize> -Ereignis für ein Formular. Der Ereignishandler verwendet die <xref:System.Windows.Forms.Form.ClientSize%2A> -Eigenschaft des Formulars auf stellen eine <xref:System.Windows.Forms.Button> -Steuerelement namens `button1` füllen Sie den gesamten Clientbereich des Formulars.  
  
 [!code-cpp[Classic Form.ClientSize Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ClientSize Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ClientSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ClientSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt das Formular.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Formular geschlossen wird, alle Ressourcen erstellt, die innerhalb des Objekts geschlossen sind, und das Formular freigegeben. Sie können das Schließen eines Formulars zur Laufzeit verhindern, durch Behandeln der <xref:System.Windows.Forms.Form.Closing> Ereignis und die Einstellung der <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.ComponentModel.CancelEventArgs> als Parameter an Ihren Ereignishandler übergebene. Wenn das Formular, das Sie schließen das Startformular der Anwendung ist, wird die Anwendung beendet.  
  
 Die beiden Bedingungen, wenn ein Formular nicht gelöscht wird, auf `Close` bei (1) sie ist Teil einer Anwendung Multiple Document Interface (MDI) und das Formular nicht sichtbar ist; und (2) Sie haben das Formular angezeigt wird mithilfe von <xref:System.Windows.Forms.Form.ShowDialog%2A>. In diesen Fällen müssen Sie zum Aufrufen <xref:System.Windows.Forms.Form.Dispose%2A> manuell, um alle Steuerelemente des Formulars für die Garbagecollection zu markieren.  
  
> [!NOTE]
>  Wenn die <xref:System.Windows.Forms.Form.Close%2A> Methode aufgerufen wird eine <xref:System.Windows.Forms.Form> als ein nicht modales Fenster angezeigt wird, können nicht aufgerufen werden die <xref:System.Windows.Forms.Control.Show%2A> Methode, um das Formular sichtbar ist, da die Ressourcen des Formulars bereits freigegeben wurden. Zum Ausblenden eines Formulars und dass es sichtbar ist, verwenden die <xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType> Methode.  
  
> [!CAUTION]
>  Vor der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 2.0 die <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType> und <xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType> Ereignisse wurden nicht wird ausgelöst, wenn die <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> Methode wird aufgerufen, um die Anwendung zu beenden. Wenn Sie Validierungscode in eines dieser Ereignisse, die ausgeführt werden müssen verfügen, sollten Sie Aufrufen der <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> Methode für jedes Formular einzeln vor dem Aufruf der <xref:System.Windows.Forms.Application.Exit%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das Formular wurde geschlossen, während ein Handle erstellt wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Sie können keine rufen Sie diese Methode aus der <see cref="E:System.Windows.Forms.Form.Activated" /> Ereignis beim <see cref="P:System.Windows.Forms.Form.WindowState" /> auf festgelegt ist <see cref="F:System.Windows.Forms.FormWindowState.Maximized" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Formular geschlossen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Die <xref:System.Windows.Forms.Form.Closed> Ereignis ist in .NET Framework, Version 2.0 veraltet; verwenden Sie die <xref:System.Windows.Forms.Form.FormClosed> Ereignis stattdessen.  
  
 Dieses Ereignis tritt auf, nachdem das Formular vom Benutzer oder durch geschlossen wurde die <xref:System.Windows.Forms.Form.Close%2A> -Methode des Formulars. Zum Schließen ein Formulars zu verhindern, behandeln die <xref:System.Windows.Forms.Form.Closing> Ereignis, und legen die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.ComponentModel.CancelEventArgs> an Ihren Ereignishandler zu übergeben `true`.  
  
 Sie können dieses Ereignis verwenden, um Aufgaben wie das Freigeben von Ressourcen, die vom Formular verwendeten und im Formular eingegebenen Informationen zu speichern oder übergeordneten Formulars zu aktualisieren.  
  
> [!CAUTION]
>  Die <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType> und <xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType> Ereignisse wurden nicht ausgelöst, wenn die <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> Methode wird aufgerufen, um die Anwendung zu beenden. Wenn Sie Validierungscode in eines dieser Ereignisse, die ausgeführt werden müssen verfügen, sollten Sie Aufrufen der <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> Methode für jedes Formular einzeln vor dem Aufruf der <xref:System.Windows.Forms.Application.Exit%2A> Methode.  
  
 Wenn das Formular mit einem übergeordneten MDI-Formulars ist die <xref:System.Windows.Forms.Form.Closing> Ereignisse von allen untergeordneten MDI-Formulare ausgelöst, bevor der übergeordnete MDI-Formular <xref:System.Windows.Forms.Form.Closing> Ereignis wird ausgelöst. Darüber hinaus die <xref:System.Windows.Forms.Form.Closed> Ereignisse von allen untergeordneten MDI-Formulare ausgelöst, bevor die <xref:System.Windows.Forms.Form.Closed> -Ereignis des übergeordneten MDI-Formulars ausgelöst wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Closed>, <xref:System.Windows.Forms.Form.Load>, <xref:System.Windows.Forms.Form.Activated>, und <xref:System.Windows.Forms.Form.Activate%2A> Elemente. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular mit `Form1` mit einem <xref:System.Windows.Forms.Button> aufgerufen `Button1` und zwei <xref:System.Windows.Forms.Label> genannten Hoststeuerelemente `Label1` und `Label2`.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closing" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Schließen des Formulars ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Die <xref:System.Windows.Forms.Form.Closing> Ereignis ist in .NET Framework, Version 2.0 veraltet; verwenden Sie die <xref:System.Windows.Forms.Form.FormClosing> Ereignis stattdessen.  
  
 Die <xref:System.Windows.Forms.Form.Closing> Ereignis tritt auf, wenn das Formular geschlossen wird. Wenn ein Formular geschlossen wird, alle Ressourcen, die innerhalb des Objekts erstellt werden freigegeben, und das Formular freigegeben. Wenn Sie dieses Ereignis abbrechen, bleibt das Formular geöffnet. Legen Sie zum Abbrechen des Abschluss eines Formulars die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.ComponentModel.CancelEventArgs> an Ihren Ereignishandler zu übergeben `true`.  
  
 Wenn ein Formular als modales Dialogfeld angezeigt wird, klicken Sie auf die **schließen** Schaltfläche (die Schaltfläche mit einem X in der oberen rechten Ecke des Formulars) bewirkt, dass das Formular ausgeblendet werden und die <xref:System.Windows.Forms.Form.DialogResult%2A> Eigenschaft festgelegt werden, um `DialogResult.Cancel`. Sie können den zugewiesenen Wert überschreiben die <xref:System.Windows.Forms.Form.DialogResult%2A> Eigenschaft klickt der Benutzer die **schließen** Schaltfläche durch Festlegen der <xref:System.Windows.Forms.Form.DialogResult%2A> Eigenschaft in einem Ereignishandler für die <xref:System.Windows.Forms.Form.Closing> Ereignis der Art.  
  
> [!NOTE]
>  Wenn die <xref:System.Windows.Forms.Form.Close%2A> Methode aufgerufen wird eine <xref:System.Windows.Forms.Form> als ein nicht modales Fenster angezeigt wird, können nicht aufgerufen werden die <xref:System.Windows.Forms.Control.Show%2A> Methode, um das Formular sichtbar ist, da die Ressourcen des Formulars bereits freigegeben wurden. Zum Ausblenden eines Formulars und dass es sichtbar ist, verwenden die <xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType> Methode.  
  
> [!CAUTION]
>  Die <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType> und <xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType> Ereignisse wurden nicht ausgelöst, wenn die <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> Methode wird aufgerufen, um die Anwendung zu beenden. Wenn Sie Validierungscode in eines dieser Ereignisse, die ausgeführt werden müssen verfügen, sollten Sie Aufrufen der <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> Methode für jedes Formular einzeln vor dem Aufruf der <xref:System.Windows.Forms.Application.Exit%2A> Methode.  
  
 Wenn das Formular mit einem übergeordneten MDI-Formulars ist die <xref:System.Windows.Forms.Form.Closing> Ereignisse von allen untergeordneten MDI-Formulare ausgelöst, bevor der übergeordnete MDI-Formular <xref:System.Windows.Forms.Form.Closing> Ereignis wird ausgelöst. Darüber hinaus die <xref:System.Windows.Forms.Form.Closed> Ereignisse von allen untergeordneten MDI-Formulare ausgelöst, bevor die <xref:System.Windows.Forms.Form.Closed> -Ereignis des übergeordneten MDI-Formulars ausgelöst wird. Durch das Abbrechen der <xref:System.Windows.Forms.Form.Closing> -Ereignis für ein untergeordnetes MDI-Formular verhindert nicht die <xref:System.Windows.Forms.Form.Closing> -Ereignis des übergeordneten MDI-Formulars ausgelöst wird. Abbrechen des Ereignisses jedoch festgelegt wird, um `true` der <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.ComponentModel.CancelEventArgs> , die als Parameter an das übergeordnete Formular übergeben wird. Um alle übergeordneten und untergeordneten MDI-Formulare geschlossen zu erzwingen, legen die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft `false` im MDI übergeordnete Formular.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit <xref:System.Windows.Forms.Form.Closing> getestet, ob der Text in einem <xref:System.Windows.Forms.TextBox> hat sich geändert. Wenn bestehen, wird der Benutzer an, ob die Änderungen in einer Datei Speichern aufgefordert.  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlBox">
      <MemberSignature Language="C#" Value="public bool ControlBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ControlBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ControlBox" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob auf der Beschriftungsleiste des Formulars ein Systemmenüfeld angezeigt wird, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn im Formular in der linken oberen Ecke ein Systemmenüfeld angezeigt wird, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Form.ControlBox%2A> -Eigenschaftensatz auf `true`, das Steuerelement wird in der linken oberen Ecke der Titelleiste angezeigt. Das Steuerelement ist, in denen der Benutzer klicken können, um das Systemmenü zuzugreifen.  
  
 Wenn Sie festlegen, <xref:System.Windows.Forms.Form.ControlBox%2A> auf `false`, und legen Sie außerdem die <xref:System.Windows.Forms.Form.Location%2A> -Eigenschaft, die <xref:System.Windows.Forms.Form.Size%2A> -Eigenschaft des Formulars wird nicht aktualisiert werden, um widerzuspiegeln, dass nicht-Clientbereich des Formulars ausgeblendet wurde. Um dieses Problem zu beheben, fügen Sie den Code ändert den <xref:System.Windows.Forms.Form.Location%2A> Eigenschaft, um die <xref:System.Windows.Forms.Control.HandleCreated> Ereignis.  
  
> [!NOTE]
>  Bei Festlegung auf `false`die <xref:System.Windows.Forms.Form.ControlBox%2A> Eigenschaft wirkt sich nicht auf einem Multiple Document Interface (MDI) untergeordnete Formular, das zum Zeitpunkt der Erstellung maximiert angezeigt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Form.ControlBox%2A>, <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, und <xref:System.Windows.Forms.Form.StartPosition%2A> Eigenschaften, um ein Formular erstellen, die über kein Rahmen oder eine Beschriftung-Feld. Das Formular in diesem Beispiel erstellte konnte verwendet werden, um einen Begrüßungsbildschirm für eine Anwendung zu erstellen. Im Beispiel erfordert, dass das Beispiel für eine Methode in einer Formularklasse definiert ist, und wird aufgerufen, wenn das Formular initialisiert wird.  
  
 [!code-cpp[Classic Form.ControlBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ControlBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ControlBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ControlBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateControlsInstance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Instanz der Steuerelementauflistung für das Steuerelement.</summary>
        <returns>Eine neue Instanz der dem Steuerelement zugewiesenen <see cref="T:System.Windows.Forms.Control.ControlCollection" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected override void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt das Handle für das Formular. Wenn eine abgeleitete Klasse diese Funktion überschreibt, muss sie die Basisimplementierung aufrufen.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Ein Handle für diese <see cref="T:System.Windows.Forms.Form" /> bereits erstellt wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die benötigten Erstellungsparameter ab, wenn das Steuerelementhandle erstellt wird.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.CreateParams" />-Eigenschaft, die die erforderlichen Erstellungsparameter enthält, wenn das Handle für das Steuerelement erstellt wird.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivate">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Deactivate" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Formular den Fokus verliert und nicht mehr das aktive Formular ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können dieses Ereignis für Aufgaben wie das Aktualisieren von einem anderen Fenster in Ihrer Anwendung mit Daten aus dem deaktivierten Formular verwenden.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.Deactivate> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.Deactivate> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#393](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#393)]
 [!code-vb[System.Windows.Forms.EventExamples#393](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#393)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den von dem Steuerelement unterstützten Standard-IME-Modus (Eingabemethoden-Editor) ab.</summary>
        <value>Einer der <see cref="T:System.Windows.Forms.ImeMode" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Eingabemethoden-Editor (IME) ist ein Programm, das Benutzern ermöglicht, komplexe Zeichen und Symbole, z. B. japanische Kanji-Zeichen, über eine Standardtastatur eingeben.  
  
 Bei Implementierung in der <xref:System.Windows.Forms.Form> Klasse, die diese Eigenschaft gibt immer die <xref:System.Windows.Forms.ImeMode?displayProperty=nameWithType> Wert. Der Wert dieser Eigenschaft zugewiesen ist die <xref:System.Windows.Forms.Control.ImeMode%2A?displayProperty=nameWithType> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardgröße des Steuerelements ab.</summary>
        <value>Die Standard-<see cref="T:System.Drawing.Size" /> des Steuerelements.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected override void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Die zu verarbeitende Windows-<see cref="T:System.Windows.Forms.Message" />.</param>
        <summary>Sendet die angegebene Meldung an die Standardfensterprozedur.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DesktopBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle DesktopBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DesktopBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Größe und Position des Formulars auf dem Windows-Desktop ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Drawing.Rectangle" />, das die Begrenzungen des Formulars auf dem Windows-Desktop in Desktopkoordinaten darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Desktopkoordinaten basieren auf den Arbeitsbereich des Bildschirms, die die Taskleiste ausgeschlossen sind. Das Koordinatensystem des Desktops basiert auf Pixel. Wenn Ihre Anwendung auf einem System Monitor ausgeführt wird, sind die Koordinaten des Formulars die Koordinaten für den kombinierten Desktop.  
  
 Sie können diese Eigenschaft verwenden, um Größe und position eines Formulars relativ zu anderen Formen oder Anwendungen auf dem Windows-Desktop.  
  
   
  
## Examples  
 Das folgende Codebeispiel legt fest, die Größe und Position eines Formulars, damit das Formular 50 Pixel vom linken Rand und 50 Pixel vom oberen Rand der Desktop ist. Dieses Beispiel erfordert, dass die Methode in einer Formularklasse definiert ist.  
  
 [!code-cpp[Classic Form.DesktopBounds Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopBounds Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopBounds Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DesktopLocation">
      <MemberSignature Language="C#" Value="public System.Drawing.Point DesktopLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point DesktopLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position des Formulars auf dem Windows-Desktop ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Drawing.Point" />, der die Position des Formulars auf dem Desktop darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Desktopkoordinaten basieren auf den Arbeitsbereich des Bildschirms, die die Taskleiste ausgeschlossen sind. Das Koordinatensystem des Desktops ist Grundlage Pixel. Wenn Ihre Anwendung auf einem System mit mehreren Bildschirmen ausgeführt wird, sind die Koordinaten des Formulars die Koordinaten für den kombinierten Desktop.  
  
 Sie können diese Eigenschaft verwenden, positionieren Sie das Formular relativ zu anderen Formen und Anwendungen auf dem Windows-Desktop.  
  
 Beim Aufrufen der <xref:System.Windows.Forms.Form.SetDesktopLocation%2A> Methode vor dem Aufruf der <xref:System.Windows.Forms.Form.Show%2A> -Methode, wird das Formular positioniert werden, an seinem Standardspeicherort, der vom Betriebssystem bestimmt wird. Weitere Informationen zur Positionierung finden Sie unter "im Abschnitt"Größe und Position im Fenster"des Dokuments"Fenster-Funktionen"in der MSDN Library unter http://msdn.microsoft.com/library".  
  
 Beim Aufrufen <xref:System.Windows.Forms.Form.SetDesktopLocation%2A> nach dem Aufruf <xref:System.Windows.Forms.Form.Show%2A>, das Formular wird am angegebenen Speicherort positioniert sein.  
  
   
  
## Examples  
 Das folgende Codebeispiel legt die Position eines Formulars, damit das Formular 100 Pixel vom linken Rand der desktop und 100 Pixel vom oberen Rand des Desktops befindet. Dieses Beispiel erfordert, dass die Methode innerhalb einer Form-Klasse definiert wurde.  
  
 [!code-cpp[Classic Form.DesktopLocation Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopLocation Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopLocation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DialogResult DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Dialogergebnis für das Formular ab oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.DialogResult" />, das das Ergebnis des Formulars bei Verwendung als Dialogfeld darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Dialogergebnis eines Formulars ist der Wert, der aus dem Formular zurückgegeben wird, wenn er als modales Dialogfeld angezeigt wird. Wenn das Formular als Dialogfeld angezeigt wird, durch Festlegen dieser Eigenschaft mit einem Wert aus der <xref:System.Windows.Forms.DialogResult> Enumeration legt den Wert für das Ergebnis des Dialogfelds für das Formular, das modale Dialogfeld ausgeblendet und die Steuerung an die aufrufende Formular zurückgegeben. Diese Eigenschaft ist in der Regel durch Festlegen der <xref:System.Windows.Forms.Button.DialogResult%2A> Eigenschaft ein <xref:System.Windows.Forms.Button> Steuerelement im Formular. Klickt der Benutzer die <xref:System.Windows.Forms.Button> zu steuern, den zugewiesenen Wert der <xref:System.Windows.Forms.Button.DialogResult%2A> Eigenschaft von der <xref:System.Windows.Forms.Button> zugewiesen ist die <xref:System.Windows.Forms.Form.DialogResult%2A> -Eigenschaft des Formulars.  
  
 Wenn ein Formular als modales Dialogfeld angezeigt wird, klicken Sie auf die **schließen** Schaltfläche (die Schaltfläche mit einem "X" in der oberen rechten Ecke des Formulars) bewirkt, dass das Formular ausgeblendet werden und die <xref:System.Windows.Forms.Form.DialogResult%2A> Eigenschaft festgelegt werden, um `DialogResult.Cancel`. Die <xref:System.Windows.Forms.Form.Close%2A> Methode wird nicht automatisch aufgerufen, wenn der Benutzer klickt der **schließen** Schaltfläche eines Dialogfelds, oder legt den Wert für die <xref:System.Windows.Forms.Form.DialogResult%2A> Eigenschaft. Stattdessen wird das Formular wird ausgeblendet, und kann erneut ohne Erstellen einer neuen Instanz des Dialogfelds angezeigt werden. Aufgrund dieses Verhaltens, rufen Sie die <xref:System.Windows.Forms.Control.Dispose%2A> -Methode des Formulars bei das Formular von der Anwendung nicht mehr benötigt wird.  
  
 Sie können diese Eigenschaft verwenden, um zu bestimmen, wie ein Dialogfeld geschlossen wird, um das Dialogfeld ausgeführten Aktionen ordnungsgemäß zu verarbeiten.  
  
> [!NOTE]
>  Sie können den zugewiesenen Wert überschreiben die <xref:System.Windows.Forms.Form.DialogResult%2A> Eigenschaft klickt der Benutzer die **schließen** Schaltfläche durch Festlegen der <xref:System.Windows.Forms.Form.DialogResult%2A> Eigenschaft in einem Ereignishandler für die <xref:System.Windows.Forms.Form.Closing> Ereignis der Art.  
  
> [!NOTE]
>  Wenn eine <xref:System.Windows.Forms.Form> wird angezeigt, wie ein nicht modales Fenster, den Rückgabewert von der <xref:System.Windows.Forms.Form.DialogResult%2A> Eigenschaft möglicherweise keinen Rückgabewert auf das Formular zugewiesen werden, da die Ressourcen des Formulars automatisch freigegeben werden, wenn das Formular geschlossen wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt ein Formular als Dialogfeld an und zeigt ein Meldungsfeld gibt an, ob durch Verweisen auf die Schaltfläche OK oder "Abbrechen", des Formulars geklickt wurde die <xref:System.Windows.Forms.Form.DialogResult%2A> -Eigenschaft des Formulars.  
  
 [!code-cpp[Classic Form.DialogResult Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DialogResult Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DialogResult Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DialogResult Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der angegebene Wert liegt außerhalb des Bereichs der gültigen Werte.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.Windows.Forms.Form" />-Klasse verwendeten Ressourcen (mit Ausnahme des Speichers) frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, der öffentlich `Dispose` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose`Ruft die geschützte `Dispose(Boolean)` Methode mit dem `disposing` Parametersatz auf `true`. <xref:System.Object.Finalize%2A>Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Windows.Forms.Form> verweist. Diese Methode ruft die `Dispose`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 <xref:System.Windows.Forms.Form.Dispose%2A>wird automatisch aufgerufen, wenn das Formular angezeigt wird, mit der <xref:System.Windows.Forms.Form.Show%2A> Methode. Wenn eine andere Methode wie z. B. <xref:System.Windows.Forms.Form.ShowDialog%2A> verwendet wird, oder das Formular nie angezeigt wird, rufen Sie <xref:System.Windows.Forms.Form.Dispose%2A> selbst innerhalb der Anwendung.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose(Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see langword="Dispose" /> freigegeben wurden. Weitere Informationen zum Implementieren <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.DpiChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die DPI-Einstellung auf dem Anzeigegerät, auf dem das Formular zurzeit angezeigt wird, geändert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FormBorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormBorderStyle FormBorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormBorderStyle FormBorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.FormBorderStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-504)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormBorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Rahmenart des Formulars ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.FormBorderStyle" />, der die Art des Rahmens für die Anzeige des Formulars darstellt. Die Standardeinstellung ist <see langword="FormBorderStyle.Sizable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Rahmenart des Formulars bestimmt, wie die äußeren Rand des Formulars angezeigt wird. Zusätzlich zum Ändern der Anzeige der Rahmen für ein Formular, verhindern, dass bestimmte Rahmenarten des Formulars angepasst wird. Z. B. die `FormBorderStyle.FixedDialog` Rahmenart der Rahmen des Formulars, eines Dialogfelds ändert und verhindert, dass das Formular, dessen Größe geändert. Die Rahmenart kann auch die Größe oder die Verfügbarkeit von Titelleistenbereichs eines Formulars beeinflussen.  
  
> [!NOTE]
>  Mit der <xref:System.Windows.Forms.FormBorderStyle.Sizable> -Format ist es unmöglich, die Größe des Fensters unter einen bestimmten minimalen Wert, auch wenn Sie festgelegt haben <xref:System.Windows.Forms.Form.ControlBox%2A> auf `false` und eine Zeichenfolge der Länge 0 (null), zugewiesen <xref:System.Windows.Forms.Form.Text%2A>. Betrachten Sie das Umgehen von dies mithilfe der <xref:System.Windows.Forms.FormBorderStyle.SizableToolWindow> stattdessen formatieren.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine neue Instanz von einem <xref:System.Windows.Forms.Form> und ruft die <xref:System.Windows.Forms.Form.ShowDialog%2A> Methode, um das Formular als Dialogfeld anzeigen. Im Beispiel wird die <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, und <xref:System.Windows.Forms.Form.StartPosition%2A> Eigenschaften, um die Darstellung und Funktionalität des Formulars in ein Dialogfeld zu ändern. Das Beispiel verwendet außerdem die <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> Methode im Format <xref:System.Windows.Forms.Control.Controls%2A> Auflistung hinzuzufügende zwei <xref:System.Windows.Forms.Button> Steuerelemente. Im Beispiel wird die <xref:System.Windows.Forms.Form.HelpButton%2A> -Eigenschaft auf eine Schaltfläche "Hilfe" in der Titelleiste des Dialogfelds angezeigt.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der angegebene Wert liegt außerhalb des Bereichs der gültigen Werte.</exception>
      </Docs>
    </Member>
    <Member MemberName="FormClosed">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosedEventHandler FormClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosedEventHandler FormClosed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem ein Formular geschlossen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.FormClosed> Ereignis tritt auf, nachdem das Formular vom Benutzer oder durch geschlossen wurde die <xref:System.Windows.Forms.Form.Close%2A> Methode oder die <xref:System.Windows.Forms.Application.Exit%2A> Methode der <xref:System.Windows.Forms.Application> Klasse. Zum Schließen ein Formulars zu verhindern, behandeln die <xref:System.Windows.Forms.Form.FormClosing> Ereignis, und legen die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.ComponentModel.CancelEventArgs> an Ihren Ereignishandler zu übergeben `true`.  
  
 Sie können dieses Ereignis verwenden, um Aufgaben wie das Freigeben von Ressourcen, die vom Formular verwendeten und im Formular eingegebenen Informationen zu speichern oder übergeordneten Formulars zu aktualisieren.  
  
 Wenn das Formular ein Multiple Document Interface (MDI) übergeordnetes Formular ist der <xref:System.Windows.Forms.Form.FormClosing> Ereignisse von allen untergeordneten MDI-Formulare ausgelöst, bevor der übergeordnete MDI-Formular <xref:System.Windows.Forms.Form.FormClosing> Ereignis wird ausgelöst. Entsprechend der <xref:System.Windows.Forms.Form.FormClosed> Ereignisse von allen untergeordneten MDI-Formulare ausgelöst, bevor die <xref:System.Windows.Forms.Form.FormClosed> -Ereignis des übergeordneten MDI-Formulars ausgelöst wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.FormClosed> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.FormClosed> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#395](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#395)]
 [!code-vb[System.Windows.Forms.EventExamples#395](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#395)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FormClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosingEventHandler FormClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosingEventHandler FormClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosing" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, bevor das Formular geschlossen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.FormClosing> Ereignis tritt auf, wenn das Formular geschlossen wird. Wenn ein Formular geschlossen wird, wird sie verworfen und freigeben aller Ressourcen, die das Formular zugeordnet. Wenn Sie dieses Ereignis abbrechen, bleibt das Formular geöffnet. Legen Sie zum Abbrechen des Abschluss eines Formulars die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.Windows.Forms.FormClosingEventArgs> an Ihren Ereignishandler zu übergeben `true`.  
  
 Wenn ein Formular als modales Dialogfeld angezeigt wird, klicken Sie auf die **schließen** Schaltfläche (die Schaltfläche mit einem X in der oberen rechten Ecke des Formulars) bewirkt, dass das Formular ausgeblendet werden und die <xref:System.Windows.Forms.Form.DialogResult%2A> Eigenschaft festgelegt werden, um `DialogResult.Cancel`. Sie können den zugewiesenen Wert überschreiben die <xref:System.Windows.Forms.Form.DialogResult%2A> Eigenschaft klickt der Benutzer die **schließen** Schaltfläche durch Festlegen der <xref:System.Windows.Forms.Form.DialogResult%2A> Eigenschaft in einem Ereignishandler für die <xref:System.Windows.Forms.Form.FormClosing> Ereignis der Art.  
  
> [!NOTE]
>  Wenn die <xref:System.Windows.Forms.Form.Close%2A> Methode aufgerufen wird eine <xref:System.Windows.Forms.Form> als ein nicht modales Fenster angezeigt wird, können nicht aufgerufen werden die <xref:System.Windows.Forms.Control.Show%2A> Methode, um das Formular sichtbar ist, da die Ressourcen des Formulars bereits freigegeben wurden. Zum Ausblenden eines Formulars und dass es sichtbar ist, verwenden die <xref:System.Windows.Forms.Control.Hide%2A> Methode.  
  
 Wenn das Formular ein Multiple Document Interface (MDI) übergeordnetes Formular ist der <xref:System.Windows.Forms.Form.FormClosing> Ereignisse von allen untergeordneten MDI-Formulare ausgelöst, bevor der übergeordnete MDI-Formular <xref:System.Windows.Forms.Form.FormClosing> Ereignis wird ausgelöst. Entsprechend der <xref:System.Windows.Forms.Form.FormClosed> Ereignisse von allen untergeordneten MDI-Formulare ausgelöst, bevor die <xref:System.Windows.Forms.Form.FormClosed> -Ereignis des übergeordneten MDI-Formulars ausgelöst wird. Durch das Abbrechen der <xref:System.Windows.Forms.Form.FormClosing> -Ereignis für ein untergeordnetes MDI-Formular verhindert nicht die <xref:System.Windows.Forms.Form.FormClosing> -Ereignis des übergeordneten MDI-Formulars ausgelöst wird. Abbrechen des Ereignisses jedoch festgelegt wird, um `true` der <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.Windows.Forms.FormClosingEventArgs> -Klasse, die als Parameter an das übergeordnete Formular übergeben wird. Um alle übergeordneten und untergeordneten MDI-Formulare geschlossen zu erzwingen, legen die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft `false` im MDI übergeordnete Formular.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.FormClosing> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.FormClosing> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#394](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#394)]
 [!code-vb[System.Windows.Forms.EventExamples#394](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#394)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAutoScaleSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.SizeF GetAutoScaleSize (System.Drawing.Font font);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.SizeF GetAutoScaleSize(class System.Drawing.Font font) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetAutoScaleSize(System.Drawing.Font)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the AutoScaleDimensions property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="font" Type="System.Drawing.Font" />
      </Parameters>
      <Docs>
        <param name="font">Ein <see cref="T:System.Drawing.Font" />, der die Schriftart für die Bestimmung der automatisch skalierten Grundgröße des Formulars darstellt.</param>
        <summary>Ruft die Größe des Formulars bei automatischer Skalierung entsprechend einer angegebenen Schriftart ab.</summary>
        <returns>Eine <see cref="T:System.Drawing.SizeF" />, die die Größe des Formulars bei automatischer Skalierung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Die <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> Methode ist in.NET Framework, Version 2.0, veraltet. Dieser Member wurde für Abwärtskompatibilität beibehalten. Weitere Informationen zur automatischen Skalierung finden Sie unter [automatische Skalierung in Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 Sie können diese Methode verwenden, zur Bestimmung der Größe, die ein Formulars für eine bestimmte Schriftart automatische Skalierung würde, vor dem Anwenden der Schriftartformats in das Formular. Wenn Sie die Größe bestimmen möchten, ein Formular ist automatisch, basierend auf dem Formular zugewiesenen Schriftart, verwenden Sie die <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="bounds">Ein <see cref="T:System.Drawing.Rectangle" />, das den Bereich angibt, für den die Anzeigebegrenzungen abgerufen werden sollen.</param>
        <param name="factor">Die Höhe und Breite der Begrenzungen des Steuerelements.</param>
        <param name="specified">Einer der Werte von <see cref="T:System.Windows.Forms.BoundsSpecified" />, die die Grenzen des Steuerelements angeben, die beim Definieren seiner Größe und Position anzugeben sind.</param>
        <summary>Ruft die Begrenzungen ab, innerhalb derer das Steuerelement skaliert wird.</summary>
        <returns>Ein <see cref="T:System.Drawing.Rectangle" />, das die Begrenzungen darstellt, innerhalb derer das Steuerelement skaliert wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HelpButton">
      <MemberSignature Language="C#" Value="public bool HelpButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HelpButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.HelpButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob auf der Titelleiste des Formulars die Hilfeschaltfläche angezeigt werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, um die Hilfeschaltfläche auf der Titelleiste des Formulars anzuzeigen, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft festgelegt wird, um `true`, eine kleine Schaltfläche mit einem Fragezeichen angezeigt wird, auf der Titelleiste links neben der **schließen** Schaltfläche. Sie können diese Schaltfläche zum Anzeigen von Hilfe für Ihre Anwendung verwenden. Können, erstellen Sie einen Ereignishandler für das <xref:System.Windows.Forms.Control.HelpRequested> -Ereignis für die <xref:System.Windows.Forms.Control> zum Anzeigen der Hilfeinformationen für den Benutzer beim Klicken auf die Schaltfläche "Hilfe" des Formulars.  
  
> [!IMPORTANT]
>  Der Wert, der die <xref:System.Windows.Forms.Form.HelpButton%2A> Eigenschaft wird ignoriert, wenn die **Maximieren** oder **Minimieren** Schaltflächen angezeigt werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine neue Instanz von einem <xref:System.Windows.Forms.Form> und ruft die <xref:System.Windows.Forms.Form.ShowDialog%2A> Methode, um das Formular als Dialogfeld anzeigen. Im Beispiel wird die <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, und <xref:System.Windows.Forms.Form.StartPosition%2A> Eigenschaften, um die Darstellung und Funktionalität des Formulars in ein Dialogfeld zu ändern. Das Beispiel verwendet außerdem die <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> Methode im Format <xref:System.Windows.Forms.Control.Controls%2A> Auflistung hinzuzufügende zwei <xref:System.Windows.Forms.Button> Steuerelemente. Im Beispiel wird die <xref:System.Windows.Forms.Form.HelpButton%2A> -Eigenschaft auf eine Schaltfläche "Hilfe" in der Titelleiste des Dialogfelds angezeigt.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HelpButtonClicked">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler HelpButtonClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler HelpButtonClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.HelpButtonClicked" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die **Hilfe** geklickt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.HelpButtonClicked> Ereignis tritt auf, wenn die **Hilfe** Titelleiste des Formulars die Schaltfläche geklickt wird. Die **Hilfe** Schaltfläche wird angezeigt, wenn die <xref:System.Windows.Forms.Form.HelpButton%2A> -Eigenschaftensatz auf `true`. <xref:System.Windows.Forms.Form.HelpButtonClicked>kann abgebrochen werden.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.HelpButtonClicked> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.HelpButtonClicked> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#388](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#388)]
 [!code-vb[System.Windows.Forms.EventExamples#388](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#388)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Drawing.Icon Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Icon Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Icon</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Symbol für das Formular ab oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Drawing.Icon" />, das das Symbol für das Formular darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Symbol "des Formulars" kennzeichnet das Bild, das das Formular in der Taskleiste als auch auf das Symbol, das für das Steuerelement im Formular angezeigt wird, darstellt.  
  
 Diese Eigenschaft hat keine Auswirkung, wenn <xref:System.Windows.Forms.Form.FormBorderStyle%2A> festgelegt ist, um <xref:System.Windows.Forms.FormBorderStyle.FixedDialog>. In diesem Fall wird das Formular kein Symbol angezeigt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem die Eingabesprache des Formulars geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können dieses Ereignis verwenden, Darstellung und Text basierend auf Änderungen an die Eingabesprache des Formulars des Formulars ändern.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.InputLanguageChanged> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.InputLanguageChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#400](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#400)]
 [!code-vb[System.Windows.Forms.EventExamples#400](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#400)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanging">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanging" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer versucht, die Eingabesprache für das Formular zu ändern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt auf, bevor die Änderung der Eingabesprache für das Formular vorgenommen wird. Sie können die Sprache ändern "Abbrechen", durch Festlegen der <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.Windows.Forms.InputLanguageChangingEventArgs> an Ihren Ereignishandler zu übergeben `false`. Wenn das Ereignis abgebrochen wird, wird die Eingabesprache nicht geändert werden. Sie können dieses Ereignis verwenden, um zu bestimmen, ob die Änderung der angeforderten Eingabesprache für Ihre Anwendung geeignet ist.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.InputLanguageChanging> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.InputLanguageChanging> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#401](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#401)]
 [!code-vb[System.Windows.Forms.EventExamples#401](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#401)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMdiChild">
      <MemberSignature Language="C#" Value="public bool IsMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Formular ein untergeordnetes MDI (Multiple Document Interface)-Formular ist.</summary>
        <value>
          <see langword="true" />, wenn das Formular ein untergeordnetes MDI-Formular ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zur Laufzeit werden untergeordnete MDI-Formulare in den Clientbereich des übergeordneten MDI-Formulars angezeigt. Ein untergeordnetes MDI-Formular kann maximiert, minimiert werden, und innerhalb der übergeordneten MDI-Formulars verschoben. Um ein untergeordnetes MDI-Formular zu erstellen, weisen die <xref:System.Windows.Forms.Form> , werden die übergeordneten MDI-Formulars, um die <xref:System.Windows.Forms.Form.MdiParent%2A> Eigenschaft des untergeordneten Formulars. Sie können die <xref:System.Windows.Forms.Form.IsMdiContainer%2A> Eigenschaft, um zu bestimmen, ob ein Formular MDI-Formulars ist übergeordnete Formular.  
  
 Sie können die <xref:System.Windows.Forms.Form.IsMdiChild%2A> Eigenschaft, um zu bestimmen, ob ein Formular, das von einer Methode oder Eigenschaft zurückgegeben, ein untergeordnetes MDI-Formular oder ein Standardformat in Ihrer Anwendung z. B. ein Dialogfeld wird.  
  
> [!NOTE]
>  Rahmen mit veränderbarer Größe, einem Systemmenüfeld und minimieren müssen sich alle untergeordneten MDI-Formulare und **Maximieren** Schaltflächen, unabhängig von den Einstellungen von der <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.ControlBox%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, und <xref:System.Windows.Forms.Form.MaximizeBox%2A> Eigenschaften.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMdiContainer">
      <MemberSignature Language="C#" Value="public bool IsMdiContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiContainer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Formular ein Container für untergeordnete MDI (Multiple Document Interface)-Formulare ist, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Formular ein Container für untergeordnete MDI-Formulare ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ändert die Anzeige und das Verhalten des Formulars in ein übergeordnetes MDI-Formular an. Wenn diese Eigenschaft festgelegt wird, um `true`, das Formular wird ein Gesenktes Clientbereich mit einem Rahmen ausgelöst. Alle untergeordneten MDI-Formulare an das übergeordnete Formular zugewiesen werden im Clientbereich angezeigt.  
  
 Wenn ein übergeordnetes MDI-Formular geschlossen wird, die <xref:System.Windows.Forms.Form.Closing> Ereignisse von allen untergeordneten MDI-Formulare ausgelöst, bevor der übergeordnete MDI-Formular <xref:System.Windows.Forms.Form.Closing> Ereignis wird ausgelöst. Darüber hinaus die <xref:System.Windows.Forms.Form.Closed> Ereignisse von allen untergeordneten MDI-Formulare ausgelöst, bevor die <xref:System.Windows.Forms.Form.Closed> -Ereignis des übergeordneten MDI-Formulars ausgelöst wird.  
  
> [!NOTE]
>  Wenn es zwei existieren <xref:System.Windows.Forms.MenuStrip> Steuerelemente in einem untergeordneten MDI-Formulars festlegen <xref:System.Windows.Forms.Form.IsMdiContainer%2A> auf `true` für das übergeordnete Formular führt den Inhalt nur eines der der <xref:System.Windows.Forms.MenuStrip> Steuerelemente. Verwendung <xref:System.Windows.Forms.ToolStripManager.Merge%2A> zum Zusammenführen der Inhalt der zusätzliche untergeordnete <xref:System.Windows.Forms.MenuStrip> Steuerelemente auf der übergeordneten MDI-Formulars.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Windows.Forms.Form.IsMdiContainer%2A> Eigenschaft sowie das Ändern der `BackColor` Eigenschaft eines MDI-Formulars. Um dieses Beispiel auszuführen, fügen Sie folgenden Code in ein neues Formular aus.  
  
 [!code-csharp[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRestrictedWindow">
      <MemberSignature Language="C#" Value="public bool IsRestrictedWindow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRestrictedWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsRestrictedWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für das Formular alle Fenster und Benutzereingabeereignisse uneingeschränkt verwendet werden können.</summary>
        <value>
          <see langword="true" />, wenn für das Formular Einschränkungen gelten, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.IsRestrictedWindow%2A> Eigenschaft bestimmt, ob die <xref:System.Security.Permissions.UIPermissionWindow.AllWindows> Berechtigung erteilt wird. Diese Eigenschaft wird zur Laufzeit in den Konstruktor des Formulars festgelegt und für die Lebensdauer des Formulars zwischengespeichert wird. Windows Forms-Anwendung unter teilweiser Vertrauenswürdigkeit ausgeführt wird können nicht diese Prüfung umgangen werden, wie die common Language Runtime stellt sicher, dass bei teilweiser Vertrauenswürdigkeit immer der übergeordneten Konstruktor aufgerufen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPreview">
      <MemberSignature Language="C#" Value="public bool KeyPreview { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeyPreview" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.KeyPreview" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Formular Tastaturereignisse empfängt, bevor das Ereignis an das Steuerelement übergeben wird, das den Fokus besitzt, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Formular alle Tastaturereignisse empfängt. <see langword="false" />, wenn das momentan ausgewählte Steuerelement im Formular Tastaturereignisse empfängt. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft festgelegt wird, um `true`, erhält das Formular alle <xref:System.Windows.Forms.Control.KeyPress>, <xref:System.Windows.Forms.Control.KeyDown>, und <xref:System.Windows.Forms.Control.KeyUp> Ereignisse. Nach dem Ereignishandler für das Formular verarbeitet die Tastatureingabe abgeschlossen haben, wird die Tastatureingabe klicken Sie dann auf das Steuerelement mit Fokus zugewiesen. Z. B. wenn die <xref:System.Windows.Forms.Form.KeyPreview%2A> -Eigenschaftensatz auf `true` und das momentan ausgewählte Steuerelement ist ein <xref:System.Windows.Forms.TextBox>, nachdem die Tastatureingabe, durch die Ereignishandler des Formulars behandelt wird die <xref:System.Windows.Forms.TextBox> Steuerelement erhält den Schlüssel, die gedrückt wurde. Um Tastaturereignisse nur auf Formularebene zu behandeln und nicht zu, dass Steuerelemente Tastaturereignisse empfangen, legen Sie die <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> Eigenschaft in Ihrem Formulars <xref:System.Windows.Forms.Control.KeyPress> Ereignishandler `true`.  
  
 Diese Eigenschaft können Sie in Ihrer Anwendung und entweder die Tastatureingabe behandeln die meisten Tastatureingaben zu verarbeiten, oder rufen Sie das entsprechende Steuerelement aus, um die Tastatureingabe zu behandeln. Wenn eine Anwendung Funktionstasten verwendet, sollten Sie verarbeiten die Tastatureingaben auf Formularebene, statt das Schreiben von Code für jedes Steuerelement, das möglicherweise Tastatureingabe Ereignisse empfängt.  
  
> [!NOTE]
>  Wenn ein Formular keine Steuerelemente angezeigt oder aktiviert hat, erhält sie automatisch alle Tastaturereignisse.  
  
> [!NOTE]
>  Ein Steuerelement eines Formulars kann Tastatureingaben "Abbrechen", die es empfängt programmiert werden. Da das Steuerelement diese Tastatureingaben nie in das Formular sendet, das Formular nie sehen sie unabhängig von der Einstellung der <xref:System.Windows.Forms.Form.KeyPreview%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen eines Formulars <xref:System.Windows.Forms.Form.KeyPreview%2A> Eigenschaft auf "true" und die Tastaturereignisse auf Formularebene zu behandeln. Fügen Sie zum Ausführen des Beispiels den folgenden Code in ein leeres Formular ein.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutMdi">
      <MemberSignature Language="C#" Value="public void LayoutMdi (System.Windows.Forms.MdiLayout value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LayoutMdi(valuetype System.Windows.Forms.MdiLayout value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.MdiLayout" />
      </Parameters>
      <Docs>
        <param name="value">Einer der <see cref="T:System.Windows.Forms.MdiLayout" />-Werte, der das Layout der untergeordneten MDI-Formulare bestimmt.</param>
        <summary>Ordnet die untergeordneten MDI (Multiple Document Interface)-Formulare im übergeordneten MDI-Formular an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, zum Anordnen von untergeordneten MDI-Formulare in Ihrer übergeordneten MDI-Formulars, um für eine einfachere Navigation und Bearbeitung von untergeordneten MDI-Formularen zu ermöglichen. Untergeordnete MDI-Formulare können horizontal und vertikal, Überlappend oder als Symbole im übergeordneten MDI-Formulars angeordnet werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel zeigt die Ereignishandler für die Menüelemente Menü Fenster in ein MDI-Anwendung übergeordneten Formular an. Jeder Ereignishandler aufruft, um die <xref:System.Windows.Forms.Form.LayoutMdi%2A> Methode zum Anordnen von untergeordneten Formulare, die derzeit in der Anwendung geöffnet sind.  
  
 [!code-cpp[Classic Form.LayoutMdi Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.LayoutMdi Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CS/source.cs#1)]
 [!code-vb[Classic Form.LayoutMdi Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Load" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, bevor ein Formular erstmals angezeigt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können dieses Ereignis verwenden, um Aufgaben wie das Zuweisen von Ressourcen, die vom Formular verwendeten.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Load>, <xref:System.Windows.Forms.Form.Activated>, und <xref:System.Windows.Forms.Form.Activate%2A> Elemente. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular mit `Form1` mit einem <xref:System.Windows.Forms.Button> aufgerufen `Button1` und zwei <xref:System.Windows.Forms.Label> genannten Hoststeuerelemente `Label1` und `Label2`.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Drawing.Point" /> ab, der die linke obere Ecke des <see cref="T:System.Windows.Forms.Form" />-Objekts in Bildschirmkoordinaten darstellt, oder legt diesen fest.</summary>
        <value>Der <see cref="T:System.Drawing.Point" />, der die linke obere Ecke des <see cref="T:System.Windows.Forms.Form" />-Objekts in Bildschirmkoordinaten darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Point>ist eine Struktur, was bedeutet, dass es sich um einen Werttyp handelt. Wenn Sie Zugriff auf eine Eigenschaft in <xref:System.Drawing.Point>, eine Kopie der Eigenschaft zurückgegeben wird. Aus diesem Grund ändern die <xref:System.Drawing.Point.X%2A> oder <xref:System.Drawing.Point.Y%2A> Eigenschaften der <xref:System.Drawing.Point> Merry der <xref:System.Windows.Forms.Control.Location%2A> Eigenschaft wirkt sich nicht die <xref:System.Windows.Forms.Control.Left%2A>, <xref:System.Windows.Forms.Control.Right%2A>, <xref:System.Windows.Forms.Control.Top%2A>, oder <xref:System.Windows.Forms.Control.Bottom%2A> Eigenschaftswerte des der <xref:System.Windows.Forms.Form>. Um diese Eigenschaften anzupassen, legen Sie jeden Eigenschaftswert einzeln, oder legen die <xref:System.Windows.Forms.Form.Location%2A> Eigenschaft mit einem neuen <xref:System.Drawing.Point>.  
  
 Die <xref:System.Windows.Forms.Form.Location%2A> Eigenschaft ruft ab oder legt ihn fest der <xref:System.Windows.Forms.Control.Location%2A> Eigenschaft der <xref:System.Windows.Forms.Control> Basisklasse und legt die <xref:System.ComponentModel.SettingsBindableAttribute.Bindable%2A> Eigenschaft `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MainMenuStrip">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuStrip MainMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MenuStrip MainMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MainMenuStrip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den primären Menücontainer für das Formular ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.MenuStrip" />-Objekt, das den Container für die Menüstruktur des Formulars darstellt. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zusätzlich zu den <xref:System.Windows.Forms.Form.MainMenuStrip%2A> -Eigenschaft müssen <xref:System.Windows.Forms.Control.ControlCollection.Add%2A> der <xref:System.Windows.Forms.MenuStrip> die Steuerung an die <xref:System.Windows.Forms.Control.Controls%2A> -Auflistung des Formulars.  
  
 Die <xref:System.Windows.Forms.MenuStrip> Klasse hat Vorrang vor den <xref:System.Windows.Forms.MainMenu> Klasse in früheren Versionen von .NET Framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zwischenraum zwischen Steuerelementen ab oder legt ihn fest.</summary>
        <value>Ein Wert, der den Zwischenraum zwischen Steuerelementen darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MarginChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich die <see cref="P:System.Windows.Forms.Form.Margin" />-Eigenschaft ändert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximizeBox">
      <MemberSignature Language="C#" Value="public bool MaximizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaximizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizeBox" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob die **Maximieren** -Schaltfläche in der Titelleiste des Formulars angezeigt wird.</summary>
        <value>
          <see langword="true" />zum Anzeigen einer **Maximieren** Schaltfläche für das Formular, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein **Maximieren** Schaltfläche können Benutzer ein Fenster auf Vollbildgröße vergrößern. Zum Anzeigen einer **Maximieren** Schaltfläche, müssen Sie auch des Formulars festlegen <xref:System.Windows.Forms.Form.FormBorderStyle%2A> Eigenschaft `FormBorderStyle.FixedSingle`, `FormBorderStyle.Sizable`, `FormBorderStyle.Fixed3D`, oder `FormBorderStyle.FixedDialog`.  
  
 Ein **Maximieren** Schaltfläche wird automatisch ein Wiederherstellungsschaltfläche, wenn ein Fenster maximiert ist. Durch Minimieren oder Wiederherstellen eines Fensters ändert sich die Schaltfläche "Wiederherstellen" wieder zu einem **Maximieren** Schaltfläche.  
  
> [!NOTE]
>  Maximieren eines Formulars zur Laufzeit generiert eine <xref:System.Windows.Forms.Control.Resize> Ereignis. Die <xref:System.Windows.Forms.Form.WindowState%2A> Eigenschaft entspricht dem aktuellen Zustand des Fensters. Wenn Sie festlegen, der <xref:System.Windows.Forms.Form.WindowState%2A> Eigenschaft, um `FormWindowState.Maximized`, unabhängig von wirksam, alle Einstellungen für sind das Formular maximiert die <xref:System.Windows.Forms.Form.MaximizeBox%2A> und <xref:System.Windows.Forms.Form.FormBorderStyle%2A> Eigenschaften.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine neue Instanz von einem <xref:System.Windows.Forms.Form> und ruft die <xref:System.Windows.Forms.Form.ShowDialog%2A> Methode, um das Formular als Dialogfeld anzeigen. Im Beispiel wird die <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, und <xref:System.Windows.Forms.Form.StartPosition%2A> Eigenschaften, um die Darstellung und Funktionalität des Formulars in ein Dialogfeld zu ändern. Das Beispiel verwendet außerdem die <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> Methode im Format <xref:System.Windows.Forms.Control.Controls%2A> Auflistung hinzuzufügende zwei <xref:System.Windows.Forms.Button> Steuerelemente. Im Beispiel wird die <xref:System.Windows.Forms.Form.HelpButton%2A> -Eigenschaft auf eine Schaltfläche "Hilfe" in der Titelleiste des Dialogfelds angezeigt.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximizedBounds">
      <MemberSignature Language="C#" Value="protected System.Drawing.Rectangle MaximizedBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle MaximizedBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizedBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des maximierten Formulars ab oder legt diese Größe fest.</summary>
        <value>Ein <see cref="T:System.Drawing.Rectangle" />, das die Begrenzungen des Formulars darstellt, wenn dieses maximiert ist.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert, der die <see cref="P:System.Drawing.Rectangle.Top" /> -Eigenschaft ist größer als die Höhe des Formulars.  
  
 - oder -   
  
 Der Wert, der die <see cref="P:System.Drawing.Rectangle.Left" /> -Eigenschaft ist größer als die Breite des Formulars.</exception>
        <block subset="none" type="overrides">
          <para>Klassen, die von erben <see cref="T:System.Windows.Forms.Form" /> können überschreiben diese Methode, um neue Grenzen für das Formular bereitzustellen, wenn dieses maximiert ist. Die Klasse wird diese Eigenschaft intern, wenn des Formulars **Maximieren** geklickt wird.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximizedBoundsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximizedBoundsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich der Wert der <see cref="P:System.Windows.Forms.Form.MaximizedBounds" />-Eigenschaft geändert hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.MaximizedBoundsChanged> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.MaximizedBoundsChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#389](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#389)]
 [!code-vb[System.Windows.Forms.EventExamples#389](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#389)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe für die Vergrößerung des Formulars ab.</summary>
        <value>Eine <see cref="T:System.Drawing.Size" />, die die maximale Größe für das Formular darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft können Sie die Größe eines Formulars auf eine angegebene maximale Größe beschränkt. Sie können diese Funktion verwenden, wenn mehrere Fenster anzeigen, zur gleichen Zeit, stellen Sie sicher, dass ein einziges Fenster nicht mit anderen Fenstern ausgeblendet werden kann. Wenn diese Eigenschaft, um festgelegt wird eine <xref:System.Drawing.Size> -Objekt, das 0 für die Höhe und Breite des Formulars 0 ist, müssen keine Maximalgröße jenseits der Grenzen von Windows festlegen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen der <xref:System.Windows.Forms.Form.MaximumSize%2A> Eigenschaft.  
  
 [!code-cpp[System.Windows.Forms.FormExample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.FormExample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.FormExample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Werte für die Höhe oder Breite innerhalb der <see cref="T:System.Drawing.Size" /> Objekt sind kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximumSizeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich der Wert der <see cref="P:System.Windows.Forms.Form.MaximumSize" />-Eigenschaft geändert hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.MaximumSizeChanged> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.MaximumSizeChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#390](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#390)]
 [!code-vb[System.Windows.Forms.EventExamples#390](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#390)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiChildActivate">
      <MemberSignature Language="C#" Value="public event EventHandler MdiChildActivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MdiChildActivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MdiChildActivate" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein untergeordnetes MDI (Multiple Document Interface)-Formular in einer MDI-Anwendung aktiviert oder geschlossen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können mithilfe dieses Ereignisses können Sie Aufgaben wie das Aktualisieren des Inhalts des untergeordneten MDI-Formulars aus, und ändern die Menüoptionen verfügbar im übergeordneten MDI-Formulars basierend auf den Status des untergeordneten MDI-Formulars, das aktiviert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.MdiChildActivate> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.MdiChildActivate> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#397](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#397)]
 [!code-vb[System.Windows.Forms.EventExamples#397](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#397)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] MdiChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] MdiChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Array von Formularen ab, das die untergeordneten MDI (Multiple Document Interface)-Formulare darstellt, deren übergeordnetes Formular dieses Formular ist.</summary>
        <value>Ein Array von <see cref="T:System.Windows.Forms.Form" />-Objekten, von denen jedes ein untergeordnetes MDI-Formular dieses Formulars bezeichnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht Ihnen das Abrufen der Verweise auf alle dem untergeordneten MDI-Formulare derzeit in einer übergeordneten MDI-Formulars geöffnet. Um ein untergeordnetes MDI-Formular zu erstellen, weisen die <xref:System.Windows.Forms.Form> , werden die übergeordneten MDI-Formulars, um die <xref:System.Windows.Forms.Form.MdiParent%2A> Eigenschaft des untergeordneten Formulars.  
  
 Sie können diese Eigenschaft verwenden, durchläuft alle dem untergeordneten MDI-Formularen zum Vorgänge wie das Speichern von Daten in einer Datenbank beim Schließen einer übergeordneten MDI-Formulars oder zum Aktualisieren von Feldern in den untergeordneten Formularen basierend auf Aktionen, die in der Anwendung ausgeführt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Form.MdiChildren%2A> Eigenschaft, um die Liste der untergeordneten MDI-Formularen durchlaufen, und fügen eine <xref:System.Windows.Forms.Button> auf jedes Steuerelement.  
  
 [!code-cpp[Form.MDIChildren#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIChildren/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIChildren#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIChildren/CS/form1.cs#1)]
 [!code-vb[Form.MDIChildren#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIChildren/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form MdiParent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form MdiParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das aktuelle übergeordnete MDI (Multiple Document Interface)-Formular für dieses Formular ab oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Form" />-Objekt, das das übergeordnete MDI-Formular darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um ein untergeordnetes MDI-Formular zu erstellen, weisen die <xref:System.Windows.Forms.Form> , werden die übergeordneten MDI-Formulars, um die <xref:System.Windows.Forms.Form.MdiParent%2A> Eigenschaft des untergeordneten Formulars. Sie können diese Eigenschaft über ein untergeordnetes MDI-Formular verwenden, um globale Informationen abzurufen, den alle untergeordneten Formulare müssen oder zum Aufrufen von Methoden, die Aktionen an, die alle untergeordneten Formulare ausführen.  
  
> [!NOTE]
>  Wenn es zwei existieren <xref:System.Windows.Forms.MenuStrip> Steuerelemente in einem untergeordneten MDI-Formulars festlegen <xref:System.Windows.Forms.Form.IsMdiContainer%2A> auf `true` für das übergeordnete Formular führt den Inhalt nur eines der der <xref:System.Windows.Forms.MenuStrip> Steuerelemente. Verwendung <xref:System.Windows.Forms.ToolStripManager.Merge%2A> zum Zusammenführen der Inhalt der zusätzliche untergeordnete <xref:System.Windows.Forms.MenuStrip> Steuerelemente auf der übergeordneten MDI-Formulars.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen von untergeordneten Formularen in einer MDI-Anwendung. Der Beispielcode erstellt ein Formular mit eindeutigen Text an das untergeordnete Formular zu identifizieren. Im Beispiel wird die <xref:System.Windows.Forms.Form.MdiParent%2A> Eigenschaft, um anzugeben, dass ein Formular ein untergeordnetes Formular handelt. Dieses Beispiel benötigen Sie, dass der Code im Beispiel aus einem Formular aufgerufen wird, ist dessen <xref:System.Windows.Forms.Form.IsMdiContainer%2A> -Eigenschaftensatz auf `true` und das Formular eine private Klasse Ebene ganzzahlige Variable, die mit dem Namen verfügt `childCount`.  
  
 [!code-cpp[Form.MDIParent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIParent/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIParent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIParent/CS/form1.cs#1)]
 [!code-vb[Form.MDIParent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIParent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Die <see cref="T:System.Windows.Forms.Form" /> zugewiesen werden, um diese Eigenschaft ist nicht als MDI-Container gekennzeichnet.  
  
 - oder -   
  
 Die <see cref="T:System.Windows.Forms.Form" /> dieser Eigenschaft zugewiesene ist ein untergeordnetes Element und ein MDI-Container-Formular.  
  
 - oder -   
  
 Die <see cref="T:System.Windows.Forms.Form" /> zugewiesen werden, um diese Eigenschaft befindet sich in einem anderen Thread.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Anfordern eines Formulars an. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Menu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu Menu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu Menu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Menu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Windows.Forms.MainMenu" /> ab, das im Formular angezeigt wird, oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.MainMenu" />, das das im Formular anzuzeigende Menü darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft verwenden, so wechseln Sie zwischen vollständigen Menü zur Laufzeit. Beispielsweise können Sie definieren eine <xref:System.Windows.Forms.MainMenu> angezeigt, wenn das Formular Multiple Document Interface (MDI) keine aktive untergeordnete MDI-Formulare und ein anderes hat <xref:System.Windows.Forms.MainMenu> angezeigt, wenn ein untergeordnetes Fenster angezeigt wird. Sie können auch ein anderes verwenden <xref:System.Windows.Forms.MainMenu> Wenn bestimmte Bedingungen in Ihrer Anwendung, die erfordern, Anzeigen von einem anderen Menüsatz vorhanden ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Windows.Forms.MainMenu>, weist zwei <xref:System.Windows.Forms.MenuItem> -Objekte und die <xref:System.Windows.Forms.MainMenu> und bindet sie an ein Formular. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> erstellte mit der Bezeichnung `Form1`.  
  
 [!code-cpp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MainMenu.MainMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MenuComplete">
      <MemberSignature Language="C#" Value="public event EventHandler MenuComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuComplete" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Menü eines Formulars den Fokus verliert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn Sie auf ein beliebiges Menüelement im in einem Menü klicken, der das Ergebnis in einem Befehl ausgeführt wird und das Menü den Fokus verliert. Verwenden Sie dieses Ereignis, um Aufgaben wie das Aktualisieren des Textes ein <xref:System.Windows.Forms.StatusBar> Steuerelement oder aktivieren und Deaktivieren von Schaltflächen auf einem <xref:System.Windows.Forms.ToolBar>.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.MenuComplete> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.MenuComplete> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#398](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#398)]
 [!code-vb[System.Windows.Forms.EventExamples#398](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#398)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MenuStart">
      <MemberSignature Language="C#" Value="public event EventHandler MenuStart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuStart" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuStart" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Menü eines Formulars den Fokus erhält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn der Benutzer alle Menüelement im Menü geklickt wird. Sie können dieses Ereignis verwenden, zum Ausführen von Aufgaben wie das Aktivieren und Deaktivieren von Steuerelementen auf dem Formular, das vom Benutzer nicht zugegriffen werden soll, wenn die Menüs zugegriffen wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.MenuStart> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.MenuStart> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#399](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#399)]
 [!code-vb[System.Windows.Forms.EventExamples#399](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#399)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergedMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu MergedMenu { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu MergedMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MergedMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das zusammengeführte Menü für das Formular ab.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.MainMenu" />, das das zusammengeführte Menü des Formulars darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird hauptsächlich verwendet, wenn das Formular ein untergeordnetes Multiple Document Interface (MDI)-Formular ist, die die Menü mit des übergeordneten Formulars zusammengeführt. Diese Eigenschaft können Sie um die aktuelle Menüstruktur in einer MDI-Anwendung zum vornehmen von Änderungen oder Hinzufügungen zu den Menüstruktur zu erhalten. Zum Abrufen von nicht zusammengeführten <xref:System.Windows.Forms.MainMenu> ein Formular zugewiesen, verwenden Sie die <xref:System.Windows.Forms.Form.Menu%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimizeBox">
      <MemberSignature Language="C#" Value="public bool MinimizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MinimizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimizeBox" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob die **Minimieren** -Schaltfläche in der Titelleiste des Formulars angezeigt wird.</summary>
        <value>
          <see langword="true" />zum Anzeigen einer **Minimieren** Schaltfläche für das Formular, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein **Minimieren** Schaltfläche ermöglicht Benutzern, um ein Fenster auf Symbolgröße zu minimieren. Zum Anzeigen einer **Minimieren** Schaltfläche, müssen Sie auch des Formulars festlegen <xref:System.Windows.Forms.Form.FormBorderStyle%2A> Eigenschaft `FormBorderStyle.FixedSingle`, `FormBorderStyle.Sizable`, `FormBorderStyle.Fixed3D`, oder `FormBorderStyle.FixedDialog`.  
  
> [!NOTE]
>  Generiert ein Formular minimiert, zur Laufzeit eine <xref:System.Windows.Forms.Control.Resize> Ereignis. Die <xref:System.Windows.Forms.Form.WindowState%2A> Eigenschaft entspricht dem aktuellen Zustand des Fensters. Wenn Sie festlegen, die <xref:System.Windows.Forms.Form.WindowState%2A> Eigenschaft `FormWindowState.Minimized`, das Formular wird minimiert, unabhängig von die Einstellungen für in Kraft sind die <xref:System.Windows.Forms.Form.MinimizeBox%2A> und <xref:System.Windows.Forms.Form.FormBorderStyle%2A> Eigenschaften.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine neue Instanz von einem <xref:System.Windows.Forms.Form> und ruft die <xref:System.Windows.Forms.Form.ShowDialog%2A> Methode, um das Formular als Dialogfeld anzeigen. Im Beispiel wird die <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, und <xref:System.Windows.Forms.Form.StartPosition%2A> Eigenschaften, um die Darstellung und Funktionalität des Formulars in ein Dialogfeld zu ändern. Das Beispiel verwendet außerdem die <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> Methode im Format <xref:System.Windows.Forms.Control.Controls%2A> Auflistung hinzuzufügende zwei <xref:System.Windows.Forms.Button> Steuerelemente. Im Beispiel wird die <xref:System.Windows.Forms.Form.HelpButton%2A> -Eigenschaft auf eine Schaltfläche "Hilfe" in der Titelleiste des Dialogfelds angezeigt.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Mindestgröße des Formulars ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Drawing.Size" />, die die minimale Größe für das Formular darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft können Sie die Größe eines Formulars auf eine bestimmte minimale Größe beschränkt. Sie können diese Funktion verwenden, um zu verhindern, dass einen Benutzer ein Fenster an unerwünschten Größe anpassen. Wenn diese Eigenschaft, um festgelegt wird eine <xref:System.Drawing.Size> -Objekt, das 0 für die Höhe und Breite des Formulars 0 ist, müssen keine Mindestgröße jenseits der Grenzen von Windows festlegen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Werte für die Höhe oder Breite innerhalb der <see cref="T:System.Drawing.Size" /> Objekt sind kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="MinimumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MinimumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MinimumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MinimumSizeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich der Wert der <see cref="P:System.Windows.Forms.Form.MinimumSize" />-Eigenschaft geändert hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.MinimumSizeChanged> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.MinimumSizeChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#391](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#391)]
 [!code-vb[System.Windows.Forms.EventExamples#391](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#391)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Modal">
      <MemberSignature Language="C#" Value="public bool Modal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Modal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Modal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses Formular modal angezeigt wird.</summary>
        <value>
          <see langword="true" />, wenn das Formular modal angezeigt wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Formular modal angezeigt wird, kann keine Eingabe (Tastatur- oder Maustastenzustand klicken) außer auf Objekte auf dem Formular modal auftreten. Das Programm muss ausblenden oder schließen ein modales Formular (normalerweise als Reaktion auf eine Benutzeraktion) vor der Eingabe in ein anderes Format auftreten kann. Formen, mit die modal angezeigt werden, werden in der Regel als Dialogfelder in einer Anwendung verwendet.  
  
 Sie können diese Eigenschaft verwenden, um zu bestimmen, ob ein Formular, das Sie von einer Methode oder Eigenschaft erhalten modal angezeigt wurde.  
  
 Um anzuzeigen, ein Formular modal verwenden die <xref:System.Windows.Forms.Form.ShowDialog%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Form.Modal%2A> Eigenschaft, um zu bestimmen, ob ein Formular als modales Formular angezeigt wird. Ist dies nicht der <xref:System.Windows.Forms.Form.FormBorderStyle%2A> und <xref:System.Windows.Forms.Form.TopLevel%2A> Eigenschaften werden geändert, um das Formular ein Formular auf der obersten Ebene mit einem Toolfensterrahmen ist.  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.Activated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnActivated%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Überschreiben diese Methode ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Eine Instanz von <see cref="T:System.EventArgs" />, die die Daten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnBackgroundImageChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.Closed" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Die <xref:System.Windows.Forms.Form.OnClosed%2A> Methode ist veraltet in .NET Framework, Version 2.0; verwenden Sie die <xref:System.Windows.Forms.Form.OnFormClosed%2A> Methode stattdessen.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnFormClosed%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Überschreiben diese Methode ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
> [!CAUTION]
>  Die <xref:System.Windows.Forms.Form.OnClosed%2A> und <xref:System.Windows.Forms.Form.OnClosing%2A> Methoden werden nicht aufgerufen, wenn die <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> Methode wird aufgerufen, um die Anwendung zu beenden. Wenn Sie Validierungscode in einer dieser Methoden, die ausgeführt werden müssen verfügen, sollten Sie Aufrufen der <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> Methode für jedes Formular einzeln vor dem Aufruf der <xref:System.Windows.Forms.Application.Exit%2A> Methode.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Überschreiben der <xref:System.Windows.Forms.Form.OnClosed%2A> Methode in einer Klasse abgeleitet <xref:System.Windows.Forms.Form> .  
  
 [!code-cpp[System.Drawing.PointsAndSizes#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.PointsAndSizes#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CS/form1.cs#6)]
 [!code-vb[System.Drawing.PointsAndSizes#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.ComponentModel.CancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.Closing" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Die <xref:System.Windows.Forms.Form.OnClosing%2A> Methode ist veraltet in .NET Framework, Version 2.0; verwenden Sie die <xref:System.Windows.Forms.Form.OnFormClosing%2A> Methode stattdessen.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnClosing%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Überschreiben diese Methode ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
> [!CAUTION]
>  Die <xref:System.Windows.Forms.Form.OnClosed%2A> und <xref:System.Windows.Forms.Form.OnClosing%2A> Methoden werden nicht aufgerufen, wenn die <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> Methode wird aufgerufen, um die Anwendung zu beenden. Wenn Sie Validierungscode in einer dieser Methoden, die ausgeführt werden müssen verfügen, sollten Sie Aufrufen der <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> Methode für jedes Formular einzeln vor dem Aufruf der <xref:System.Windows.Forms.Application.Exit%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit <xref:System.Windows.Forms.Form.Closing> getestet, ob der Text in einem <xref:System.Windows.Forms.TextBox> hat sich geändert. Wenn bestehen, wird der Benutzer an, ob die Änderungen in einer Datei Speichern aufgefordert.  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected override void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnCreateControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst das <see langword="CreateControl" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.Forms.Form.OnCreateControl" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Windows.Forms.Form.OnCreateControl" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivate">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.Deactivate" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnDeactivate%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.Forms.DpiChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(class System.Windows.Forms.DpiChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDpiChanged(System.Windows.Forms.DpiChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DpiChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.DpiChanged" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected override void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnabledChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.EnabledChanged" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected override void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Enter" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnEnter%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFontChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.FontChanged" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFormClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosed (System.Windows.Forms.FormClosedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosed(class System.Windows.Forms.FormClosedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.FormClosedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.FormClosed" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.OnFormClosing%2A> Methode entfernt das aktuelle Formular aus dem <xref:System.Windows.Forms.Application.OpenForms%2A> Auflistung der zugeordneten <xref:System.Windows.Forms.Application>.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnFormClosed%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Überschreiben diese Methode ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnFormClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosing (System.Windows.Forms.FormClosingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosing(class System.Windows.Forms.FormClosingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.FormClosingEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.FormClosing" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnFormClosing%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnGetDpiScaledSize">
      <MemberSignature Language="C#" Value="protected virtual bool OnGetDpiScaledSize (int deviceDpiOld, int deviceDpiNew, ref System.Drawing.Size desiredSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnGetDpiScaledSize(int32 deviceDpiOld, int32 deviceDpiNew, valuetype System.Drawing.Size&amp; desiredSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnGetDpiScaledSize(System.Int32,System.Int32,System.Drawing.Size@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" />
        <Parameter Name="desiredSize" Type="System.Drawing.Size&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">Der DPI-Wert für das Anzeigegerät, auf dem das Formular zuvor angezeigt wurde.</param>
        <param name="deviceDpiNew">Der DPI-Wert für das Anzeigegerät, auf dem das Formular angezeigt wird.</param>
        <param name="desiredSize">Eine <see cref="T:System.Drawing.Size" />, die die neue Größe des Formulars basierend auf dem neuen DPI-Wert darstellt.</param>
        <summary>Löst das GetDpiScaledSize-Ereignis aus.</summary>
        <returns>
          <see langword="true" />, wenn erfolgreich, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleCreated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.HandleCreated" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleDestroyed(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.HandleDestroyed" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHelpButtonClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpButtonClicked (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpButtonClicked(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.ComponentModel.CancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.HelpButtonClicked" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnHelpButtonClicked%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanged (System.Windows.Forms.InputLanguageChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanged(class System.Windows.Forms.InputLanguageChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Forms.InputLanguageChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.InputLanguageChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnInputLanguageChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanging (System.Windows.Forms.InputLanguageChangingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanging(class System.Windows.Forms.InputLanguageChangingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Forms.InputLanguageChangingEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.InputLanguageChanging" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnInputLanguageChanging%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected override void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">Die Ereignisdaten.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Layout" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.Load" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnLoad%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximizedBoundsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximizedBoundsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnMaximizedBoundsChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMaximumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.MaximumSizeChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnMaximumSizeChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMdiChildActivate">
      <MemberSignature Language="C#" Value="protected virtual void OnMdiChildActivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMdiChildActivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.MdiChildActivate" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnMdiChildActivate%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMenuComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.MenuComplete" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnMenuComplete%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMenuStart">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuStart (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuStart(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.MenuStart" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnMenuStart%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMinimumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMinimumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMinimumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.MinimumSizeChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnMinimumSizeChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected override void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.PaintEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Paint" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected override void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResize(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Resize" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResizeBegin">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeBegin (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeBegin(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.ResizeBegin" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.ResizeBegin> Ereignis wird nur ausgelöst, wenn des Formulars <xref:System.Windows.Forms.Control.CanRaiseEvents%2A> -Eigenschaftensatz auf `true`.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnResizeBegin%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnResizeEnd">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeEnd (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeEnd(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.ResizeEnd" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.ResizeEnd> Ereignis wird nur ausgelöst, wenn des Formulars <xref:System.Windows.Forms.Control.CanRaiseEvents%2A> -Eigenschaftensatz auf `true`.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnResizeEnd%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das aktuelle Formular oder eines seiner übergeordneten Ressourcen freigegeben ist die <xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A> Methode kehrt zurück, ohne eine Aktion ausgeführt. Wenn die <xref:System.Windows.Forms.Control.RightToLeft%2A> -Eigenschaft des Formulars hat den Wert <xref:System.Windows.Forms.RightToLeft.Yes>, und klicken Sie dann die Ziehpunkte des Formulars und seiner untergeordneten Steuerelemente durch Aufrufen von neu erstellt werden die <xref:System.Windows.Forms.Control.RecreateHandle%2A> Methode.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnShown">
      <MemberSignature Language="C#" Value="protected virtual void OnShown (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShown(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Form.Shown" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.Shown> Ereignis tritt auf, wenn das Formular erstmalig angezeigt wird.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnShown%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected override void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnStyleChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.StyleChanged" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected override void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnTextChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.TextChanged" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected override void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.VisibleChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Form.OnVisibleChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Opacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.OpacityConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Durchlässigkeit des Formulars ab oder legt diese fest.</summary>
        <value>Die Durchlässigkeit des Formulars. Der Standard ist 1,00.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.Opacity%2A> Eigenschaft können Sie den Grad der Transparenz für das Formular und seine Steuerelemente angeben. Wenn diese Eigenschaft auf einen Wert kleiner als 100 Prozent (1.00) festgelegt ist, wird das gesamte Formular, Rahmen, einschließlich transparenter vorgenommen. Wenn diese Eigenschaft auf einen Wert von 0 Prozent (0.00) wird das Formular vollständig unsichtbar. Sie können diese Eigenschaft verwenden, um verschiedene Ebenen der Transparenz bereitzustellen oder um Geben Sie beispielsweise einen Effekte wie einstellt eines Formulars in oder aus der Sicht. Sie können z. B. ein Formular in den Anzeigebereich phase, durch Festlegen der <xref:System.Windows.Forms.Form.Opacity%2A> Eigenschaft auf einen Wert von 0 Prozent (0.00) und den Wert schrittweise erhöhen, bis 100 Prozent (1.00) erreicht.  
  
 <xref:System.Windows.Forms.Form.Opacity%2A>unterscheidet sich von der gebotenen Transparenz der <xref:System.Windows.Forms.Form.TransparencyKey%2A>, die nur ein Formular und seine Steuerelemente vollständig transparent. Wenn sie die gleiche Farbe wie der Wert im angegebenen sind die <xref:System.Windows.Forms.Form.TransparencyKey%2A> Eigenschaft.  
  
 Diese Eigenschaft wird nicht unterstützt, wenn <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> ist `true`.  
  
 Die <xref:System.Windows.Forms.Form.Opacity%2A> Eigenschaft hängt von der in den Ebenen Windows-API, die eingeführt wurde mit Windows 2000. Weitere Informationen finden Sie unter "In den Ebenen Windows: A New Möglichkeit zum Verwenden Lichtdurchlässigkeit und Transparenz Effekte in Windows Applications" in der Platform SDK-Dokumentation unter [http://msdn.microsoft.com](http://msdn.microsoft.com/).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen eines Formulars, das angezeigt wird, mit einer Durchlässigkeit von 75 Prozent. Das Codebeispiel erstellt ein neues Formular, das sich in der Mitte des Bildschirms mit einer <xref:System.Windows.Forms.Form.Opacity%2A> Eigenschaft festgelegt wird, um die Durchlässigkeit des Formulars zu ändern. Das Codebeispiel setzt auch die <xref:System.Windows.Forms.Form.Size%2A> Eigenschaft ermöglichen einen größeren Größe, Form als die Standardgröße des Formulars. Dieses Codebeispiel wurde unter der Annahme geschrieben, dass die in diesem Beispiel definierte Methode aus einem anderen Formular in einem Ereignishandler oder eine andere Methode aufgerufen wird.  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnedForms">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] OwnedForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] OwnedForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.OwnedForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Array von <see cref="T:System.Windows.Forms.Form" />-Objekten ab, die alle Formulare darstellen, die dieses Formular besitzt.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Form" />-Array, das die Formulare darstellt, die dieses Formular besitzt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt ein Array, das alle Formulare enthält, die dieses Formular besitzt. Um ein Formular, das im Besitz einer anderen Form zu machen, rufen Sie die <xref:System.Windows.Forms.Form.AddOwnedForm%2A> Methode. Das Formular auf das Besitzerformular zugewiesen bleibt im Besitz befindlichen, bis die <xref:System.Windows.Forms.Form.RemoveOwnedForm%2A> -Methode aufgerufen wird. Sie können auch ein Formular, das im Besitz von einem anderen festlegen, die <xref:System.Windows.Forms.Form.Owner%2A> Eigenschaft mit einem Verweis auf das Besitzerformular.  
  
 Wenn eine andere Form ein Formulars Besitz befindet, ist es geschlossen oder ausgeblendet werden, zusammen mit dem Besitzerformular. Betrachten Sie beispielsweise ein Formular mit dem Namen `Form2` , deren Besitzer ein Formular mit dem Namen `Form1`. Wenn `Form1` geschlossen oder minimiert, `Form2` auch geschlossen oder ausgeblendet wird. Formulare werden ebenfalls nicht hinter dem Besitzerformular angezeigt. Sie können verwendet Formulare für Windows, z. B. Suchen und Ersetzen von Fenstern, bei denen hinter dem Besitzerformular nicht angezeigt werden soll, wenn das Besitzerformular ausgewählt ist.  
  
> [!NOTE]
>  Wenn das Formular ein Multiple Document Interface (MDI) übergeordnetes Formular ist, wird diese Eigenschaft zurück, dass alle Formulare, die mit Ausnahme von untergeordneten MDI-Formulare angezeigt werden, die derzeit geöffnet. Verwenden Sie zum Abrufen der untergeordnete MDI-Formulare in einem übergeordneten MDI-Formulars geöffnet die <xref:System.Windows.Forms.Form.MdiChildren%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Form.OwnedForms%2A> so ändern Sie alle Formulare, die Besitzer der Eigenschaft. Die erste Methode im Beispiel fügt zum Array der Formulare der Besitzer ein Formular zugeordnet. Die zweite Methode durchläuft alle Formulare und ändert die Beschriftung. Dieses Beispiel erfordert, dass beide Methoden, indem Sie ein Ereignis oder eine andere Methode eines Formulars aufgerufen werden.  
  
 [!code-cpp[Form.OwnedForms#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.OwnedForms/CPP/form1.cpp#1)]
 [!code-csharp[Form.OwnedForms#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.OwnedForms/CS/form1.cs#1)]
 [!code-vb[Form.OwnedForms#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.OwnedForms/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Formular ab, das Besitzer dieses Formulars ist, oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Form" />-Objekt, das das Formular darstellt, das Besitzer dieses Formulars ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um ein Formular, das im Besitz einer anderen Form zu machen, weisen die <xref:System.Windows.Forms.Form.Owner%2A> Eigenschaft einen Verweis auf das Formular, das den Besitzer.  
  
 Wenn eine andere Form ein Formulars Besitz befindet, ist es geschlossen oder ausgeblendet werden, zusammen mit dem Besitzerformular. Betrachten Sie beispielsweise ein Formular mit dem Namen `Form2` , deren Besitzer ein Formular mit dem Namen `Form1`. Wenn `Form1` geschlossen oder minimiert, `Form2` auch geschlossen oder ausgeblendet wird. Formulare werden ebenfalls nicht hinter dem Besitzerformular angezeigt. Sie können verwendet Formulare für Windows, z. B. Suchen und Ersetzen von Fenstern, bei denen nicht verschwinden sollte, wenn das Besitzerformular ausgewählt ist. Verwenden Sie zum Bestimmen der Formulare, die ein übergeordnetes Formular gehören, die <xref:System.Windows.Forms.Form.OwnedForms%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Ein Fenster der obersten Ebene sind keine Besitzer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">Eine als Verweis übergebene <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Win32-Meldung darstellt.</param>
        <param name="keyData">Einer der <see cref="T:System.Windows.Forms.Keys" />-Werte, die die zu verarbeitende Taste darstellen.</param>
        <summary>Verarbeitet eine Befehlstaste.</summary>
        <returns>
          <see langword="true" />, wenn der Tastaturanschlag verarbeitet und auf das Steuerelement angewendet wurde, andernfalls <see langword="false" />, um eine weitere Verarbeitung zu ermöglichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.ProcessCmdKey%2A> Methode überschreibt die  
  
 <xref:System.Windows.Forms.ContainerControl.ProcessCmdKey%2A?displayProperty=nameWithType>Implementierung, die zusätzliche Verarbeitung von Hauptmenü Befehl Schlüssel und MDI-Zugriffstasten bereitstellen.  
  
 Informationen zum Auffangen von Tastatureingaben finden Sie unter "Vorgehensweise beim Tastatureingaben in Steuerelementen mithilfe von Visual C#-trap" und "Vorgehensweise zum Abfangen der Tastatureingaben in .NET Steuerelementen mithilfe von Visual Basic .NET" in der Microsoft Knowledge Base unter http://support.microsoft.com.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogChar(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Das zu verarbeitende Zeichen.</param>
        <summary>Verarbeitet ein Dialogfeldzeichen.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Einer der <see cref="T:System.Windows.Forms.Keys" />-Werte, die die zu verarbeitende Taste darstellen.</param>
        <summary>Verarbeitet eine Tastatureingabe im Dialogfeld.</summary>
        <returns>
          <see langword="true" />, wenn der Tastaturanschlag verarbeitet und auf das Steuerelement angewendet wurde, andernfalls <see langword="false" />, um eine weitere Verarbeitung zu ermöglichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.ProcessDialogKey%2A> Methode überschreibt die <xref:System.Windows.Forms.ContainerControl.ProcessDialogKey%2A?displayProperty=nameWithType> Implementierung zusätzliche Behandlung der Schlüssel zurückgeben und das ESCAPEZEICHEN in Dialogfeldern bereitstellen. Die Methode führt keine Verarbeitung von Tastatureingaben, die die ALT-Taste oder die CONTROL-Modifizierer enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected override bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Eine als Verweis übergebene <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Fenstermeldung darstellt.</param>
        <summary>Zeigt eine Tastaturmeldung in der Vorschau an.</summary>
        <returns>
          <see langword="true" />, wenn die Meldung vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected override bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessMnemonic(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Das zu verarbeitende Zeichen.</param>
        <summary>Verarbeitet ein mnemonisches Zeichen.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen als mnemonisches Zeichen vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessTabKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessTabKey (bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessTabKey(bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessTabKey(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forward">
          <see langword="true" />um die Steuerelemente in der ContainerControl vorwärts zu durchlaufen; andernfalls <see langword="false" />.</param>
        <summary>Wählt das nächste verfügbare Steuerelement aus, das zum aktiven Steuerelement wird.</summary>
        <returns>
          <see langword="true" />Wenn ein Steuerelement ausgewählt ist. andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveOwnedForm">
      <MemberSignature Language="C#" Value="public void RemoveOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm">Ein <see cref="T:System.Windows.Forms.Form" />-Objekt, das das aus der Liste von Formularen mit diesem Besitzerformular zu entfernende Formular darstellt.</param>
        <summary>Entfernt ein Formular aus dem Besitzerformular.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Formular auf das Besitzerformular zugewiesen bleibt bis zum Besitzer der <xref:System.Windows.Forms.Form.RemoveOwnedForm%2A> -Methode aufgerufen wird. Zusätzlich zum Entfernen der Besitzer ein Formulars aus der Liste der Besitzer ein Formular, legt diese Methode auch das Besitzerformular zu `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResizeBegin">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeBegin;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeBegin" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeBegin" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Formular in den Größenänderungsmodus wechselt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.ResizeBegin> Ereignis wird ausgelöst, wenn der Benutzer beginnt, um die Größe von einem Formular in der Regel durch Klicken und Ziehen der Rahmen oder dem Größenziehpunkt befindet sich auf der unteren rechten Ecke des Formulars. Diese Aktion setzt das Formular in eine modale Größenanpassungsschleife, bis das Resize-Vorgang abgeschlossen ist. In der Regel tritt der folgende Satz von Ereignissen während eines Vorgangs zum Ändern der Größe:  
  
1.  Ein einzelnes <xref:System.Windows.Forms.Form.ResizeBegin> Ereignis tritt auf, wenn das Formular den Größenänderungsmodus wechselt.  
  
2.  0 (null) oder mehr Nummernpaare <xref:System.Windows.Forms.Control.Resize> und <xref:System.Windows.Forms.Control.SizeChanged> Ereignisse auftreten, weil der Formulars <xref:System.Windows.Forms.Form.Size%2A> geändert wird.  
  
3.  Ein einzelnes <xref:System.Windows.Forms.Form.ResizeEnd> Ereignis tritt auf, wenn das Formular den Größenänderungsmodus verlässt.  
  
> [!NOTE]
>  Nur klicken, ohne auf einen Rahmen ziehen oder Größenziehpunkt generiert die <xref:System.Windows.Forms.Form.ResizeBegin> und <xref:System.Windows.Forms.Form.ResizeEnd> Ereignisse ohne alle Zwischendateien <xref:System.Windows.Forms.Control.Resize> und <xref:System.Windows.Forms.Control.SizeChanged> Ereignis-Paaren.  
  
 Die <xref:System.Windows.Forms.Form.ResizeBegin> und <xref:System.Windows.Forms.Form.ResizeEnd> Ereignispaar wird auch ausgelöst, wenn der Benutzer das Formular in der Regel bewegt durch Klicken und ziehen auf der Titelleiste. Diese Ereignisse werden nicht generiert durch programmgesteuerte Bearbeitung des Formulars, z. B. durch Ändern der <xref:System.Windows.Forms.Form.Size%2A> oder <xref:System.Windows.Forms.Control.Location%2A> Eigenschaften.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.ResizeBegin> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.ResizeBegin> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#404](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#404)]
 [!code-vb[System.Windows.Forms.EventExamples#404](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#404)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResizeEnd">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeEnd" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Formular den Größenänderungsmodus verlässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.ResizeEnd> Ereignis wird ausgelöst, wenn der Benutzer die Größe eines Formulars, in der Regel durch Ziehen der Rahmen oder dem Größenziehpunkt befindet sich auf der unteren rechten Ecke des Formulars und dann losgelassen wird beendet. Weitere Informationen über die Größenänderung im Vorgang finden Sie unter der <xref:System.Windows.Forms.Form.ResizeBegin> Ereignis.  
  
 Die <xref:System.Windows.Forms.Form.ResizeEnd> Ereignis wird auch generiert, nachdem der Benutzer durch Klicken und ziehen auf der Titelleiste in der Regel eine Form bewegt. Dieses Ereignis wird nicht generiert durch programmgesteuerte Bearbeitung des Formulars, z. B. durch Ändern der <xref:System.Windows.Forms.Form.Size%2A> oder <xref:System.Windows.Forms.Control.Location%2A> Eigenschaften.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.ResizeEnd> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.ResizeEnd> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#405](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#405)]
 [!code-vb[System.Windows.Forms.EventExamples#405](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#405)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position und die Größe des Formulars im normalen Fensterzustand ab.</summary>
        <value>Ein <see cref="T:System.Drawing.Rectangle" />, das die Position und die Größe des Formulars im normalen Fensterzustand enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalerweise verwenden Sie die <xref:System.Windows.Forms.Form.RestoreBounds%2A> Eigenschaft zum Nachverfolgen von Fenstergröße des Benutzers, und positionieren Sie die Einstellungen für das Formular im normalen Fensterzustand. Sollten Sie sowohl den Wert der verfolgen die <xref:System.Windows.Forms.Form.WindowState%2A> und <xref:System.Windows.Forms.Form.RestoreBounds%2A> Eigenschaften nachzuverfolgen und die Einstellungen des Benutzers Fenster.  
  
> [!NOTE]
>  Der Wert des der <xref:System.Windows.Forms.Form.RestoreBounds%2A> Eigenschaft ist nur gültig, wenn die <xref:System.Windows.Forms.Form.WindowState%2A> Eigenschaft von der <xref:System.Windows.Forms.Form> Klasse ist nicht gleich <xref:System.Windows.Forms.FormWindowState.Normal>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayout">
      <MemberSignature Language="C#" Value="public virtual bool RightToLeftLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeftLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RightToLeftLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob die Anordnung der Spiegelung von rechts nach links aktiviert ist.</summary>
        <value>
          <see langword="true" />, wenn die Anordnung der Spiegelung von rechts nach links aktiviert ist, andernfalls <see langword="false" /> für die Standardanordnung von untergeordneten Steuerelementen. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> Eigenschaft eignet sich hauptsächlich für die Entwicklung weltweit einsatzfähiger Formularen für Zielgruppen. Viele Formen sind so konzipiert, dass Steuerelemente in einem Formular in einer Weise von links nach rechts angeordnet werden. Diese Formen sind kompatibel mit den Sprachen, die diese Richtung schreiben folgen. Wenn Sie die gleichen Formulare für Benutzer der rechts-nach-links-Sprachen angezeigt, ist es jedoch oft vorzuziehen, um die Reihenfolge der Steuerelemente im Formular umzukehren. Wenn beide die <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> und <xref:System.Windows.Forms.Control.RightToLeft%2A> Eigenschaften sind `true`Spiegelung wird aktiviert, für das Formular und Positionierung von Steuerelementen und Textfluss werden rechts-nach-links.  
  
 Im Gegensatz zu <xref:System.Windows.Forms.Control.RightToLeft%2A>, <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> erbt nicht. Wenn der Wert für die untergeordneten Steuerelemente wirksam werden soll, müssen Sie es für jedes untergeordnete Steuerelement festlegen, die gespiegelt werden soll.  
  
 Ownerdrawing wird nicht unterstützt, wenn <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> festgelegt ist, um `Yes`. Besitzer Draw-Ereignisse werden nach wie vor erfolgen, aber das Verhalten sämtlicher Code, den Sie in diese Ereignisse erstellen, ist nicht definiert. Darüber hinaus <xref:System.Windows.Forms.Control.BackgroundImage%2A>, <xref:System.Windows.Forms.Form.Opacity%2A>, <xref:System.Windows.Forms.Form.TransparencyKey%2A>, und die zeichnen-Ereignisse werden nicht unterstützt.  
  
 Die <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> und <xref:System.Windows.Forms.Control.RightToLeft%2A> Eigenschaften dazu führen, dass die folgenden Win32-API-Fensterstile festgelegt werden:  
  
-   Wenn <xref:System.Windows.Forms.Control.RightToLeft%2A> auf festgelegt ist `Yes` und <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> auf festgelegt ist `true`, legt Windows Forms die `WS_EX_LAYOUTRTL` Fensterstil und entfernt die `WS_EX_RIGHT` und `WS_EX_RTLREADING` Stile.  
  
-   Wenn <xref:System.Windows.Forms.Control.RightToLeft%2A> festgelegt ist, um `Yes` jedoch <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> auf festgelegt ist `No`, Windows Forms festgelegt die `WS_EX_RIGHT` und `WS_EX_RTLREADING` Fensterstile.  
  
 Ändern des Werts dieser Eigenschaft löst die <xref:System.Windows.Forms.Form.RightToLeftLayoutChanged> Ereignis.  
  
 Weitere Informationen zu Globalisierungsproblemen finden Sie unter [bewährte Methoden für die Entwicklung weltweit einsatzfähiger Anwendungen](~/docs/standard/globalization-localization/best-practices-for-developing-world-ready-apps.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem sich der Wert der <see cref="P:System.Windows.Forms.Form.RightToLeftLayout" />-Eigenschaft geändert hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.RightToLeft%2A> und <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> Eigenschaften werden in der Regel bei der Entwicklung weltweit einsatzfähiger Anwendungen verwendet.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.RightToLeftLayoutChanged> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.RightToLeftLayoutChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#402](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#402)]
 [!code-vb[System.Windows.Forms.EventExamples#402](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#402)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected override void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="factor">Der Faktor, um den die Höhe und die Breite des Steuerelements skaliert werden.</param>
        <param name="specified">Ein <see cref="T:System.Windows.Forms.BoundsSpecified" />-Wert, der die Begrenzungen des Steuerelements angibt und bei der Definition von Größe und Position verwendet wird.</param>
        <summary>Skaliert Speicherort, Größe, Textabstand und Rand eines Steuerelements.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected override void ScaleCore (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleCore(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleCore(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Der Prozentsatz für die horizontale Skalierung des Formulars.</param>
        <param name="y">Der Prozentsatz für die vertikale Skalierung des Formulars.</param>
        <summary>Führt die Skalierung des Formulars aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected override void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Select(System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">Gibt an, dass das aktive Steuerelement geändert wird, wenn true festgelegt ist.</param>
        <param name="forward">Wenn „directed“ true ist, wird hiermit die Richtung gesteuert, in die der Fokus verschoben wird. Durch Festlegen auf <see langword="true" /> wird das nächste Steuerelement ausgewählt. Andernfalls wird das vorherige Steuerelement ausgewählt.</param>
        <summary>Aktiviert dieses Formular und wählt optional das nächste oder vorherige Steuerelement aus.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern des Fokus. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected override void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Der neue <see cref="P:System.Windows.Forms.Control.Left" />-Eigenschaftswert des Steuerelements.</param>
        <param name="y">Der neue <see cref="P:System.Windows.Forms.Control.Top" />-Eigenschaftswert des Steuerelements.</param>
        <param name="width">Der neue <see cref="P:System.Windows.Forms.Control.Width" />-Eigenschaftswert des Steuerelements.</param>
        <param name="height">Der neue <see cref="P:System.Windows.Forms.Control.Height" />-Eigenschaftswert des Steuerelements.</param>
        <param name="specified">Eine bitweise Kombination der <see cref="T:System.Windows.Forms.BoundsSpecified" />-Werte.</param>
        <summary>Legt die angegebenen Begrenzungen dieses Steuerelements fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected override void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die angeforderte Breite des Clientbereichs.</param>
        <param name="y">Die angeforderte Höhe des Clientbereichs.</param>
        <summary>Legt die Clientgröße des Formulars fest. Hiermit werden die Begrenzungen des Formulars so angepasst, dass die Clientgröße der angeforderten Größe entspricht.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDesktopBounds">
      <MemberSignature Language="C#" Value="public void SetDesktopBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate der Formularposition.</param>
        <param name="y">Die y-Koordinate der Formularposition.</param>
        <param name="width">Die Breite des Formulars.</param>
        <param name="height">Die Höhe des Formulars.</param>
        <summary>Legt die Begrenzungen des Formulars in Desktopkoordinaten fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Desktopkoordinaten basieren auf den Arbeitsbereich des Bildschirms, die die Taskleiste ausgeschlossen sind. Sie können diese Methode verwenden, die Position und Größe des Formulars auf dem Desktop festlegen. Da Desktopkoordinaten auf den Arbeitsbereich des Formulars basieren, können Sie diese Methode verwenden, um sicherzustellen, dass das Formular vollständig auf dem Desktop sichtbar ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Windows.Forms.Form.SetDesktopBounds%2A> Methode. Um dieses Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular, das eine Schaltfläche mit dem Namen enthält `Button2`. Stellen Sie sicher, dass alle Ereignisse den Ereignishandler zugeordnet sind.  
  
 [!code-cpp[System.Windows.Forms.FormExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.FormExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.FormExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDesktopLocation">
      <MemberSignature Language="C#" Value="public void SetDesktopLocation (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopLocation(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopLocation(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate der Formularposition.</param>
        <param name="y">Die y-Koordinate der Formularposition.</param>
        <summary>Legt die Position des Formulars in Desktopkoordinaten fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Desktopkoordinaten basieren auf den Arbeitsbereich des Bildschirms, die die Taskleiste ausgeschlossen sind. Sie können diese Methode verwenden, um das Formular zu positionieren, auf dem Desktop. Da Desktopkoordinaten auf den Arbeitsbereich des Formulars basieren, können Sie diese Methode verwenden, um sicherzustellen, dass das Formular vollständig auf dem Desktop sichtbar ist. Diese Methode dient in erster Linie für Formulare der obersten Ebene verwendet werden soll; Verwenden Sie die <xref:System.Windows.Forms.Form.LayoutMdi%2A> Methode, um die Multiple Document Interface (MDI) untergeordnete Formulare positionieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Load> und <xref:System.Windows.Forms.Form.Activate%2A> Elemente. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular namens `Form1` aufgerufen, die eine Schaltfläche enthält `Button1` und zwei `Label` genannten Hoststeuerelemente `Label1` und `Label2`.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected override void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetVisibleCore(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          <see langword="true" />, um das Steuerelement sichtbar zu machen, andernfalls <see langword="false" />.</param>
        <summary>Legt das Steuerelement auf den angegebenen sichtbaren Zustand fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Show(System.Windows.Forms.IWin32Window)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" />
      </Parameters>
      <Docs>
        <param name="owner">Ein Objekt, das <see cref="T:System.Windows.Forms.IWin32Window" /> implementiert und das Fenster der obersten Ebene darstellt, das dieses Formular besitzt.</param>
        <summary>Zeigt dem Benutzer das Formular mit dem angegebenen Besitzer an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, ein nicht modales Formular angezeigt. Bei Verwendung dieser Methode die <xref:System.Windows.Forms.Form.Owner%2A> -Eigenschaft des Formulars festgelegt ist, um `owner`. Das Formular nicht modalen können die <xref:System.Windows.Forms.Form.Owner%2A> Eigenschaft, um Informationen über das übergeordnete Formular abzurufen.  Beim Aufrufen dieser Methode ist identisch mit der Einstellung der <xref:System.Windows.Forms.Form.Owner%2A> nicht modalen-Eigenschaft und dem anschließenden Aufrufen der <xref:System.Windows.Forms.Control.Show> Methode.  
  
 Anzeigen des Formulars entspricht dem Festlegen der <xref:System.Windows.Forms.Control.Visible%2A> Eigenschaft `true`. Nach der <xref:System.Windows.Forms.Form.Show%2A> -Methode aufgerufen wird, die <xref:System.Windows.Forms.Control.Visible%2A> Eigenschaft gibt einen Wert von `true` bis die <xref:System.Windows.Forms.Control.Hide%2A> Methode wird aufgerufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das anzuzeigende Formular ist bereits sichtbar.  
  
 - oder -   
  
 Die im angegebenen Format der <paramref name="owner" /> -Parameter ist identisch mit dem Formular angezeigt wird.  
  
 - oder -   
  
 Das anzuzeigende Formular ist deaktiviert.  
  
 - oder -   
  
 Das anzuzeigende Formular ist ein Fenster der obersten Ebene.  
  
 - oder -   
  
 Als Dialogfeld angezeigten Formular ist bereits ein modales Formular.  
  
 - oder -   
  
 Der aktuelle Prozess im interaktiven Modus nicht ausgeführt wird (Weitere Informationen finden Sie unter <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zeigt das Formular als modales Dialogfeld an.</summary>
        <returns>Einer der <see cref="T:System.Windows.Forms.DialogResult" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, um ein modales Dialogfeld in der Anwendung anzuzeigen. Wenn diese Methode aufgerufen wird, ist der folgende Code wird erst ausgeführt, nachdem das Dialogfeld geschlossen wird. Das Dialogfeld kann zugewiesen werden, einen der Werte von der <xref:System.Windows.Forms.DialogResult> Enumeration durch Zuweisung zu der <xref:System.Windows.Forms.Button.DialogResult%2A> Eigenschaft eine <xref:System.Windows.Forms.Button> auf dem Formular oder durch Festlegen der <xref:System.Windows.Forms.Form.DialogResult%2A> -Eigenschaft des Formulars im Code. Dieser Wert wird von dieser Methode zurückgegeben. Dieser Rückgabewert können Sie bestimmen, wie zum Verarbeiten der Aktionen, die Sie im Dialogfeld aufgetreten sind. Angenommen, wenn das Dialogfeld geschlossen und zurückgegeben wurde die `DialogResult.Cancel` Wert über diese Methode können Sie Code nach dem Aufruf von verhindern <xref:System.Windows.Forms.Form.ShowDialog%2A> aus ausführen.  
  
 Wenn ein Formular als modales Dialogfeld angezeigt wird, klicken Sie auf die **schließen** Schaltfläche (die Schaltfläche mit einem X in der oberen rechten Ecke des Formulars) bewirkt, dass das Formular ausgeblendet werden und die <xref:System.Windows.Forms.Form.DialogResult%2A> Eigenschaft festgelegt werden, um `DialogResult.Cancel`. Im Gegensatz zu nicht modalen Formulare die <xref:System.Windows.Forms.Form.Close%2A> Methode wird nicht von der .NET Framework aufgerufen, wenn der Benutzer klickt auf die Schaltfläche Schließen eines Dialogfelds, oder den Wert für legt die <xref:System.Windows.Forms.Form.DialogResult%2A> Eigenschaft. Stattdessen wird das Formular wird ausgeblendet, und kann erneut ohne Erstellen einer neuen Instanz des Dialogfelds angezeigt werden. Da ein Formular angezeigt, wie ein Dialogfeld und geschlossen ausgeblendet wird, aufgerufen werden, muss die <xref:System.Windows.Forms.Control.Dispose%2A> Methode des Formulars bei das Formular von der Anwendung nicht mehr benötigt wird.  
  
 Diese Version von den <xref:System.Windows.Forms.Form.ShowDialog%2A> Methode gibt keines Formulars oder Steuerelements als Besitzer. Wenn diese Version aufgerufen wird, erfolgt das aktuell aktive Fenster den Besitzer des Dialogfelds. Wenn Sie einen bestimmten Besitzer angeben möchten, verwenden Sie die andere Version dieser Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Formular als modales Dialogfeld angezeigt und den Rückgabewert des Dialogfelds ausgewertet, bevor festgestellt wird, ob der Wert des gelesen ein <xref:System.Windows.Forms.TextBox> Steuerelement im Formular Dialogfelds. Dieses Beispiel erfordert, dass eine <xref:System.Windows.Forms.Form> mit dem Namen `testDialog` wird erstellt und die darin enthaltenen eine <xref:System.Windows.Forms.TextBox> Steuerelement namens `TextBox1`. Beispiel darüber hinaus ist es erforderlich, dass Code in diesem Beispiel enthaltenen und von einem anderen aufgerufen <xref:System.Windows.Forms.Form> um anzeigen `testDialog` als modales Dialogfeld. Im Beispiel wird die Version des <xref:System.Windows.Forms.Form.ShowDialog%2A> , die einen Besitzer für das Dialogfeld angibt.  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das anzuzeigende Formular ist bereits sichtbar.  
  
 - oder -   
  
 Das anzuzeigende Formular ist deaktiviert.  
  
 - oder -   
  
 Das anzuzeigende Formular ist ein Fenster der obersten Ebene.  
  
 - oder -   
  
 Als Dialogfeld angezeigten Formular ist bereits ein modales Formular.  
  
 - oder -   
  
 Der aktuelle Prozess im interaktiven Modus nicht ausgeführt wird (Weitere Informationen finden Sie unter <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog(System.Windows.Forms.IWin32Window)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" />
      </Parameters>
      <Docs>
        <param name="owner">Ein beliebiges Objekt, das <see cref="T:System.Windows.Forms.IWin32Window" /> implementiert, das das Fenster der obersten Ebene und damit den Besitzer des modalen Dialogfelds darstellt.</param>
        <summary>Zeigt das Formular als modales Dialogfeld mit dem angegebenen Besitzer an.</summary>
        <returns>Einer der <see cref="T:System.Windows.Forms.DialogResult" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, um ein modales Dialogfeld in der Anwendung anzuzeigen. Wenn diese Methode aufgerufen wird, ist der folgende Code wird erst ausgeführt, nachdem das Dialogfeld geschlossen wird. Das Dialogfeld kann zugewiesen werden, einen der Werte von <xref:System.Windows.Forms.DialogResult> durch Zuweisung zu den <xref:System.Windows.Forms.Button.DialogResult%2A> Eigenschaft eine <xref:System.Windows.Forms.Button> auf dem Formular oder durch Festlegen der <xref:System.Windows.Forms.Form.DialogResult%2A> -Eigenschaft des Formulars im Code. Dieser Wert wird von dieser Methode zurückgegeben. Dieser Rückgabewert können Sie bestimmen, wie zum Verarbeiten der Aktionen, die Sie im Dialogfeld aufgetreten sind. Angenommen, wenn das Dialogfeld geschlossen und zurückgegeben wurde die `DialogResult.Cancel` Wert über diese Methode können Sie Code nach dem Aufruf von verhindern <xref:System.Windows.Forms.Form.ShowDialog%2A> aus ausführen.  
  
 Wenn ein Formular als modales Dialogfeld angezeigt wird, klicken Sie auf die **schließen** Schaltfläche (die Schaltfläche mit einem X in der oberen rechten Ecke des Formulars) bewirkt, dass das Formular ausgeblendet werden und die <xref:System.Windows.Forms.Form.DialogResult%2A> Eigenschaft festgelegt werden, um `DialogResult.Cancel`. Im Gegensatz zu nicht modalen Formularen der <xref:System.Windows.Forms.Form.Close%2A> Methode wird nicht von der .NET Framework aufgerufen, wenn der Benutzer klickt auf die Schaltfläche Schließen eines Dialogfelds, oder den Wert für legt die <xref:System.Windows.Forms.Form.DialogResult%2A> Eigenschaft. Stattdessen wird das Formular wird ausgeblendet, und kann erneut ohne Erstellen einer neuen Instanz des Dialogfelds angezeigt werden. Da ein Formular angezeigt, wie ein Dialogfeld und geschlossen ausgeblendet wird, aufgerufen werden, muss die <xref:System.Windows.Forms.Control.Dispose%2A> Methode des Formulars bei das Formular von der Anwendung nicht mehr benötigt wird.  
  
 Diese Version von den <xref:System.Windows.Forms.Form.ShowDialog%2A> Methode ermöglicht Ihnen die Angabe ein bestimmtes Formulars, das das Dialogfeld besitzen soll, das angezeigt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Formular als modales Dialogfeld angezeigt und den Rückgabewert des Dialogfelds ausgewertet, bevor festgestellt wird, ob der Wert des gelesen ein <xref:System.Windows.Forms.TextBox> Steuerelement im Formular Dialogfelds. Dieses Beispiel erfordert, dass eine <xref:System.Windows.Forms.Form> mit dem Namen `Form2` wird erstellt und die darin enthaltenen eine <xref:System.Windows.Forms.TextBox> Steuerelement namens `TextBox1`. Im Beispiel wird die Version des <xref:System.Windows.Forms.Form.ShowDialog%2A> , die einen Besitzer für das Dialogfeld angibt.  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die im angegebenen Format der <paramref name="owner" /> -Parameter ist identisch mit dem Formular angezeigt wird.</exception>
        <exception cref="T:System.InvalidOperationException">Das anzuzeigende Formular ist bereits sichtbar.  
  
 - oder -   
  
 Das anzuzeigende Formular ist deaktiviert.  
  
 - oder -   
  
 Das anzuzeigende Formular ist ein Fenster der obersten Ebene.  
  
 - oder -   
  
 Als Dialogfeld angezeigten Formular ist bereits ein modales Formular.  
  
 - oder -   
  
 Der aktuelle Prozess im interaktiven Modus nicht ausgeführt wird (Weitere Informationen finden Sie unter <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="ShowIcon">
      <MemberSignature Language="C#" Value="public bool ShowIcon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowIcon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowIcon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Symbol auf der Titelleiste des Formulars angezeigt wird, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn auf der Titelleiste des Formulars ein Symbol angezeigt wird, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.ShowIcon%2A> Eigenschaft enthält eine <xref:System.Boolean> Wert, der angibt, ob des Formulars <xref:System.Windows.Forms.Form.Icon%2A> wird in der Titelleiste des Formulars angezeigt. Wenn die <xref:System.Windows.Forms.Form.ControlBox%2A> Eigenschaft `false`, sowohl das Symbol als auch das Kontrollkästchen werden unterdrückt.  
  
 Wenn <xref:System.Windows.Forms.Form.ShowIcon%2A> ist `false` , wenn die Primärform angezeigt wird, wird ein generisches Symbol in der Taskleistenschaltfläche für die Anwendung angezeigt.  
  
 Diese Eigenschaft hat keine Auswirkung, wenn <xref:System.Windows.Forms.Form.FormBorderStyle%2A> festgelegt ist, um <xref:System.Windows.Forms.FormBorderStyle.FixedDialog>. In diesem Fall wird das Formular ein Symbol nicht angezeigt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Formular auf der Windows-Taskleiste angezeigt wird, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, um das Formular zur Laufzeit auf der Windows-Taskleiste anzuzeigen, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Formular in eine andere Form untergeordnet ist, wird das untergeordnete Formular nicht in der Windows-Taskleiste angezeigt.  
  
 Sie können diese Eigenschaft verwenden, um zu verhindern, dass Benutzer das Formular über die Windows-Taskleiste auswählen. Z. B. Wenn Sie ein Toolfenster suchen und Ersetzen in der Anwendung anzeigen, sollten Sie verhindern, dass dieses Fenster über die Windows-Taskleiste ausgewählt werden, da Sie im Hauptfenster der Anwendung und das Suchen und Ersetzen-Toolfenster müssten angezeigt, um Suchvorgänge ordnungsgemäß zu verarbeiten.  
  
 Wird häufig mit dem soll diese Eigenschaft beim Erstellen eines Formulars mit der <xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow> Stil. Festlegen der <xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow> Stil allein ist nicht garantiert, dass ein Fenster nicht in der Taskleiste angezeigt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Form.ShowInTaskbar%2A> Eigenschaft, um ein Dialogfeld wird nicht in der Windows-Taskleiste angezeigt.  
  
 [!code-cpp[Form.ShowInTaskbar#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.ShowInTaskbar/CPP/form1.cpp#1)]
 [!code-csharp[Form.ShowInTaskbar#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.ShowInTaskbar/CS/form1.cs#1)]
 [!code-vb[Form.ShowInTaskbar#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.ShowInTaskbar/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shown">
      <MemberSignature Language="C#" Value="public event EventHandler Shown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Shown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Shown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt immer dann ein, wenn das Formular erstmalig angezeigt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.Shown> Ereignis wird nur beim ersten ein Formular angezeigt wird; anschließend minimieren, maximieren, wiederherstellen, ausblenden, anzeigen, oder ungültig macht und Neuzeichnen werden dieses Ereignis nicht ausgelöst. Weitere Informationen zur Reihenfolge der Ereignisse eines Formulars finden Sie unter [Reihenfolge der Ereignisse in Windows Forms](~/docs/framework/winforms/order-of-events-in-windows-forms.md).  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Form.Shown> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz des Typs enthält <xref:System.Windows.Forms.Form> mit dem Namen `Form1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Form.Shown> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#403](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#403)]
 [!code-vb[System.Windows.Forms.EventExamples#403](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#403)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowWithoutActivation">
      <MemberSignature Language="C#" Value="protected virtual bool ShowWithoutActivation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowWithoutActivation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowWithoutActivation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Fenster beim Öffnen aktiviert ist.</summary>
        <value>
          <see langword="True" />, wenn das Fenster nicht aktiviert wird, wenn es angezeigt wird, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, wenn Sie ein Fenster der obersten Ebene angezeigt werden sollen, aber nicht angezeigt werden sollen, eines Benutzers Arbeit zu unterbrechen, ergreifen Sie hierzu den Eingabefokus nicht auf dem aktuellen Fenster. Dies kann ein Information-Popup-Fenster oder ein unverankertes Fenster, z. B. eine Toolspalette in der Paint-Anwendung sein.  
  
 Da diese Eigenschaft schreibgeschützt ist, können Sie seinen Wert nur ändern, indem überschreiben <xref:System.Windows.Forms.Form.ShowWithoutActivation%2A> in Ihren eigenen Formular und Programmierung zurückkehren `true`.  
  
 Wenn das Fenster nicht aktivierten Benutzeroberflächen-Steuerelemente verwenden muss, sollten Sie mit der <xref:System.Windows.Forms.ToolStrip> steuert, wie z. B. <xref:System.Windows.Forms.ToolStripDropDown>. Diese Steuerelemente sind fensterlose und werden nicht dazu, dass ein Fenster zu aktivieren, wenn sie ausgewählt werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des Formulars ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Drawing.Size" />, die die Größe des Formulars darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bietet die Möglichkeit, legen Sie die Höhe und Breite (in Pixel) des Formulars zur gleichen Zeit anstatt durch die Einstellung der <xref:System.Windows.Forms.Control.Height%2A> und <xref:System.Windows.Forms.Control.Width%2A> Eigenschaften einzeln. Wenn Sie die Größe und Position eines Formulars festlegen möchten, können Sie mithilfe der <xref:System.Windows.Forms.Form.DesktopBounds%2A> -Eigenschaft für die Größe und Position des Formulars basierend auf Desktopkoordinaten oder verwenden Sie die <xref:System.Windows.Forms.Control.Bounds%2A> Eigenschaft von der <xref:System.Windows.Forms.Control> Klasse zum Festlegen der Größe und Position des Formulars basierend auf Bildschirm Koord Inates.  
  
> [!NOTE]
>  Der maximale Wert dieser Eigenschaft wird von der Auflösung des Bildschirms beschränkt, auf dem das Formular ausgeführt wird. Der Wert darf nicht größer als 12 Pixel über jede Dimension Bildschirm (horizontale + 12 und vertikale + 12) sein.  
  
> [!NOTE]
>  Für Pocket PC-Geräte können Sie ein Fenster in der Größe veränderbaren erstellen, indem <xref:System.Windows.Forms.Form.FormBorderStyle%2A> auf `None` und entfernen Sie die <xref:System.Windows.Forms.MainMenu> Steuerelement. Auf SmartPhone-Geräte können Sie nie Ändern einer <xref:System.Windows.Forms.Form> -es wird immer den gesamten Bildschirm ausfüllen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen eines Formulars, das angezeigt wird, mit einer Durchlässigkeit von 75 Prozent. Der Beispielcode erstellt ein neues Formular, das sich in der Mitte des Bildschirms mit einer <xref:System.Windows.Forms.Form.Opacity%2A> Eigenschaft festgelegt wird, um die Durchlässigkeit des Formulars zu ändern. Der Beispielcode setzt auch die <xref:System.Windows.Forms.Form.Size%2A> Eigenschaft ermöglichen einen größeren Größe, Form als die Standardgröße des Formulars. Dieses Beispiel benötigen Sie, dass die in diesem Beispiel definierte Methode aus einem anderen Formular in einem Ereignishandler oder eine andere Methode aufgerufen wird.  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeGripStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.SizeGripStyle SizeGripStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.SizeGripStyle SizeGripStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.SizeGripStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.SizeGripStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Art des Größenziehpunkts in der rechten unteren Ecke des Formulars ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.SizeGripStyle" />, der die Art des anzuzeigenden Größenziehpunkts darstellt. Die Standardeinstellung ist <see cref="F:System.Windows.Forms.SizeGripStyle.Auto" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft können Sie bestimmen, wann der Größenziehpunkt auf dem Formular angezeigt wird. Sie können diese Eigenschaft auf dem Größenziehpunkt angezeigt oder haben sie automatisch angezeigt, basierend auf der Einstellung der Festlegen der <xref:System.Windows.Forms.Form.FormBorderStyle%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Größenziehpunkts für Ausblenden einer <xref:System.Windows.Forms.Form> bei der <xref:System.Windows.Forms.Form> kann nicht geändert werden.  
  
 [!code-cpp[Form.SizeGripStyle#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.SizeGripStyle/CPP/form1.cpp#1)]
 [!code-csharp[Form.SizeGripStyle#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.SizeGripStyle/CS/form1.cs#1)]
 [!code-vb[Form.SizeGripStyle#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.SizeGripStyle/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der angegebene Wert liegt außerhalb des Bereichs der gültigen Werte.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormStartPosition StartPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormStartPosition StartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.StartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormStartPosition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anfangsposition des Formulars zur Laufzeit ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.FormStartPosition" />, die die Anfangsposition des Formulars darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht Ihnen, die Anfangsposition des Formulars festgelegt, wenn er zur Laufzeit angezeigt wird. Die Position des Formulars kann manuell angegeben werden, indem die <xref:System.Windows.Forms.Form.Location%2A> Eigenschaft oder verwenden den Standardspeicherort von Windows angegeben. Sie können auch das Formular zum Anzeigen von in der Mitte des Bildschirms oder in der Mitte des übergeordneten Formulars für Formulare, z. B. Multiple Document Interface (MDI) untergeordnete Formulare positionieren.  
  
 Diese Eigenschaft muss festgelegt werden, bevor das Formular angezeigt wird.  Sie können diese Eigenschaft festlegen, vor dem Aufrufen der <xref:System.Windows.Forms.Form.Show%2A> oder <xref:System.Windows.Forms.Form.ShowDialog%2A> Methode oder im Konstruktor des Formulars.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine neue Instanz von einem <xref:System.Windows.Forms.Form> und ruft die <xref:System.Windows.Forms.Form.ShowDialog%2A> Methode, um das Formular als Dialogfeld anzeigen. Im Beispiel wird die <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, und <xref:System.Windows.Forms.Form.StartPosition%2A> Eigenschaften, um die Darstellung und Funktionalität des Formulars in ein Dialogfeld zu ändern. Das Beispiel verwendet außerdem die <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> Methode im Format <xref:System.Windows.Forms.Control.Controls%2A> Auflistung hinzuzufügende zwei <xref:System.Windows.Forms.Button> Steuerelemente. Im Beispiel wird die <xref:System.Windows.Forms.Form.HelpButton%2A> -Eigenschaft auf eine Schaltfläche "Hilfe" in der Titelleiste des Dialogfelds angezeigt.  
  
 [!code-cpp[Classic Form.StartPosition Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.StartPosition Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CS/source.cs#1)]
 [!code-vb[Classic Form.StartPosition Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.StartPosition Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der angegebene Wert liegt außerhalb des Bereichs der gültigen Werte.</exception>
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Aktivierreihenfolge des Steuerelements in dessen Container ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Int32" />-Struktur, die den Index des Steuerelements in der Gruppe von Steuerelementen in dessen Container enthält, die in der Aktivierreihenfolge enthalten ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formulare werden nicht in der Aktivierreihenfolge enthalten. Festlegen der <xref:System.Windows.Forms.Form.TabIndex%2A> Eigenschaft wird keine Aktion ausgeführt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabIndexChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Form.TabIndex" />-Eigenschaft ändert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Benutzer den Fokus mit der TAB-TASTE auf dieses Steuerelement setzen können, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn der Fokus mit der TAB-TASTE auf dieses Steuerelement gesetzt werden kann, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabStopChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich die <see cref="P:System.Windows.Forms.Form.TabStop" />-Eigenschaft ändert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den diesem Steuerelement zugeordneten Text ab oder legt diesen fest.</summary>
        <value>Der diesem Steuerelement zugeordnete Text.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopLevel">
      <MemberSignature Language="C#" Value="public bool TopLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopLevel" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Formular als Fenster der obersten Ebene angezeigt wird, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, um das Formular als Fenster der obersten Ebene anzuzeigen, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Formular der obersten Ebene ist ein Fenster, der ohne übergeordnetes Formular aufweist, oder dessen übergeordnetes Formular ist der Desktopfenster. Fenster auf oberster Ebene werden in der Regel als das Hauptformular in einer Anwendung verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mithilfe der <xref:System.Windows.Forms.Form.Modal%2A> Eigenschaft, um zu bestimmen, ob ein Formular als modales Formular angezeigt wird. Ist dies nicht der <xref:System.Windows.Forms.Form.FormBorderStyle%2A> und <xref:System.Windows.Forms.Form.TopLevel%2A> Eigenschaften werden geändert, um das Formular auf der obersten Ebene Formular mit Toolfensterrahmen ist.  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Ein Multiple Document Interface (MDI) übergeordnetes Formular muss es sich um ein Fenster der obersten Ebene sein.</exception>
      </Docs>
    </Member>
    <Member MemberName="TopMost">
      <MemberSignature Language="C#" Value="public bool TopMost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopMost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopMost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Formular als oberstes Formular angezeigt werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, um das Formular als oberstes Formular anzuzeigen, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oberstes Formular wird ein Formular, das alle anderen (höchsten) Formulare überlagert, auch wenn es sich nicht um das Formular "aktiv" oder Vordergrund ist. Oberste Formulare werden immer am höchsten Punkt in der Z-Reihenfolge der Fenster auf dem Desktop angezeigt. Sie können diese Eigenschaft verwenden, um ein Formular erstellen, die immer in der Anwendung, z. B. ein Toolfenster suchen und ersetzen angezeigt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie oberstes Formular zu erstellen. Das Beispiel erstellt zwei Formen enthalten, von denen eine wird maximiert und eine, die als oberstes Formular angezeigt werden sollen. Die erste Form, die mit dem Namen `bottomForm`, wird angezeigt, maximiert angezeigt wird, mithilfe der <xref:System.Windows.Forms.Form.WindowState%2A> -Eigenschaft, um die Funktionen des obersten Formulars besser zu veranschaulichen. Die zweite Form, die mit dem Namen `topMostForm`, legt der <xref:System.Windows.Forms.Form.TopMost%2A> Eigenschaft `true` um das Formular als oberstes Formular anzuzeigen. Wenn dieser Code ausgeführt wird, einen durch Klicken auf das Formular maximiert verursacht keinen oberste Formular unterhalb des maximierten Formulars angezeigt werden. Das Beispiel erfordert, dass die im Beispiel definierte Methode aus einem anderen Formular aufgerufen wird.  
  
 [!code-cpp[Form.TopMost#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.TopMost/CPP/form1.cpp#1)]
 [!code-csharp[Form.TopMost#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.TopMost/CS/form1.cs#1)]
 [!code-vb[Form.TopMost#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.TopMost/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Zeichenfolge ab, die die aktuelle Instanz des Formulars darstellt.</summary>
        <returns>Eine Zeichenfolge mit dem vollqualifizierten Namen der Klasse des Formularobjekts, wobei die <see cref="P:System.Windows.Forms.Form.Text" />-Eigenschaft des Formulars am Ende angefügt ist. Z. B., wenn das Formular von der Klasse abgeleitet ist <c>"MyForm"</c> in der <c>MyNamespace</c> -Namespace und die <see cref="P:System.Windows.Forms.Form.Text" /> -Eigenschaftensatz auf <c>Hello, World</c>, wird diese Methode zurückgeben <c>MyNamespace.MyForm, Text: Hello, World</c>.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransparencyKey">
      <MemberSignature Language="C#" Value="public System.Drawing.Color TransparencyKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color TransparencyKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TransparencyKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Farbe ab, in der transparente Bereiche des Formulars darstellt werden, oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Drawing.Color" />, die die Farbe für eine transparente Anzeige im Formular darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Form.TransparencyKey%2A> Eigenschaft zugewiesen ist ein <xref:System.Drawing.Color>, die Bereiche des Formulars, die dieselbe <xref:System.Windows.Forms.Control.BackColor%2A> transparent angezeigt. Alle Mausaktionen, z. B. das Klicken auf die Maus, die für die transparente Bereiche des Formulars ausgeführt werden, werden auf dem Windows unterhalb der transparenten Bereich übertragen werden. Z. B. wenn Clientbereichs eines Formulars erfolgt transparent ist, klicken mit der Maus auf diesen Bereich die ereignisbenachrichtigung der klicken Sie auf einem beliebigen Fenster beim Senden, die darunter liegenden. Wenn Sie die Farbe zugewiesen der <xref:System.Windows.Forms.Form.TransparencyKey%2A> Eigenschaft ist identisch mit der alle Steuerelemente im Formular, die sie auch transparent angezeigt. Angenommen, Sie haben eine <xref:System.Windows.Forms.Button> Steuerelement auf ein Formular, seine <xref:System.Windows.Forms.Form.TransparencyKey%2A> -Eigenschaftensatz auf `SystemColors.Control`, das Steuerelement transparent angezeigt, es sei denn, der <xref:System.Windows.Forms.Control.BackColor%2A> Eigenschaft von der <xref:System.Windows.Forms.Button> Steuerelement wird in einer anderen Farbe geändert.  
  
 Diese Eigenschaft wird nicht unterstützt, wenn <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> ist `true`.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein Fenster mit einem transparenten Clientbereich unabhängig von der Hintergrundfarbe des Formulars. Dieses Beispiel erfordert, dass das Beispiel für eine Methode innerhalb einer Form-Klasse definiert ist.  
  
 [!code-cpp[Classic Form.TransparencyKey Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.TransparencyKey Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CS/source.cs#1)]
 [!code-vb[Classic Form.TransparencyKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultButton">
      <MemberSignature Language="C#" Value="protected override void UpdateDefaultButton ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void UpdateDefaultButton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.UpdateDefaultButton" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktualisiert, welche Schaltfläche die Standardschaltfläche ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Form.UpdateDefaultButton%2A> Methode bestimmt, welches Steuerelement die Schaltfläche im Formular löst das Click-Ereignis, wenn der Benutzer die EINGABETASTE drückt, gemäß der folgenden Priorität:  
  
1.  Wenn die <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> Eigenschaft implementiert die <xref:System.Windows.Forms.IButtonControl> Schnittstelle, die Kontrolle über die Standardschaltfläche ist.  
  
2.  Die <xref:System.Windows.Forms.Form.AcceptButton%2A> Eigenschaft ist die Standardschaltfläche.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass alle untergeordneten Steuerelemente in einem Steuerelement, die die Validierung unterstützten, ihre Daten validieren.</summary>
        <returns>
          <see langword="true" />, wenn alle untergeordneten Elemente erfolgreich validiert wurden, andernfalls <see langword="false" />. Wenn sie vom <see cref="E:System.Windows.Forms.Control.Validating" />-Ereignishandler oder vom <see cref="E:System.Windows.Forms.Control.Validated" />-Ereignishandler aufgerufen wird, gibt diese Methode immer <see langword="false" /> zurück.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren (System.Windows.Forms.ValidationConstraints validationConstraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren(valuetype System.Windows.Forms.ValidationConstraints validationConstraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationConstraints" Type="System.Windows.Forms.ValidationConstraints" />
      </Parameters>
      <Docs>
        <param name="validationConstraints">Schränkt ein, bei welchen Steuerelementen das <see cref="E:System.Windows.Forms.Control.Validating" />-Ereignis ausgelöst wird.</param>
        <summary>Bewirkt, dass alle untergeordneten Steuerelemente in einem Steuerelement, die die Validierung unterstützten, ihre Daten validieren.</summary>
        <returns>
          <see langword="true" />, wenn alle untergeordneten Elemente erfolgreich validiert wurden, andernfalls <see langword="false" />. Wenn sie vom <see cref="E:System.Windows.Forms.Control.Validating" />-Ereignishandler oder vom <see cref="E:System.Windows.Forms.Control.Validated" />-Ereignishandler aufgerufen wird, gibt diese Methode immer <see langword="false" /> zurück.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormWindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormWindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormWindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Formular minimiert, maximiert oder normal ist, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.FormWindowState" />, der darstellt, ob ein Formular minimiert, maximiert oder normal ist. Die Standardeinstellung ist <see langword="FormWindowState.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bevor Sie ein Formular angezeigt wird, die <xref:System.Windows.Forms.Form.WindowState%2A> -Eigenschaftensatz ist immer auf `FormWindowState.Normal`, unabhängig von die ursprüngliche Einstellung. Dies spiegelt wider, der <xref:System.Windows.Forms.Control.Height%2A>, <xref:System.Windows.Forms.Control.Left%2A>, <xref:System.Windows.Forms.Control.Top%2A>, und <xref:System.Windows.Forms.Control.Width%2A> eigenschafteneinstellungen. Wenn ein Formular ausgeblendet ist, nachdem es angezeigt wurde, diese Eigenschaften entsprechen den vorherigen Zustand erst das Formular erneut, unabhängig von der alle Änderungen angezeigt wird an der <xref:System.Windows.Forms.Form.WindowState%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen der <xref:System.Windows.Forms.Form.WindowState%2A> zu maximiert. Der Code aus aufgerufen wird die <xref:System.Windows.Forms.Form.Shown> Ereignishandler, nachdem das Formular erstellt wurde.  
  
```csharp  
private void Form1_Shown(object sender, EventArgs e)  
        {  
            this.WindowState = System.Windows.Forms.FormWindowState.Maximized;  
        }  
```  
  
```vb  
Private  Sub Form1_Shown(ByVal sender As Object, ByVal e As EventArgs)  
            Me.WindowState = System.Windows.Forms.FormWindowState.Maximized  
End Sub  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der angegebene Wert liegt außerhalb des Bereichs der gültigen Werte.</exception>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.WndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Die zu verarbeitende Windows-<see cref="T:System.Windows.Forms.Message" />.</param>
        <summary>Verarbeitet Windows-Meldungen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
