<Type Name="Control" FullName="System.Windows.Forms.Control">
  <TypeSignature Language="C#" Value="public class Control : System.ComponentModel.Component, IDisposable, System.ComponentModel.ISynchronizeInvoke, System.Windows.Forms.IBindableComponent, System.Windows.Forms.IDropTarget, System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Control extends System.ComponentModel.Component implements class System.ComponentModel.IComponent, class System.ComponentModel.ISynchronizeInvoke, class System.IDisposable, class System.Windows.Forms.IBindableComponent, class System.Windows.Forms.IDropTarget, class System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Control" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISynchronizeInvoke</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IBindableComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IDropTarget</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiert die Basisklasse für Steuerelemente. Steuerelemente sind Komponenten mit visueller Darstellung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um eine eigene Klasse zu erstellen, erben die <xref:System.Windows.Forms.UserControl>, <xref:System.Windows.Forms.Control> Klassen, oder mithilfe von Windows Forms Steuerelemente. Weitere Informationen zum Erstellen von benutzerdefinierter Steuerelementen finden Sie unter [Entwickeln benutzerdefinierter Windows Forms-Steuerelementen mit .NET Framework](~/docs/framework/winforms/controls/developing-custom-windows-forms-controls.md).  
  
 Die <xref:System.Windows.Forms.Control> Klasse implementiert sehr grundlegenden Funktionen von Klassen, die Informationen für den Benutzer anzuzeigen. Benutzereingaben über die Tastatur und Zeigegeräte verarbeitet. Er verarbeitet die Nachrichtenrouting und Sicherheit. Definiert die Grenzen eines Steuerelements (die Position und Größe), obwohl ihn Paint-Ereignisse nicht implementiert ist. Es bietet ein Fensterhandle (`hWnd`).  
  
 Windows Forms-Steuerelemente verwenden Umgebungseigenschaften, damit untergeordnete Steuerelemente wie ihre Umgebung angezeigt werden können. Ein *ambient-Eigenschaft* eine Steuerelementeigenschaft ist, dass, sofern Sie nicht festgelegt ist, wird vom übergeordneten Steuerelement abgerufen. Wenn das Steuerelement keine <xref:System.Windows.Forms.Control.Parent%2A>, und die Eigenschaft nicht festgelegt ist, versucht das Steuerelement, um zu bestimmen, den Wert der ambient-Eigenschaft über die <xref:System.Windows.Forms.Control.Site%2A> Eigenschaft. Wenn das Steuerelement nicht platziert wird, wenn der Standort unterstützt keine Umgebungseigenschaften, oder wenn die Eigenschaft nicht festgelegt ist, auf die <xref:System.Windows.Forms.AmbientProperties>, das Steuerelement verwendet die eigenen Standardwerten. In der Regel eine Ambiente-Eigenschaft stellt ein Merkmal eines Steuerelements, wie z. B. <xref:System.Windows.Forms.Control.BackColor%2A>, d. h. ein untergeordnetes Steuerelement mitgeteilt. Z. B. eine <xref:System.Windows.Forms.Button> verfügen über denselben <xref:System.Windows.Forms.Control.BackColor%2A> wie das übergeordnete Objekt <xref:System.Windows.Forms.Form> standardmäßig. Von bereitgestellten Ambient-Eigenschaften der <xref:System.Windows.Forms.Control> Klasse einbeziehen: <xref:System.Windows.Forms.Control.Cursor%2A>, <xref:System.Windows.Forms.Control.Font%2A>, <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.ForeColor%2A>, und <xref:System.Windows.Forms.Control.RightToLeft%2A>.  
  
> [!NOTE]
>  Damit Ihre Windows Forms-Anwendung, die visuelle Stile unterstützen, werden Sie sicher, dass der <xref:System.Windows.Forms.FlatStyle> Eigenschaft `System` und fügen Sie ein Manifest in die ausführbare Datei. Ein Manifest ist eine XML-Datei, die enthalten ist, als eine Ressource in der ausführbaren Datei der Anwendung oder als separate Datei, die sich im selben Verzeichnis wie die ausführbare Datei befindet. Ein Beispiel für ein Manifest finden Sie im Beispielabschnitt von der <xref:System.Windows.Forms.FlatStyle> Enumeration. Weitere Informationen zur Verwendung von visuellen Stilen finden Sie unter[visuelle Stile](http://msdn.microsoft.com/library/windows/desktop/bb773187.aspx).  
  
 Windows Forms verfügt über integrierte Accessibility-Unterstützung und bietet Informationen zu Ihrer Anwendung, die zum Arbeiten mit Barrierefreiheit-Clientanwendungen wie z. B. Dienstprogramme für Bildschirm Enlarger "und" Prüfer, voice-Hilfsprogramme, auf dem Bildschirm Tastaturen ermöglicht, Alternative Eingabegeräte, und Tastatur Erweiterung Hilfsprogramme. In einigen Fällen sollten Sie zusätzlichen Informationen an Clientanwendungen für Barrierefreiheit zu senden. Es gibt zwei Methoden zum Bereitstellen von zusätzlichen Informationen. Sie können festlegen, die <xref:System.Windows.Forms.Control.AccessibleName%2A>, <xref:System.Windows.Forms.Control.AccessibleDescription%2A>, <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A>, und <xref:System.Windows.Forms.Control.AccessibleRole%2A> Eigenschaftswerte, die Clientanwendungen für Barrierefreiheit gemeldet werden. Diese Methode wird normalerweise verwendet, um begrenzte Informationen zu Eingabehilfen für vorhandene Steuerelemente bereitzustellen. Alternativ können Sie eine eigene Klasse ableiten von Schreiben der <xref:System.Windows.Forms.AccessibleObject> oder <xref:System.Windows.Forms.Control.ControlAccessibleObject> Klassen, wie viele Informationen über Eingabehilfen nach Bedarf.  
  
> [!NOTE]
>  Legen Sie die Größe eines Steuerelements nicht in seinem Konstruktor, um eine bessere Leistung zu gewährleisten. Die bevorzugte Methode ist, überschreiben die <xref:System.Windows.Forms.Control.DefaultSize%2A> Eigenschaft.  
  
> [!NOTE]
>  Fügen Sie keine datenbindungen für ein <xref:System.Windows.Forms.Control> in seinem Konstruktor. Auf diese Weise wird führen zu Fehlern bei der Codeerzeugung und kann unerwünschtes Verhalten führen.  
  
 Die meisten der Steuerelemente in der <xref:System.Windows.Forms> Namespace verwenden das zugrunde liegende Windows-Standardsteuerelement als Basis für die Erstellung. Weitere Informationen zu allgemeinen Windows-Steuerelemente, finden Sie unter[Allgemeine Referenz zu Steuerelement](http://msdn.microsoft.com/library/windows/desktop/bb775497.aspx).  
  
 Verwenden Sie zum Identifizieren der Windows Forms-Steuerelemente in einem separaten Prozess, einen Standard `SendMessage` Aufruf WM_GETCONTROLNAME nachrichtenparametertyp. WM_GETCONTROLNAME ist unabhängig von der Sprache und die Windows-Hierarchie. Weitere Informationen finden Sie im Thema "Empfohlene Lösung für Windows Forms" in[Automatisieren von Windows Forms](http://msdn.microsoft.com/library/ms996405.aspx).  
  
 Verwenden der <xref:System.Windows.Forms.Control.InvokeRequired%2A> Eigenschaft, um den Zugriff auf das Steuerelement aus mehreren Threads synchronisieren. Weitere Informationen zu Multithread-Windows Forms-Steuerelementen finden Sie unter [Vorgehensweise: Stellen Sie threadsichere Aufrufe von Windows Forms-Steuerelementen](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md)  
  
 ]]></format>
    </remarks>
    <threadsafe>Nur die folgenden Elemente threadsicher sind: <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />, <see cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />, <see cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />, <see cref="P:System.Windows.Forms.Control.InvokeRequired" />, und <see cref="M:System.Windows.Forms.Control.CreateGraphics" /> , wenn das Handle für das Steuerelement bereits erstellt wurde. Aufrufen von <see cref="M:System.Windows.Forms.Control.CreateGraphics" /> , bevor das Handle des Steuerelements in einem Hintergrundthread erstellt werden können dazu führen, dass unzulässigen threadübergreifenden aufrufen.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Control" />-Klasse mit Standardeinstellungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control> Klasse ist die Basisklasse für alle Steuerelemente, die in einer Windows Forms-Anwendung verwendet. Da diese Klasse in der Regel nicht zum Erstellen einer Instanz der Klasse verwendet wird, wird dieser Konstruktor wird in der Regel nicht direkt aufgerufen, aber stattdessen durch eine abgeleitete Klasse aufgerufen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Der vom Steuerelement angezeigte Text.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Control" />-Klasse mit bestimmtem Text.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control> Klasse ist die Basisklasse für alle Steuerelemente, die in einer Windows Forms-Anwendung verwendet. Da diese Klasse in der Regel nicht zum Erstellen einer Instanz der Klasse verwendet wird, wird dieser Konstruktor wird in der Regel nicht direkt aufgerufen, aber stattdessen durch eine abgeleitete Klasse aufgerufen wird.  
  
 Diese Version von der <xref:System.Windows.Forms.Control.%23ctor%2A> Konstruktor legt die anfängliche <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert angibt, der die `text` Parameterwert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="parent">Das <see cref="T:System.Windows.Forms.Control" />, das das übergeordnete Element des Steuerelements sein soll.</param>
        <param name="text">Der vom Steuerelement angezeigte Text.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Control" />-Klasse als untergeordnetes Steuerelement mit bestimmtem Text.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control> Klasse ist die Basisklasse für alle Steuerelemente, die in einer Windows Forms-Anwendung verwendet. Da diese Klasse in der Regel nicht zum Erstellen einer Instanz der Klasse verwendet wird, wird dieser Konstruktor wird in der Regel nicht direkt aufgerufen, aber stattdessen durch eine abgeleitete Klasse aufgerufen wird.  
  
 Diese Version von der <xref:System.Windows.Forms.Control.%23ctor%2A> Konstruktor legt die anfängliche <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert angibt, der die `text` Parameterwert. Der Konstruktor fügt auch das Steuerelement an des übergeordnete Steuerelements <xref:System.Windows.Forms.Control.ControlCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">Der vom Steuerelement angezeigte Text.</param>
        <param name="left">Die <see cref="P:System.Drawing.Point.X" />-Position des Steuerelements in Pixel vom linken Rand des Containers des Steuerelements. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Left" />-Eigenschaft zugewiesen.</param>
        <param name="top">Die <see cref="P:System.Drawing.Point.Y" />-Position des Steuerelements in Pixel vom oberen Rand des Containers des Steuerelements. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Top" />-Eigenschaft zugewiesen.</param>
        <param name="width">Die Breite des Steuerelements in Pixel. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Width" />-Eigenschaft zugewiesen.</param>
        <param name="height">Die Höhe des Steuerelements in Pixel. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Height" />-Eigenschaft zugewiesen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Control" />-Klasse mit bestimmtem Text, bestimmter Größe und Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control> Klasse ist die Basisklasse für alle Steuerelemente, die in einer Windows Forms-Anwendung verwendet. Da diese Klasse in der Regel nicht zum Erstellen einer Instanz der Klasse verwendet wird, wird dieser Konstruktor wird in der Regel nicht direkt aufgerufen, aber stattdessen durch eine abgeleitete Klasse aufgerufen wird.  
  
 Diese Version von der <xref:System.Windows.Forms.Control.%23ctor%2A> Konstruktor legt die anfängliche <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert angibt, der die `text` Parameterwert. Der ursprüngliche <xref:System.Windows.Forms.Control.Size%2A> und <xref:System.Windows.Forms.Control.Location%2A> des Steuerelements werden gemäß der `left`, `top`, `width` und `height` Parameterwerte.  
  
> [!NOTE]
>  Legen Sie die Größe eines Steuerelements nicht in seinem Konstruktor, um eine bessere Leistung zu gewährleisten. Die bevorzugte Methode ist, überschreiben die <xref:System.Windows.Forms.Control.DefaultSize%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parent">Das <see cref="T:System.Windows.Forms.Control" />, das das übergeordnete Element des Steuerelements sein soll.</param>
        <param name="text">Der vom Steuerelement angezeigte Text.</param>
        <param name="left">Die <see cref="P:System.Drawing.Point.X" />-Position des Steuerelements in Pixel vom linken Rand des Containers des Steuerelements. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Left" />-Eigenschaft zugewiesen.</param>
        <param name="top">Die <see cref="P:System.Drawing.Point.Y" />-Position des Steuerelements in Pixel vom oberen Rand des Containers des Steuerelements. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Top" />-Eigenschaft zugewiesen.</param>
        <param name="width">Die Breite des Steuerelements in Pixel. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Width" />-Eigenschaft zugewiesen.</param>
        <param name="height">Die Höhe des Steuerelements in Pixel. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Height" />-Eigenschaft zugewiesen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Control" />-Klasse als untergeordnetes Steuerelement mit bestimmtem Text, bestimmter Größe und Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control> Klasse ist die Basisklasse für alle Steuerelemente, die in einer Windows Forms-Anwendung verwendet. Da diese Klasse in der Regel nicht zum Erstellen einer Instanz der Klasse verwendet wird, wird dieser Konstruktor wird in der Regel nicht direkt aufgerufen, aber stattdessen durch eine abgeleitete Klasse aufgerufen wird.  
  
 Diese Version von der <xref:System.Windows.Forms.Control.%23ctor%2A> Konstruktor legt die anfängliche <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert angibt, der die `text` Parameterwert. Der Konstruktor fügt auch das Steuerelement an des übergeordnete Steuerelements <xref:System.Windows.Forms.Control.ControlCollection>. Der ursprüngliche <xref:System.Windows.Forms.Control.Size%2A> und <xref:System.Windows.Forms.Control.Location%2A> des Steuerelements werden gemäß der `left`, `top`, `width` und `height` Parameterwerte.  
  
> [!NOTE]
>  Legen Sie die Größe eines Steuerelements nicht in seinem Konstruktor, um eine bessere Leistung zu gewährleisten. Die bevorzugte Methode ist, überschreiben die <xref:System.Windows.Forms.Control.DefaultSize%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">Die <see cref="T:System.Windows.Forms.AccessibleEvents" />-Enumeration, über die die Clientanwendungen für die Barrierefreiheit benachrichtigt werden sollen.</param>
        <param name="childID">Das untergeordnete <see cref="T:System.Windows.Forms.Control" />, das über das barrierefreie Ereignis benachrichtigt werden soll.</param>
        <summary>Benachrichtigt die Clientanwendungen für die Barrierefreiheit über die angegebenen <see cref="T:System.Windows.Forms.AccessibleEvents" /> für das angegebene untergeordnete Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A?displayProperty=nameWithType> Methode für die einzelnen <xref:System.Windows.Forms.AccessibleEvents> sind, dass die Clientanwendungen für Barrierefreiheit benachrichtigt zu werden. Die <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A> Methode wird in der Regel aufgerufen, wenn eine Eigenschaft nicht festgelegt oder innerhalb von ist ein Ereignishandler. Rufen Sie z. B. möglicherweise die <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A> Methode und übergeben ein <xref:System.Windows.Forms.AccessibleEvents> Wert `Hide` aus innerhalb des ereignishandlers für das <xref:System.Windows.Forms.Control.VisibleChanged?displayProperty=nameWithType> Ereignis.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Erstellung eines Diagramms Eingabehilfen-fähig zu steuern, mit der <xref:System.Windows.Forms.AccessibleObject> und <xref:System.Windows.Forms.Control.ControlAccessibleObject> Klassen zum Offenlegen von Informationen zugegriffen werden kann. Das Steuerelement zeichnet zwei Kurven geteilt zusammen mit einer Legende an. Die `ChartControlAccessibleObject` -Klasse, abgeleitet von `ControlAccessibleObject`, werden in der <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> Methode, um benutzerdefinierte barrierefreie Informationen für das Diagrammsteuerelement bereitzustellen. Da die Diagrammlegende nicht tatsächlich <xref:System.Windows.Forms.Control> -basierte Steuerelement, sondern gezeichnet wird vom Diagrammsteuerelement, ist es aber keine integrierten barrierefreien Informationen. Aus diesem Grund die `ChartControlAccessibleObject` -Klasse überschreibt die <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> -Methode zur Rückgabe der `CurveLegendAccessibleObject` , zugegriffen werden Informationen für jeden Teil der Legende darstellt. Wenn eine zugänglich-fähige Anwendung dieses Steuerelement verwendet wird, bieten das Steuerelement die erforderlichen Informationen zugegriffen werden kann.  
  
 Dieser Code veranschaulicht die Aufrufen der <xref:System.Windows.Forms.Control.AccessibilityNotifyClients%2A> Methode. Finden Sie unter der <xref:System.Windows.Forms.AccessibleObject> Übersicht über die Klasse für das gesamte Codebeispiel dargestellt.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#5)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#5)]
 [!code-vb[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 objectID, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="objectID" Type="System.Int32" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">Die <see cref="T:System.Windows.Forms.AccessibleEvents" />-Enumeration, über die die Clientanwendungen für die Barrierefreiheit benachrichtigt werden sollen.</param>
        <param name="objectID">Der Bezeichner von <see cref="T:System.Windows.Forms.AccessibleObject" />.</param>
        <param name="childID">Das untergeordnete <see cref="T:System.Windows.Forms.Control" />, das über das barrierefreie Ereignis benachrichtigt werden soll.</param>
        <summary>Benachrichtigt die Clientanwendungen für die Barrierefreiheit über die angegebenen <see cref="T:System.Windows.Forms.AccessibleEvents" /> für das angegebene untergeordnete Steuerelement.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityObject">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleObject AccessibilityObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AccessibleObject AccessibilityObject" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibilityObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das dem Steuerelement zugewiesene <see cref="T:System.Windows.Forms.AccessibleObject" /> ab.</summary>
        <value>Das dem Steuerelement zugewiesene <see cref="T:System.Windows.Forms.AccessibleObject" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Instanz, die von dieser Methode zurückgegebene überschreiben, um die <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> Methode.  
  
 Wenn dem Steuerelement gerade kein <xref:System.Windows.Forms.AccessibleObject> zugewiesen ist, wird eine neue Instanz davon erstellt.  
  
> [!NOTE]
>  Zum Abrufen oder Festlegen der <xref:System.Windows.Forms.Control.AccessibilityObject%2A> -Eigenschaft, müssen Sie einen Verweis zum Hinzufügen der `Accessibility` mit installierte Assembly die[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
 Weitere Informationen zu barrierefreiheitsobjekten finden Sie unter [Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592.aspx).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibleDefaultActionDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDefaultActionDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDefaultActionDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardbeschreibung der Aktion des Steuerelements ab, das von Clientanwendungen für Barrierefreiheit verwendet wird, oder legt diese fest.</summary>
        <value>Die Beschreibung der Standardaktion des Steuerelements für die Verwendung durch Clientanwendungen für die Barrierefreiheit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Objekt <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A> Eigenschaft beschreibt primäre Objektmethode Manipulation aus Sicht des Benutzers. Diese Eigenschaft sollte ein Verb oder ein kurzer Ausdruck sein.  
  
> [!NOTE]
>  Nicht alle Objekte verfügen "Aktionen", und einige Objekte möglicherweise eine Standardaktion, die auf bezieht die <xref:System.Windows.Forms.AccessibleObject.Value%2A?displayProperty=nameWithType> Eigenschaft an, wie in den folgenden Beispielen:  
  
-   Ein aktiviertes Kontrollkästchen verfügt über eine Standardaktion "Deaktivieren" und den Wert "Aktiviert".  
  
-   Ein deaktiviertes Kontrollkästchen verfügt über eine Standardaktion "Check" und den Wert "Deaktiviert".  
  
-   Eine Schaltfläche mit der Bezeichnung "Print" hat eine Default-Aktion "Press", ohne Wert.  
  
-   Eine Bezeichnung oder ein Textfeld-Steuerelement, das "Drucker" anzeigt, verfügt über keine Standardaktion, hat aber einen Wert von "Drucker".  
  
 Weitere Informationen zu Eigenschaften von Objekten zugegriffen werden kann, finden Sie unter [von beschreibenden Inhaltseigenschaften](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibleDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Beschreibung des von Clientanwendungen für die Barrierefreiheit verwendeten Steuerelements ab oder legt diese fest.</summary>
        <value>Die Beschreibung des von Clientanwendungen für die Barrierefreiheit verwendeten Steuerelements. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Objekt <xref:System.Windows.Forms.Control.AccessibleDescription%2A> Eigenschaft bietet eine textbeschreibung über visuelle Darstellung des Objekts. Die Beschreibung dient in erster Linie größer Kontext sehbehindert oder blind Benutzern bereitzustellen, aber es kann auch zum Kontext zu suchen oder anderen Anwendungen verwendet werden.  
  
 Die <xref:System.Windows.Forms.Control.AccessibleDescription%2A> Eigenschaft erforderlich, wenn die Beschreibung nicht offensichtlich ist, oder falls sie redundant ist anhand des Objekts <xref:System.Windows.Forms.Control.AccessibleName%2A>, <xref:System.Windows.Forms.Control.AccessibleRole%2A>, <xref:System.Windows.Forms.AccessibleObject.State%2A>, und <xref:System.Windows.Forms.AccessibleObject.Value%2A> Eigenschaften. Z. B. eine Schaltfläche "OK", würden keine zusätzlichen Informationen erforderlich, aber eine Schaltfläche, die ein Bild eines Kaktus zeigt, würde. Die <xref:System.Windows.Forms.Control.AccessibleName%2A>, und <xref:System.Windows.Forms.Control.AccessibleRole%2A> (und vielleicht <xref:System.Windows.Forms.AccessibleObject.Help%2A>) Eigenschaften der Kaktusschaltfläche würden ihren Zweck zu beschreiben, aber die <xref:System.Windows.Forms.Control.AccessibleDescription%2A> Eigenschaft übermitteln würde weniger konkrete Informationen, z. B. "Eine Schaltfläche, die ein Bild eines Kaktus zeigt".  
  
 Weitere Informationen zu Eigenschaften von Objekten zugegriffen werden kann, finden Sie unter [von beschreibenden Inhaltseigenschaften](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine Instanz des eine <xref:System.Windows.Forms.CheckBox> abgeleitete Klasse, `MyCheckBox`, weist ihm eine <xref:System.Drawing.Image> auf seine <xref:System.Windows.Forms.ButtonBase.Image%2A> Eigenschaft und legt die <xref:System.Windows.Forms.Control.AccessibleName%2A> und <xref:System.Windows.Forms.Control.AccessibleDescription%2A> Eigenschaften, da der <xref:System.Windows.Forms.Control.Text%2A> Eigenschaft ist `null`. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> mit dem Namen `MyForm`.  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibleName">
      <MemberSignature Language="C#" Value="public string AccessibleName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des von Clientanwendungen für die Barrierefreiheit verwendeten Steuerelements ab oder legt diesen fest.</summary>
        <value>Der Name des von Clientanwendungen für die Barrierefreiheit verwendeten Steuerelements. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.AccessibleName%2A> Eigenschaft ist eine Bezeichnung, die kurz beschreibt und identifiziert das Objekt in dessen Container, z. B. den Text in eine <xref:System.Windows.Forms.Button>, der Name des eine <xref:System.Windows.Forms.MenuItem>, oder eine Bezeichnung neben angezeigt ein <xref:System.Windows.Forms.TextBox> Steuerelement.  
  
 Weitere Informationen zu Eigenschaften von Objekten zugegriffen werden kann, finden Sie unter der "[Inhalt des beschreibenden Eigenschaften](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine Instanz des eine <xref:System.Windows.Forms.CheckBox> abgeleitete Klasse, `MyCheckBox`, weist ihm eine <xref:System.Drawing.Image> auf seine <xref:System.Windows.Forms.ButtonBase.Image%2A> Eigenschaft und legt die <xref:System.Windows.Forms.Control.AccessibleName%2A> und <xref:System.Windows.Forms.Control.AccessibleDescription%2A> Eigenschaften seit der <xref:System.Windows.Forms.Control.Text%2A> Eigenschaft ist `null`. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> mit dem Namen `MyForm`.  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibleRole">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleRole AccessibleRole { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AccessibleRole AccessibleRole" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleRole" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleRole</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die barrierefreie Rolle des Steuerelements ab oder legt diese fest.</summary>
        <value>Einer der Werte von <see cref="T:System.Windows.Forms.AccessibleRole" />. Die Standardeinstellung ist <see langword="Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.AccessibleRole%2A>-Eigenschaft beschreibt, zu welcher Art von Benutzeroberflächenelement ein Objekt gehört. Wenn die Rolle des Steuerelements nicht bestimmt werden kann, wird die <xref:System.Windows.Forms.Control.AccessibleRole%2A>-Eigenschaft auf `Default` festgelegt.  
  
 Weitere Informationen zu Eigenschaften von Objekten zugegriffen werden kann, finden Sie unter [von beschreibenden Inhaltseigenschaften](http://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der zugewiesene Wert ist nicht der <see cref="T:System.Windows.Forms.AccessibleRole" /> Werte.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public virtual bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement Daten annehmen kann, die vom Benutzer darauf gezogen wurden, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn Drag &amp; Drop-Vorgänge für das Steuerelement zulässig sind, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Code Beispiel kann der Benutzer ein Bild oder eine Bilddatei in das Formular ziehen und an dem Punkt darauf angezeigt werden, gelöscht wird. Die <xref:System.Windows.Forms.Control.OnPaint%2A> Methode wird überschrieben, um das Bild gezeichnet werden jedes Mal der Form gezeichnet wird, andernfalls das Bild nur bis zum nächsten Neuzeichnen beibehalten möchten. Die <xref:System.Windows.Forms.Control.DragEnter> Ereignisbehandlungsmethode bestimmt den Typ der Daten in das Formular gezogen wird, und das entsprechende Feedback enthält. Die <xref:System.Windows.Forms.Control.DragDrop> Ereignisbehandlungsmethode zeigt das Bild auf dem Formular ein, wenn ein <xref:System.Drawing.Image> aus Daten erstellt werden können. Da die <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> und <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> Werte sind Bildschirmkoordinaten, die im Beispiel wird die <xref:System.Windows.Forms.Control.PointToClient%2A> Methode, um sie in Clientkoordinaten zu konvertieren.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für uneingeschränkten Zwischenablagezugriff auf diese Eigenschaft festgelegt werden soll <see langword="true" />. Zugeordnete Enumeration: die <see langword="AllClipboard" /> Wert<see cref="T:System.Security.Permissions.UIPermissionClipboard" /></permission>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.AllowDrop" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.AllowDrop" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen. Sie müssen nicht beide außer Kraft setzen der <see langword="get" /> und <see langword="set" /> Accessoren der der <see cref="P:System.Windows.Forms.Control.AllowDrop" /> Eigenschaft; Sie können nur eine bei Bedarf überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Anchor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AnchorStyles Anchor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AnchorStyles Anchor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Anchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AnchorStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Ränder des Containers ab, an die ein Steuerelement gebunden ist, oder legt diese fest und bestimmt, wie die Größe des Steuerelements mit dessen übergeordnetem Element geändert wird.</summary>
        <value>Eine bitweise Kombination der <see cref="T:System.Windows.Forms.AnchorStyles" />-Werte. Der Standardwert ist <see langword="Top" /> und <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Forms.Control.Anchor%2A> Eigenschaft definieren, wie die Größe eines Steuerelements automatisch geändert wird, während das übergeordnete Steuerelement angepasst wird. Verankern ein Steuerelement am übergeordneten Steuerelement wird sichergestellt, dass die verankerten Kanten in der gleichen Position relativ zu den Rändern des übergeordneten Steuerelements beim Ändern der Größe des übergeordneten Steuerelements bleiben.  
  
 Sie können ein Steuerelement an eine oder mehrere Ränder des Containers verankern. Angenommen, Sie haben eine <xref:System.Windows.Forms.Form> mit einer <xref:System.Windows.Forms.Button> , deren <xref:System.Windows.Forms.Control.Anchor%2A> Eigenschaftswert festgelegt ist, um `Top` und `Bottom`, die <xref:System.Windows.Forms.Button> wird gestreckt, um das Verwalten des verankerten Abstands zur oberen und unteren Rand der <xref:System.Windows.Forms.Form>als die <xref:System.Windows.Forms.Control.Height%2A> von der <xref:System.Windows.Forms.Form> erhöht wird.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.Control.Anchor%2A> und <xref:System.Windows.Forms.Control.Dock%2A> Eigenschaften schließen sich gegenseitig. Zu einem Zeitpunkt kann nur festgelegt werden, und die letzte Gruppe hat Vorrang vor.  
  
   
  
## Examples  
 Das folgende Codebeispiel fügt ein <xref:System.Windows.Forms.Button> zu einem Formular und legt einige gemeinsamen Eigenschaften. Im Beispiel verankert die Schaltfläche, um der unteren rechten Ecke des Formulars, daher die relative Position behält der Größe des Formulars. Als Nächstes wird die <xref:System.Windows.Forms.Control.BackgroundImage%2A> und ändert die Größe der Schaltfläche, um die gleiche Größe wie die <xref:System.Drawing.Image>. Klicken Sie dann im Beispiel wird die <xref:System.Windows.Forms.Control.TabStop%2A> auf `true` und legt die <xref:System.Windows.Forms.Control.TabIndex%2A> Eigenschaft. Schließlich Fügt einen Ereignishandler behandeln die <xref:System.Windows.Forms.Control.Click> -Ereignis der Schaltfläche. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.ImageList> mit dem Namen `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.Anchor" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.Anchor" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen. Sie müssen nicht beide außer Kraft setzen der <see langword="get" /> und <see langword="set" /> Accessoren der der <see cref="P:System.Windows.Forms.Control.Anchor" /> Eigenschaft; Sie können nur eine bei Bedarf überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutoScrollOffset">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Point AutoScrollOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point AutoScrollOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Point), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft in <see cref="M:System.Windows.Forms.ScrollableControl.ScrollControlIntoView(System.Windows.Forms.Control)" /> ab oder legt anhand dessen fest, in welcher Richtung der Bildlauf dieses Steuerelements durchgeführt wird.</summary>
        <value>Ein <see cref="T:System.Drawing.Point" />, der die Bildlaufposition angibt. Der Standardwert ist die linke obere Ecke des Steuerelements.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public virtual bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Diese Eigenschaft ist für diese Klasse nicht relevant.</summary>
        <value>
          Im aktivierten Zustand <see langword="true" />, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.AutoSizeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dieses Ereignis ist für diese Klasse nicht relevant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-501)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Hintergrundfarbe für das Steuerelement ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Drawing.Color" />, die die Hintergrundfarbe des Steuerelements darstellt. Der Standardwert ist der Wert der <see cref="P:System.Windows.Forms.Control.DefaultBackColor" />-Eigenschaft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.BackColor%2A> Eigenschaft unterstützt keine transparente Farben aus, es sei denn, die `SupportsTransparentBackColor` Wert <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> festgelegt ist, um `true`.  
  
 Die <xref:System.Windows.Forms.Control.BackColor%2A> Eigenschaft ist eine ambient-Eigenschaft. Eine Ambiente-Eigenschaft ist eine Steuerelementeigenschaft, wenn nicht festgelegt ist, wird vom übergeordneten Steuerelement abgerufen. Z. B. eine <xref:System.Windows.Forms.Button> verfügen über denselben <xref:System.Windows.Forms.Control.BackColor%2A> wie das übergeordnete Objekt <xref:System.Windows.Forms.Form> standardmäßig. Weitere Informationen zu Umgebungseigenschaften, finden Sie unter der <xref:System.Windows.Forms.AmbientProperties> Klasse oder die <xref:System.Windows.Forms.Control> -Klassenübersicht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.BackColor%2A> und <xref:System.Windows.Forms.Control.ForeColor%2A> der Steuerelemente auf die Standardfarben für das System. Wenn das Steuerelement alle untergeordneten Steuerelemente verfügt, ruft der Code rekursiv selbst auf. Dieses Codebeispiel benötigen Sie ein <xref:System.Windows.Forms.Form> mit mindestens einem untergeordneten Steuerelement jedoch ein untergeordneter Container steuern, wie z. B. eine <xref:System.Windows.Forms.Panel> oder <xref:System.Windows.Forms.GroupBox>, mit einem eigenen untergeordneten Steuerelemente würde besser veranschaulichen die Rekursion.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.BackColor" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.BackColor" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen. Sie müssen nicht beide außer Kraft setzen der <see langword="get" /> und <see langword="set" /> Accessoren der der <see cref="P:System.Windows.Forms.Control.BackColor" /> Eigenschaft; Sie können nur eine bei Bedarf überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BackColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackColorChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.BackColor" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.BackColor%2A> -Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignishandler, der ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster *PropertyName* `Changed` , sind wird ausgelöst, wenn das entsprechende *PropertyName* -Wert ändert (* PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> , enthält eine <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das im Steuerelement angezeigte Hintergrundbild ab oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Drawing.Image" />, das das im Hintergrund des Steuerelements anzuzeigende Bild darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Verwenden der <xref:System.Windows.Forms.Control.BackgroundImage%2A> Eigenschaft, um ein Bild auf einem Steuerelement zu platzieren.  
  
> [!NOTE]
>  Bilder mit durchsichtigen oder transparenten Farben werden von Windows Forms-Steuerelementen als Hintergrundbilder nicht unterstützt.  
>   
>  Diese Eigenschaft wird nicht unterstützt, auf untergeordnete Steuerelemente, deren <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> Eigenschaft ist `true`.  
  
   
  
## Examples  
 Das folgende Codebeispiel fügt ein <xref:System.Windows.Forms.Button> zu einem Formular und legt einige gemeinsamen Eigenschaften. Im Beispiel verankert die Schaltfläche, um der unteren rechten Ecke des Formulars, daher die relative Position behält der Größe des Formulars. Als Nächstes wird die <xref:System.Windows.Forms.Control.BackgroundImage%2A> und ändert die Größe der Schaltfläche, um die gleiche Größe wie die <xref:System.Drawing.Image>. Klicken Sie dann im Beispiel wird die <xref:System.Windows.Forms.Control.TabStop%2A> auf `true` und legt die <xref:System.Windows.Forms.Control.TabIndex%2A> Eigenschaft. Schließlich Fügt einen Ereignishandler behandeln die <xref:System.Windows.Forms.Control.Click> -Ereignis der Schaltfläche. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.ImageList> mit dem Namen `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen. Sie müssen nicht beide außer Kraft setzen der <see langword="get" /> und <see langword="set" /> Accessoren der der <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> Eigenschaft; Sie können nur eine bei Bedarf überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.BackgroundImage" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.BackgroundImage%2A> -Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignishandler, der ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster *PropertyName* `Changed` , sind wird ausgelöst, wenn das entsprechende *PropertyName* -Wert ändert (* PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> , enthält eine <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, welches Hintergrundbildlayout gemäß der Definition in der <see cref="T:System.Windows.Forms.ImageLayout" />-Enumeration verwendet wird.</summary>
        <value>Einer der Werte von <see cref="T:System.Windows.Forms.ImageLayout" /> (<see cref="F:System.Windows.Forms.ImageLayout.Center" />, <see cref="F:System.Windows.Forms.ImageLayout.None" />, <see cref="F:System.Windows.Forms.ImageLayout.Stretch" />, <see cref="F:System.Windows.Forms.ImageLayout.Tile" /> oder <see cref="F:System.Windows.Forms.ImageLayout.Zoom" />). Der Standardwert lautet <see cref="F:System.Windows.Forms.ImageLayout.Tile" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> Eigenschaft, um anzugeben, die Position und das Verhalten eines Bilds, das Sie in einem Steuerelement abgelegt haben. <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A>wirkt sich nur dann, wenn die <xref:System.Windows.Forms.Control.BackgroundImage%2A> festgelegt wird.  
  
 Sie können die Leistung für große Bilder erhöhen, wenn Sie festlegen, <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> auf einen anderen Wert als <xref:System.Windows.Forms.ImageLayout.Tile>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der angegebene Aufzählungswert ist nicht vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich die <see cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> eigenschaftenänderungen entweder programmgesteuert oder durch eine Benutzerinteraktion.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#9)]
 [!code-vb[System.Windows.Forms.EventExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat für eine Methode, die keine Parameter annimmt.</param>
        <summary>Führt den angegebenen Delegaten asynchron für den Thread aus, in dem das dem Steuerelement zugrunde liegende Handle erstellt wurde.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das das Ergebnis der <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />-Operation darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat wird asynchron aufgerufen, und diese Methode wird sofort zurückgegeben. Von jedem Thread, auch den Thread, die das Handle des Steuerelements besitzt, können Sie diese Methode aufrufen. Wenn das Handle des Steuerelements noch nicht vorhanden ist, durchsucht dieser Methode Kette übergeordneter des Steuerelements bis zu einem Steuerelement oder ein Formular, das ein Fensterhandle besitzt. Wenn kein entsprechendes Handle gefunden werden kann, <xref:System.Windows.Forms.Control.BeginInvoke%2A> wird eine Ausnahme ausgelöst. Ausnahmen in der Delegatmethode gelten als nicht abgefangen und an die Anwendung nicht abgefangene Ausnahme-Handler gesendet werden.  
  
 Sie können Aufrufen <xref:System.Windows.Forms.Control.EndInvoke%2A> den Rückgabewert des Delegaten abgerufen, wenn erforderlich, aber dies ist nicht erforderlich. <xref:System.Windows.Forms.Control.EndInvoke%2A>blockiert, bis der Rückgabewert abgerufen werden kann.  
  
> [!NOTE]
>  Die meisten Methoden in einem Steuerelement können nur von dem Thread aufgerufen werden, auf das Steuerelement erstellt wurde. Zusätzlich zu den <xref:System.Windows.Forms.Control.InvokeRequired%2A> -Eigenschaft, es gibt vier Methoden für ein Steuerelement, die threadsicher sind: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, und <xref:System.Windows.Forms.Control.CreateGraphics%2A> , wenn das Handle für das Steuerelement bereits erstellt wurde. Aufrufen von <xref:System.Windows.Forms.Control.CreateGraphics%2A> , bevor das Handle des Steuerelements in einem Hintergrundthread erstellt werden können dazu führen, dass unzulässigen threadübergreifenden aufrufen. Für alle anderen Methodenaufrufe sollten Sie eine der Methoden Invoke verwenden, um den Aufruf an das Steuerelement-Thread zu marshallen. Die Invoke-Methoden rufen immer ihre Rückrufe auf Thread des Steuerelements.  
  
> [!NOTE]
>  Eine Ausnahme kann ausgelöst werden, wenn der Thread, der die Nachricht zu verarbeiten, sollten nicht mehr aktiv ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Windows.Forms.Control.BeginInvoke%2A> Methode.  
  
 [!code-cpp[Control_BeginInvoke#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#2)]
 [!code-csharp[Control_BeginInvoke#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#2)]
 [!code-vb[Control_BeginInvoke#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es kann keine entsprechenden Fensterhandle gefunden werden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat, der eine Methode, die mit Parametern über die gleiche Anzahl und Typ, der in enthalten sind die <c>Args</c> Parameter.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Dies kann <see langword="null" /> sein, wenn keine Argumente benötigt werden.</param>
        <summary>Führt den angegebenen Delegaten asynchron mit den angegebenen Argumenten für den Thread aus, in dem das diesem Steuerelement zugrunde liegende Handle erstellt wurde.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das das Ergebnis der <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />-Operation darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat wird asynchron aufgerufen, und diese Methode wird sofort zurückgegeben. Von jedem Thread, auch den Thread, die das Handle des Steuerelements besitzt, können Sie diese Methode aufrufen. Wenn das Handle des Steuerelements noch nicht vorhanden ist, durchsucht dieser Methode Kette übergeordneter des Steuerelements bis zu einem Steuerelement oder ein Formular, das ein Fensterhandle besitzt. Wenn kein entsprechendes Handle gefunden werden kann, <xref:System.Windows.Forms.Control.BeginInvoke%2A> wird eine Ausnahme ausgelöst. Ausnahmen in der Delegatmethode gelten als nicht abgefangen und an die Anwendung nicht abgefangene Ausnahme-Handler gesendet werden.  
  
 Sie können Aufrufen <xref:System.Windows.Forms.Control.EndInvoke%2A> den Rückgabewert des Delegaten abgerufen, wenn erforderlich, aber dies ist nicht erforderlich. <xref:System.Windows.Forms.Control.EndInvoke%2A>blockiert, bis der Rückgabewert abgerufen werden kann.  
  
> [!NOTE]
>  Die meisten Methoden in einem Steuerelement können nur von dem Thread aufgerufen werden, auf das Steuerelement erstellt wurde. Zusätzlich zu den <xref:System.Windows.Forms.Control.InvokeRequired%2A> -Eigenschaft, es gibt vier Methoden für ein Steuerelement, die threadsicher sind: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, und <xref:System.Windows.Forms.Control.CreateGraphics%2A> , wenn das Handle für das Steuerelement bereits erstellt wurde. Aufrufen von <xref:System.Windows.Forms.Control.CreateGraphics%2A> , bevor das Handle des Steuerelements in einem Hintergrundthread erstellt werden können dazu führen, dass unzulässigen threadübergreifenden aufrufen. Für alle anderen Methodenaufrufe sollten Sie eine der Methoden Invoke verwenden, um den Aufruf an das Steuerelement-Thread zu marshallen. Die Invoke-Methoden rufen immer ihre Rückrufe auf Thread des Steuerelements.  
  
> [!NOTE]
>  Eine Ausnahme kann ausgelöst werden, wenn der Thread, der die Nachricht zu verarbeiten, sollten nicht mehr aktiv ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Windows.Forms.Control.BeginInvoke%2A> Methode.  
  
 [!code-cpp[Control_BeginInvoke#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#1)]
 [!code-csharp[Control_BeginInvoke#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#1)]
 [!code-vb[Control_BeginInvoke#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es kann keine entsprechenden Fensterhandle gefunden werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="BindingContext">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.BindingContext BindingContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingContext BindingContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BindingContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Windows.Forms.BindingContext" /> für das Steuerelement ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.BindingContext" /> für das Steuerelement.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingContext> von einer <xref:System.Windows.Forms.Control> dient zum Zurückgeben einer einzelnen <xref:System.Windows.Forms.BindingManagerBase> für alle datengebundenen Steuerelemente enthalten die <xref:System.Windows.Forms.Control>. Die <xref:System.Windows.Forms.BindingManagerBase> behält alle Steuerelemente, die an die gleiche Datenquelle synchronisiert gebunden sind. Z. B. die <xref:System.Windows.Forms.BindingManagerBase.Position%2A> Eigenschaft von der <xref:System.Windows.Forms.BindingManagerBase> gibt das Element in der zugrunde liegenden Liste, die alle datengebundenen Steuerelemente zeigen.  
  
 Weitere Informationen zum Erstellen einer neuen <xref:System.Windows.Forms.BindingContext> und Zuweisen der <xref:System.Windows.Forms.Control.BindingContext%2A> Eigenschaft finden Sie unter der <xref:System.Windows.Forms.BindingContext.%23ctor%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt vier <xref:System.Windows.Forms.Binding> Objekte fünf Steuerelemente binden einer <xref:System.Windows.Forms.DateTimePicker> und vier <xref:System.Windows.Forms.TextBox> Steuerelemente auf mehrere Datenquellen. Die <xref:System.Windows.Forms.BindingContext> dient dann zum Abrufen der <xref:System.Windows.Forms.BindingManagerBase> für jede Datenquelle.  
  
 [!code-cpp[Classic BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.BindingContext" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.BindingContext" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen. Sie müssen nicht beide außer Kraft setzen der <see langword="get" /> und <see langword="set" /> Accessoren der der <see cref="P:System.Windows.Forms.Control.BindingContext" /> Eigenschaft; Sie können nur eine bei Bedarf überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BindingContextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BindingContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BindingContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BindingContextChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="T:System.Windows.Forms.BindingContext" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Hinzufügen einer neuen <xref:System.Windows.Forms.BindingContext> auf die <xref:System.Windows.Forms.Control> über die <xref:System.Windows.Forms.Control.BindingContext%2A> Eigenschaft finden Sie unter der <xref:System.Windows.Forms.BindingContext.%23ctor%2A> Konstruktor.  
  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.BindingContext%2A> -Eigenschaft geändert wird, die durch eine programmgesteuerte Änderung oder die Interaktion des Benutzers geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel fügt ein <xref:System.EventHandler> zum Delegieren der <xref:System.Windows.Forms.Control.BindingContextChanged> -Ereignis für ein <xref:System.Windows.Forms.TextBox> Steuerelement.  
  
 [!code-cpp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CS/source.cs#1)]
 [!code-vb[Classic Control.BindingContextChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bottom">
      <MemberSignature Language="C#" Value="public int Bottom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Bottom" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bottom" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Abstand zwischen dem unteren Rand des Steuerelements und dem oberen Rand des Clientbereichs des zugehörigen Containers in Pixel ab.</summary>
        <value>Ein <see cref="T:System.Int32" />-Wert, der den Abstand zwischen dem unteren Rand des Steuerelements und dem oberen Rand des Clientbereichs des zugehörigen Containers in Pixel darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft entspricht der Summe aus der <xref:System.Windows.Forms.Control.Top%2A> Eigenschaftswert, und die <xref:System.Windows.Forms.Control.Height%2A> Eigenschaftswert.  
  
 Die <xref:System.Windows.Forms.Control.Bottom%2A> Eigenschaft ist eine schreibgeschützte Eigenschaft. Können Sie durch Ändern des Werts der Wert dieser Eigenschaft ändern die <xref:System.Windows.Forms.Control.Top%2A> oder <xref:System.Windows.Forms.Control.Height%2A> Eigenschaften oder das Aufrufen der <xref:System.Windows.Forms.Control.SetBounds%2A>, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, <xref:System.Windows.Forms.Control.UpdateBounds%2A>, oder <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.Bottom%2A> Eigenschaft, um die untere Grenze der definieren eine <xref:System.Windows.Forms.TextBox> -Steuerelement relativ zum Clientbereich des Containers.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle Bounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle Bounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe und die Position des Steuerelements, einschließlich seiner Nicht-Clientelemente, in Pixel relativ zum übergeordneten Steuerelement ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Drawing.Rectangle" /> in Pixel relativ to zum übergeordneten Steuerelement, das die Größe und Position des Steuerelements darstellt, einschließlich seiner Nicht-Clientelemente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Grenzen des Steuerelements enthalten, der nicht-Clientelemente z. B. Bildlaufleisten, Rahmen, Titelleisten und Menüs. Die <xref:System.Windows.Forms.Control.SetBoundsCore%2A> Methode wird aufgerufen, um das Festlegen der <xref:System.Windows.Forms.Control.Bounds%2A> Eigenschaft. Die <xref:System.Windows.Forms.Control.Bounds%2A> Eigenschaft wird nicht immer über geändert seine `set` Methode, sodass Sie überschreiben soll die <xref:System.Windows.Forms.Control.SetBoundsCore%2A> Methode, um sicherzustellen, dass der Code ausgeführt wird bei der <xref:System.Windows.Forms.Control.Bounds%2A> festgelegt wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt drei <xref:System.Windows.Forms.Button> Steuerelemente eines Formulars und legt deren Größe und Position mithilfe der verschiedenen hinsichtlich der Größe und Position-bezogene Eigenschaften. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> , besitzt eine Breite und Höhe von mindestens 300 Pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BringToFront">
      <MemberSignature Language="C#" Value="public void BringToFront ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringToFront() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BringToFront" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zeigt dieses Steuerelement am Anfang der z-Reihenfolge an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Steuerelement wird am Anfang der Z-Reihenfolge verschoben. Wenn das Steuerelement ein untergeordnetes Element eines anderen Steuerelements ist, wird das untergeordnete Steuerelement am Anfang der Z-Reihenfolge verschoben. <xref:System.Windows.Forms.Control.BringToFront%2A>unterstützt keine stellen, die ein Steuerelement ein Steuerelement der obersten Ebene, und es wird nicht ausgelöst. die <xref:System.Windows.Forms.Control.Paint> Ereignis.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird sichergestellt, dass eine <xref:System.Windows.Forms.Label> sichtbar ist, durch Aufrufen seiner <xref:System.Windows.Forms.Control.BringToFront%2A> Methode. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> mit einem <xref:System.Windows.Forms.Panel> mit dem Namen `panel1`, und ein <xref:System.Windows.Forms.Label> mit dem Namen `label1`.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected virtual bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanEnableIme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="P:System.Windows.Forms.Control.ImeMode" />-Eigenschaft auf einen aktiven Wert festgelegt werden kann, um IME-Unterstützung zu aktivieren.</summary>
        <value>
          <see langword="true" /> in allen Fällen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen können überschreiben diese-Eigenschaft zum Zurückgeben von `false` Wenn Eingabemethoden-Editor nicht unterstützt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFocus">
      <MemberSignature Language="C#" Value="public bool CanFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement den Fokus erhalten kann.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement den Fokus erhalten kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Damit für ein Steuerelement Eingabefokus erhält, muss das Steuerelement ein Handle zugewiesen, verfügen und die <xref:System.Windows.Forms.Control.Visible%2A> und <xref:System.Windows.Forms.Control.Enabled%2A> Eigenschaften müssen beide auf festgelegt werden `true` für sowohl das Steuerelement und alle übergeordneten Steuerelemente und das Steuerelement einem Formular sein müssen oder die äußersten übergeordneten Steuerelement muss ein Formular.  
  
   
  
## Examples  
 Das folgende Codebeispiel legt den Fokus auf den angegebenen <xref:System.Windows.Forms.Control>, wenn es den Fokus erhalten kann.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRaiseEvents">
      <MemberSignature Language="C#" Value="protected override bool CanRaiseEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRaiseEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt fest, ob Ereignisse für das Steuerelement ausgelöst werden können.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement als ActiveX-Steuerelement gehostet wird, dessen Ereignisse nicht eingefroren sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Steuerelement als ActiveX-Steuerelement gehostet wird, wird diese Eigenschaft zurückgeben `false` , wenn das ActiveX-Steuerelement seine Ereignisse eingefroren wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSelect">
      <MemberSignature Language="C#" Value="public bool CanSelect { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSelect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanSelect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement ausgewählt werden kann.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement ausgewählt werden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `true` Wenn die `Selectable` Wert <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> auf festgelegt ist `true`wird in ein anderes Steuerelement enthalten, die das Steuerelement selbst ist sichtbar und aktiviert und alle übergeordneten Steuerelemente werden sichtbar und aktiviert.  
  
 Windows Forms-Steuerelemente in der folgenden Liste sind nicht auswählbar und gibt den Wert der `false` für die <xref:System.Windows.Forms.Control.CanSelect%2A> Eigenschaft. Von diesen Steuerelementen abgeleitete Steuerelemente sind ebenfalls nicht ausgewählt werden.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel>(Wenn kein Link im Steuerelement vorhanden ist)  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das angegebene wählt <xref:System.Windows.Forms.Control>, wenn er ausgewählt werden kann.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public bool Capture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Capture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Capture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Maus vom Steuerelement erfasst wurde, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die Maus vom Steuerelement erfasst wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Steuerelement die Maus erfasst hat, empfängt es Mauseingaben, und zwar unabhängig davon, ob der Cursor innerhalb seiner Grenzen befindet. Die Maus ist in der Regel nur während eines Ziehvorgangs erfasst.  
  
 Nur Vordergrundfenster kann die Maus erfassen. Wenn ein Hintergrundfenster im versucht, die dazu, empfängt das Fenster Nachrichten nur für Mausereignisse, die auftreten, wenn der Mauszeiger innerhalb der sichtbare Teil des Fensters befindet. Darüber hinaus auch, wenn das Fenster im Vordergrund die Maus erfasst hat, kann der Benutzer noch ein weiteres Fenster klicken er in den Vordergrund gestellt.  
  
 Wenn die Maus erfasst wird, sollten Tastenkombinationen funktionieren nicht.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Windows.Forms.Control.Capture%2A> Eigenschaft. Zum Ausführen dieses Beispiels fügen Sie folgenden code in ein Formular mit einem <xref:System.Windows.Forms.Label> mit dem Namen label1 und zwei <xref:System.Windows.Forms.ListBox> Steuerelemente mit dem Namen listbox1 und ListBox2 enthält. Stellen Sie sicher, das Formular und die Steuerelemente <xref:System.Windows.Forms.Control.MouseDown> Ereignis bezieht sich auf die Methode in diesem Beispiel.  
  
 [!code-cpp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlCapture#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster zum Wert dieser Eigenschaft festgelegt. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CausesValidation">
      <MemberSignature Language="C#" Value="public bool CausesValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CausesValidation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CausesValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement bei Erhalt des Fokus eine Validierung für alle eine Validierung erfordernden Steuerelemente veranlasst, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement eine Validierung für alle eine Validierung erfordernden Steuerelemente veranlasst, wenn es den Fokus erhält, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A> -Eigenschaftensatz auf `false`, <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> Ereignisse werden unterdrückt.  
  
 Die <xref:System.Windows.Forms.Control.CausesValidation%2A> in der Regel festgelegt ist `false` für Steuerelemente, z. B. eine Schaltfläche "Hilfe".  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die abgeleitete Klasse <xref:System.Windows.Forms.TextBox> und überprüft eine e-Mail-Adresse, die der Benutzer eingibt. Wenn die e-Mail-Adresse nicht in das Standardformat ist (mit "@" and "."), die Überprüfung fehlschlägt, eine <xref:System.Windows.Forms.ErrorProvider> -Symbol wird angezeigt, und das Ereignis abgebrochen wird. Eine der Schaltflächen auf dem Formular hat seine <xref:System.Windows.Forms.Control.CausesValidation%2A> -Eigenschaftensatz auf `false`. Klicken Sie auf, oder Festlegen des Fokus auf diese Schaltfläche wird keine Überprüfung ausgelöst. Dieses Beispiel erfordert, dass eine <xref:System.Windows.Forms.TextBox>, wird ein <xref:System.Windows.Forms.ErrorProvider> -Steuerelement, und ein <xref:System.Windows.Forms.Button> in einem Formular erstellt wurden.  
  
 [!code-cpp[Control.Validating#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#2)]
 [!code-csharp[Control.Validating#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#2)]
 [!code-vb[Control.Validating#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CausesValidationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CausesValidationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CausesValidationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CausesValidationChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.CausesValidation" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A> -Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeUICues">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.UICuesEventHandler ChangeUICues;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.UICuesEventHandler ChangeUICues" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ChangeUICues" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.UICuesEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich die Hinweise auf den Fokus oder die Tastatur-Benutzeroberfläche ändern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.ChangeUICues> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.ChangeUICues> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#67](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#67)]
 [!code-vb[System.Windows.Forms.EventExamples#67](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#67)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForIllegalCrossThreadCalls">
      <MemberSignature Language="C#" Value="public static bool CheckForIllegalCrossThreadCalls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob Aufrufe an den falschen Thread, der auf die <see cref="P:System.Windows.Forms.Control.Handle" />-Eigenschaft eines Steuerelements zugreift, abgefangen werden sollen, wenn eine Anwendung gedebuggt wird, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn Aufrufe an den falschen Thread abgefangen werden sollen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein anderen Thread als der erstellende Thread eines Steuerelements versucht, eine der Methoden oder Eigenschaften des Steuerelements zuzugreifen, führt dies häufig zu unvorhersehbaren Ergebnissen. Eine allgemeine ungültige Threadaktivität ist ein Aufruf an den falschen Thread, der des Steuerelements zugreift <xref:System.Windows.Forms.Control.Handle%2A> Eigenschaft. Legen Sie <xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A> auf `true` zum Suchen und diese Threadaktivität leichter diagnostizieren, während des Debuggens.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Click" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Klicken auf das Steuerelement ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Click> Ereignis übergibt es ein <xref:System.EventArgs> an den Ereignishandler, sodass nur darauf, dass mit einem Klick aufgetreten ist. Wenn Sie spezifischere Mausinformationen (Schaltfläche, Anzahl der Klicks, Drehen des Mausrades oder Speicherort), verwenden die <xref:System.Windows.Forms.Control.MouseClick> Ereignis. Allerdings die <xref:System.Windows.Forms.Control.MouseClick> Ereignis wird nicht ausgelöst werden, wenn die von der Aktion als dem der Maus, z. B. durch Drücken der EINGABETASTE verursacht wurde.  
  
 Ein Doppelklick wird durch die mauseinstellungen des Betriebssystems des Benutzers bestimmt. Der Benutzer kann den Zeitraum festlegen, innerhalb dessen der zweite Mausklick erfolgen muss, damit zwei aufeinander folgende Mausklicks als Doppelklick erkannt werden. Die <xref:System.Windows.Forms.Control.Click> Ereignis wird jedes Mal, wenn ein Steuerelement doppelgeklickt wird. Angenommen, Sie haben die Ereignishandler für die <xref:System.Windows.Forms.Control.Click> und <xref:System.Windows.Forms.Control.DoubleClick> Ereignisse von einem <xref:System.Windows.Forms.Form>, die <xref:System.Windows.Forms.Control.Click> und <xref:System.Windows.Forms.Control.DoubleClick> Ereignisse werden ausgelöst, wenn das Formular doppelgeklickt wird, und beide Methoden aufgerufen werden. Wenn ein Steuerelement doppelgeklickt wird und dass Steuerelement nicht unterstützt die <xref:System.Windows.Forms.Control.DoubleClick> -Ereignis der <xref:System.Windows.Forms.Control.Click> Ereignis möglicherweise zweimal ausgelöst.  
  
 Müssen Sie festlegen der `StandardClick` Wert <xref:System.Windows.Forms.ControlStyles> auf `true` für dieses Ereignis ausgelöst werden soll.  
  
> [!NOTE]
>  Die folgenden Ereignisse werden nicht ausgelöst, für die <xref:System.Windows.Forms.TabControl> -Klasse, es sei denn, es ist mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> Auflistung: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn mindestens ein ist <xref:System.Windows.Forms.TabPage> in der Auflistung und Interaktion des Benutzers mit dem Registerkarten-Steuerelement-Header (, in dem die <xref:System.Windows.Forms.TabPage> Namen angezeigt werden), wird die <xref:System.Windows.Forms.TabControl> des entsprechenden Ereignisses. Jedoch, wenn das Eingreifen des Benutzers innerhalb der Clientbereich der Registerkartenseite der <xref:System.Windows.Forms.TabPage> des entsprechenden Ereignisses.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die <xref:System.Windows.Forms.Control.Click> Ereignis in einem Ereignishandler.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Erben von einer standardmäßigen Windows Forms-Steuerelement, und Ändern der <see langword="StandardClick" /> oder <see langword="StandardDoubleClick" /> Werte <see cref="T:System.Windows.Forms.ControlStyles" /> auf <see langword="true" /> kann unerwartetes Verhalten verursachen oder überhaupt haben keine Auswirkung, wenn das Steuerelement nicht unterstützt die <see cref="E:System.Windows.Forms.Control.Click" /> oder <see cref="E:System.Windows.Forms.Control.DoubleClick" />Ereignisse.  
  
 Die folgende Tabelle enthält die Windows Forms-Steuerelemente und welches Ereignis (<see cref="E:System.Windows.Forms.Control.Click" /> oder <see cref="E:System.Windows.Forms.Control.DoubleClick" />) wird als Antwort auf die angegebene Mausaktion ausgelöst.  
  
 <list type="table"><listheader><term>Steuerelement  
  
 </term><description>Klicken mit der linken Maustaste  
  
 </description><description>Doppelklicken mit der linken Maustaste  
  
 </description><description>Klicken mit der rechten Maustaste  
  
 </description><description>Doppelklicken mit der rechten Maustaste  
  
 </description><description>Klicken mit der mittleren Maustaste  
  
 </description><description>Mittlere Maustaste doppelklicken.  
  
 </description><description>XButton1 Mausklick  
  
 </description><description>Doppelklick XButton1  
  
 </description><description>XButton2 Mausklick  
  
 </description><description>Doppelklick XButton2  
  
 </description></listheader><item><term><see cref="T:System.Windows.Forms.MonthCalendar" />,  
  
 <see cref="T:System.Windows.Forms.DateTimePicker" />,  
  
 <see cref="T:System.Windows.Forms.HScrollBar" />,  
  
 <see cref="T:System.Windows.Forms.VScrollBar" /></term><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Button" />,  
  
 <see cref="T:System.Windows.Forms.CheckBox" />,  
  
 <see cref="T:System.Windows.Forms.RichTextBox" />,  
  
 <see cref="T:System.Windows.Forms.RadioButton" /></term><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, klicken Sie auf  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ListBox" />,  
  
 <see cref="T:System.Windows.Forms.CheckedListBox" />,  
  
 <see cref="T:System.Windows.Forms.ComboBox" /></term><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.TextBox" />,  
  
 <see cref="T:System.Windows.Forms.DomainUpDown" />,  
  
 <see cref="T:System.Windows.Forms.NumericUpDown" /></term><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description></item><item><term> * <see cref="T:System.Windows.Forms.TreeView" />,  
  
 \*<see cref="T:System.Windows.Forms.ListView" /> </term> <description> Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ProgressBar" />,  
  
 <see cref="T:System.Windows.Forms.TrackBar" /></term><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, klicken Sie auf  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, klicken Sie auf  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, klicken Sie auf  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, klicken Sie auf  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, klicken Sie auf  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Form" />,  
  
 <see cref="T:System.Windows.Forms.DataGrid" />,  
  
 <see cref="T:System.Windows.Forms.Label" />,  
  
 <see cref="T:System.Windows.Forms.LinkLabel" />,  
  
 <see cref="T:System.Windows.Forms.Panel" />,  
  
 <see cref="T:System.Windows.Forms.GroupBox" />,  
  
 <see cref="T:System.Windows.Forms.PictureBox" />,  
  
 <see cref="T:System.Windows.Forms.Splitter" />,  
  
 <see cref="T:System.Windows.Forms.StatusBar" />,  
  
 <see cref="T:System.Windows.Forms.ToolBar" />,  
  
 <see cref="T:System.Windows.Forms.TabPage" />,  
  
 ** <see cref="T:System.Windows.Forms.TabControl" /></term><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description></item></list>  
  
 \*Der Mauszeiger über ein untergeordnetes Objekt sein (<see cref="T:System.Windows.Forms.TreeNode" /> oder <see cref="T:System.Windows.Forms.ListViewItem" />).  
  
 ** Der <see cref="T:System.Windows.Forms.TabControl" /> müssen, verfügen Sie über mindestens einen <see cref="T:System.Windows.Forms.TabPage" /> in seiner <see cref="P:System.Windows.Forms.TabControl.TabPages" /> Auflistung.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Rechteck ab, das den Clientbereich des Steuerelements darstellt.</summary>
        <value>Ein <see cref="T:System.Drawing.Rectangle" />, das den Clientbereich des Steuerelements darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das den Clientbereich eines Steuerelements wird die Begrenzungen des Steuerelements, minus der nicht-Clientelemente z. B. Bildlaufleisten, Rahmen, Titelleisten und Menüs.  
  
 Da Clientkoordinaten relativ zur linken oberen Ecke des Clientbereichs des Steuerelements befinden, sind die Koordinaten der oberen linken Ecke des Rechtecks, das von dieser Eigenschaft zurückgegebene (0,0). Sie können diese Eigenschaft verwenden, um die Größe und die Koordinaten des Clientbereichs des Steuerelements für Aufgaben wie Zeichnen auf der Oberfläche des Steuerelements abzurufen.  
  
 Weitere Informationen zum Zeichnen auf Steuerelementen finden Sie unter [Rendern eines Windows Forms-Steuerelements](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für ein Formular automatischen Bildlauf ermöglicht, ändert die Größe des Formulars und stellt sicher, dass eine Schaltfläche sichtbar bleibt, nachdem die Größe des Formulars. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> mit einem <xref:System.Windows.Forms.Button> mit dem Namen `button2` darauf.  
  
 [!code-cpp[Windows.Forms.Control Member5#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#2)]
 [!code-csharp[Windows.Forms.Control Member5#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#2)]
 [!code-vb[Windows.Forms.Control Member5#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe und Breite des Clientbereichs des Steuerelements ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Drawing.Size" />, das die Abmessungen des Clientbereichs des Steuerelements darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das den Clientbereich eines Steuerelements wird die Begrenzungen des Steuerelements, minus der nicht-Clientelemente z. B. Bildlaufleisten, Rahmen, Titelleisten und Menüs. Die <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> Methode wird aufgerufen, um das Festlegen der <xref:System.Windows.Forms.Control.ClientSize%2A> Eigenschaft. Die <xref:System.Windows.Forms.Control.ClientSize%2A> Eigenschaft wird nicht immer über geändert seine `set` Methode, sodass Sie überschreiben soll die <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> Methode, um sicherzustellen, dass der Code ausgeführt wird bei der <xref:System.Windows.Forms.Control.ClientSize%2A> festgelegt wird.  
  
 Die <xref:System.Drawing.Size.Width%2A?displayProperty=nameWithType> und <xref:System.Drawing.Size.Height%2A?displayProperty=nameWithType> Eigenschaften darstellen, die Breite und Höhe des Clientbereichs des Steuerelements. Sie können diese Eigenschaft verwenden, um die Größe des Clientbereichs des Steuerelements für Aufgaben wie Zeichnen auf der Oberfläche des Steuerelements abzurufen.  
  
 Weitere Informationen zum Zeichnen auf Steuerelementen finden Sie unter [Rendern eines Windows Forms-Steuerelements](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).  
  
> [!NOTE]
>  Anwendungseinstellungen können auf diese Eigenschaft kann nicht gebunden werden. Weitere Informationen zu Anwendungseinstellungen, finden Sie unter [Übersicht über Anwendungseinstellungen](~/docs/framework/winforms/advanced/application-settings-overview.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das angegebene Steuerelement ändert, damit das Steuerelement den formatierten Text angepasst wird. Der formatierte Text ist die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaft mit dem Steuerelement zugewiesen <xref:System.Windows.Forms.Control.Font%2A> auf den Text angewendet. Die `AutoSizeControl` Methode in diesem Beispiel verfügt auch über eine `textPadding` Parameter, der die Auffüllung anzuwendende an allen Rändern des Steuerelements darstellt. Damit der Leerraum gleich angezeigt wird, richtet den Text der <xref:System.Drawing.ContentAlignment?displayProperty=nameWithType> Wert, wenn das Steuerelement unterstützt.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ClientSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ClientSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ClientSizeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.ClientSize" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.ClientSizeChanged> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.ClientSizeChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#12)]
 [!code-vb[System.Windows.Forms.EventExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Description("ControlCompanyNameDescr")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Unternehmens oder des Entwicklers der Anwendung ab, die das Steuerelement enthält.</summary>
        <value>Der Name des Unternehmens oder des Entwicklers der Anwendung, die das Steuerelement enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.CompanyName%2A> Eigenschaft ist eine schreibgeschützte Eigenschaft. Um den Wert dieser Eigenschaft ändern, legen die <xref:System.Reflection.AssemblyCompanyAttribute.Company%2A> Eigenschaftswert, der die <xref:System.Reflection.AssemblyCompanyAttribute>. Die folgende Zeile der C#-Code legt die <xref:System.Windows.Forms.Control.CompanyName%2A> Eigenschaft.  
  
```csharp  
[assembly: AssemblyCompany("Microsoft")]  
```  
  
> [!NOTE]
>  Es wird dringend empfohlen, dass Sie den Firmennamen, Produktname und Produktversion für Ihre app bereitstellen.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt Informationen über die Anwendung in einem <xref:System.Windows.Forms.Label> enthalten eine <xref:System.Windows.Forms.Form>. Dieses Beispiel erfordert, dass die <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> und <xref:System.Windows.Forms.Control.ProductVersion%2A> festgelegt wurden.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Forms.Control ctl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Windows.Forms.Control ctl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Contains(System.Windows.Forms.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="ctl">Der auszuwertende <see cref="T:System.Windows.Forms.Control" />.</param>
        <summary>Ruft einen Wert ab, der angibt, ob das angegebene Steuerelement dem Steuerelement untergeordnet ist.</summary>
        <returns>
          <see langword="true" />, wenn das angegebene Steuerelement dem Steuerelement untergeordnet ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird sichergestellt, dass eine <xref:System.Windows.Forms.Label> sichtbar ist, durch Aufrufen seiner <xref:System.Windows.Forms.Control.BringToFront%2A> Methode. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> mit einem <xref:System.Windows.Forms.Panel> mit dem Namen `panel1`, und ein <xref:System.Windows.Forms.Label> mit dem Namen `label1`.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsFocus">
      <MemberSignature Language="C#" Value="public bool ContainsFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContainsFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement oder eines der untergeordneten Steuerelemente den Eingabefokus besitzt.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement oder eines der untergeordneten Steuerelemente den Eingabefokus besitzt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft verwenden, um zu bestimmen, ob ein Steuerelement oder eines der darin enthaltenen Steuerelemente den Eingabefokus besitzt. Verwenden, um zu bestimmen, ob das Steuerelement den Fokus hat, unabhängig davon, ob alle untergeordneten Steuerelemente den Fokus besitzt die <xref:System.Windows.Forms.Control.Focused%2A> Eigenschaft. Wenn ein Steuerelement den Eingabefokus umbenennen möchten, verwenden Sie die <xref:System.Windows.Forms.Control.Focus%2A> oder <xref:System.Windows.Forms.Control.Select%2A> Methoden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das dem Steuerelement zugeordnete Kontextmenü ab oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.ContextMenu" />, das das diesem Steuerelement zugeordnete Kontextmenü darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mithilfe von Kontextmenüs kontextspezifische Menüoptionen für Benutzer gewähren, wenn sie mit der rechten auf das Steuerelement Maustaste.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.ContextMenu> zugewiesene eine <xref:System.Windows.Forms.TreeView> Wenn die rechte Maustaste gedrückt und losgelassen wird. Dieser Code erfordert, dass Sie haben eine <xref:System.Windows.Forms.Form> mit einem <xref:System.Windows.Forms.TreeView> darauf. Es ist auch erforderlich, die die <xref:System.Windows.Forms.TreeView> verfügt über eine <xref:System.Windows.Forms.ContextMenu> zugewiesen seine <xref:System.Windows.Forms.Control.ContextMenu%2A> Eigenschaft.  
  
 [!code-cpp[Windows.Forms.Control Properties2#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#5)]
 [!code-csharp[Windows.Forms.Control Properties2#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#5)]
 [!code-vb[Windows.Forms.Control Properties2#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.ContextMenu" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.ContextMenu" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen. Sie müssen nicht beide außer Kraft setzen der <see langword="get" /> und <see langword="set" /> Accessoren der der <see cref="P:System.Windows.Forms.Control.ContextMenu" /> Eigenschaft; Sie können nur eine bei Bedarf überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.ContextMenu" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.ContextMenu%2A> -Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Meldung angezeigt, bei eine Änderung im Kontextmenü.  
  
 [!code-cpp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CPP/control_contextmenu_creategraphics.cpp#2)]
 [!code-csharp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CS/control_contextmenu_creategraphics.cs#2)]
 [!code-vb[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/VB/control_contextmenu_creategraphics.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStrip">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenuStrip ContextMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenuStrip ContextMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die diesem Steuerelement zugeordnete <see cref="T:System.Windows.Forms.ContextMenuStrip" />-Klasse ab oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Windows.Forms.ContextMenuStrip" /> für dieses Steuerelement, oder <see langword="null" />, wenn keine <see cref="T:System.Windows.Forms.ContextMenuStrip" /> vorhanden ist. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Windows.Forms.ContextMenu> auch dem Steuerelement zugewiesen wurde die <xref:System.Windows.Forms.ContextMenu> hat Vorrang vor den <xref:System.Windows.Forms.ContextMenuStrip>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Hinzufügen von drei <xref:System.Windows.Forms.ToolStripMenuItem> Datenbankobjekte in einem <xref:System.Windows.Forms.ContextMenuStrip>. Es zeigt darüber hinaus die Einstellung der <xref:System.Windows.Forms.Control.ContextMenuStrip%2A> -Eigenschaft des Formulars.  
  
 [!code-csharp[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStripChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuStripChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuStripChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuStripChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.ContextMenuStrip" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.ContextMenuStripChanged> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.ContextMenuStripChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#14)]
 [!code-vb[System.Windows.Forms.EventExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlAdded">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlAdded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlAdded" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="T:System.Windows.Forms.Control.ControlCollection" /> ein neues Steuerelement hinzugefügt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit <xref:System.Windows.Forms.Control.ControlAdded> Hinzufügen des Steuerelements zu einem Formular und zeigt den Namen des hinzugefügten Steuerelements in einer <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlRemoved">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlRemoved" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Entfernen des Steuerelements aus der <see cref="T:System.Windows.Forms.Control.ControlCollection" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit <xref:System.Windows.Forms.Control.ControlRemoved> ein Steuerelement aus einem Formular zu entfernen und zeigt den Namen des entfernten Steuerelements in einer <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control/ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die im Steuerelement enthaltene Auflistung von Steuerelementen ab.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.Control.ControlCollection" />, die die Auflistung der im Steuerelement enthaltenen Steuerelemente darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Forms.Control> kann als übergeordnetes Element einer Auflistung von Steuerelemente fungieren. Z. B. wenn mehrere Steuerelemente hinzugefügt werden eine <xref:System.Windows.Forms.Form>, jedes Steuerelement ist ein Mitglied der <xref:System.Windows.Forms.Control.ControlCollection> zugewiesene der <xref:System.Windows.Forms.Control.Controls%2A> -Eigenschaft des Formulars, das von abgeleitet ist die <xref:System.Windows.Forms.Control> Klasse.  
  
 Können Sie die Steuerelemente im Ändern der <xref:System.Windows.Forms.Control.ControlCollection> zugewiesene der <xref:System.Windows.Forms.Control.Controls%2A> Eigenschaft mithilfe der Methoden zur Verfügung, in der <xref:System.Windows.Forms.Control.ControlCollection> Klasse.  
  
 Wenn mehrere Steuerelemente einem übergeordneten Steuerelement hinzufügen, wird empfohlen, Sie rufen die <xref:System.Windows.Forms.Control.SuspendLayout%2A> -Methode vor dem Initialisieren der Steuerelemente hinzugefügt werden. Rufen Sie nach dem Hinzufügen der Steuerelemente an das übergeordnete Steuerelement an, die <xref:System.Windows.Forms.Control.ResumeLayout%2A> Methode. Auf diese Weise wird die Leistung von Anwendungen mit vielen Steuerelementen erhöhen.  
  
 Verwenden der <xref:System.Windows.Forms.Control.Controls%2A> Eigenschaft zum Durchlaufen aller Steuerelemente eines Formulars, einschließlich geschachtelter Steuerelemente. Verwenden der <xref:System.Windows.Forms.Control.GetNextControl%2A> Methode, um das vorherige oder nächste untergeordnete Steuerelement in der Aktivierreihenfolge abzurufen. Verwenden der <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> Eigenschaft zum Abrufen oder Festlegen eines Containersteuerelements des zum aktiven Steuerelements.  
  
   
  
## Examples  
 Im folgenden Codebeispiel Beispiel entfernt eine <xref:System.Windows.Forms.Control> aus der <xref:System.Windows.Forms.Control.ControlCollection> der abgeleiteten Klasse <xref:System.Windows.Forms.Panel> ist ein Member der Auflistung. Im Beispiel erfordert, dass Sie erstellt haben eine <xref:System.Windows.Forms.Panel>, <xref:System.Windows.Forms.Button>, und mindestens eine <xref:System.Windows.Forms.RadioButton> control für eine <xref:System.Windows.Forms.Form>. Die <xref:System.Windows.Forms.RadioButton> Steuerelemente hinzugefügt werden die <xref:System.Windows.Forms.Panel> -Steuerelement, und die <xref:System.Windows.Forms.Panel> ein Steuerelement hinzugefügt wurde, um die <xref:System.Windows.Forms.Form>. Wenn die Schaltfläche klicken, wird das Optionsfeld mit dem Namen `removeButton` wird daraus der <xref:System.Windows.Forms.Control.ControlCollection>.  
  
 [!code-cpp[ControlCollection#4](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlCollection/CPP/controlcollection.cpp#4)]
 [!code-csharp[ControlCollection#4](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlCollection/CS/controlcollection.cs#4)]
 [!code-vb[ControlCollection#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlCollection/VB/controlcollection.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein neues Objekt für die Barrierefreiheit für das Steuerelement.</summary>
        <returns>Ein neues <see cref="T:System.Windows.Forms.AccessibleObject" /> für das Steuerelement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>-Methode nicht explizit aufrufen, wird sie beim Verweis auf die <xref:System.Windows.Forms.Control.AccessibilityObject%2A>-Eigenschaft aufgerufen.  
  
> [!NOTE]
>  Zum Abrufen oder Festlegen der <xref:System.Windows.Forms.Control.AccessibilityObject%2A> -Eigenschaft, müssen Sie einen Verweis zum Hinzufügen der `Accessibility` mit installierte Assembly die [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Erstellung eines Diagramms Eingabehilfen-fähig zu steuern, mit der <xref:System.Windows.Forms.AccessibleObject> und <xref:System.Windows.Forms.Control.ControlAccessibleObject> Klassen zum Offenlegen von Informationen zugegriffen werden kann. Das Steuerelement zeichnet zwei Kurven geteilt zusammen mit einer Legende an. Die `ChartControlAccessibleObject` -Klasse, abgeleitet von `ControlAccessibleObject`, werden in der <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> Methode, um benutzerdefinierte barrierefreie Informationen für das Diagrammsteuerelement bereitzustellen. Da die Diagrammlegende nicht tatsächlich <xref:System.Windows.Forms.Control> -basierte Steuerelement, sondern gezeichnet wird vom Diagrammsteuerelement, ist es aber keine integrierten barrierefreien Informationen. Aus diesem Grund die `ChartControlAccessibleObject` -Klasse überschreibt die <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> -Methode zur Rückgabe der `CurveLegendAccessibleObject` , zugegriffen werden Informationen für jeden Teil der Legende darstellt. Wenn eine zugänglich-fähige Anwendung dieses Steuerelement verwendet wird, bieten das Steuerelement die erforderlichen Informationen zugegriffen werden kann.  
  
 Dieser Codeauszug veranschaulicht das Überschreiben der <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> Methode. Finden Sie unter der <xref:System.Windows.Forms.AccessibleObject> Übersicht über die Klasse für das gesamte Codebeispiel dargestellt.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#2)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#2)]
 [!code-vb[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" /> in einer abgeleiteten Klasse rufen Sie nicht der Basisklasse <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateControl">
      <MemberSignature Language="C#" Value="public void CreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt das Erstellen des sichtbaren Steuerelements, einschließlich des Handles und aller sichtbaren untergeordneten Steuerelemente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.CreateControl%2A> Methode erzwingt ein Handle für das Steuerelement und seine untergeordneten Steuerelemente erstellt werden. Diese Methode verwendet wird, wenn Sie ein Handle für die Bearbeitung des Steuerelements oder seine untergeordneten Elemente sofort benötigen. einfach Aufrufen eines Steuerelements Konstruktor erstellt nicht die <xref:System.Windows.Forms.Control.Handle%2A>.  
  
 <xref:System.Windows.Forms.Control.CreateControl%2A>ein Steuerelementhandle wird nicht erstellt werden, wenn des Steuerelements <xref:System.Windows.Forms.Control.Visible%2A> Eigenschaft ist `false`. Können Sie entweder die <xref:System.Windows.Forms.Control.CreateHandle%2A> Methode oder den Zugriff der <xref:System.Windows.Forms.Control.Handle%2A> Eigenschaft beim Erstellen des Steuerelements behandeln unabhängig von der Steuerung der Sichtbarkeit, aber in diesem Fall kein Fenster Handles für das Steuerelement untergeordnete Elemente erstellt werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControlsInstance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Instanz der Steuerelementauflistung für das Steuerelement.</summary>
        <returns>Eine neue Instanz der dem Steuerelement zugewiesenen <see cref="T:System.Windows.Forms.Control.ControlCollection" />.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Die Basisklassenversion dieser Methode sollte nicht durch eine abgeleitete Klasse aufgerufen werden.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public bool Created { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Created" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Created" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement erstellt wurde.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement erstellt wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Created%2A> -Eigenschaft gibt `true` Wenn die <xref:System.Windows.Forms.Control> wurde erfolgreich erstellt, auch wenn das Handle des Steuerelements wurde nicht erstellt oder noch nicht neu erstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateGraphics">
      <MemberSignature Language="C#" Value="public System.Drawing.Graphics CreateGraphics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Graphics CreateGraphics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateGraphics" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt die <see cref="T:System.Drawing.Graphics" /> für das Steuerelement.</summary>
        <returns>Das <see cref="T:System.Drawing.Graphics" /> für das Steuerelement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics> -Objekt, das Sie durch Abrufen der <xref:System.Windows.Forms.Control.CreateGraphics%2A> Methode sollte normalerweise nicht beibehalten werden, nachdem die aktuelle Windows-Meldung verarbeitet wurde, da mit diesem Objekt gezeichnete Elemente mit der nächsten WM_PAINT-Meldung gelöscht wird. Sie können daher nicht Zwischenspeichern der <xref:System.Drawing.Graphics> -Objekt zur Wiederverwendung, verwenden nicht sichtbare Gesamtwerte Methoden wie z. B. <xref:System.Drawing.Graphics.MeasureString%2A?displayProperty=nameWithType>. Stattdessen müssen Sie aufrufen <xref:System.Windows.Forms.Control.CreateGraphics%2A> jedes Mal, die Sie verwenden möchten die <xref:System.Drawing.Graphics> Objekt, und rufen Sie anschließend <xref:System.Drawing.Graphics.Dispose%2A> Sie abschließend verwenden. Weitere Informationen zu Windows-Meldungen, finden Sie unter <xref:System.Windows.Forms.Control.WndProc%2A>.  
  
 Programmbedingt <xref:System.Windows.Forms.Control.CreateGraphics%2A> legt den Besitz an den aufrufenden Thread und schlägt fehl, wenn sie für andere Threads aufgerufen wird.  
  
> [!NOTE]
>  Zusätzlich zu den <xref:System.Windows.Forms.Control.InvokeRequired%2A> -Eigenschaft, es gibt vier Methoden für ein Steuerelement, die threadsicher sind: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, und <xref:System.Windows.Forms.Control.CreateGraphics%2A> , wenn das Handle für das Steuerelement bereits erstellt wurde. Aufrufen von <xref:System.Windows.Forms.Control.CreateGraphics%2A> , bevor das Handle des Steuerelements in einem Hintergrundthread erstellt werden können dazu führen, dass unzulässigen threadübergreifenden aufrufen. Für alle anderen Methodenaufrufe sollten Sie eine der Methoden Invoke verwenden, um den Aufruf an das Steuerelement-Thread zu marshallen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das angegebene Steuerelement ändert, damit das Steuerelement den formatierten Text angepasst wird. Der formatierte Text ist die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaft mit dem Steuerelement zugewiesen <xref:System.Windows.Forms.Control.Font%2A> auf den Text angewendet. Die `AutoSizeControl` Methode in diesem Beispiel verfügt auch über eine `textPadding` Parameter, der die Auffüllung anzuwendende an allen Rändern des Steuerelements darstellt. Damit der Leerraum gleich angezeigt wird, richtet den Text der `MiddleCenter` Wert <xref:System.Drawing.ContentAlignment?displayProperty=nameWithType> , wenn das Steuerelement unterstützt.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für sichere untergeordnete Fenster zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="SafeSubWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected virtual void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein Handle für das Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel rufen Sie nicht die <xref:System.Windows.Forms.Control.CreateHandle%2A> -Methode direkt. Die bevorzugte Methode aufrufen, wird die <xref:System.Windows.Forms.Control.CreateControl%2A> -Methode, die erzwingt, dass ein Handle für das Steuerelement und seine untergeordneten Steuerelemente erstellt werden, wenn das Steuerelement erstellt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt ist in einem freigegebenen Zustand.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.Forms.Control.CreateHandle" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Windows.Forms.Control.CreateHandle" /> Methode, um sicherzustellen, dass das Handle erstellt wird.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die benötigten Erstellungsparameter ab, wenn das Steuerelementhandle erstellt wird.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.CreateParams" />-Eigenschaft, die die erforderlichen Erstellungsparameter enthält, wenn das Handle für das Steuerelement erstellt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.CreateParams%2A> Eigenschaft sollte nicht außer Kraft gesetzt und Anpassen die Eigenschaften des abgeleiteten Steuerelements verwendet werden. Eigenschaften, z. B. die <xref:System.Windows.Forms.CreateParams.Caption%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.CreateParams.Width%2A?displayProperty=nameWithType>, und <xref:System.Windows.Forms.CreateParams.Height%2A?displayProperty=nameWithType> sollte durch die entsprechenden Eigenschaften in das Steuerelement festgelegt werden, z. B. <xref:System.Windows.Forms.Control.Text%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Control.Width%2A?displayProperty=nameWithType> und <xref:System.Windows.Forms.Control.Height%2A?displayProperty=nameWithType>. Die <xref:System.Windows.Forms.CreateParams> sollten nur erweitert werden, wenn Sie eine standardmäßige Windows-Steuerelementklasse oder festzulegende Formate werden nicht von Windows Forms-Namespace bereitgestellt. Weitere Informationen zum Erstellen von Steuerelementparameter, finden Sie unter der `CreateWindow` und `CreateWindowEx` Funktionen und die [CREATESTRUCT](http://msdn.microsoft.com/library/windows/desktop/ms632603.aspx)Dokumentation-Struktur.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erweitert die <xref:System.Windows.Forms.Control.CreateParams%2A> Eigenschaft eine <xref:System.Windows.Forms.Button> abgeleitete Klasse. Die <xref:System.Windows.Forms.CreateParams.Style%2A?displayProperty=nameWithType> Eigenschaft geändert wird, die bewirkt, dass der Schaltfläche zum Anzeigen einer <xref:System.Drawing.Icon> anstelle einer <xref:System.Drawing.Image>. Dieses Beispiel benötigen Sie, dass Sie eine Klasse, die haben von erben die <xref:System.Windows.Forms.Button> Klasse.  
  
 [!code-cpp[CreateParams#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CreateParams/CPP/createparams.cpp#3)]
 [!code-csharp[CreateParams#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CreateParams/CS/createparams.cs#3)]
 [!code-vb[CreateParams#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CreateParams/VB/createparams.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer nicht verwalteten Code aufgerufen werden, wenn der Wert der Eigenschaft abrufen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.CreateParams" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.CreateParams" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Cursor ab, der angezeigt wird, wenn sich der Mauszeiger über dem Steuerelement befindet, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Cursor" />, der den Cursor darstellt, der angezeigt wird, wenn sich der Mauszeiger über dem Steuerelement befindet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zuweisen einer <xref:System.Windows.Forms.Cursor> auf die <xref:System.Windows.Forms.Control.Cursor%2A> Eigenschaft des Steuerelements so ändern Sie den Cursor angezeigt, wenn der Mauszeiger über dem Steuerelement befindet. So ändern Sie den Mauszeiger für alle Steuerelemente auf die Anwendung vorübergehend die <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType> Eigenschaft. In der Regel legen Sie die <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType> Eigenschaft, um ein Wartecursor beim Auffüllen einer <xref:System.Windows.Forms.ComboBox> oder speichern oder Laden einer Datei.  
  
 Die <xref:System.Windows.Forms.Control.Cursor%2A> Eigenschaft ist eine ambient-Eigenschaft. Eine Ambiente-Eigenschaft ist eine Steuerelementeigenschaft, wenn nicht festgelegt ist, wird vom übergeordneten Steuerelement abgerufen. Z. B. eine <xref:System.Windows.Forms.Button> verfügen über denselben <xref:System.Windows.Forms.Control.BackColor%2A> wie das übergeordnete Objekt <xref:System.Windows.Forms.Form> standardmäßig. Weitere Informationen zu Umgebungseigenschaften, finden Sie unter der <xref:System.Windows.Forms.AmbientProperties> Klasse oder die <xref:System.Windows.Forms.Control> -Klassenübersicht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel Beispiel füllt ein <xref:System.Windows.Forms.ComboBox> mit verfügbaren logischen Laufwerke des Benutzers. Im Beispiel wird auch des Kombinationsfelds <xref:System.Windows.Forms.Cursor> Eigenschaft daher <xref:System.Windows.Forms.Cursors.Hand%2A?displayProperty=nameWithType> Cursor wird angezeigt, wenn der Mauszeiger über die Dropdown Schaltfläche befindet. Dieser Code erfordert, dass Sie haben eine <xref:System.Windows.Forms.Form> mit einem <xref:System.Windows.Forms.ComboBox> darauf.  
  
 [!code-cpp[Windows.Forms.Control Properties2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für sichere untergeordnete Fenster zum Wert dieser Eigenschaft festgelegt. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.Cursor" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.Cursor" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen. Müssen nicht beide überschreiben die <see langword="get" /> und <see langword="set" /> Methoden die <see cref="P:System.Windows.Forms.Control.Cursor" /> Eigenschaft; Sie können nur eine bei Bedarf überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CursorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CursorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CursorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CursorChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.Cursor" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Cursor%2A> -Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Ändern des Mauscursors mithilfe der <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType> -Eigenschaft, die <xref:System.Windows.Forms.Cursor> -Klasse, und die <xref:System.Windows.Forms.Cursors> Klasse. Das Beispiel erstellt ein Formular, enthält ein <xref:System.Windows.Forms.ComboBox> -Steuerelement, ein <xref:System.Windows.Forms.Panel> -Steuerelement, und ein <xref:System.Windows.Forms.ListView> Steuerelement. Die <xref:System.Windows.Forms.ComboBox> enthält alle Cursor gebotenen der <xref:System.Windows.Forms.Cursors> Klasse. Wenn der Benutzer wählt ein Mauszeiger auf die <xref:System.Windows.Forms.ComboBox>, <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType> Eigenschaftensatz wird auf den ausgewählten Cursor, der aktualisiert wird, den Cursor für die <xref:System.Windows.Forms.Panel>. Die <xref:System.Windows.Forms.ListView> wird jedes Mal aktualisiert, wenn die <xref:System.Windows.Forms.Control.CursorChanged?displayProperty=nameWithType> Ereignis auftritt.  
  
 [!code-cpp[System.Windows.Forms.Cursors#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CPP/cursorexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursors#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CS/cursorexample.cs#1)]
 [!code-vb[System.Windows.Forms.Cursors#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursors/VB/cursorexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ControlBindingsCollection DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ControlBindingsCollection DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DataBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlBindingsCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Datenbindungen für das Steuerelement ab.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.ControlBindingsCollection" />, die die <see cref="T:System.Windows.Forms.Binding" />-Objekte für das Steuerelement enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Forms.Control.DataBindings%2A> aufzurufende Eigenschaft der <xref:System.Windows.Forms.ControlBindingsCollection>. Durch Hinzufügen von <xref:System.Windows.Forms.Binding> Datenbankobjekte in der Auflistung können Sie eine Eigenschaft eines Steuerelements an die Eigenschaft eines Objekts binden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel fügt <xref:System.Windows.Forms.Binding> -Objekte und die <xref:System.Windows.Forms.ControlBindingsCollection> fünf Steuerelemente: vier <xref:System.Windows.Forms.TextBox> Steuerelemente und ein <xref:System.Windows.Forms.DateTimePicker> Steuerelement. Der Zugriff auf die <xref:System.Windows.Forms.ControlBindingsCollection> erfolgt über die <xref:System.Windows.Forms.Control.DataBindings%2A>-Eigenschaft der <xref:System.Windows.Forms.Control>-Klasse.  
  
 [!code-cpp[Classic Control.DataBindings Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.DataBindings Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CS/source.cs#1)]
 [!code-vb[Classic Control.DataBindings Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.DataBindings Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultBackColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultBackColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardhintergrundfarbe des Steuerelements ab.</summary>
        <value>Die Standardhintergrund-<see cref="T:System.Drawing.Color" /> des Steuerelements. Die Standardeinstellung ist <see cref="P:System.Drawing.SystemColors.Control" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die Standardeinstellung <xref:System.Windows.Forms.Control.BackColor%2A> Eigenschaftswert, der einen generischen Steuerelement der obersten Ebene. Abgeleitete Klassen können unterschiedliche Standardwerte aufweisen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A>, und <xref:System.Windows.Forms.Control.DefaultForeColor%2A> Elemente. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular mit einem <xref:System.Windows.Forms.ListBox> ListBox1 aufgerufen. Rufen Sie die `Populate_ListBox` -Methode im Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load> Ereignisbehandlungsmethode.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCursor">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Cursor DefaultCursor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor DefaultCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Standardcursor für das Steuerelement ab oder legt ihn fest.</summary>
        <value>Ein Objekt vom Typ <see cref="T:System.Windows.Forms.Cursor" />, das den aktuellen Standardcursor darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreiben Sie <xref:System.Windows.Forms.Control.DefaultCursor%2A> so konfigurieren Sie einen Standardcursor für das Steuerelement. Dies ist effizienter als den Cursor im Konstruktor des Steuerelements festlegen, und durch das automatische Unterstützung bestimmter cursorspezifischen Designer-Funktionen erhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultFont">
      <MemberSignature Language="C#" Value="public static System.Drawing.Font DefaultFont { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Drawing.Font DefaultFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardschriftart des Steuerelements ab.</summary>
        <value>Die Standard-<see cref="T:System.Drawing.Font" /> des Steuerelements. Der zurückgegebene Wert variiert je nach Betriebssystem des Benutzers und lokaler Kultureinstellung des Systems.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle beschreibt den Rückgabewert von <xref:System.Windows.Forms.Control.DefaultFont%2A> je nach Betriebssystem und der lokalen Kultur.  
  
|System / und Kultur|Schriftart|  
|----------------------------|----------|  
|Windows NT 4 x, japanische version|MS UI dem Gotischen, 9-Punkt.|  
|Arabische Windows|Tahoma, 8 Punkt.|  
|Andere Betriebssystem/Kultur|MS Shell Dlg logische Schriftart in der Regel Microsoft San Serif 8 Punkt.|  
  
 MS Shell Dlg ordnet eine Schriftart in der Registrierung festgelegt.  
  
 Wenn die vorherigen Schriftarten nicht installiert sind, ist die Standardschriftart Tahoma, 8 Punkt. Wenn Tahoma, 8 Punkt, nicht installiert ist, <xref:System.Windows.Forms.Control.DefaultFont%2A> gibt den Wert der <xref:System.Drawing.FontFamily.GenericSansSerif%2A> Eigenschaft  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A>, und <xref:System.Windows.Forms.Control.DefaultForeColor%2A> Elemente. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular mit einem <xref:System.Windows.Forms.ListBox> ListBox1 aufgerufen. Rufen Sie die `Populate_ListBox` -Methode im Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load> Ereignisbehandlungsmethode.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Standardschriftart oder alternativen regionalen Schriftarten sind nicht auf dem Clientcomputer installiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultForeColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultForeColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardvordergrundfarbe des Steuerelements ab.</summary>
        <value>Die standardmäßige Vordergrund-<see cref="T:System.Drawing.Color" /> des Steuerelements. Die Standardeinstellung ist <see cref="P:System.Drawing.SystemColors.ControlText" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die Standardeinstellung <xref:System.Windows.Forms.Control.ForeColor%2A> Eigenschaftswert eines Steuerelements. Abgeleitete Klassen können unterschiedliche Standardwerte aufweisen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A>, und <xref:System.Windows.Forms.Control.DefaultForeColor%2A> Elemente. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular mit einem <xref:System.Windows.Forms.ListBox> ListBox1 aufgerufen. Rufen Sie die `Populate_ListBox` -Methode im Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load> Ereignisbehandlungsmethode.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den von dem Steuerelement unterstützten Standard-IME-Modus (Eingabemethoden-Editor) ab.</summary>
        <value>Einer der <see cref="T:System.Windows.Forms.ImeMode" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein IME (Eingabemethoden-Editor) ist ein Programm, das Benutzern ermöglicht, komplexe Zeichen und Symbole, z. B. japanische Kanji-Zeichen, über eine Standardtastatur eingeben.  
  
 Bei Implementierung in der <xref:System.Windows.Forms.Control> Klasse, die diese Eigenschaft gibt immer die <xref:System.Windows.Forms.ImeMode?displayProperty=nameWithType> Wert. Die <xref:System.Windows.Forms.ImeMode.Inherit> Wert gibt an, dass der IME-Modus vom übergeordneten Steuerelement geerbt wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel setzt die <xref:System.Windows.Forms.Control.DefaultImeMode%2A> Eigenschaft, um den Eingabemethoden-Editors zu aktivieren.  
  
 [!code-cpp[Windows.Forms.Control Properties2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#4)]
 [!code-csharp[Windows.Forms.Control Properties2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#4)]
 [!code-vb[Windows.Forms.Control Properties2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.DefaultImeMode" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.DefaultImeMode" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultMargin">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultMargin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den als Standardwert angegebenen Leerraum zwischen Steuerelementen in Pixel ab.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Padding" />, das den Standardzwischenraum zwischen Steuerelementen darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMaximumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge und die Höhe in Pixel ab, die als die maximale Standardgröße eines Steuerelements angegeben ist.</summary>
        <value>Eine <see cref="M:System.Drawing.Point.#ctor(System.Drawing.Size)" />-Struktur, die die Größe des Steuerelements darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMinimumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMinimumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge und die Höhe in Pixel ab, die als die minimale Standardgröße eines Steuerelements angegeben ist.</summary>
        <value>Eine <see cref="T:System.Drawing.Size" />-Struktur, die die Größe des Steuerelements darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPadding">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultPadding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultPadding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultPadding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den internen Abstand des Inhalts eines Steuerelements in Pixel ab.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Padding" />-Objekt, das den internen Abstand des Inhalts eines Steuerelements darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardgröße des Steuerelements ab.</summary>
        <value>Die Standard-<see cref="T:System.Drawing.Size" /> des Steuerelements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.DefaultSize%2A> Eigenschaft stellt die <xref:System.Drawing.Size> des Steuerelements, wenn es ursprünglich erstellt wurde. Sie können die Größe des Steuerelements anzupassen, durch Festlegen seiner <xref:System.Windows.Forms.Control.Size%2A> Eigenschaftswert.  
  
> [!NOTE]
>  Um eine bessere Leistung zu gewährleisten, stellen Sie keine der <xref:System.Drawing.Size> eines Steuerelements in seinem Konstruktor. Die bevorzugte Methode ist, überschreiben die <xref:System.Windows.Forms.Control.DefaultSize%2A> Eigenschaft.  
  
> [!NOTE]
>  In Windows Server 2003-Systemen, die Größe des eine <xref:System.Windows.Forms.Form> wird durch die maximale Pixelbreite und Höhe des Monitors eingeschränkt.  
  
   
  
## Examples  
 Das folgende Codebeispiel setzt die <xref:System.Windows.Forms.Control.DefaultSize%2A> -Eigenschaft, und macht die Standardgröße der quadratischen Format 500 Pixel.  
  
 [!code-cpp[Windows.Forms.Control Properties2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.DefaultSize" /> -Eigenschaft in einer abgeleiteten Klasse, ist es besser, zum Zurückgeben einer <see cref="T:System.Drawing.Size" /> mit den gewünschten Dimensionen anstatt alle Implementierung überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected virtual void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Die zu verarbeitende Windows-<see cref="T:System.Windows.Forms.Message" />.</param>
        <summary>Sendet die angegebene Meldung an die Standardfensterprozedur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu Windows-Meldungen verarbeitet, finden Sie unter der [WindowProc-Funktion](http://go.microsoft.com/fwlink/?LinkId=181565).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DestroyHandle">
      <MemberSignature Language="C#" Value="protected virtual void DestroyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DestroyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DestroyHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht das mit dem Steuerelement verknüpfte Handle.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> Methode, um sicherzustellen, dass das Handle zerstört wird.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DeviceDpi">
      <MemberSignature Language="C#" Value="public int DeviceDpi { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DeviceDpi" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DeviceDpi" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den DPI-Wert für das Anzeigegerät ab, auf dem das Steuerelement aktuell angezeigt wird.</summary>
        <value>Der DPI-Wert des Anzeigegeräts.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayRectangle">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Rectangle DisplayRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DisplayRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DisplayRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Rechteck ab, das den Anzeigebereich des Steuerelements darstellt.</summary>
        <value>Ein <see cref="T:System.Drawing.Rectangle" />, das den Anzeigebereich des Steuerelements darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.DisplayRectangle%2A> Eigenschaft gibt das Clientrechteck neben dem Anzeigebereich des Steuerelements zurück. Für die Klasse Basissteuerelement entspricht dies dem Clientrechteck. Allerdings kann die erbende Steuerelemente sinnvoll, diese zu ändern, wenn der Clientbereich vom Anzeigebereich unterscheidet. Das Anzeigerechteck ist der kleinste <xref:System.Drawing.Rectangle> , die ein Steuerelement einschließt und wird verwendet, um das Layout der Steuerelemente.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.DisplayRectangle" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.DisplayRectangle" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Alternativ müssen Sie alle Implementierung bereitstellen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die vom <see cref="T:System.Windows.Forms.Control" /> und den untergeordneten Steuerelementen verwendeten nicht verwalteten Ressourcen und optional auch die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, der öffentlich `Dispose()` Methode und die <xref:System.Object.Finalize%2A> Methode.`Dispose()` Ruft die geschützte `Dispose(Boolean)` Methode mit dem `disposing` Parametersatz auf `true`. <xref:System.Object.Finalize%2A>Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Windows.Forms.Control> verweist. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Zum Überschreiben <see langword="Dispose(Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die einen früheren Aufruf freigegeben wurden <see langword="Dispose" />. Weitere Informationen zum Implementieren <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Disposing">
      <MemberSignature Language="C#" Value="public bool Disposing { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Disposing" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Disposing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Windows.Forms.Control" />-Basisklasse gerade freigegeben wird.</summary>
        <value>
          <see langword="true" />, wenn die <see cref="T:System.Windows.Forms.Control" />-Basisklasse gerade freigegeben wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft gibt `true`, der Base <xref:System.Windows.Forms.Control> -Basisklasse gerade freigegeben. Nachdem das Steuerelement freigegeben wurde, kann er nicht mehr als ein gültiges Windows-Steuerelement verwiesen werden. Auch wenn die Instanz eines Steuerelements verworfen wird, wird es weiterhin im Arbeitsspeicher beibehalten, bis sie durch die Garbagecollection aus dem Speicher entfernt wird. Wenn ein Steuerelement freigegeben wurde, rufen Sie können nicht die <xref:System.Windows.Forms.Control.RecreateHandle%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dock">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.DockStyle Dock { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DockStyle Dock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Dock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DockStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, welche Steuerelementrahmen am übergeordneten Steuerelement angedockt sind, und bestimmt, wie die Größe eines Steuerelements mit dem übergeordneten Steuerelement geändert wird.</summary>
        <value>Einer der <see cref="T:System.Windows.Forms.DockStyle" />-Werte. Die Standardeinstellung ist <see cref="F:System.Windows.Forms.DockStyle.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Forms.Control.Dock%2A> Eigenschaft definieren, wie die Größe eines Steuerelements automatisch geändert wird, während das übergeordnete Steuerelement angepasst wird. Z. B. <xref:System.Windows.Forms.Control.Dock%2A> auf <xref:System.Windows.Forms.DockStyle?displayProperty=nameWithType> bewirkt, dass das Steuerelement selbst am linken Rand des übergeordneten Steuerelements ausgerichtet und wird geändert, wenn das übergeordnete Steuerelement angepasst wird. Steuerelemente werden in der Z-Reihenfolge angedockt ist die Schichtung der Steuerelemente in einem Formular auf das Formular z-Achse (Tiefe).  
  
 Ein Steuerelement an einer Kante seines übergeordneten Containers angedockt werden kann oder an allen Rändern angedockt werden kann und den übergeordneten Container ausfüllen.  
  
 Festlegen der <xref:System.Windows.Forms.Control.Margin%2A> Eigenschaft für ein angedocktes Steuerelement wirkt sich nicht auf den Abstand des Steuerelements aus der die Ränder des Containers.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.Control.Anchor%2A> und <xref:System.Windows.Forms.Control.Dock%2A> Eigenschaften schließen sich gegenseitig. Zu einem Zeitpunkt kann nur festgelegt werden, und die letzte Gruppe hat Vorrang vor.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Windows.Forms.GroupBox> und legt einige gemeinsamen Eigenschaften. Das Beispiel erstellt eine <xref:System.Windows.Forms.TextBox> und legt seine <xref:System.Windows.Forms.Control.Location%2A> innerhalb der Gruppenfeld. Als Nächstes wird die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaft der Gruppenfeld und wird das Gruppenfeld am oberen Rand des Formulars angedockt. Abschließend wird das Gruppenfeld deaktiviert, indem die <xref:System.Windows.Forms.Control.Enabled%2A> Eigenschaft `false`, die bewirkt, dass alle Steuerelemente, die deaktiviert werden in der Gruppe enthaltenen.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der zugewiesene Wert ist nicht der <see cref="T:System.Windows.Forms.DockStyle" /> Werte.</exception>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.Dock" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.Dock" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen. Müssen nicht beide überschreiben die <see langword="get" /> und <see langword="set" /> Methoden die <see cref="P:System.Windows.Forms.Control.Dock" /> Eigenschaft; Sie können nur eine bei Bedarf überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DockChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DockChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DockChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DockChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.Dock" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Dock%2A> -Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignishandler, der ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster *PropertyName* `Changed` , sind wird ausgelöst, wenn das entsprechende *PropertyName* -Wert ändert (* PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> , enthält eine <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DoDragDrop">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DragDropEffects DoDragDrop (object data, System.Windows.Forms.DragDropEffects allowedEffects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DragDropEffects DoDragDrop(object data, valuetype System.Windows.Forms.DragDropEffects allowedEffects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragDropEffects</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="allowedEffects" Type="System.Windows.Forms.DragDropEffects" />
      </Parameters>
      <Docs>
        <param name="data">Die zu ziehenden Daten.</param>
        <param name="allowedEffects">Einer der <see cref="T:System.Windows.Forms.DragDropEffects" />-Werte.</param>
        <summary>Beginnt einen Drag &amp; Drop-Vorgang.</summary>
        <returns>Ein Wert aus der <see cref="T:System.Windows.Forms.DragDropEffects" />-Enumeration, der das Ergebnis des Drag &amp; Drop-Vorgangs darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `allowedEffects` Parameter bestimmt, welche Vorgänge ausgeführt werden können. Wenn des Ziehvorgangs mit Anwendungen in einem anderen Prozess zusammenarbeiten muss, sollten Daten entweder eine verwaltete Basisklasse sein (<xref:System.String>, <xref:System.Drawing.Bitmap>, oder <xref:System.Drawing.Imaging.Metafile>), oder ein Objekt, das implementiert <xref:System.Runtime.Serialization.ISerializable> oder <xref:System.Windows.Forms.IDataObject>.  
  
 Nachfolgend wird beschrieben, wie und wann Ereignisse für Drag & Drop-Vorgänge ausgelöst werden.  
  
 Die <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode bestimmt die unter der aktuellen Cursorposition. Er überprüft dann um festzustellen, ob das Steuerelement ein gültiges Ablageziel ist.  
  
 Wenn das Steuerelement ein gültiges Ablageziel ist die <xref:System.Windows.Forms.Control.GiveFeedback> Ereignis wird mit dem angegebenen Drag & Drop-Effekt ausgelöst. Eine Liste der Drag & Drop-Effekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
 Änderungen der Mauszeigerposition, des Tastaturzustands und des Zustands der Maustasten werden verfolgt.  
  
-   Wenn die Benutzeraktion das Fenster verlässt, wird das <xref:System.Windows.Forms.Control.DragLeave>-Ereignis ausgelöst.  
  
-   Wenn der Mauszeiger in ein anderes Steuerelement bewegt wird, wird das <xref:System.Windows.Forms.Control.DragEnter>-Ereignis für dieses Steuerelement ausgelöst.  
  
-   Wenn die Maus bewegt wird, ohne das Steuerelement zu verlassen, wird das <xref:System.Windows.Forms.Control.DragOver>-Ereignis ausgelöst.  
  
 Wenn es eine Änderung in der Tastatur- oder Maustastenzustands der <xref:System.Windows.Forms.Control.QueryContinueDrag> Ereignis wird ausgelöst, und bestimmt, ob der Ziehvorgang, der Daten gelöscht werden, fortgesetzt oder Abbrechen des Vorgangs basierend auf den Wert der <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> Eigenschaft, der des Ereignis <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Continue`, <xref:System.Windows.Forms.Control.DragOver> Ereignis wird ausgelöst, um den Vorgang fortzusetzen und die <xref:System.Windows.Forms.Control.GiveFeedback> Ereignis mit dem neuen Effekt ausgelöst, damit eine entsprechende visuelle Rückmeldung festgelegt werden kann. Eine Liste der gültigen Ablageeffekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
    > [!NOTE]
    >  Die <xref:System.Windows.Forms.Control.DragOver> und <xref:System.Windows.Forms.Control.GiveFeedback> Ereignisse werden kombiniert, damit der Benutzer die Maus über das Ablageziel bewegen, aktuelle Rückmeldung auf beiden Seiten der Maus gewährt wird.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Drop`, ist der Wert des Ablageeffekts an die Quelle zurückgegeben, die Source-Anwendung auf den entsprechenden Vorgang für die Quelldaten; ausführen kann z. B. dadurch die Daten Ausschneiden, wenn der Vorgang einen Verschiebevorgang handelt.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Cancel`die <xref:System.Windows.Forms.Control.DragLeave> Ereignis wird ausgelöst.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode alle Ausnahmen abfängt und löst nur die folgenden Sicherheits- oder kritische Ausnahmen:  
  
-   SecurityException  
  
-   NullReferenceException  
  
-   StackOverflowException  
  
-   OutOfMemoryException  
  
-   ThreadAbortException  
  
-   ExecutionEngineException  
  
-   IndexOutOfRangeException  
  
-   AccessViolationException  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, einen Drag-and-Drop-Vorgang zwischen zwei <xref:System.Windows.Forms.ListBox> Steuerelemente. Im Beispiel wird die <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode, wenn der Ziehvorgang beginnt. Der Ziehvorgang beginnt, wenn die Maus bewegt hat mehr als <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> aus die Position des Mauszeigers während der <xref:System.Windows.Forms.Control.MouseDown> Ereignis. Die <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> Methode wird verwendet, um zu bestimmen, den Index des Elements, das beim Ziehen die `MouseDown` Ereignis.  
  
 Das Beispiel veranschaulicht außerdem die Verwendung von benutzerdefiniertem Cursor für den Drag & Drop-Vorgang. Das Beispiel erfordert, dass zwei Cursordateien `3dwarro.cur` und `3dwno.cur`, im Anwendungsverzeichnis, für den benutzerdefinierten vorhanden und Drop bzw. den Cursor. Die benutzerdefinierte Cursor verwendet werden, wenn die `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> aktiviert ist. Die benutzerdefinierte Cursor werden festgelegt, der <xref:System.Windows.Forms.Control.GiveFeedback> -Ereignishandler.  
  
 Die Tastaturstatus wird ausgewertet, der <xref:System.Windows.Forms.Control.DragOver> -Ereignishandler für das Recht `ListBox`, um zu bestimmen, welche des Ziehvorgangs werden basierend auf den Zustand der Tasten UMSCHALT, STRG, ALT oder STRG + ALT. Die Position in der `ListBox` , in die Dropdownliste käme werden auch während des bestimmt die `DragOver` Ereignis. Wenn die Daten so löschen Sie keine `String`, die <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> auf festgelegt ist `None` in <xref:System.Windows.Forms.DragDropEffects>. Schließlich wird der Status des im Dropdownmenü angezeigt, der `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 Die Daten für das Recht löschen `ListBox` wird bestimmt, der <xref:System.Windows.Forms.Control.DragDrop> -Ereignishandler und die `String` Wert wird an die entsprechende Stelle im hinzugefügt der `ListBox`. Wenn der Ziehvorgang außerhalb der Grenzen des Formulars verschoben, der Drag-and-Drop-Vorgang abgebrochen wird, der <xref:System.Windows.Forms.Control.QueryContinueDrag> -Ereignishandler.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.DragDropEffects> Enumeration, um festzulegen, wie Daten zwischen den Steuerelementen in einem Drag & Drop-Vorgang beteiligten übertragen werden sollen. Dieses Beispiel benötigen Sie, dass das Formular enthält ein <xref:System.Windows.Forms.RichTextBox> Steuerelement und ein <xref:System.Windows.Forms.ListBox> -Steuerelement, und dass die <xref:System.Windows.Forms.ListBox> Steuerelement mit einer Liste der gültigen Dateinamen gefüllt wird. Wenn der Benutzer einen Dateinamen auf zieht die <xref:System.Windows.Forms.RichTextBox> -Steuerelement, des Steuerelements <xref:System.Windows.Forms.Control.DragEnter> Ereignis wird ausgelöst. Innerhalb des ereignishandlers der <xref:System.Windows.Forms.DragEventArgs.Effect%2A> Eigenschaft von der <xref:System.Windows.Forms.DragEventArgs> wird initialisiert, um <xref:System.Windows.Forms.DragDropEffects> um anzugeben, dass die Daten, die auf den Dateipfad verweist auf kopiert werden sollen die <xref:System.Windows.Forms.RichTextBox> Steuerelement.  
  
 [!code-cpp[RichTextDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextDragDrop/CS/form1.cs#1)]
 [!code-vb[RichTextDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextDragDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffered">
      <MemberSignature Language="C#" Value="protected virtual bool DoubleBuffered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DoubleBuffered" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DoubleBuffered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement seine Oberfläche unter Verwendung eines sekundären Puffers neu zeichnen soll, um Flackern zu verringern oder zu vermeiden, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn die Oberfläche des Steuerelements mit Doppelpufferung gezeichnet werden soll, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gepufferte Grafiken können reduziert oder zunichte Flackern, die progressive Neuzeichnen der Teile einer angezeigten Fläche zurückzuführen ist. Gepufferte Grafiken erfordern, dass die aktualisierten Grafikdaten zuerst in einen Puffer geschrieben werden. Die Daten in den Grafikpuffer werden dann schnell in angezeigten-Oberfläche Speicher geschrieben. Die angezeigten Grafikspeicher Schalters relativ schnell reduziert das Flackern, das andernfalls auftreten kann.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.DoubleBuffered%2A>ist keine bindbare Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event EventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DoubleClick" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Doppelklicken auf das Steuerelement ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Doppelklick wird durch die mauseinstellungen des Betriebssystems des Benutzers bestimmt. Der Benutzer kann den Zeitraum festlegen, innerhalb dessen der zweite Mausklick erfolgen muss, damit zwei aufeinander folgende Mausklicks als Doppelklick erkannt werden. Die <xref:System.Windows.Forms.Control.Click> Ereignis wird jedes Mal, wenn ein Steuerelement doppelgeklickt wird. Angenommen, Sie haben die Ereignishandler für die <xref:System.Windows.Forms.Control.Click> und <xref:System.Windows.Forms.Control.DoubleClick> Ereignisse von einem <xref:System.Windows.Forms.Form>, die <xref:System.Windows.Forms.Control.Click> und <xref:System.Windows.Forms.Control.DoubleClick> Ereignisse werden ausgelöst, wenn das Formular doppelgeklickt wird, und beide Methoden aufgerufen werden. Wenn ein Steuerelement doppelgeklickt wird und dass Steuerelement nicht unterstützt die <xref:System.Windows.Forms.Control.DoubleClick> -Ereignis der <xref:System.Windows.Forms.Control.Click> Ereignis möglicherweise zweimal ausgelöst.  
  
 Müssen Sie festlegen der `StandardDoubleClick` und `StandardClick` Werte <xref:System.Windows.Forms.ControlStyles> auf `true` für dieses Ereignis ausgelöst werden soll. Diese Werte möglicherweise bereits auf festgelegt `true` , wenn Sie von vorhandenen erben Windows Forms-Steuerelemente.  
  
> [!NOTE]
>  Die folgenden Ereignisse werden nicht ausgelöst, für die <xref:System.Windows.Forms.TabControl> -Klasse, es sei denn, es ist mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> Auflistung: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn mindestens ein ist <xref:System.Windows.Forms.TabPage> in der Auflistung und Interaktion des Benutzers mit dem Registerkarten-Steuerelement-Header (, in dem die <xref:System.Windows.Forms.TabPage> Namen angezeigt werden), wird die <xref:System.Windows.Forms.TabControl> des entsprechenden Ereignisses. Jedoch, wenn das Eingreifen des Benutzers innerhalb der Clientbereich der Registerkartenseite der <xref:System.Windows.Forms.TabPage> des entsprechenden Ereignisses.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.DoubleClick> -Ereignis für ein <xref:System.Windows.Forms.ListBox> aufgeführt, die Textdateien laden die <xref:System.Windows.Forms.ListBox> in einer <xref:System.Windows.Forms.TextBox> Steuerelement.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Erben von einer standardmäßigen Windows Forms-Steuerelement, und Ändern der <see langword="StandardClick" /> oder <see langword="StandardDoubleClick" /> Werte <see cref="T:System.Windows.Forms.ControlStyles" /> auf <see langword="true" /> kann unerwartetes Verhalten verursachen oder überhaupt haben keine Auswirkung, wenn das Steuerelement nicht unterstützt die <see cref="E:System.Windows.Forms.Control.Click" /> oder <see cref="E:System.Windows.Forms.Control.DoubleClick" />Ereignisse.  
  
 Die folgende Tabelle enthält die Windows Forms-Steuerelemente und welches Ereignis (<see cref="E:System.Windows.Forms.Control.Click" /> oder <see cref="E:System.Windows.Forms.Control.DoubleClick" />) wird als Antwort auf die angegebene Mausaktion ausgelöst.  
  
 <list type="table"><listheader><term>Steuerelement  
  
 </term><description>Klicken mit der linken Maustaste  
  
 </description><description>Doppelklicken mit der linken Maustaste  
  
 </description><description>Klicken mit der rechten Maustaste  
  
 </description><description>Doppelklicken mit der rechten Maustaste  
  
 </description><description>Klicken mit der mittleren Maustaste  
  
 </description><description>Mittlere Maustaste doppelklicken.  
  
 </description><description>XButton1 Mausklick  
  
 </description><description>Doppelklick XButton1  
  
 </description><description>XButton2 Mausklick  
  
 </description><description>Doppelklick XButton2  
  
 </description></listheader><item><term><see cref="T:System.Windows.Forms.MonthCalendar" />,  
  
 <see cref="T:System.Windows.Forms.DateTimePicker" />,  
  
 <see cref="T:System.Windows.Forms.RichTextBox" />,  
  
 <see cref="T:System.Windows.Forms.HScrollBar" />,  
  
 <see cref="T:System.Windows.Forms.VScrollBar" /></term><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Button" />,  
  
 <see cref="T:System.Windows.Forms.CheckBox" />,  
  
 <see cref="T:System.Windows.Forms.RadioButton" /></term><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, klicken Sie auf  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ListBox" />,  
  
 <see cref="T:System.Windows.Forms.CheckedListBox" />,  
  
 <see cref="T:System.Windows.Forms.ComboBox" /></term><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.TextBox" />,  
  
 <see cref="T:System.Windows.Forms.DomainUpDown" />,  
  
 <see cref="T:System.Windows.Forms.NumericUpDown" /></term><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description></item><item><term> * <see cref="T:System.Windows.Forms.TreeView" />,  
  
 \*<see cref="T:System.Windows.Forms.ListView" /> </term> <description> Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description><description>keine  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.ProgressBar" />,  
  
 <see cref="T:System.Windows.Forms.TrackBar" /></term><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, klicken Sie auf  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, klicken Sie auf  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, klicken Sie auf  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, klicken Sie auf  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, klicken Sie auf  
  
 </description></item><item><term><see cref="T:System.Windows.Forms.Form" />,  
  
 <see cref="T:System.Windows.Forms.DataGrid" />,  
  
 <see cref="T:System.Windows.Forms.Label" />,  
  
 <see cref="T:System.Windows.Forms.LinkLabel" />,  
  
 <see cref="T:System.Windows.Forms.Panel" />,  
  
 <see cref="T:System.Windows.Forms.GroupBox" />,  
  
 <see cref="T:System.Windows.Forms.PictureBox" />,  
  
 <see cref="T:System.Windows.Forms.Splitter" />,  
  
 <see cref="T:System.Windows.Forms.StatusBar" />,  
  
 <see cref="T:System.Windows.Forms.ToolBar" />,  
  
 <see cref="T:System.Windows.Forms.TabPage" />,  
  
 ** <see cref="T:System.Windows.Forms.TabControl" /></term><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description><description>Klicken Sie auf  
  
 </description><description>Klicken Sie auf, DoubleClick  
  
 </description></item></list>  
  
 \*Der Mauszeiger über ein untergeordnetes Objekt sein (<see cref="T:System.Windows.Forms.TreeNode" /> oder <see cref="T:System.Windows.Forms.ListViewItem" />).  
  
 ** Der <see cref="T:System.Windows.Forms.TabControl" /> müssen, verfügen Sie über mindestens einen <see cref="T:System.Windows.Forms.TabPage" /> in seiner <see cref="P:System.Windows.Forms.TabControl.TabPages" /> Auflistung.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedAfterParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedAfterParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedAfterParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedAfterParent" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die DPI-Einstellung für ein Steuerelement programmgesteuert geändert wird, nachdem der DPI-Wert für das übergeordnete Steuerelement oder Formular geändert wurde.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedBeforeParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedBeforeParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedBeforeParent" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die DPI-Einstellung für ein Steuerelement programmgesteuert geändert wird, bevor ein DPI-Änderungsereignis für das übergeordnete Steuerelement oder Formular auftritt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragDrop" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Drag &amp; Drop-Vorgang abgeschlossen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.DragEventArgs.X%2A> und <xref:System.Windows.Forms.DragEventArgs.Y%2A> Eigenschaften der <xref:System.Windows.Forms.DragEventArgs> befinden sich in Bildschirmkoordinaten, nicht Clientkoordinaten. Die folgende Zeile [!INCLUDE[csprcs](~/includes/csprcs-md.md)] konvertiert der Code die Eigenschaften für einen Client <xref:System.Drawing.Point>.  
  
```  
Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
```  
  
> [!NOTE]
>  In Versionen vor [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], wenn Sie Ablegen einer <xref:System.Windows.Forms.UserControl> mit <xref:System.Windows.Forms.Control.DragEnter> und <xref:System.Windows.Forms.Control.DragDrop> Ereignisse in einem Windows Form und ziehen Sie ein Element auf das die <xref:System.Windows.Forms.UserControl> zur Entwurfszeit die `DropDrop` und `DropEnter` Ereignisse sind wird ausgelöst. Jedoch, wenn Sie zu schließen und öffnen Sie die Projektmappe erneut die <xref:System.Windows.Forms.Control.DragEnter> und <xref:System.Windows.Forms.Control.DragDrop> Ereignisse werden nicht erneut ausgelöst.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Dieser Code veranschaulicht die Verwendung der <xref:System.Windows.Forms.Control.DragDrop> Ereignis. Finden Sie unter der <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode für das gesamte Codebeispiel dargestellt.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#5)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#5)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Objekt in die Begrenzungen des Steuerelements gezogen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.DragEnter> Ereignis wird ausgelöst, wenn während eines Drag & Drop-Vorgangs der Mauszeiger über dem Steuerelement bewegt wird.  
  
> [!NOTE]
>  In Versionen vor [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], wenn Sie Ablegen einer <xref:System.Windows.Forms.UserControl> mit <xref:System.Windows.Forms.Control.DragEnter> und <xref:System.Windows.Forms.Control.DragDrop> Ereignisse in einem Windows Form und ziehen Sie ein Element auf das die <xref:System.Windows.Forms.UserControl> zur Entwurfszeit die `DropDrop` und `DropEnter` Ereignisse sind wird ausgelöst. Jedoch, wenn Sie zu schließen und öffnen Sie die Projektmappe erneut die <xref:System.Windows.Forms.Control.DragEnter> und <xref:System.Windows.Forms.Control.DragDrop> Ereignisse werden nicht erneut ausgelöst.  
  
 Nachfolgend wird beschrieben, wie und wann Ereignisse für Drag & Drop-Vorgänge ausgelöst werden.  
  
 Die <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode bestimmt die unter der aktuellen Cursorposition. Er überprüft dann um festzustellen, ob das Steuerelement ein gültiges Ablageziel ist.  
  
 Wenn das Steuerelement ein gültiges Ablageziel ist die <xref:System.Windows.Forms.Control.GiveFeedback> Ereignis wird mit dem angegebenen Drag & Drop-Effekt ausgelöst. Eine Liste der Drag & Drop-Effekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
 Änderungen der Mauszeigerposition, des Tastaturzustands und des Zustands der Maustasten werden verfolgt.  
  
-   Wenn die Benutzeraktion das Fenster verlässt, wird das <xref:System.Windows.Forms.Control.DragLeave>-Ereignis ausgelöst.  
  
-   Wenn der Mauszeiger in ein anderes Steuerelement bewegt wird, wird das <xref:System.Windows.Forms.Control.DragEnter>-Ereignis für dieses Steuerelement ausgelöst.  
  
-   Wenn die Maus bewegt wird, ohne das Steuerelement zu verlassen, wird das <xref:System.Windows.Forms.Control.DragOver>-Ereignis ausgelöst.  
  
 Wenn es eine Änderung in der Tastatur- oder Maustastenzustands der <xref:System.Windows.Forms.Control.QueryContinueDrag> Ereignis wird ausgelöst, und bestimmt, ob der Ziehvorgang, der Daten gelöscht werden, fortgesetzt oder Abbrechen des Vorgangs basierend auf den Wert der <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> Eigenschaft, der des Ereignis <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Continue`, <xref:System.Windows.Forms.Control.DragOver> Ereignis wird ausgelöst, um den Vorgang fortzusetzen und die <xref:System.Windows.Forms.Control.GiveFeedback> Ereignis mit dem neuen Effekt ausgelöst, damit eine entsprechende visuelle Rückmeldung festgelegt werden kann. Eine Liste der gültigen Ablageeffekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
    > [!NOTE]
    >  Die <xref:System.Windows.Forms.Control.DragOver> und <xref:System.Windows.Forms.Control.GiveFeedback> Ereignisse werden kombiniert, damit der Benutzer die Maus über das Ablageziel bewegen, aktuelle Rückmeldung auf beiden Seiten der Maus gewährt wird.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Drop`, ist der Wert des Ablageeffekts an die Quelle zurückgegeben, die Source-Anwendung auf den entsprechenden Vorgang für die Quelldaten; ausführen kann z. B. dadurch die Daten Ausschneiden, wenn der Vorgang einen Verschiebevorgang handelt.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Cancel`die <xref:System.Windows.Forms.Control.DragLeave> Ereignis wird ausgelöst.  
  
    > [!NOTE]
    >  Die <xref:System.Windows.Forms.DragEventArgs.X%2A> und <xref:System.Windows.Forms.DragEventArgs.Y%2A> Eigenschaften der <xref:System.Windows.Forms.DragEventArgs> befinden sich in Bildschirmkoordinaten, nicht Clientkoordinaten. Die folgende Zeile [!INCLUDE[csprcs](~/includes/csprcs-md.md)] konvertiert der Code die Eigenschaften für einen Client <xref:System.Drawing.Point>.  
  
    ```  
    Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
    ```  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, einen Drag-and-Drop-Vorgang zwischen zwei <xref:System.Windows.Forms.ListBox> Steuerelemente. Im Beispiel wird die <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode, wenn der Ziehvorgang beginnt. Der Ziehvorgang beginnt, wenn die Maus bewegt hat mehr als <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> aus die Position des Mauszeigers während der <xref:System.Windows.Forms.Control.MouseDown> Ereignis. Die <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> Methode wird verwendet, um zu bestimmen, den Index des Elements, das beim Ziehen die `MouseDown` Ereignis.  
  
 Das Beispiel veranschaulicht außerdem die Verwendung von benutzerdefiniertem Cursor für den Drag & Drop-Vorgang. Das Beispiel erfordert, dass zwei Cursordateien `3dwarro.cur` und `3dwno.cur`, im Anwendungsverzeichnis, für den benutzerdefinierten vorhanden und Drop bzw. den Cursor. Die benutzerdefinierte Cursor verwendet werden, wenn die `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> aktiviert ist. Die benutzerdefinierte Cursor werden festgelegt, der <xref:System.Windows.Forms.Control.GiveFeedback> -Ereignishandler.  
  
 Die Tastaturstatus wird ausgewertet, der <xref:System.Windows.Forms.Control.DragOver> -Ereignishandler für das Recht `ListBox`, um zu bestimmen, welche des Ziehvorgangs werden basierend auf den Zustand der Tasten UMSCHALT, STRG, ALT oder STRG + ALT. Die Position in der `ListBox` , in die Dropdownliste käme werden auch während des bestimmt die `DragOver` Ereignis. Wenn die Daten so löschen Sie keine `String`, die <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> auf festgelegt ist `None` in <xref:System.Windows.Forms.DragDropEffects>. Schließlich wird der Status des im Dropdownmenü angezeigt, der `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 Die Daten für das Recht löschen `ListBox` wird bestimmt, der <xref:System.Windows.Forms.Control.DragDrop> -Ereignishandler und die `String` Wert wird an die entsprechende Stelle im hinzugefügt der `ListBox`. Wenn der Ziehvorgang außerhalb der Grenzen des Formulars verschoben, der Drag-and-Drop-Vorgang abgebrochen wird, der <xref:System.Windows.Forms.Control.QueryContinueDrag> -Ereignishandler.  
  
 Dieser Code veranschaulicht die Verwendung der <xref:System.Windows.Forms.Control.DragEnter> Ereignis. Finden Sie unter der <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode für das gesamte Codebeispiel dargestellt.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Objekt aus den Grenzen des Steuerelements gezogen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.DragLeave> Ereignis wird ausgelöst, wenn den Cursor aus dem Steuerelement bewegt oder der aktuellen Drag & Drop-Vorgang abgebrochen.  
  
 Nachfolgend wird beschrieben, wie und wann Ereignisse für Drag & Drop-Vorgänge ausgelöst werden.  
  
 Die <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode bestimmt die unter der aktuellen Cursorposition. Er überprüft dann um festzustellen, ob das Steuerelement ein gültiges Ablageziel ist.  
  
 Wenn das Steuerelement ein gültiges Ablageziel ist die <xref:System.Windows.Forms.Control.GiveFeedback> Ereignis wird mit dem angegebenen Drag & Drop-Effekt ausgelöst. Eine Liste der Drag & Drop-Effekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
 Änderungen der Mauszeigerposition, des Tastaturzustands und des Zustands der Maustasten werden verfolgt.  
  
-   Wenn die Benutzeraktion das Fenster verlässt, wird das <xref:System.Windows.Forms.Control.DragLeave>-Ereignis ausgelöst.  
  
-   Wenn der Mauszeiger in ein anderes Steuerelement bewegt wird, wird das <xref:System.Windows.Forms.Control.DragEnter>-Ereignis für dieses Steuerelement ausgelöst.  
  
-   Wenn die Maus bewegt wird, ohne das Steuerelement zu verlassen, wird das <xref:System.Windows.Forms.Control.DragOver>-Ereignis ausgelöst.  
  
 Wenn es eine Änderung in der Tastatur- oder Maustastenzustands der <xref:System.Windows.Forms.Control.QueryContinueDrag> Ereignis wird ausgelöst, und bestimmt, ob der Ziehvorgang, der Daten gelöscht werden, fortgesetzt oder Abbrechen des Vorgangs basierend auf den Wert der <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> Eigenschaft, der des Ereignis <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Continue`, <xref:System.Windows.Forms.Control.DragOver> Ereignis wird ausgelöst, um den Vorgang fortzusetzen und die <xref:System.Windows.Forms.Control.GiveFeedback> Ereignis mit dem neuen Effekt ausgelöst, damit eine entsprechende visuelle Rückmeldung festgelegt werden kann. Eine Liste der gültigen Ablageeffekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
    > [!NOTE]
    >  Die <xref:System.Windows.Forms.Control.DragOver> und <xref:System.Windows.Forms.Control.GiveFeedback> Ereignisse werden kombiniert, damit der Benutzer die Maus über das Ablageziel bewegen, aktuelle Rückmeldung auf beiden Seiten der Maus gewährt wird.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Drop`, ist der Wert des Ablageeffekts an die Quelle zurückgegeben, die Source-Anwendung auf den entsprechenden Vorgang für die Quelldaten; ausführen kann z. B. dadurch die Daten Ausschneiden, wenn der Vorgang einen Verschiebevorgang handelt.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Cancel`die <xref:System.Windows.Forms.Control.DragLeave> Ereignis wird ausgelöst.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, einen Drag-and-Drop-Vorgang zwischen zwei <xref:System.Windows.Forms.ListBox> Steuerelemente. Im Beispiel wird die <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode, wenn der Ziehvorgang beginnt. Der Ziehvorgang beginnt, wenn die Maus bewegt hat mehr als <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> aus die Position des Mauszeigers während der <xref:System.Windows.Forms.Control.MouseDown> Ereignis. Die <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> Methode wird verwendet, um zu bestimmen, den Index des Elements, das beim Ziehen die `MouseDown` Ereignis.  
  
 Das Beispiel veranschaulicht außerdem die Verwendung von benutzerdefiniertem Cursor für den Drag & Drop-Vorgang. Das Beispiel erfordert, dass zwei Cursordateien `3dwarro.cur` und `3dwno.cur`, im Anwendungsverzeichnis, für den benutzerdefinierten vorhanden und Drop bzw. den Cursor. Die benutzerdefinierte Cursor verwendet werden, wenn die `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> aktiviert ist. Die benutzerdefinierte Cursor werden festgelegt, der <xref:System.Windows.Forms.Control.GiveFeedback> -Ereignishandler.  
  
 Die Tastaturstatus wird ausgewertet, der <xref:System.Windows.Forms.Control.DragOver> -Ereignishandler für das Recht `ListBox`, um zu bestimmen, welche des Ziehvorgangs werden basierend auf den Zustand der Tasten UMSCHALT, STRG, ALT oder STRG + ALT. Die Position in der `ListBox` , in die Dropdownliste käme werden auch während des bestimmt die `DragOver` Ereignis. Wenn die Daten so löschen Sie keine `String`, die <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> auf festgelegt ist `None` in <xref:System.Windows.Forms.DragDropEffects>. Schließlich wird der Status des im Dropdownmenü angezeigt, der `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 Die Daten für das Recht löschen `ListBox` wird bestimmt, der <xref:System.Windows.Forms.Control.DragDrop> -Ereignishandler und die `String` Wert wird an die entsprechende Stelle im hinzugefügt der `ListBox`. Wenn der Ziehvorgang außerhalb der Grenzen des Formulars verschoben, der Drag-and-Drop-Vorgang abgebrochen wird, der <xref:System.Windows.Forms.Control.QueryContinueDrag> -Ereignishandler.  
  
 Dieser Code veranschaulicht die Verwendung der <xref:System.Windows.Forms.Control.DragLeave> Ereignis. Finden Sie unter der <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode für das gesamte Codebeispiel dargestellt.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragOver" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Objekt über die Begrenzungen des Steuerelements gezogen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.DragOver> Ereignis wird ausgelöst, wenn der Mauszeiger während eines Drag & Drop-Vorgangs innerhalb der Grenzen des Steuerelements bewegt wird.  
  
 Nachfolgend wird beschrieben, wie und wann Ereignisse für Drag & Drop-Vorgänge ausgelöst werden.  
  
 Die <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode bestimmt die unter der aktuellen Cursorposition. Er überprüft dann um festzustellen, ob das Steuerelement ein gültiges Ablageziel ist.  
  
 Wenn das Steuerelement ein gültiges Ablageziel ist die <xref:System.Windows.Forms.Control.GiveFeedback> Ereignis wird mit dem angegebenen Drag & Drop-Effekt ausgelöst. Eine Liste der Drag & Drop-Effekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
 Änderungen der Mauszeigerposition, des Tastaturzustands und des Zustands der Maustasten werden verfolgt.  
  
-   Wenn die Benutzeraktion das Fenster verlässt, wird das <xref:System.Windows.Forms.Control.DragLeave>-Ereignis ausgelöst.  
  
-   Wenn der Mauszeiger in ein anderes Steuerelement bewegt wird, wird das <xref:System.Windows.Forms.Control.DragEnter>-Ereignis für dieses Steuerelement ausgelöst.  
  
-   Wenn die Maus bewegt wird, ohne das Steuerelement zu verlassen, wird das <xref:System.Windows.Forms.Control.DragOver>-Ereignis ausgelöst.  
  
 Wenn es eine Änderung in der Tastatur- oder Maustastenzustands der <xref:System.Windows.Forms.Control.QueryContinueDrag> Ereignis wird ausgelöst, und bestimmt, ob der Ziehvorgang, der Daten gelöscht werden, fortgesetzt oder Abbrechen des Vorgangs basierend auf den Wert der <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> Eigenschaft, der des Ereignis <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> Wert `Continue`, die <xref:System.Windows.Forms.Control.DragOver> Ereignis wird ausgelöst, um den Vorgang fortzusetzen und die <xref:System.Windows.Forms.Control.GiveFeedback> Ereignis mit dem neuen Effekt ausgelöst, damit eine entsprechende visuelle Rückmeldung festgelegt werden kann. Eine Liste der gültigen Ablageeffekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
    > [!NOTE]
    >  Die <xref:System.Windows.Forms.Control.DragOver> und <xref:System.Windows.Forms.Control.GiveFeedback> Ereignisse werden kombiniert, damit der Benutzer die Maus über das Ablageziel bewegen, aktuelle Rückmeldung auf beiden Seiten der Maus gewährt wird.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Drop`, ist der Wert des Ablageeffekts an die Quelle zurückgegeben, die Source-Anwendung auf den entsprechenden Vorgang für die Quelldaten; ausführen kann z. B. dadurch die Daten Ausschneiden, wenn der Vorgang einen Verschiebevorgang handelt.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Cancel`die <xref:System.Windows.Forms.Control.DragLeave> Ereignis wird ausgelöst.  
  
    > [!NOTE]
    >  Die <xref:System.Windows.Forms.DragEventArgs.X%2A> und <xref:System.Windows.Forms.DragEventArgs.Y%2A> Eigenschaften der <xref:System.Windows.Forms.DragEventArgs> befinden sich in Bildschirmkoordinaten, nicht Clientkoordinaten. Die folgende Zeile der C#-Code die Eigenschaften für einen Client konvertiert <xref:System.Drawing.Point>:  
    >   
    >  Zeigen Sie ClientPoint = targetControl.PointToClient (neue Verwaltungspunkt (de. X, Deutschland. Y));  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, einen Drag-and-Drop-Vorgang zwischen zwei <xref:System.Windows.Forms.ListBox> Steuerelemente. Im Beispiel wird die <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode, wenn der Ziehvorgang beginnt. Der Ziehvorgang beginnt, wenn die Maus bewegt hat mehr als <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> aus die Position des Mauszeigers während der <xref:System.Windows.Forms.Control.MouseDown> Ereignis. Die <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> Methode wird verwendet, um zu bestimmen, den Index des Elements, das beim Ziehen die `MouseDown` Ereignis.  
  
 Das Beispiel veranschaulicht außerdem die Verwendung von benutzerdefiniertem Cursor für den Drag & Drop-Vorgang. Das Beispiel erfordert, dass zwei Cursordateien `3dwarro.cur` und `3dwno.cur`, im Anwendungsverzeichnis, für den benutzerdefinierten vorhanden und Drop bzw. den Cursor. Die benutzerdefinierte Cursor verwendet werden, wenn die `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> aktiviert ist. Die benutzerdefinierte Cursor werden festgelegt, der <xref:System.Windows.Forms.Control.GiveFeedback> -Ereignishandler.  
  
 Die Tastaturstatus wird ausgewertet, der <xref:System.Windows.Forms.Control.DragOver> -Ereignishandler für das Recht `ListBox`, um zu bestimmen, welche des Ziehvorgangs werden basierend auf den Zustand der Tasten UMSCHALT, STRG, ALT oder STRG + ALT. Die Position in der `ListBox` , in die Dropdownliste käme werden auch während des bestimmt die `DragOver` Ereignis. Wenn die Daten so löschen Sie keine `String`, die <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> auf festgelegt ist `None` in <xref:System.Windows.Forms.DragDropEffects>. Schließlich wird der Status des im Dropdownmenü angezeigt, der `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 Die Daten für das Recht löschen `ListBox` wird bestimmt, der <xref:System.Windows.Forms.Control.DragDrop> -Ereignishandler und die `String` Wert wird an die entsprechende Stelle im hinzugefügt der `ListBox`. Wenn der Ziehvorgang außerhalb der Grenzen des Formulars verschoben, der Drag-and-Drop-Vorgang abgebrochen wird, der <xref:System.Windows.Forms.Control.QueryContinueDrag> -Ereignishandler.  
  
 Dieser Code veranschaulicht die Verwendung der <xref:System.Windows.Forms.Control.DragOver> Ereignis. Finden Sie unter der <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode für das gesamte Codebeispiel dargestellt.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#4)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#4)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="bitmap">Die Bitmap, in die gezeichnet werden soll.</param>
        <param name="targetBounds">Die Begrenzungen, innerhalb derer das Steuerelement gerendert wird.</param>
        <summary>Unterstützt das Rendering für die angegebene Bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.DrawToBitmap%2A> Methode wird nicht für ActiveX-Steuerelemente unterstützt. Sie können außer Kraft setzen die <xref:System.Windows.Forms.Control.OnPrint%2A> Ereignis und benutzerdefinierte drucken Logik bereitstellen, falls erforderlich.  
  
 Die <xref:System.Windows.Forms.Control.DrawToBitmap%2A> Methode hat die folgenden Einschränkungen:  
  
-   Ein <xref:System.ArgumentException> für große Bitmaps ausgelöst werden kann. Die maximale zulässige Größe hängt vom Computer ab.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A>unterstützt nicht die `Ink` Steuerelemente für das Betriebssystem Windows XP Tablet PC Edition 2005.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A>Zeichnet ein untergeordnetes Element keine <xref:System.Windows.Forms.TextBox> Wenn die <xref:System.Windows.Forms.Control.Visible%2A> Eigenschaft von der <xref:System.Windows.Forms.TextBox> auf festgelegt ist `false`.  
  
-   Steuerelemente im Container werden in umgekehrter Reihenfolge gerendert.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A>ist nicht voll funktionsfähig ist, für die <xref:System.Windows.Forms.RichTextBox>; nur der Rahmen einer Bitmap gezeichnet wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-514)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement auf Benutzerinteraktionen reagieren kann, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement auf Benutzerinteraktionen reagieren kann, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.Windows.Forms.Control.Enabled%2A> -Eigenschaft, können Sie aktivieren oder Deaktivieren von Steuerelementen zur Laufzeit. Sie können z. B. Steuerelemente deaktivieren, die nicht mit dem aktuellen Status der Anwendung gelten. Sie können auch ein Steuerelement, um ihre Verwendung eingeschränkt deaktivieren. Beispielsweise kann eine Schaltfläche deaktiviert werden, um zu verhindern, dass den Benutzer Sie darauf klicken. Wenn ein Steuerelement deaktiviert ist, kann es nicht ausgewählt werden.  
  
> [!IMPORTANT]
>  Festlegen der <xref:System.Windows.Forms.Control.Enabled%2A> Eigenschaft `false` nicht Systemmenüfeld für die Anwendung deaktivieren oder verhindern, dass das Anwendungsfenster der Fokus erhält.  
  
 Wenn ein Container-Steuerelement hat die enabled-Eigenschaft auf festgelegt `false`, alle darin enthaltenen Steuerelemente sind ebenfalls deaktiviert. Angenommen, klickt der Benutzer auf eines der Steuerelemente in einem deaktivierten enthaltenen <xref:System.Windows.Forms.GroupBox> -Steuerelement, werden keine Ereignisse ausgelöst.  
  
> [!NOTE]
>  Wenn ein bildlauffähiges Steuerelement deaktiviert ist, werden die Bildlaufleisten ebenfalls deaktiviert. Beispielsweise kann ein deaktiviertes mehrzeiliges Textfeld scrollen, um alle Zeilen von Text anzuzeigen.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Windows.Forms.GroupBox> und legt einige gemeinsamen Eigenschaften. Das Beispiel erstellt eine <xref:System.Windows.Forms.TextBox> und legt seine <xref:System.Windows.Forms.Control.Location%2A> innerhalb der Gruppenfeld. Als Nächstes wird die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaft der Gruppenfeld und wird das Gruppenfeld am oberen Rand des Formulars angedockt. Abschließend wird das Gruppenfeld deaktiviert, indem die <xref:System.Windows.Forms.Control.Enabled%2A> Eigenschaft `false`, die bewirkt, dass alle Steuerelemente, die deaktiviert werden in der Gruppe enthaltenen.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnabledChanged">
      <MemberSignature Language="C#" Value="public event EventHandler EnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.EnabledChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.Enabled" />-Eigenschaftswert geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Enabled%2A> -Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet zwei <xref:System.Windows.Forms.RadioButton> Steuerelemente zur Veranschaulichung der <xref:System.Windows.Forms.Control.EnabledChanged> Ereignis. Auf eine Schaltfläche ändert den Wert von der <xref:System.Windows.Forms.Control.Enabled%2A> Eigenschaft der Schaltfläche auf `false` und zeigt eine <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-csharp[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInvoke">
      <MemberSignature Language="C#" Value="public object EndInvoke (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object EndInvoke(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das <see cref="T:System.IAsyncResult" />, das einen bestimmten asynchronen Aufrufvorgang darstellt, der beim Aufrufen von <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" /> zurückgegeben wird.</param>
        <summary>Ruft den Rückgabewert des asynchronen Vorgangs ab, der durch das übergebene <see cref="T:System.IAsyncResult" /> dargestellt wird.</summary>
        <returns>Das von dem asynchronen Vorgang generierte <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der asynchrone Vorgang nicht abgeschlossen wurde, wird diese Funktion blockieren, bis das Ergebnis verfügbar ist.  
  
> [!NOTE]
>  Zusätzlich zu den <xref:System.Windows.Forms.Control.InvokeRequired%2A> -Eigenschaft, es gibt vier Methoden für ein Steuerelement, die threadsicher sind: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, und <xref:System.Windows.Forms.Control.CreateGraphics%2A> , wenn das Handle für das Steuerelement bereits erstellt wurde. Aufrufen von <xref:System.Windows.Forms.Control.CreateGraphics%2A> , bevor das Handle des Steuerelements in einem Hintergrundthread erstellt werden können dazu führen, dass unzulässigen threadübergreifenden aufrufen. Für alle anderen Methodenaufrufe sollten Sie eine der Methoden Invoke verwenden, um den Aufruf an das Steuerelement-Thread zu marshallen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="asyncResult" /> Parameterwert ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="asyncResult" /> Objekt wurde nicht durch einen vorherigen Aufruf von erstellt die <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" /> Methode aus dem gleichen Steuerelement.</exception>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public event EventHandler Enter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Enter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Enter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Eintreten in den Bereich des Steuerelements ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Fokus ändern, indem Sie mithilfe der Tastatur (Registerkarte, UMSCHALT + TAB usw.), durch Aufrufen der <xref:System.Windows.Forms.Control.Select%2A> oder <xref:System.Windows.Forms.Control.SelectNextControl%2A> Methoden, oder durch Festlegen der <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> Eigenschaft auf das aktuelle Formular den Fokusereignisse auftreten, in der folgenden Reihenfolge:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Wenn Sie den Fokus ändern, mit der Maus oder durch Aufrufen der <xref:System.Windows.Forms.Control.Focus%2A> -Methode, den Fokusereignisse auftreten, in der folgenden Reihenfolge:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A> -Eigenschaftensatz auf `false`, <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> Ereignisse werden unterdrückt.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.Control.Enter> und <xref:System.Windows.Forms.Control.Leave> Ereignisse unterdrückt werden, indem die <xref:System.Windows.Forms.Form> Klasse. Die entsprechenden Ereignisse in der <xref:System.Windows.Forms.Form> Klasse werden die <xref:System.Windows.Forms.Form.Activated> und <xref:System.Windows.Forms.Form.Deactivate> Ereignisse. Die <xref:System.Windows.Forms.Control.Enter> und <xref:System.Windows.Forms.Control.Leave> Ereignisse sind hierarchisch und werden nach oben oder unten der übergeordneten Kette weitergegeben, bis das entsprechende Steuerelement erreicht ist. Nehmen wir beispielsweise an, Sie haben eine <xref:System.Windows.Forms.Form> mit zwei <xref:System.Windows.Forms.GroupBox> Steuerelemente, und jedes <xref:System.Windows.Forms.GroupBox> Steuerelement verfügt über einen <xref:System.Windows.Forms.TextBox> Steuerelement. Beim Bewegen der Einfügemarke eine <xref:System.Windows.Forms.TextBox> zu "other" die <xref:System.Windows.Forms.Control.Leave> Ereignis wird ausgelöst, für die <xref:System.Windows.Forms.TextBox> und <xref:System.Windows.Forms.GroupBox>, und die <xref:System.Windows.Forms.Control.Enter> Ereignis wird ausgelöst, für die anderen <xref:System.Windows.Forms.GroupBox> und <xref:System.Windows.Forms.TextBox>.  
  
> [!CAUTION]
>  Versuchen Sie nicht, legen Sie den Fokus innerhalb der <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, oder <xref:System.Windows.Forms.Control.Validated> -Ereignishandler. Auf diese Weise kann dazu führen, dass die Anwendung oder das Betriebssystem nicht mehr reagiert. Weitere Informationen finden Sie unter der `WM_KILLFOCUS` Thema im Abschnitt "Keyboard Input Reference" und im Abschnitt "Message Deadlocks", der die[zu Nachrichten und Warteschlangen](http://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx)Thema.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.Enter> Ereignis so ändern Sie die Vordergrund- und Hintergrundfarben von einem <xref:System.Windows.Forms.TextBox> unter bestimmten Bedingungen.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindForm">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form FindForm ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Form FindForm() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FindForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft das Formular ab, in dem sich das Steuerelement befindet.</summary>
        <returns>Das <see cref="T:System.Windows.Forms.Form" />, in dem sich das Steuerelement befindet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Des Steuerelements <xref:System.Windows.Forms.Control.Parent%2A> Eigenschaftswert möglicherweise nicht identisch mit der <xref:System.Windows.Forms.Form> zurückgegebenes <xref:System.Windows.Forms.Control.FindForm%2A> Methode. Z. B. wenn ein <xref:System.Windows.Forms.RadioButton> Steuerelement enthaltenen eine <xref:System.Windows.Forms.GroupBox> -Steuerelement, und die <xref:System.Windows.Forms.GroupBox> befindet sich auf eine <xref:System.Windows.Forms.Form>, die <xref:System.Windows.Forms.RadioButton> des Steuerelements <xref:System.Windows.Forms.Control.Parent%2A> ist die <xref:System.Windows.Forms.GroupBox> und <xref:System.Windows.Forms.GroupBox> Steuerelement <xref:System.Windows.Forms.Control.Parent%2A>ist die <xref:System.Windows.Forms.Form>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird, sucht das Formular, das die angegebene Schaltfläche enthält.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Focus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den Eingabefokus auf das Steuerelement.</summary>
        <returns>
          <see langword="true" />, wenn die Anforderung des Eingabefokus erfolgreich war, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Focus%2A> -Methode zurückkehrt `true` , wenn das Steuerelement den Eingabefokus erfolgreich erhalten hat. Das Steuerelement kann den Eingabefokus haben, während alle visuellen Hinweise, dass es den Fokus nicht angezeigt. Dieses Verhalten wird in erster Linie durch die unten aufgeführten nicht auswählbares-Steuerelemente beobachtet, oder alle Steuerelemente abgeleitet werden.  
  
 Ein Steuerelement ausgewählt werden kann und Eingabefokus erhalten, wenn alle folgenden Bedingungen erfüllt sind: die `Selectable` Wert <xref:System.Windows.Forms.ControlStyles> festgelegt ist, um `true`in ein anderes Steuerelement enthalten ist und alle übergeordneten Steuerelemente werden sichtbar und aktiviert.  
  
 Windows Forms-Steuerelemente in der folgenden Liste sind nicht auswählbar. Von diesen Steuerelementen abgeleitete Steuerelemente sind ebenfalls nicht ausgewählt werden.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel>(Wenn kein Link im Steuerelement vorhanden ist)  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Focus%2A>eine Low-Level Methode ist in erster Linie für Autoren von benutzerdefinierten Steuerelementen vorgesehen werden. Stattdessen sollten Anwendungsprogrammierer verwenden die <xref:System.Windows.Forms.Control.Select%2A> Methode oder die <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> Eigenschaft für untergeordnete Steuerelemente oder das <xref:System.Windows.Forms.Form.Activate%2A> -Methode für Formulare.  
  
   
  
## Examples  
 Das folgende Codebeispiel legt den Fokus auf den angegebenen <xref:System.Windows.Forms.Control>, wenn es den Fokus erhalten kann.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public virtual bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Focused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement den Eingabefokus besitzt.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement den Fokus besitzt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Der folgende code deaktiviert das Beispiel ein <xref:System.Windows.Forms.MenuItem> Wenn eine <xref:System.Windows.Forms.TextBox> verfügt nicht über den Fokus. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> mit einem <xref:System.Windows.Forms.TextBox> mit dem Namen `textBox1` und zwei <xref:System.Windows.Forms.MenuItem> Objekte, die mit dem Namen `menuItemEdit` und `menuItemEditInsertCustomerInfo`.  
  
 [!code-cpp[Windows.FOrms.Control Members2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#4)]
 [!code-csharp[Windows.FOrms.Control Members2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#4)]
 [!code-vb[Windows.FOrms.Control Members2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.Focused" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.Focused" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-512)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Schriftart für die Anzeige von Text im Steuerelement ab oder legt diese fest.</summary>
        <value>Der <see cref="T:System.Drawing.Font" />, der auf den Text angewendet werden soll, der im Steuerelement angezeigt wird. Der Standardwert ist der Wert der <see cref="P:System.Windows.Forms.Control.DefaultFont" />-Eigenschaft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Font%2A> Eigenschaft ist eine ambient-Eigenschaft. Eine Ambiente-Eigenschaft ist eine Steuerelementeigenschaft, wenn nicht festgelegt ist, wird vom übergeordneten Steuerelement abgerufen. Z. B. eine <xref:System.Windows.Forms.Button> verfügen über denselben <xref:System.Windows.Forms.Control.BackColor%2A> wie das übergeordnete Objekt <xref:System.Windows.Forms.Form> standardmäßig. Weitere Informationen zu Umgebungseigenschaften, finden Sie unter der <xref:System.Windows.Forms.AmbientProperties> Klasse oder die <xref:System.Windows.Forms.Control> -Klassenübersicht.  
  
 Da die <xref:System.Drawing.Font> ist unveränderlich (d. h., dass Sie die Eigenschaften nicht anpassen können), Sie können nur Zuweisen der <xref:System.Windows.Forms.Control.Font%2A> Eigenschaft ein neues <xref:System.Drawing.Font>. Allerdings können Sie die neue Schriftart auf die vorhandene Schriftart basieren.  
  
 [Visual Basic, c#]  
  
 Im folgenden finden ein Beispiel dazu, wie die vorhandene Schriftart fett zu formatieren:  
  
```csharp  
myControl.Font = new Font(myControl.Font,   
    myControl.Font.Style | FontStyle.Bold);  
```  
  
```vb  
MyControl.Font = New Font(MyControl.Font, _   
    MyControl.Font.Style Or FontStyle.Bold)  
```  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.FontDialog> für den Benutzer und die Änderungen der <xref:System.Drawing.Font> von einem <xref:System.Windows.Forms.DateTimePicker> Steuerelement. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> mit <xref:System.Windows.Forms.Button> und ein <xref:System.Windows.Forms.DateTimePicker> darauf.  
  
 [!code-cpp[Control_Font#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Font/CPP/control_font.cpp#1)]
 [!code-csharp[Control_Font#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Font/CS/control_font.cs#1)]
 [!code-vb[Control_Font#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Font/VB/control_font.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.Font" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.Font" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen. Sie müssen nicht beide außer Kraft setzen der <see langword="get" /> und <see langword="set" /> Accessoren der der <see cref="P:System.Windows.Forms.Control.Font" /> Eigenschaft; Sie können nur eine bei Bedarf überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FontChanged">
      <MemberSignature Language="C#" Value="public event EventHandler FontChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler FontChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.FontChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.Font" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Font%2A> -Eigenschaft geändert wird, indem Sie entweder eine programmgesteuerte Änderung oder durch Interaktion.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Windows.Forms.Control.FontChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontHeight">
      <MemberSignature Language="C#" Value="protected int FontHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FontHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.FontHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe der Schriftart des Steuerelements ab oder legt diese fest.</summary>
        <value>Die Höhe des <see cref="T:System.Drawing.Font" /> des Steuerelements in Pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.Control.FontHeight%2A> Eigenschaft sollte nicht festgelegt werden, um einen anderen Wert als des Steuerelements <xref:System.Drawing.Font.Height%2A?displayProperty=nameWithType> Wert oder -1. Festlegen von <xref:System.Windows.Forms.Control.FontHeight%2A> auf-1 festgelegt, hat den Effekt der zwischengespeicherte Höhenwert gelöscht, und der Wert wird berechnet das nächste Mal die Eigenschaft verwiesen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-513)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Vordergrundfarbe des Steuerelements ab oder legt diese fest.</summary>
        <value>Die Vordergrund-<see cref="T:System.Drawing.Color" /> des Steuerelements. Der Standardwert ist der Wert der <see cref="P:System.Windows.Forms.Control.DefaultForeColor" />-Eigenschaft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.ForeColor%2A> Eigenschaft ist eine ambient-Eigenschaft. Eine Ambiente-Eigenschaft ist eine Steuerelementeigenschaft, wenn nicht festgelegt ist, wird vom übergeordneten Steuerelement abgerufen. Z. B. eine <xref:System.Windows.Forms.Button> verfügen über denselben <xref:System.Windows.Forms.Control.BackColor%2A> wie das übergeordnete Objekt <xref:System.Windows.Forms.Form> standardmäßig. Weitere Informationen zu Umgebungseigenschaften, finden Sie unter der <xref:System.Windows.Forms.AmbientProperties> Klasse oder die <xref:System.Windows.Forms.Control> -Klassenübersicht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.BackColor%2A> und <xref:System.Windows.Forms.Control.ForeColor%2A> der Steuerelemente auf die Standardfarben für das System. Wenn das Steuerelement alle untergeordneten Steuerelemente verfügt, ruft der Code rekursiv selbst auf. Dieses Codebeispiel benötigen Sie ein <xref:System.Windows.Forms.Form> mit mindestens einem untergeordneten Steuerelement jedoch ein untergeordneter Container steuern, wie z. B. eine <xref:System.Windows.Forms.Panel> oder <xref:System.Windows.Forms.GroupBox>, mit einem eigenen untergeordneten Steuerelemente würde besser veranschaulichen die Rekursion.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.ForeColor" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.ForeColor" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen. Sie müssen nicht beide außer Kraft setzen der <see langword="get" /> und <see langword="set" /> Accessoren der der <see cref="P:System.Windows.Forms.Control.ForeColor" /> Eigenschaft; Sie können nur eine bei Bedarf überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ForeColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ForeColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ForeColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ForeColorChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.ForeColor" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.ForeColor%2A> -Eigenschaft geändert wird, indem Sie entweder eine programmgesteuerte Änderung oder durch Interaktion.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignishandler, der ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster *PropertyName* `Changed` , sind wird ausgelöst, wenn das entsprechende *PropertyName* -Wert ändert (* PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> , enthält eine <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromChildHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromChildHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromChildHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromChildHandle(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Das zu suchende Fensterhandle (<see langword="HWND" />).</param>
        <summary>Ruft das Steuerelement ab, das das angegebene Handle enthält.</summary>
        <returns>Das <see cref="T:System.Windows.Forms.Control" />, das das dem angegebenen Handle zugeordnete Steuerelement darstellt, gibt <see langword="null" /> zurück, wenn kein Steuerelement mit dem angegebenen Handle gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht Kette übergeordneter Fenster-Handle, bis ein Handle gefunden wird, die ein Steuerelement zugeordnet ist. Diese Methode ist zuverlässiger als die <xref:System.Windows.Forms.Control.FromHandle%2A> -Methode, weil sie Steuerelemente, die mehr als ein Handle besitzen, korrekt zurückgibt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromHandle(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Das zu suchende Fensterhandle (<see langword="HWND" />).</param>
        <summary>Gibt das Steuerelement zurück, das gerade dem angegebenen Handle zugeordnet ist.</summary>
        <returns>Ein <see cref="T:System.Windows.Forms.Control" />, das das dem angegebenen Handle zugeordnete Steuerelement darstellt, gibt <see langword="null" /> zurück, wenn kein Steuerelement mit dem angegebenen Handle gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Forms.Control.FromChildHandle%2A> Methode, wenn Sie zum Zurückgeben von Steuerelementen, die mehr als ein Handle besitzen müssen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessibilityObjectById">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject GetAccessibilityObjectById (int objectId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject GetAccessibilityObjectById(int32 objectId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAccessibilityObjectById(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="objectId">Ein <see langword="Int32" />, der das abzurufende <see cref="T:System.Windows.Forms.AccessibleObject" /> bezeichnet.</param>
        <summary>Ruft das angegebene <see cref="T:System.Windows.Forms.AccessibleObject" /> ab.</summary>
        <returns>Das angegebene <see cref="T:System.Windows.Forms.AccessibleObject" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.AutoSizeMode GetAutoSizeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.AutoSizeMode GetAutoSizeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAutoSizeMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, wie sich ein Steuerelement verhält, wenn seine <see cref="P:System.Windows.Forms.Control.AutoSize" />-Eigenschaft aktiviert wird.</summary>
        <returns>Einer der <see cref="T:System.Windows.Forms.AutoSizeMode" />-Werte.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">Ein <see cref="T:System.Drawing.Point" />, mit den Koordinaten der Position, an denen Sie nach einem Steuerelement suchen möchten. Die Koordinaten werden relativ zur oberen linken Ecke des Clientbereichs des Steuerelements angegeben.</param>
        <summary>Ruft das untergeordnete Steuerelement ab, das sich an den angegebenen Koordinaten befindet.</summary>
        <returns>Ein <see cref="T:System.Windows.Forms.Control" />, das das an der angegebenen Position befindliche Steuerelement darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine untergeordneten Steuerelement am angegebenen Punkt der <xref:System.Windows.Forms.Control.GetChildAtPoint%2A> -Methode zurückkehrt `null`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, diese Methode aufzurufen, wenn das zurückgegebene Steuerelement ist nicht auf das ein untergeordnetes Element des Steuerelements. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt, System.Windows.Forms.GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt, valuetype System.Windows.Forms.GetChildAtPointSkip skipValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point,System.Windows.Forms.GetChildAtPointSkip)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="skipValue" Type="System.Windows.Forms.GetChildAtPointSkip" />
      </Parameters>
      <Docs>
        <param name="pt">Ein <see cref="T:System.Drawing.Point" />, mit den Koordinaten der Position, an denen Sie nach einem Steuerelement suchen möchten. Die Koordinaten werden relativ zur oberen linken Ecke des Clientbereichs des Steuerelements angegeben.</param>
        <param name="skipValue">Einer der Werte von <see cref="T:System.Windows.Forms.GetChildAtPointSkip" />, womit bestimmt wird, ob untergeordnete Steuerelemente eines bestimmten Typs ignoriert werden sollen.</param>
        <summary>Ruft das untergeordnete Steuerelement ab, das sich an den angegebenen Koordinaten befindet, und gibt an, ob untergeordnete Steuerelemente eines bestimmten Typs ignoriert werden sollen.</summary>
        <returns>Das untergeordnete <see cref="T:System.Windows.Forms.Control" /> an den angegebenen Koordinaten.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainerControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IContainerControl GetContainerControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.IContainerControl GetContainerControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetContainerControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IContainerControl</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das nächste <see cref="T:System.Windows.Forms.ContainerControl" /> aufwärts in der Kette übergeordneter Steuerelemente des Steuerelements zurück.</summary>
        <returns>Ein <see cref="T:System.Windows.Forms.IContainerControl" />, das das übergeordnete Element des <see cref="T:System.Windows.Forms.Control" /> darstellt.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetNextControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetNextControl (System.Windows.Forms.Control ctl, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetNextControl(class System.Windows.Forms.Control ctl, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetNextControl(System.Windows.Forms.Control,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">Das <see cref="T:System.Windows.Forms.Control" />, mit dem die Suche begonnen werden soll.</param>
        <param name="forward">
          <see langword="true" />, um vorwärts in der Aktivierreihenfolge zu suchen, <see langword="false" />, um rückwärts zu suchen.</param>
        <summary>Ruft das nächste oder vorherige Steuerelement in der Aktivierreihenfolge untergeordneter Steuerelemente ab.</summary>
        <returns>Das nächste <see cref="T:System.Windows.Forms.Control" /> in der Aktivierreihenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.GetNextControl%2A> Methode ist abhängig von der Aktivierreihenfolge. Verwenden Sie zum Durchlaufen aller Steuerelemente eines Formulars, einschließlich geschachtelter Steuerelemente der <xref:System.Windows.Forms.Control.Controls%2A> Eigenschaft. Verwenden Sie zum Abrufen oder Festlegen eines Containersteuerelements des zum aktiven Steuerelements, das <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPreferredSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size GetPreferredSize (System.Drawing.Size proposedSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.Size GetPreferredSize(valuetype System.Drawing.Size proposedSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proposedSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="proposedSize">Der Bereich mit benutzerdefinierter Größe eines Steuerelements.</param>
        <summary>Ruft die Größe eines rechteckigen Bereichs ab, in den ein Steuerelement eingefügt werden kann.</summary>
        <returns>Ein geordnetes Paar vom Typ <see cref="T:System.Drawing.Size" />, das die Breite und Höhe eines Rechtecks darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten des <xref:System.Windows.Forms.Control.GetPreferredSize%2A> unterscheidet sich von Steuerelement. Die <xref:System.Windows.Forms.Control.LayoutEngine%2A> möglicherweise nicht die zurückgegebene Größe des Steuerelements zuweisen. Sie können eine Größe größer als die Einschränkungen, die im angegebenen Zurückgeben der `proposedSize` Parameter, aber `proposedSize` sollte abnehmen, wie die Einschränkung verringert. Beispielsweise `GetPreferredSize(new Size(100, 0))` muss nicht breiter als `GetPreferredSize(new Size(200, 0))`. Die Ausnahme ist ein `proposedSize` 0 oder `Size.Empty`, uneingeschränkten dem als definiert sind.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="bounds">Ein <see cref="T:System.Drawing.Rectangle" />, das den Bereich angibt, für den die Anzeigebegrenzungen abgerufen werden sollen.</param>
        <param name="factor">Die Höhe und Breite der Begrenzungen des Steuerelements.</param>
        <param name="specified">Einer der Werte von <see cref="T:System.Windows.Forms.BoundsSpecified" />, die die Grenzen des Steuerelements angeben, die beim Definieren seiner Größe und Position anzugeben sind.</param>
        <summary>Ruft die Begrenzungen ab, innerhalb derer das Steuerelement skaliert wird.</summary>
        <returns>Ein <see cref="T:System.Drawing.Rectangle" />, das die Begrenzungen darstellt, innerhalb derer das Steuerelement skaliert wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine Hilfsmethode, die aufgerufen wird, indem Sie <xref:System.Windows.Forms.Control.ScaleControl%2A> abzurufenden die Grenzen, innerhalb derer das Steuerelement skaliert wird. Sie können diese Methode wiederverwenden überschreiben die <xref:System.Windows.Forms.Control.ScaleControl%2A> Skalierung Logik, aber Sie müssen eine eigene Grenzen angeben. Die Standardimplementierung gibt skalierte Grenzen, die akzeptieren berücksichtigt die `specified` Grenzen, ob das Steuerelement die oberste Ebene ist, ob das Steuerelement ist feste Breite oder Automatische Größe der und aller Zusatzelemente möglicherweise das Steuerelement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStyle">
      <MemberSignature Language="C#" Value="protected bool GetStyle (System.Windows.Forms.ControlStyles flag);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetStyle(valuetype System.Windows.Forms.ControlStyles flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
      </Parameters>
      <Docs>
        <param name="flag">Das <see cref="T:System.Windows.Forms.ControlStyles" />-Bit, dessen Wert zurückgegeben werden soll.</param>
        <summary>Ruft den Wert für das angegebene Steuerelement-Formatbit für das Steuerelement ab.</summary>
        <returns>
          <see langword="true" />, wenn das angegebene Steuerelement-Formatbit auf <see langword="true" /> festgelegt ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerelement-Stil Bitflags dienen zum Kategorisieren unterstützten Verhalten. Ein Steuerelement kann ein Format aktivieren, durch Aufrufen der <xref:System.Windows.Forms.Control.SetStyle%2A> -Methode und übergeben die entsprechende <xref:System.Windows.Forms.ControlStyles> Bit-als auch der boolesche Wert auf das Bit festgelegt werden soll. Zum Bestimmen des Werts, der mit einem angegebenen zugewiesen <xref:System.Windows.Forms.ControlStyles> bit, verwenden Sie die <xref:System.Windows.Forms.Control.GetStyle%2A> -Methode und übergeben Sie die <xref:System.Windows.Forms.ControlStyles> Element ausgewertet.  
  
   
  
## Examples  
 Im folgenden Code wird zurückgegeben, die der Wert der zugehörigen Formatvorlage doppelte Pufferung für Bits eine <xref:System.Windows.Forms.Form>. In diesem Beispiel gibt `true` nur, wenn der Style-Bits, zum festgelegt sind `true`.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#4)]
 [!code-csharp[Windows.Forms.ControlMembers6#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#4)]
 [!code-vb[Windows.Forms.ControlMembers6#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTopLevel">
      <MemberSignature Language="C#" Value="protected bool GetTopLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetTopLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetTopLevel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, ob es sich bei dem Steuerelement um ein Steuerelement der obersten Ebene handelt.</summary>
        <returns>
          <see langword="true" />, wenn das Steuerelement ein Steuerelement der obersten Ebene ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GiveFeedback" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt während eines Ziehvorgangs ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.GiveFeedback> Ereignis wird ausgelöst, wenn ein Drag & Drop-Vorgang gestartet wird. Mit dem <xref:System.Windows.Forms.Control.GiveFeedback> -Ereignis, die Quelle des Drag-Ereignis kann ändern, die Darstellung des Mauszeigers um dem Benutzer während eines Drag & Drop-Vorgangs ein visuelles Feedback.  
  
 Nachfolgend wird beschrieben, wie und wann Ereignisse für Drag & Drop-Vorgänge ausgelöst werden.  
  
 Die <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode bestimmt die unter der aktuellen Cursorposition. Er überprüft dann um festzustellen, ob das Steuerelement ein gültiges Ablageziel ist.  
  
 Wenn das Steuerelement ein gültiges Ablageziel ist die <xref:System.Windows.Forms.Control.GiveFeedback> Ereignis wird mit dem angegebenen Drag & Drop-Effekt ausgelöst. Eine Liste der Drag & Drop-Effekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
 Änderungen der Mauszeigerposition, des Tastaturzustands und des Zustands der Maustasten werden verfolgt.  
  
-   Wenn die Benutzeraktion das Fenster verlässt, wird das <xref:System.Windows.Forms.Control.DragLeave>-Ereignis ausgelöst.  
  
-   Wenn der Mauszeiger in ein anderes Steuerelement bewegt wird, wird das <xref:System.Windows.Forms.Control.DragEnter>-Ereignis für dieses Steuerelement ausgelöst.  
  
-   Wenn die Maus bewegt wird, ohne das Steuerelement zu verlassen, wird das <xref:System.Windows.Forms.Control.DragOver>-Ereignis ausgelöst.  
  
 Wenn es eine Änderung in der Tastatur- oder Maustastenzustands der <xref:System.Windows.Forms.Control.QueryContinueDrag> Ereignis wird ausgelöst, und bestimmt, ob der Ziehvorgang, der Daten gelöscht werden, fortgesetzt oder Abbrechen des Vorgangs basierend auf den Wert der <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> Eigenschaft, der des Ereignis <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Continue`, <xref:System.Windows.Forms.Control.DragOver> Ereignis wird ausgelöst, um den Vorgang fortzusetzen und die <xref:System.Windows.Forms.Control.GiveFeedback> Ereignis mit dem neuen Effekt ausgelöst, damit eine entsprechende visuelle Rückmeldung festgelegt werden kann. Eine Liste der gültigen Ablageeffekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
    > [!NOTE]
    >  Die <xref:System.Windows.Forms.Control.DragOver> und <xref:System.Windows.Forms.Control.GiveFeedback> Ereignisse werden kombiniert, damit der Benutzer die Maus über das Ablageziel bewegen, aktuelle Rückmeldung auf beiden Seiten der Maus gewährt wird.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Drop`, ist der Wert des Ablageeffekts an die Quelle zurückgegeben, die Source-Anwendung auf den entsprechenden Vorgang für die Quelldaten; ausführen kann z. B. dadurch die Daten Ausschneiden, wenn der Vorgang einen Verschiebevorgang handelt.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Cancel`die <xref:System.Windows.Forms.Control.DragLeave> Ereignis wird ausgelöst.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, einen Drag-and-Drop-Vorgang zwischen zwei <xref:System.Windows.Forms.ListBox> Steuerelemente. Im Beispiel wird die <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode, wenn der Ziehvorgang beginnt. Der Ziehvorgang beginnt, wenn die Maus bewegt hat mehr als <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> aus die Position des Mauszeigers während der <xref:System.Windows.Forms.Control.MouseDown> Ereignis. Die <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> Methode wird verwendet, um zu bestimmen, den Index des Elements, das beim Ziehen die `MouseDown` Ereignis.  
  
 Das Beispiel veranschaulicht außerdem die Verwendung von benutzerdefiniertem Cursor für den Drag & Drop-Vorgang. Das Beispiel erfordert, dass zwei Cursordateien `3dwarro.cur` und `3dwno.cur`, im Anwendungsverzeichnis, für den benutzerdefinierten vorhanden und Drop bzw. den Cursor. Die benutzerdefinierte Cursor verwendet werden, wenn die `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> aktiviert ist. Die benutzerdefinierte Cursor werden festgelegt, der <xref:System.Windows.Forms.Control.GiveFeedback> -Ereignishandler.  
  
 Die Tastaturstatus wird ausgewertet, der <xref:System.Windows.Forms.Control.DragOver> -Ereignishandler für das Recht `ListBox`, um zu bestimmen, welche des Ziehvorgangs werden basierend auf den Zustand der Tasten UMSCHALT, STRG, ALT oder STRG + ALT. Die Position in der `ListBox` , in die Dropdownliste käme werden auch während des bestimmt die `DragOver` Ereignis. Wenn die Daten so löschen Sie keine `String`, die <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> auf festgelegt ist `None` in <xref:System.Windows.Forms.DragDropEffects>. Schließlich wird der Status des im Dropdownmenü angezeigt, der `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 Die Daten für das Recht löschen `ListBox` wird bestimmt, der <xref:System.Windows.Forms.Control.DragDrop> -Ereignishandler und die `String` Wert wird an die entsprechende Stelle im hinzugefügt der `ListBox`. Wenn der Ziehvorgang außerhalb der Grenzen des Formulars verschoben, der Drag-and-Drop-Vorgang abgebrochen wird, der <xref:System.Windows.Forms.Control.QueryContinueDrag> -Ereignishandler.  
  
 Dieser Code veranschaulicht die Verwendung der <xref:System.Windows.Forms.Control.GiveFeedback> Ereignis. Finden Sie unter der <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode für das gesamte Codebeispiel dargestellt.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event EventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GotFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Steuerelement den Fokus erhält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Fokus ändern, indem Sie mithilfe der Tastatur (Registerkarte, UMSCHALT + TAB usw.), durch Aufrufen der <xref:System.Windows.Forms.Control.Select%2A> oder <xref:System.Windows.Forms.Control.SelectNextControl%2A> Methoden, oder durch Festlegen der <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> Eigenschaft auf das aktuelle Formular den Fokusereignisse auftreten, in der folgenden Reihenfolge:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Wenn Sie den Fokus ändern, mit der Maus oder durch Aufrufen der <xref:System.Windows.Forms.Control.Focus%2A> -Methode, den Fokusereignisse auftreten, in der folgenden Reihenfolge:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A> -Eigenschaftensatz auf `false`, <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> Ereignisse werden unterdrückt.  
  
 **Hinweis** der <xref:System.Windows.Forms.Control.GotFocus> und <xref:System.Windows.Forms.Control.LostFocus> Ereignisse sind auf niedriger Ebene Fokusereignisse, die an die Nachrichten WM_KILLFOCUS und WM_SETFOCUS Windows gebunden sind. In der Regel die <xref:System.Windows.Forms.Control.GotFocus> und <xref:System.Windows.Forms.Control.LostFocus> Ereignisse werden nur verwendet, bei der Aktualisierung <xref:System.Windows.Forms.UICues> oder beim Schreiben benutzerdefinierter Steuerelemente. Stattdessen die <xref:System.Windows.Forms.Control.Enter> und <xref:System.Windows.Forms.Control.Leave> Ereignisse sollte verwendet werden, für alle Steuerelemente außer der <xref:System.Windows.Forms.Form> Klasse, die die <xref:System.Windows.Forms.Form.Activated> und <xref:System.Windows.Forms.Form.Deactivate> Ereignisse. Weitere Informationen zu den <xref:System.Windows.Forms.Control.GotFocus> und <xref:System.Windows.Forms.Control.LostFocus> -Ereignissen finden Sie unter der [WM_SETFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646283\(v=vs.85\).aspx)und[WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) Themen.  
  
> [!CAUTION]
>  Versuchen Sie nicht, legen Sie den Fokus innerhalb der <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, oder <xref:System.Windows.Forms.Control.Validated> -Ereignishandler. Auf diese Weise kann dazu führen, dass die Anwendung oder das Betriebssystem nicht mehr reagiert. Weitere Informationen finden Sie unter der [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) Thema.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.GotFocus> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.GotFocus> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#47](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#47)]
 [!code-vb[System.Windows.Forms.EventExamples#47](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-515)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Fensterhandle ab, an das das Steuerelement gebunden ist.</summary>
        <value>Ein <see cref="T:System.IntPtr" /> mit dem Fensterhandle (<see langword="HWND" />) des Steuerelements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert, der die <xref:System.Windows.Forms.Control.Handle%2A> Eigenschaft ist ein Windows- `HWND`. Wenn das Handle noch nicht erstellt wurde, wird das Handle zu erstellenden Verweis auf diese Eigenschaft erzwungen werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Windows.Forms.ControlPaint.DrawFocusRectangle%2A?displayProperty=nameWithType> und <xref:System.Windows.Forms.Control.Handle%2A> Eigenschaft. Fügen zum Ausführen der Beispiel den folgenden Code in einem Formular. Fügen Sie zwei Schaltflächen, die mit dem Namen `Button1` und `Button2` in das Formular und vergewissern Sie sich an ihren Ereignishandler alle Ereignisse verbunden sind.  
  
 [!code-cpp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleCreated">
      <MemberSignature Language="C#" Value="public event EventHandler HandleCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleCreated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleCreated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Handle für das Steuerelement erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Handle wird erstellt, wenn die <xref:System.Windows.Forms.Control> zum ersten Mal angezeigt wird. Z. B. wenn ein <xref:System.Windows.Forms.Control> wird erstellt, hat <xref:System.Windows.Forms.Control.Visible%2A> festgelegt `false`, <xref:System.Windows.Forms.Control.HandleCreated> -Ereignis wird nicht ausgelöst werden, bis <xref:System.Windows.Forms.Control.Visible%2A> auf festgelegt ist `true`.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter[behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.HandleCreated> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.HandleCreated> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#37](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#37)]
 [!code-vb[System.Windows.Forms.EventExamples#37](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#37)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleDestroyed">
      <MemberSignature Language="C#" Value="public event EventHandler HandleDestroyed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleDestroyed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleDestroyed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Handle des Steuerelements gerade zerstört wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Während der <xref:System.Windows.Forms.Control.HandleDestroyed> Ereignis, das Steuerelement ist immer noch ein gültiges Windows-Steuerelement und dem <xref:System.Windows.Forms.Control.Handle%2A> neu erstellt werden können, durch Aufrufen der <xref:System.Windows.Forms.Control.RecreateHandle%2A> Methode.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.HandleDestroyed> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.HandleDestroyed> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#38](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#38)]
 [!code-vb[System.Windows.Forms.EventExamples#38](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#38)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChildren">
      <MemberSignature Language="C#" Value="public bool HasChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.HasChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement ein oder mehrere untergeordnete Steuerelemente enthält.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement ein oder mehrere untergeordnete Steuerelemente enthält, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.Controls%2A> Auflistung verfügt über eine <xref:System.Windows.Forms.Layout.ArrangedElementCollection.Count%2A> größer als 0 (null), die <xref:System.Windows.Forms.Control.HasChildren%2A> Eigenschaft zurück `true`. Zugreifen auf die <xref:System.Windows.Forms.Control.HasChildren%2A> Eigenschaft erzwingt nicht die Erstellung einer <xref:System.Windows.Forms.Control.ControlCollection> , wenn das Steuerelement keine untergeordneten Elemente aufweist, sodass Verweis auf diese Eigenschaft kann einen Leistungsvorteil bieten beim Durchlaufen einer Struktur von Steuerelementen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.BackColor%2A> und <xref:System.Windows.Forms.Control.ForeColor%2A> der Steuerelemente auf die Standardfarben für das System. Wenn das Steuerelement alle untergeordneten Steuerelemente verfügt, ruft der Code rekursiv selbst auf. Dieses Codebeispiel benötigen Sie ein <xref:System.Windows.Forms.Form> mit mindestens einem untergeordneten Steuerelement jedoch ein untergeordneter Container steuern, wie z. B. eine <xref:System.Windows.Forms.Panel> oder <xref:System.Windows.Forms.GroupBox>, mit einem eigenen untergeordneten Steuerelemente würde besser veranschaulichen die Rekursion.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public int Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe des Steuerelements ab bzw. legt diese fest.</summary>
        <value>Die Höhe des Steuerelements in Pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Änderungen an der <xref:System.Windows.Forms.Control.Height%2A> und <xref:System.Windows.Forms.Control.Top%2A> Eigenschaft Werte bewirken, dass die <xref:System.Windows.Forms.Control.Bottom%2A> Eigenschaftswert des Steuerelements ändern.  
  
> [!NOTE]
>  Die minimale Höhe für das abgeleitete Steuerelement <xref:System.Windows.Forms.Splitter> beträgt ein Pixel. Die Standardhöhe für die <xref:System.Windows.Forms.Splitter> Steuerelement ist drei Pixel. Festlegen der Höhe der <xref:System.Windows.Forms.Splitter> die Steuerung an einen Wert kleiner als eine den Eigenschaftswert auf die Standardhöhe zurückgesetzt wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt drei <xref:System.Windows.Forms.Button> Steuerelemente eines Formulars und legt deren Größe und Position mithilfe der verschiedenen hinsichtlich der Größe und Position-bezogene Eigenschaften. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> , besitzt eine Breite und Höhe von mindestens 300 Pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HelpRequested">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HelpEventHandler HelpRequested;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HelpEventHandler HelpRequested" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HelpRequested" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer die Hilfe für ein Steuerelement anfordert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.HelpRequested> -Ereignis wird normalerweise ausgelöst, wenn der Benutzer F1 drückt Schlüssel oder einen zugehörigen kontextbezogene Hilfe-Schaltfläche geklickt wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Behandlung der <xref:System.Windows.Forms.Control.HelpRequested> Ereignis, um benutzerdefinierte Hilfeinhalt für ein Formular mit vier Adressfeldern angezeigt. Die <xref:System.Windows.Forms.Control.HelpRequested> Ereignis wird ausgelöst, entweder durch Drücken der F1-Taste mit dem Fokus im Adressenfeld, oder die mithilfe der Schaltfläche "kontextbezogene Hilfe" und dann auf der Hilfecursor auf Adressenfeld. Die <xref:System.Windows.Forms.HelpEventArgs.Handled%2A> Eigenschaftensatz wird auf "true", um anzugeben, dass die `HelpRequested` Ereignis behandelt wird. Das Beispiel zeigt auch das Speichern des Hilfetext in der <xref:System.Windows.Forms.Control.Tag%2A?displayProperty=nameWithType> Eigenschaft.  
  
 [!code-cpp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CPP/helpevent.cpp#1)]
 [!code-csharp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CS/helpevent.cs#1)]
 [!code-vb[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/VB/helpevent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Hide" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verbirgt das Steuerelement vor dem Benutzer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ausblenden des Steuerelements entspricht dem Festlegen der <xref:System.Windows.Forms.Control.Visible%2A> Eigenschaft `false`. Nach der <xref:System.Windows.Forms.Control.Hide%2A> -Methode aufgerufen wird, die <xref:System.Windows.Forms.Control.Visible%2A> Eigenschaft gibt einen Wert von `false` bis die <xref:System.Windows.Forms.Control.Show%2A> Methode wird aufgerufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Schaltfläche ausgeblendet, wenn Sie die STRG-Taste gedrückt wird, wenn die Schaltfläche geklickt wird. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Button> mit dem Namen `button1` auf eine <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ImeMode ImeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den IME-Modus (Eingabemethoden-Editor) des Steuerelements ab oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Windows.Forms.ImeMode" />-Werte. Die Standardeinstellung ist <see cref="F:System.Windows.Forms.ImeMode.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein IME ist ein Programm, das Benutzern ermöglicht, komplexe Zeichen und Symbole, z. B. japanische Kanji-Zeichen, geben über eine Standardtastatur. Die <xref:System.Windows.Forms.Control.ImeMode%2A> -Eigenschaftensatz ist in der Regel auf <xref:System.Windows.Forms.ImeMode?displayProperty=nameWithType> für eine <xref:System.Windows.Forms.TextBox> Steuerelement, das nur numerische Werte eingegeben werden soll. Die <xref:System.Windows.Forms.Control.ImeMode%2A> Eigenschaftswert festgelegt ist, um <xref:System.Windows.Forms.ImeMode?displayProperty=nameWithType> für die <xref:System.Windows.Forms.Form> Klasse.  
  
 Die meisten Klassen, die nicht direkt unterstützen Eingabemethoden-Editoren, oder die direkte Eingabe von einer IME zulassen, werden den Wert dieser Eigenschaft auf festgelegt <xref:System.Windows.Forms.ImeMode.NoControl>.  
  
> [!IMPORTANT]
>  Der Benutzer kann interaktiv ändern die <xref:System.Windows.Forms.Control.ImeMode%2A> es sei denn, es programmgesteuert festgelegt wurde <xref:System.Windows.Forms.ImeMode?displayProperty=nameWithType>. In diesem Fall wird der Benutzer nicht den Eingabemethoden-Editor verwenden können.  
>   
>  Die <xref:System.Windows.Forms.Control.ImeMode%2A> Eigenschaft wird auf Windows 8 ignoriert, wenn der globale Eingabemodus aktiviert ist. Weitere Informationen finden Sie unter[Switch Text Eingabe geändert aus threadspezifisches pro Benutzer](http://go.microsoft.com/fwlink/?LinkID=256509).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der zugewiesene Wert ist nicht der <see cref="T:System.Windows.Forms.ImeMode" /> Enumerationswerte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ImeModeBase">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode ImeModeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeModeBase" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeModeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den IME-Modus eines Steuerelements ab oder legt diesen fest.</summary>
        <value>Der IME-Modus des Steuerelements.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeModeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ImeModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ImeModeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see cref="P:System.Windows.Forms.Control.ImeMode" />-Eigenschaft geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.ImeMode%2A> -Eigenschaft geändert wird, indem Sie entweder eine programmgesteuerte Änderung oder durch Interaktion.  
  
 Steuerelemente, die keine Eingabemethoden-Manager unterstützen werden dieses Ereignis nie ausgelöst werden.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignishandler, der ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster *PropertyName* `Changed` , sind wird ausgelöst, wenn das entsprechende *PropertyName* -Wert ändert (* PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> , enthält eine <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitLayout">
      <MemberSignature Language="C#" Value="protected virtual void InitLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InitLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird nach dem Hinzufügen des Steuerelements zu einem anderen Container aufgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.InitLayout%2A> Methode wird aufgerufen, unmittelbar nach dem Hinzufügen eines Steuerelements zu einem Container. Die <xref:System.Windows.Forms.Control.InitLayout%2A> -Methode ermöglicht es einem Steuerelement Datenbankzustands Layout basierend auf seinem Container initialisiert werden. Angenommen, Sie in der Regel Nutzungsrichtlinie Verankern und Andocken von an das Steuerelement in der <xref:System.Windows.Forms.Control.InitLayout%2A> Methode.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.Forms.Control.InitLayout" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Windows.Forms.Control.InitLayout" /> Methode, damit das Steuerelement ordnungsgemäß angezeigt wird.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erklärt die ganze Oberfläche des Steuerelements für ungültig und bewirkt, dass das Steuerelement neu gezeichnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Windows.Forms.Control.Invalidate%2A> -Methode nicht erzwingen, dass ein synchrones Zeichnen; um eine synchrone Paint zu erzwingen, rufen Sie die <xref:System.Windows.Forms.Control.Update%2A> Methode nach dem Aufruf der <xref:System.Windows.Forms.Control.Invalidate%2A> Methode. Wenn diese Methode ohne Parameter aufgerufen wird, wird der gesamte Clientbereich der aktualisierungsregion hinzugefügt.  
  
   
  
## Examples  
 Im folgenden Code Beispiel kann der Benutzer ein Bild oder eine Bilddatei in das Formular ziehen und an dem Punkt darauf angezeigt werden, gelöscht wird. Die <xref:System.Windows.Forms.Control.OnPaint%2A> Methode wird überschrieben, um das Bild gezeichnet werden jedes Mal der Form gezeichnet wird, andernfalls das Bild nur bis zum nächsten Neuzeichnen beibehalten möchten. Die <xref:System.Windows.Forms.Control.DragEnter> Ereignisbehandlungsmethode bestimmt den Typ der Daten in das Formular gezogen wird, und das entsprechende Feedback enthält. Die <xref:System.Windows.Forms.Control.DragDrop> Ereignisbehandlungsmethode zeigt das Bild auf dem Formular ein, wenn ein <xref:System.Drawing.Image> aus Daten erstellt werden können. Da die <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> und <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> Werte sind Bildschirmkoordinaten, die im Beispiel wird die <xref:System.Windows.Forms.Control.PointToClient%2A> Methode, um sie in Clientkoordinaten zu konvertieren.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidateChildren">
          <see langword="true" />, um die untergeordneten Steuerelemente des Steuerelements für ungültig zu erklären, andernfalls <see langword="false" />.</param>
        <summary>Erklärt einen bestimmten Bereich des Steuerelements für ungültig und veranlasst, dass eine Zeichnenmeldung an das Steuerelement gesendet wird. Bei Bedarf wird das dem Steuerelement zugewiesene untergeordnete Steuerelement für ungültig erklärt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Windows.Forms.Control.Invalidate%2A> -Methode nicht erzwingen, dass ein synchrones Zeichnen; um eine synchrone Paint zu erzwingen, rufen Sie die <xref:System.Windows.Forms.Control.Update%2A> Methode nach dem Aufruf der <xref:System.Windows.Forms.Control.Invalidate%2A> Methode. Wenn diese Methode ohne Parameter aufgerufen wird, wird der gesamte Clientbereich der aktualisierungsregion hinzugefügt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rc">Ein <see cref="T:System.Drawing.Rectangle" />, das den für ungültig zu erklärenden Bereich darstellt.</param>
        <summary>Erklärt den angegebenen Bereich des Steuerelements für ungültig, indem es diesen dem Aktualisierungsbereich des Steuerelements hinzufügt. Dies ist der Bereich, der beim nächsten Zeichnenvorgang neu gezeichnet wird. Außerdem wird veranlasst, dass eine Zeichnenmeldung an das Steuerelement gesendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Windows.Forms.Control.Invalidate%2A> -Methode nicht erzwingen, dass ein synchrones Zeichnen; um eine synchrone Paint zu erzwingen, rufen Sie die <xref:System.Windows.Forms.Control.Update%2A> Methode nach dem Aufruf der <xref:System.Windows.Forms.Control.Invalidate%2A> Methode. Wenn diese Methode ohne Parameter aufgerufen wird, wird der gesamte Clientbereich der aktualisierungsregion hinzugefügt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">Die für ungültig zu erklärende <see cref="T:System.Drawing.Region" />.</param>
        <summary>Erklärt den angegebenen Bereich des Steuerelements für ungültig, indem es diesen dem Aktualisierungsbereich des Steuerelements hinzufügt. Dies ist der Bereich, der beim nächsten Zeichnenvorgang neu gezeichnet wird. Außerdem wird veranlasst, dass eine Zeichnenmeldung an das Steuerelement gesendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Windows.Forms.Control.Invalidate%2A> -Methode nicht erzwingen, dass ein synchrones Zeichnen; um eine synchrone Paint zu erzwingen, rufen Sie die <xref:System.Windows.Forms.Control.Update%2A> Methode nach dem Aufruf der <xref:System.Windows.Forms.Control.Invalidate%2A> Methode. Wenn diese Methode ohne Parameter aufgerufen wird, wird der gesamte Clientbereich der aktualisierungsregion hinzugefügt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rc">Ein <see cref="T:System.Drawing.Rectangle" />, das den für ungültig zu erklärenden Bereich darstellt.</param>
        <param name="invalidateChildren">
          <see langword="true" />, um die untergeordneten Steuerelemente des Steuerelements für ungültig zu erklären, andernfalls <see langword="false" />.</param>
        <summary>Erklärt den angegebenen Bereich des Steuerelements für ungültig, indem es diesen dem Aktualisierungsbereich des Steuerelements hinzufügt. Dies ist der Bereich, der beim nächsten Zeichnenvorgang neu gezeichnet wird. Außerdem wird veranlasst, dass eine Zeichnenmeldung an das Steuerelement gesendet wird. Bei Bedarf wird das dem Steuerelement zugewiesene untergeordnete Steuerelement für ungültig erklärt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Windows.Forms.Control.Invalidate%2A> -Methode nicht erzwingen, dass ein synchrones Zeichnen; um eine synchrone Paint zu erzwingen, rufen Sie die <xref:System.Windows.Forms.Control.Update%2A> Methode nach dem Aufruf der <xref:System.Windows.Forms.Control.Invalidate%2A> Methode. Wenn diese Methode ohne Parameter aufgerufen wird, wird der gesamte Clientbereich der aktualisierungsregion hinzugefügt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="region">Die für ungültig zu erklärende <see cref="T:System.Drawing.Region" />.</param>
        <param name="invalidateChildren">
          <see langword="true" />, um die untergeordneten Steuerelemente des Steuerelements für ungültig zu erklären, andernfalls <see langword="false" />.</param>
        <summary>Erklärt den angegebenen Bereich des Steuerelements für ungültig, indem es diesen dem Aktualisierungsbereich des Steuerelements hinzufügt. Dies ist der Bereich, der beim nächsten Zeichnenvorgang neu gezeichnet wird. Außerdem wird veranlasst, dass eine Zeichnenmeldung an das Steuerelement gesendet wird. Bei Bedarf wird das dem Steuerelement zugewiesene untergeordnete Steuerelement für ungültig erklärt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Windows.Forms.Control.Invalidate%2A> -Methode nicht erzwingen, dass ein synchrones Zeichnen; um eine synchrone Paint zu erzwingen, rufen Sie die <xref:System.Windows.Forms.Control.Update%2A> Methode nach dem Aufruf der <xref:System.Windows.Forms.Control.Invalidate%2A> Methode. Wenn diese Methode ohne Parameter aufgerufen wird, wird der gesamte Clientbereich der aktualisierungsregion hinzugefügt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidated">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InvalidateEventHandler Invalidated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InvalidateEventHandler Invalidated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Invalidated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InvalidateEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn für die Anzeige eines Steuerelements eine Neuzeichnung erforderlich ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.Invalidated> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.Invalidated> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#40)]
 [!code-vb[System.Windows.Forms.EventExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#40)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat, der eine aufzurufende Methode im Threadkontext des Steuerelements enthält.</param>
        <summary>Führt den angegebenen Delegaten für den Thread aus, der das dem Steuerelement zugrunde liegende Fensterhandle besitzt.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegaten ähneln Funktionszeiger in C oder C++-Sprachen. Delegaten einen Verweis auf eine Methode innerhalb einer Delegatobjekt zu kapseln. Das Delegatobjekt kann dann an Code, der die referenzierte Methodenaufrufe übergeben werden, und die aufgerufene Methode kann zum Zeitpunkt der Kompilierung unbekannt sein. Im Gegensatz zu Funktionszeigern in C oder C++ sind Delegaten objektorientiert, typsicher und sicherer.  
  
 Die <xref:System.Windows.Forms.Control.Invoke%2A> Methode sucht das Steuerelement übergeordneten Kette bis gefunden wird, ein Steuerelement oder ein Formular, das ein Fenster zu verarbeiten, wenn das zugrunde liegende Fensterhandle des Steuerelements noch nicht vorhanden ist. Wenn kein entsprechendes Handle gefunden werden kann, die <xref:System.Windows.Forms.Control.Invoke%2A> Methode löst eine Ausnahme aus. Während des Aufrufs ausgelöste Ausnahmen werden zurück an den Aufrufer weitergegeben.  
  
> [!NOTE]
>  Zusätzlich zu den <xref:System.Windows.Forms.Control.InvokeRequired%2A> -Eigenschaft, es gibt vier Methoden für ein Steuerelement, die threadsicher sind: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, und <xref:System.Windows.Forms.Control.CreateGraphics%2A> , wenn das Handle für das Steuerelement bereits erstellt wurde. Aufrufen von <xref:System.Windows.Forms.Control.CreateGraphics%2A> , bevor das Handle des Steuerelements in einem Hintergrundthread erstellt werden können dazu führen, dass unzulässigen threadübergreifenden aufrufen. Für alle anderen Methodenaufrufe sollten Sie eine der Methoden Invoke verwenden, um den Aufruf an das Steuerelement-Thread zu marshallen.  
  
 Der Delegat kann einer Instanz von <xref:System.EventHandler>, in diesem Fall der Absenderparameter dieses Steuerelement enthält, und die Ereignisparameter enthält <xref:System.EventArgs.Empty?displayProperty=nameWithType>. Der Delegat kann auch eine Instanz von <xref:System.Windows.Forms.MethodInvoker>, oder einen beliebigen anderen Delegaten, der eine-Parameterliste der "void" akzeptiert. Ein Aufruf einer <xref:System.EventHandler> oder <xref:System.Windows.Forms.MethodInvoker> Delegat wird als ein Aufruf von einem anderen Typ des Delegaten schneller sein.  
  
> [!NOTE]
>  Eine Ausnahme kann ausgelöst werden, wenn der Thread, der die Nachricht zu verarbeiten, sollten nicht mehr aktiv ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, Steuerelemente, die einen Delegaten enthalten. Der Delegat kapselt eine Methode, die im Listenfeld Elemente hinzufügt, und diese Methode wird für den Thread, der Besitzer das zugrunde liegende Handle des Formulars ist, ausgeführt. Wenn der Benutzer auf die Schaltfläche klickt `Invoke` führt den Delegaten.  
  
 [!code-cpp[Control_Invoke2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke2/CPP/control_invoke2.cpp#1)]
 [!code-csharp[Control_Invoke2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke2/CS/control_invoke2.cs#1)]
 [!code-vb[Control_Invoke2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke2/VB/control_invoke2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat, der eine Methode, die mit Parametern über die gleiche Anzahl und Typ, der in enthalten sind die <c>Args</c> Parameter.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Dieser Parameter kann <see langword="null" /> sein, wenn die Methode keine Argumente annimmt.</param>
        <summary>Führt mit der angegebenen Argumentliste den angegebenen Delegaten für den Thread aus, der das dem Steuerelement zugrunde liegende Fensterhandle besitzt.</summary>
        <returns>Ein <see cref="T:System.Object" />, das den Rückgabewert des aufgerufenen Delegaten enthält, oder <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegaten ähneln Funktionszeiger in C oder C++-Sprachen. Delegaten einen Verweis auf eine Methode innerhalb einer Delegatobjekt zu kapseln. Das Delegatobjekt kann dann an Code, der die referenzierte Methodenaufrufe übergeben werden, und die aufgerufene Methode kann zum Zeitpunkt der Kompilierung unbekannt sein. Im Gegensatz zu Funktionszeigern in C oder C++ sind Delegaten objektorientiert, typsicher und sicherer.  
  
 Wenn das Handle des Steuerelements noch nicht vorhanden ist, durchsucht dieser Methode Kette übergeordneter des Steuerelements bis zu einem Steuerelement oder ein Formular, das ein Fensterhandle besitzt. Wenn kein entsprechendes Handle gefunden werden kann, löst diese Methode eine Ausnahme aus. Während des Aufrufs ausgelöste Ausnahmen werden zurück an den Aufrufer weitergegeben.  
  
> [!NOTE]
>  Zusätzlich zu den <xref:System.Windows.Forms.Control.InvokeRequired%2A> -Eigenschaft, es gibt vier Methoden für ein Steuerelement, die threadsicher sind: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A>, und <xref:System.Windows.Forms.Control.CreateGraphics%2A> , wenn das Handle für das Steuerelement bereits erstellt wurde. Aufrufen von <xref:System.Windows.Forms.Control.CreateGraphics%2A> , bevor das Handle des Steuerelements in einem Hintergrundthread erstellt werden können dazu führen, dass unzulässigen threadübergreifenden aufrufen. Für alle anderen Methodenaufrufe sollten Sie eine der Methoden Invoke verwenden, um den Aufruf an das Steuerelement-Thread zu marshallen.  
  
 Der Delegat kann einer Instanz von <xref:System.EventHandler>, in diesem Fall der Absenderparameter dieses Steuerelement enthält, und die Ereignisparameter enthält <xref:System.EventArgs.Empty?displayProperty=nameWithType>. Der Delegat kann auch eine Instanz von <xref:System.Windows.Forms.MethodInvoker>, oder einen beliebigen anderen Delegaten, der eine-Parameterliste der "void" akzeptiert. Ein Aufruf einer <xref:System.EventHandler> oder <xref:System.Windows.Forms.MethodInvoker> Delegat wird als ein Aufruf von einem anderen Typ des Delegaten schneller sein.  
  
> [!NOTE]
>  Eine Ausnahme kann ausgelöst werden, wenn der Thread, der die Nachricht zu verarbeiten, sollten nicht mehr aktiv ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, Steuerelemente, die einen Delegaten enthalten. Der Delegat kapselt eine Methode, die im Listenfeld hinzufügt, und diese Methode für den Thread, der Besitzer das zugrunde liegende Handle des Formulars ist, mit den angegebenen Argumenten, ausgeführt wird. Wenn der Benutzer auf die Schaltfläche klickt `Invoke` führt den Delegaten.  
  
 [!code-cpp[Control_Invoke1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke1/CPP/control_invoke1.cpp#1)]
 [!code-csharp[Control_Invoke1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke1/CS/control_invoke1.cs#1)]
 [!code-vb[Control_Invoke1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke1/VB/control_invoke1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeGotFocus">
      <MemberSignature Language="C#" Value="protected void InvokeGotFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeGotFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">Das <see cref="T:System.Windows.Forms.Control" />, dem das Ereignis zugewiesen werden soll.</param>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.GotFocus" />-Ereignis für das angegebene Steuerelement aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeLostFocus">
      <MemberSignature Language="C#" Value="protected void InvokeLostFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeLostFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">Das <see cref="T:System.Windows.Forms.Control" />, dem das Ereignis zugewiesen werden soll.</param>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.LostFocus" />-Ereignis für das angegebene Steuerelement aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeOnClick">
      <MemberSignature Language="C#" Value="protected void InvokeOnClick (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeOnClick(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">Das <see cref="T:System.Windows.Forms.Control" />, dem das <see cref="E:System.Windows.Forms.Control.Click" />-Ereignis zugewiesen werden soll.</param>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Click" />-Ereignis für das angegebene Steuerelement aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokePaint">
      <MemberSignature Language="C#" Value="protected void InvokePaint (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaint(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c">Das <see cref="T:System.Windows.Forms.Control" />, dem das <see cref="E:System.Windows.Forms.Control.Paint" />-Ereignis zugewiesen werden soll.</param>
        <param name="e">Ein <see cref="T:System.Windows.Forms.PaintEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Paint" />-Ereignis für das angegebene Steuerelement aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokePaintBackground">
      <MemberSignature Language="C#" Value="protected void InvokePaintBackground (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaintBackground(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c">Das <see cref="T:System.Windows.Forms.Control" />, dem das <see cref="E:System.Windows.Forms.Control.Paint" />-Ereignis zugewiesen werden soll.</param>
        <param name="e">Ein <see cref="T:System.Windows.Forms.PaintEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see langword="PaintBackground" />-Ereignis für das angegebene Steuerelement aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeRequired">
      <MemberSignature Language="C#" Value="public bool InvokeRequired { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvokeRequired" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.InvokeRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt ob der Aufrufer beim Aufruf von Methoden des Steuerelements eine Aufrufmethode aufrufen muss, da sich der Aufrufer in einem anderen Thread als dem befindet, in dem das Steuerelement erstellt wurde.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="P:System.Windows.Forms.Control.Handle" /> des Steuerelements in einem anderen Thread als dem aufrufenden Thread erstellt wurde, sodass Aufrufe des Steuerelements durch eine Aufrufmethode erfolgen müssen), andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerelemente in Windows Forms gebunden sind, für einen bestimmten Thread und sind nicht threadsicher. Aus diesem Grund werden, wenn Sie eine Methode des Steuerelements aus einem anderen Thread aufrufen, müssen Sie eine Verwenden von des Steuerelements Aufrufen von Methoden, um den Aufruf an den richtigen Thread zu marshallen. Diese Eigenschaft kann verwendet werden, um festzustellen, ob Sie eine Aufrufmethode, die ist hilfreich aufrufen müssen, wenn Sie nicht wissen, welcher Thread ein Steuerelement besitzt.  
  
> [!NOTE]
>  Zusätzlich zu den <xref:System.Windows.Forms.Control.InvokeRequired%2A> -Eigenschaft, es gibt vier Methoden in einem Steuerelement threadsicher aufgerufen werden: <xref:System.Windows.Forms.Control.Invoke%2A>,<xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> und <xref:System.Windows.Forms.Control.CreateGraphics%2A> , wenn das Handle für das Steuerelement bereits erstellt wurde. Aufrufen von <xref:System.Windows.Forms.Control.CreateGraphics%2A> , bevor das Handle des Steuerelements in einem Hintergrundthread erstellt werden können dazu führen, dass unzulässigen threadübergreifenden aufrufen. Für alle anderen Methodenaufrufe, sollten Sie mithilfe eines der folgenden Methoden beim Aufrufen aus einem anderen Thread aufgerufen werden soll.  
  
 Wenn das Handle des Steuerelements noch nicht vorhanden ist, <xref:System.Windows.Forms.Control.InvokeRequired%2A> durchsucht das Steuerelement übergeordnete Kette bis gefunden wird, ein Steuerelement oder ein Formular, das ein Fensterhandle besitzt. Wenn kein entsprechendes Handle gefunden werden kann, die <xref:System.Windows.Forms.Control.InvokeRequired%2A> -Methode zurückkehrt `false`.  
  
 Dies bedeutet, dass <xref:System.Windows.Forms.Control.InvokeRequired%2A> zurückgeben können `false` Wenn <xref:System.Windows.Forms.Control.Invoke%2A> ist nicht erforderlich (der Aufruf erfolgt im selben Thread), oder wenn das Steuerelement in einem anderen Thread erstellt wurde, aber das Handle des Steuerelements noch nicht erstellt wurde.  
  
 Im Fall, in dem das Handle des Steuerelements nicht noch erstellt wurde, sollten Sie nicht einfach Eigenschaften, Methoden oder Ereignisse für das Steuerelement aufrufen. Dies kann dazu führen, dass das Handle des Steuerelements im Hintergrundthread, der das Steuerelement in einem Thread ohne ein Nachrichtensystem isolieren und die Anwendung destabilisiert erstellt werden.  
  
 Sie können für diesen Fall schützen, durch den Wert der überprüfen <xref:System.Windows.Forms.Control.IsHandleCreated%2A> beim <xref:System.Windows.Forms.Control.InvokeRequired%2A> gibt `false` in einem Hintergrundthread auf. Wenn das Steuerelementhandle noch nicht erstellt wurde, müssen Sie warten, bis es vor dem Aufruf erstellt wurde <xref:System.Windows.Forms.Control.Invoke%2A> oder <xref:System.Windows.Forms.Control.BeginInvoke%2A>. Dies geschieht normalerweise nur, wenn ein Thread im Hintergrund im Konstruktor des primären Formulars für die Anwendung erstellt wird (wie in `Application.Run(new MainForm())`, bevor das Formular gezeigt wurde oder `Application.Run` aufgerufen wurde.  
  
 Eine Lösung besteht darin, warten Sie, bis der Handle des Formulars vor dem Starten des Hintergrundthreads erstellt wurde. Erzwingen Sie Erstellung Handle durch Aufrufen der <xref:System.Windows.Forms.Control.Handle%2A> -Eigenschaft sein, oder warten Sie, bis die <xref:System.Windows.Forms.Form.Load> Ereignis, um die im Hintergrund ausgeführten Prozess zu starten.  
  
 Eine noch bessere Lösung ist die Verwendung der `SynchronizationContext` zurückgegebenes <xref:System.Threading.SynchronizationContext> anstelle eines Steuerelements für das Marshalling von threadübergreifenden.  
  
> [!NOTE]
>  Eine Ausnahme kann ausgelöst werden, wenn der Thread, der die Nachricht zu verarbeiten, sollten nicht mehr aktiv ist.  
  
 Weitere Informationen zu Multithread-Windows Forms-Steuerelementen finden Sie unter [wie: Verwenden Sie einen Hintergrundthread für die Suche nach Dateien](~/docs/framework/winforms/controls/how-to-use-a-background-thread-to-search-for-files.md) und [Vorgehensweise: Stellen Sie threadsichere Aufrufe von Windows Forms-Steuerelementen](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAccessible">
      <MemberSignature Language="C#" Value="public bool IsAccessible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAccessible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsAccessible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement für barrierefreie Anwendungen sichtbar ist, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement für barrierefreie Anwendungen sichtbar ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement freigegeben wurde.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement freigegeben wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft gibt `true`, das Steuerelement wurde verworfen und kann nicht mehr als ein gültiges Windows-Steuerelement verwiesen werden. Auch wenn die Instanz eines Steuerelements verworfen wird, wird es weiterhin im Arbeitsspeicher beibehalten, bis sie durch die Garbagecollection aus dem Speicher entfernt wird. Wenn ein Steuerelement verworfen wird, kann nicht aufrufen seiner <xref:System.Windows.Forms.Control.RecreateHandle%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHandleCreated">
      <MemberSignature Language="C#" Value="public bool IsHandleCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleCreated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsHandleCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dem Steuerelement ein Handle zugeordnet ist.</summary>
        <value>
          <see langword="true" />, wenn dem Steuerelement ein Handle zugeordnet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Forms.Control.IsHandleCreated%2A> -Eigenschaft können Sie bestimmen, ob <xref:System.Windows.Forms.Control.CreateHandle%2A> aufgerufen wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputChar">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Das zu überprüfende Zeichen.</param>
        <summary>Bestimmt, ob ein Zeichen ein vom Steuerelement erkanntes Eingabezeichen ist.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen direkt an das Steuerelement gesendet und nicht vorverarbeitet werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.Forms.Control.IsInputChar%2A> Methode, um zu bestimmen, ob das angegebene Zeichen durch die `charCode` Parameter ist ein Eingabezeichen, das das Steuerelement möchte. Diese Methode wird aufgerufen, während die Fenster Nachricht vorverarbeiten, um zu bestimmen, ob das angegebene Eingabezeichen vorverarbeitet oder direkt an das Steuerelement gesendet werden soll. Wenn <xref:System.Windows.Forms.Control.IsInputChar%2A> gibt `true`, das angegebene Zeichen direkt an das Steuerelement gesendet wird. Wenn <xref:System.Windows.Forms.Control.IsInputChar%2A> gibt `false`, das angegebene Zeichen vorverarbeitet und nur dann an das Steuerelement gesendet werden, wenn er nicht in der Vorverarbeitungsphase verarbeitet wird. Die vorverarbeitung der ein Zeichen enthält, wird geprüft, ob das Zeichen eines mnemonischen Codes eines anderen Steuerelements ist.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Einer der <see cref="T:System.Windows.Forms.Keys" />-Werte.</param>
        <summary>Bestimmt, ob es sich bei der angegebenen Taste um eine normale Eingabetaste handelt oder um eine Sondertaste, für die eine Vorverarbeitung erforderlich ist.</summary>
        <returns>
          <see langword="true" />, wenn die angegebene Taste eine normale Taste ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.Forms.Control.IsInputKey%2A> Methode, um zu bestimmen, ob der Schlüssel vom angegeben der `keyData` Parameter ist ein Eingabe-Schlüssel, der das Steuerelement möchte. Diese Methode wird aufgerufen, während die Fenster Nachricht vorverarbeiten, um zu bestimmen, ob die angegebene Taste vorverarbeitet oder direkt an das Steuerelement gesendet werden soll. Wenn <xref:System.Windows.Forms.Control.IsInputKey%2A> gibt `true`, der angegebene Schlüssel direkt an das Steuerelement gesendet wird. Wenn <xref:System.Windows.Forms.Control.IsInputKey%2A> gibt `false`, der angegebene Schlüssel vorverarbeitet und nur dann an das Steuerelement gesendet werden, wenn er nicht in der Vorverarbeitungsphase verarbeitet wird. Tasten, die vorverarbeitet werden, gehören die Registerkarte, RETURN, ESC-Taste, und die nach-oben, nach-unten, links und nach-rechts-Schlüssel.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Überschreiben der <xref:System.Windows.Forms.Control.IsInputKey%2A> Methode für eine <xref:System.Windows.Forms.TextBox> Steuerelement. In diesem Beispiel wird die `TabTextBox` Klasse verarbeitet die TAB-Taste. Wenn die `TabTextBox` den Fokus besitzt, und der Benutzer drückt die TAB-Taste vier Speicherplätzen werden an der Texteinfügemarke hinzugefügt und Ersetzen Sie dabei alle markierten Text. Wird standardmäßig die <xref:System.Windows.Forms.TextBox> Steuerelement verarbeitet die TAB-Taste durch den Eingabefokus auf das nächste Steuerelement verschieben. In diesem Fall das Keypress nie erreicht die <xref:System.Windows.Forms.Control.OnKeyDown%2A> Methode überschreiben. Um dieses Standardverhalten zu verhindern, dass die <xref:System.Windows.Forms.Control.IsInputKey%2A> -methodenüberschreibung gibt `true` Wenn der Benutzer die TAB-Taste drückt. Für alle anderen KeyPress-Ereignissen die <xref:System.Windows.Forms.Control.IsInputKey%2A> methodenüberschreibung gibt das Ergebnis des Aufrufs der Methode die Basisklassenversion.  
  
 [!code-csharp[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/cs/form1.cs#0)]
 [!code-vb[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/vb/form1.vb#0)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsKeyLocked">
      <MemberSignature Language="C#" Value="public static bool IsKeyLocked (System.Windows.Forms.Keys keyVal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyLocked(valuetype System.Windows.Forms.Keys keyVal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsKeyLocked(System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyVal" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyVal">Der FESTSTELLTASTE-, NUM- oder ROLLEN-Member der <see cref="T:System.Windows.Forms.Keys" />-Enumeration.</param>
        <summary>Bestimmt, ob die FESTSTELLTASTE, NUM oder ROLLEN aktiviert ist.</summary>
        <returns>
          <see langword="true" />, wenn die angegebenen Tasten aktiviert sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Forms.Control.IsKeyLocked%2A> Eigenschaft, um zu bestimmen, ob die FESTSTELLTASTE, NUM oder Rollen, entweder einzeln oder in Kombination sind.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt ein Meldungsfeld gibt an, ob der angegebene Schlüssel (FESTSTELLTASTE in diesem Fall) wirksam wird.  
  
 [!code-cpp[ControlIsKeyLocked#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlIsKeyLocked/CPP/controliskeylocked.cpp#1)]
 [!code-csharp[ControlIsKeyLocked#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlIsKeyLocked/CS/controliskeylocked.cs#1)]
 [!code-vb[ControlIsKeyLocked#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlIsKeyLocked/VB/controliskeylocked.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die <paramref name="keyVal" /> Parameter verweist auf eine Taste als die FESTSTELLTASTE, NUM oder Rollen.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMirrored">
      <MemberSignature Language="C#" Value="public bool IsMirrored { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMirrored" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsMirrored" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement gespiegelt wird.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement gespiegelt wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein gespiegeltes Steuerelement zeigt das Layout und Text von rechts nach links. Weitere Informationen finden Sie unter [Vorgehensweise: Erstellen von gespiegelten Windows Forms und Steuerelementen](http://msdn.microsoft.com/en-us/7c5c4ecc-9bfb-4508-8383-753e306719b1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMnemonic">
      <MemberSignature Language="C#" Value="public static bool IsMnemonic (char charCode, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMnemonic(char charCode, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="charCode">Das zu überprüfende Zeichen.</param>
        <param name="text">Die zu durchsuchende Zeichenfolge.</param>
        <summary>Bestimmt, ob das angegebene Zeichen das mnemonische Zeichen ist, das dem Steuerelement in der angegebenen Zeichenfolge zugewiesen wurde.</summary>
        <returns>
          <see langword="true" />, wenn das <paramref name="charCode" />-Zeichen das dem Steuerelement zugewiesene mnemonische Zeichen ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das mnemonische Zeichen ist das Zeichen unmittelbar nach der ersten Instanz von "&" in eine <xref:System.String>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, eine Erweiterung der Schaltfläche-Klasse, überschreibt die <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> Methode, um benutzerdefiniertes Verhalten bereitzustellen. Das Beispiel zeigt auch die Verwendung der <xref:System.Windows.Forms.Control.CanSelect%2A> und <xref:System.Windows.Forms.Control.IsMnemonic%2A> Eigenschaften. Fügen zum Ausführen dieses Beispiel den folgenden Code nach einer Form-Klasse, in der gleichen Datei. Fügen Sie eine Schaltfläche vom Typ `MnemonicButton` in das Formular.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Taste gedrückt wird, während das Steuerelement den Fokus hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tastaturereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Um Tastaturereignisse nur auf Formularebene zu behandeln und andere Steuerelemente zum Empfangen von Tastaturereignissen nicht aktivieren, legen Sie die <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> Eigenschaft in Ihrem Formulars <xref:System.Windows.Forms.Control.KeyPress> Ereignisbehandlungsmethode zu `true`. Bestimmte Tasten, z. B. die Registerkarte, RETURN, ESC und Pfeil werden von Steuerelementen automatisch behandelt. Diese Schlüssel Auslösen der <xref:System.Windows.Forms.Control.KeyDown> Ereignis müssen Sie überschreiben die <xref:System.Windows.Forms.Control.IsInputKey%2A> -Methode in jedes Steuerelement im Formular. Der Code zum Überschreiben von der <xref:System.Windows.Forms.Control.IsInputKey%2A> müssten zu bestimmen, ob eines der Sondertasten gedrückt wird, und gibt den Wert `true`. Anstelle von der <xref:System.Windows.Forms.Control.IsInputKey%2A> -Methode, die Sie behandeln die <xref:System.Windows.Forms.Control.PreviewKeyDown> Ereignis, und legen die <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> Eigenschaft `true`. Ein Codebeispiel finden Sie unter der <xref:System.Windows.Forms.Control.PreviewKeyDown> Ereignis.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.KeyDown> Ereignis, um den Typ der Zeichen in das Steuerelement eingegeben bestimmen.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyPressEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyPressEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyPress" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyPressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Zeichen-, die LEER- oder RÜCKTASTE gedrückt wird, während das Steuerelement den Fokus hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tastaturereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Die <xref:System.Windows.Forms.Control.KeyPress> Ereignis wird nicht von Schlüsseln von nicht-Zeichen als Leerzeichen und RÜCKTASTE; allerdings die Zeichentasten lösen die <xref:System.Windows.Forms.Control.KeyDown> und <xref:System.Windows.Forms.Control.KeyUp> Ereignisse.  
  
 Verwenden der <xref:System.Windows.Forms.KeyPressEventArgs.KeyChar%2A> Eigenschaft, um Tastatureingaben zur Laufzeit und zu verwenden oder eine Teilmenge von allgemeinen Tastatureingaben zu ändern.  
  
 Um Tastaturereignisse nur auf Formularebene zu behandeln und andere Steuerelemente zum Empfangen von Tastaturereignissen nicht aktivieren, legen Sie die <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> Eigenschaft in Ihrem Formulars <xref:System.Windows.Forms.Control.KeyPress> Ereignisbehandlungsmethode zu `true`.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.KeyPress> Ereignis, um zu verhindern, dass die Zeichen Eintreten in das Steuerelement.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Taste losgelassen wird, während das Steuerelement den Fokus hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tastaturereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Um Tastaturereignisse nur auf Formularebene zu behandeln und andere Steuerelemente zum Empfangen von Tastaturereignissen nicht aktivieren, legen Sie die <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> Eigenschaft in Ihrem Formulars <xref:System.Windows.Forms.Control.KeyPress> Ereignisbehandlungsmethode zu `true`. Bestimmte Tasten, z. B. die Registerkarte, RETURN, ESC und Pfeil werden von Steuerelementen automatisch behandelt. Diese Schlüssel Auslösen der <xref:System.Windows.Forms.Control.KeyUp> Ereignis müssen Sie überschreiben die <xref:System.Windows.Forms.Control.IsInputKey%2A> -Methode in jedes Steuerelement im Formular. Der Code für die Außerkraftsetzung der <xref:System.Windows.Forms.Control.IsInputKey%2A> müssten zu bestimmen, ob eines der Sondertasten gedrückt wird, und gibt den Wert `true`.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.KeyUp> Ereignis mit der <xref:System.Windows.Forms.Help> Klasse, um dem Benutzer die Hilfe als Popup anzuzeigen.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Layout">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LayoutEventHandler Layout;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LayoutEventHandler Layout" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Layout" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LayoutEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Steuerelement seine untergeordneten Steuerelemente neu positionieren muss.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Layout> Ereignis tritt auf, wenn untergeordnete Steuerelemente hinzugefügt oder entfernt werden, wenn die Begrenzungen des Steuerelements ändert, und wenn andere Veränderungen stattfinden, die das Layout des Steuerelements beeinflussen können. Das Layout-Ereignis kann unterdrückt werden, mithilfe der <xref:System.Windows.Forms.Control.SuspendLayout%2A> und <xref:System.Windows.Forms.Control.ResumeLayout%2A> Methoden. Zum Anhalten geführt Layout können Sie mehrere Aktionen für ein Steuerelement ausführen, ohne ein Layout für jede Änderung auszuführen. Beispielsweise, wenn Sie die Größe und Position ein Steuerelements, jede Operation ausgelöst werden soll, eine <xref:System.Windows.Forms.Control.Layout> Ereignis.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird Rechenzentren eine <xref:System.Windows.Forms.Form> auf dem Bildschirm in der <xref:System.Windows.Forms.Control.Layout> Ereignis. Dadurch wird das Formular zentriert, wenn der Benutzer die Größe ändern lassen möchten. Dieses Beispiel benötigen Sie nach der Erstellung einer <xref:System.Windows.Forms.Form> Steuerelement.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutEngine">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Layout.LayoutEngine LayoutEngine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Layout.LayoutEngine LayoutEngine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.LayoutEngine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Layout.LayoutEngine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine zwischengespeicherte Instanz des Layoutmoduls des Steuerelements ab.</summary>
        <value>Die <see cref="T:System.Windows.Forms.Layout.LayoutEngine" /> für den Inhalt des Steuerelements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.LayoutEngine%2A> -Eigenschaft ruft die Layoutmodul ab, für die untergeordneten Elemente des Steuerelements statt für das Steuerelement selbst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public event EventHandler Leave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Leave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Leave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Eingabefokus das Steuerelement verlässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Fokus ändern, indem Sie mithilfe der Tastatur (Registerkarte, UMSCHALT + TAB usw.), durch Aufrufen der <xref:System.Windows.Forms.Control.Select%2A> oder <xref:System.Windows.Forms.Control.SelectNextControl%2A> Methoden, oder durch Festlegen der <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> Eigenschaft auf das aktuelle Formular den Fokusereignisse auftreten, in der folgenden Reihenfolge:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Wenn Sie den Fokus ändern, mit der Maus oder durch Aufrufen der <xref:System.Windows.Forms.Control.Focus%2A> -Methode, den Fokusereignisse auftreten, in der folgenden Reihenfolge:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A> -Eigenschaftensatz auf `false`, <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> Ereignisse werden unterdrückt.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.Control.Enter> und <xref:System.Windows.Forms.Control.Leave> Ereignisse unterdrückt werden, indem die <xref:System.Windows.Forms.Form> Klasse. Die entsprechenden Ereignisse in der <xref:System.Windows.Forms.Form> Klasse werden die <xref:System.Windows.Forms.Form.Activated> und <xref:System.Windows.Forms.Form.Deactivate> Ereignisse. Die <xref:System.Windows.Forms.Control.Enter> und <xref:System.Windows.Forms.Control.Leave> Ereignisse sind hierarchisch und werden nach oben oder unten der übergeordneten Kette weitergegeben, bis das entsprechende Steuerelement erreicht ist. Nehmen wir beispielsweise an, Sie haben eine <xref:System.Windows.Forms.Form> mit zwei <xref:System.Windows.Forms.GroupBox> Steuerelemente, und jedes <xref:System.Windows.Forms.GroupBox> Steuerelement verfügt über einen <xref:System.Windows.Forms.TextBox> Steuerelement. Beim Bewegen der Einfügemarke eine <xref:System.Windows.Forms.TextBox> zu "other" die <xref:System.Windows.Forms.Control.Leave> Ereignis wird ausgelöst, für die <xref:System.Windows.Forms.TextBox> und <xref:System.Windows.Forms.GroupBox>, und die <xref:System.Windows.Forms.Control.Enter> Ereignis wird ausgelöst, für die anderen <xref:System.Windows.Forms.GroupBox> und <xref:System.Windows.Forms.TextBox>.  
  
> [!CAUTION]
>  Versuchen Sie nicht, legen Sie den Fokus innerhalb der <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, oder <xref:System.Windows.Forms.Control.Validated> -Ereignishandler. Auf diese Weise kann dazu führen, dass die Anwendung oder das Betriebssystem nicht mehr reagiert. Weitere Informationen finden Sie unter der [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) Thema.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.Leave> Ereignis ein Steuerelements auf seinen ursprünglichen Zustand zurückgesetzt.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public int Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Abstand zwischen dem linken Rand des Steuerelements und dem linken Rand des Clientbereichs des zugehörigen Containers in Pixel ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Int32" />-Wert, der den Abstand zwischen dem linken Rand des Steuerelements und dem linken Rand des Clientbereichs des zugehörigen Containers in Pixel darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Left%2A> Eigenschaftswert entspricht der <xref:System.Drawing.Point.X%2A?displayProperty=nameWithType> Eigenschaft von der <xref:System.Windows.Forms.Control.Location%2A> Eigenschaftswert des Steuerelements.  
  
 Änderungen an der <xref:System.Windows.Forms.Control.Width%2A> und <xref:System.Windows.Forms.Control.Left%2A> Eigenschaft Werte bewirken, dass die <xref:System.Windows.Forms.Control.Right%2A> Eigenschaftswert des Steuerelements ändern.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt drei <xref:System.Windows.Forms.Button> Steuerelemente eines Formulars und legt deren Größe und Position mithilfe der verschiedenen hinsichtlich der Größe und Position-bezogene Eigenschaften. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> , besitzt eine Breite und Höhe von mindestens 300 Pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Koordinaten der linken oberen Ecke des Steuerelements relativ zur linken oberen Ecke des Containers ab oder legt diese fest.</summary>
        <value>Der <see cref="T:System.Drawing.Point" />, der die linke obere Ecke des Steuerelements relativ zur linken oberen Ecke des Containers darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da die <xref:System.Drawing.Point> Klasse ist ein Werttyp (`Structure` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)], `struct` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)]), es wird zurückgegeben, mit dem Wert, d. h., den Zugriff auf die Eigenschaft gibt eine Kopie des linken oberen Punkts des Steuerelements zurück. Anpassen der <xref:System.Drawing.Point.X%2A> oder <xref:System.Drawing.Point.Y%2A> Eigenschaften der <xref:System.Drawing.Point> zurückgegeben, die von dieser Eigenschaft wirkt sich nicht die <xref:System.Windows.Forms.Control.Left%2A>, <xref:System.Windows.Forms.Control.Right%2A>, <xref:System.Windows.Forms.Control.Top%2A>, oder <xref:System.Windows.Forms.Control.Bottom%2A> Eigenschaftswerte des Steuerelements. Diese Eigenschaften, die jeden Eigenschaftswert einzeln festlegen oder Anpassen der <xref:System.Windows.Forms.Control.Location%2A> Eigenschaft mit einem neuen <xref:System.Drawing.Point>.  
  
 Wenn die <xref:System.Windows.Forms.Control> ist eine <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Control.Location%2A> Eigenschaftswert darstellt, der oberen linken Ecke des der <xref:System.Windows.Forms.Form> in Bildschirmkoordinaten.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Windows.Forms.GroupBox> und legt einige gemeinsamen Eigenschaften. Das Beispiel erstellt eine <xref:System.Windows.Forms.TextBox> und legt seine <xref:System.Windows.Forms.Control.Location%2A> innerhalb der Gruppenfeld. Als Nächstes wird die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaft der Gruppenfeld und wird das Gruppenfeld am oberen Rand des Formulars angedockt. Abschließend wird das Gruppenfeld deaktiviert, indem die <xref:System.Windows.Forms.Control.Enabled%2A> Eigenschaft `false`, die bewirkt, dass alle Steuerelemente, die deaktiviert werden in der Gruppe enthaltenen.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LocationChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.Location" />-Eigenschaftswert geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Location%2A> -Eigenschaft geändert wird, indem Sie entweder eine programmgesteuerte Änderung oder durch Interaktion.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel Beispiel löst die <xref:System.Windows.Forms.Control.LocationChanged> Ereignis auf einer <xref:System.Windows.Forms.StatusStrip> Wenn Größe des Formulars.  
  
 [!code-csharp[System.Windows.Forms.LocationChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.LocationChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalToDeviceUnits">
      <MemberSignature Language="C#" Value="public int LogicalToDeviceUnits (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LogicalToDeviceUnits(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.LogicalToDeviceUnits(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der zu konvertierende logische Wert.</param>
        <summary>Konvertiert einen logischen DPI-Wert in den entsprechenden DeviceUnit-DPI-Wert.</summary>
        <returns>Der resultierende DeviceUnit-Wert.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event EventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LostFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Steuerelement den Fokus verliert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Fokus ändern, indem Sie mithilfe der Tastatur (Registerkarte, UMSCHALT + TAB usw.), durch Aufrufen der <xref:System.Windows.Forms.Control.Select%2A> oder <xref:System.Windows.Forms.Control.SelectNextControl%2A> Methoden, oder durch Festlegen der <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> Eigenschaft auf das aktuelle Formular den Fokusereignisse auftreten, in der folgenden Reihenfolge:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Wenn Sie den Fokus ändern, mit der Maus oder durch Aufrufen der <xref:System.Windows.Forms.Control.Focus%2A> -Methode, den Fokusereignisse auftreten, in der folgenden Reihenfolge:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A> -Eigenschaftensatz auf `false`, <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> Ereignisse werden unterdrückt.  
  
 Wenn der <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.ComponentModel.CancelEventArgs> auf festgelegt ist `true` in der <xref:System.Windows.Forms.Control.Validating> Ereignisdelegaten, der alle Ereignisse, die in der Regel nach dem auftreten würden die <xref:System.Windows.Forms.Control.Validating> Ereignis werden unterdrückt.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.Control.GotFocus> und <xref:System.Windows.Forms.Control.LostFocus> Ereignisse sind auf niedriger Ebene Fokusereignisse, die an die Nachrichten WM_KILLFOCUS und WM_SETFOCUS Windows gebunden sind. In der Regel die <xref:System.Windows.Forms.Control.GotFocus> und <xref:System.Windows.Forms.Control.LostFocus> Ereignisse werden nur verwendet, bei der Aktualisierung <xref:System.Windows.Forms.UICues> oder beim Schreiben benutzerdefinierter Steuerelemente. Stattdessen die <xref:System.Windows.Forms.Control.Enter> und <xref:System.Windows.Forms.Control.Leave> Ereignisse sollte verwendet werden, für alle Steuerelemente außer der <xref:System.Windows.Forms.Form> Klasse, die die <xref:System.Windows.Forms.Form.Activated> und <xref:System.Windows.Forms.Form.Deactivate> Ereignisse. Weitere Informationen zu den <xref:System.Windows.Forms.Control.GotFocus> und <xref:System.Windows.Forms.Control.LostFocus> -Ereignissen finden Sie unter der [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) und [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) Themen.  
  
> [!CAUTION]
>  Versuchen Sie nicht, legen Sie den Fokus innerhalb der <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, oder <xref:System.Windows.Forms.Control.Validated> -Ereignishandler. Auf diese Weise kann dazu führen, dass die Anwendung oder das Betriebssystem nicht mehr reagiert. Weitere Informationen finden Sie unter der [WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) Thema.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, überprüfen den Text für TextBox1. Außerdem zeigt es die Behandlung der <xref:System.Windows.Forms.Control.LostFocus> -Ereignisses durch Festlegen der <xref:System.Windows.Forms.FileDialog.InitialDirectory%2A?displayProperty=nameWithType> Eigenschaft, um den Text in TextBox1. Das Codebeispiel verwendet die <xref:System.Windows.Forms.ErrorProvider.GetError%2A?displayProperty=nameWithType> Methode, um bei einem Fehler zu überprüfen, bevor Sie das Dialogfeld Datei öffnen. Um dieses Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular mit einem <xref:System.Windows.Forms.TextBox> mit dem Namen `TextBox1`, wird ein <xref:System.Windows.Forms.OpenFileDialog> mit dem Namen `OpenFileDialog1`, eine <xref:System.Windows.Forms.Button> mit dem Namen `Button1`, und ein <xref:System.Windows.Forms.ErrorProvider> mit dem Namen `ErrorProvider1`. Stellen Sie sicher, dass alle Ereignisse den Ereignishandler zugeordnet sind.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#2)]
 [!code-csharp[System.Windows.Forms.FileDialog#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#2)]
 [!code-vb[System.Windows.Forms.FileDialog#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zwischenraum zwischen Steuerelementen ab oder legt ihn fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Padding" />, das den Zwischenraum zwischen Steuerelementen darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerelemente erhalten Standardwerte für <xref:System.Windows.Forms.Control.Margin%2A> , sind ausreichend nahe bei Richtlinien für Windows-Benutzeroberfläche. Einige Anpassungen der möglicherweise weiterhin für bestimmte Anwendungen erforderlich sind.  
  
> [!NOTE]
>  Festlegen der <xref:System.Windows.Forms.Control.Margin%2A> Eigenschaft für ein angedocktes Steuerelement wirkt sich nicht auf den Abstand des Steuerelements aus der die Ränder des Containers.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MarginChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Rand des Steuerelements geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.MarginChanged> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.MarginChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#21)]
 [!code-vb[System.Windows.Forms.EventExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe ab, die die Obergrenze bildet, die <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" /> angeben kann, oder legt diese fest.</summary>
        <value>Ein geordnetes Paar vom Typ <see cref="T:System.Drawing.Size" />, das die Breite und Höhe eines Rechtecks darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe ab, die die Untergrenze bildet, die <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" /> angeben kann, oder legt diese fest.</summary>
        <value>Ein geordnetes Paar vom Typ <see cref="T:System.Drawing.Size" />, das die Breite und Höhe eines Rechtecks darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifierKeys">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Keys ModifierKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.Keys ModifierKeys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ModifierKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Keys</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, welche der Zusatztasten (Umschalttaste, STRG und ALT) gedrückt ist.</summary>
        <value>Eine bitweise Kombination der <see cref="T:System.Windows.Forms.Keys" />-Werte. Die Standardeinstellung ist <see cref="F:System.Windows.Forms.Keys.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird eine Schaltfläche ausgeblendet, wenn Sie die STRG-Taste gedrückt wird, während die Schaltfläche geklickt wird. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Button> mit dem Namen `button1` auf eine <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseButtons">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.MouseButtons MouseButtons { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.MouseButtons MouseButtons" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MouseButtons" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseButtons</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, welche Maustasten gedrückt sind.</summary>
        <value>Eine bitweise Kombination der <see cref="T:System.Windows.Forms.MouseButtons" />-Enumerationswerte. Die Standardeinstellung ist <see cref="F:System.Windows.Forms.MouseButtons.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>, und <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> Elemente. Um das Beispiel auszuführen, fügen Sie den folgenden Code in das Formular Form1 mehrere Steuerelemente enthält. Dieses Beispiel erfordert, dass die <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, und <xref:System.Windows.Forms.Control.MouseUp> Ereignisse an die Ereignishandler, die im Beispiel definierte verbunden sind.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseCaptureChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MouseCaptureChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseCaptureChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseCaptureChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Steuerelement die Mausaufzeichnung verliert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In seltenen Szenarien müssen Sie möglicherweise unerwartete Eingaben erkennen. Betrachten Sie beispielsweise die folgenden Szenarien.  
  
-   Während eines Mausvorgangs öffnet der Benutzer das Startmenü durch die Windows-Taste oder STRG + ESC drücken.  
  
-   Während eines Mausvorgangs, wechselt der Benutzer in ein anderes Programm durch Drücken von ALT + TAB drücken.  
  
-   Während eines Mausvorgangs zeigt ein anderes Programm ein Fenster oder ein Meldungsfeld an, die Fokus von der aktuellen Anwendung akzeptiert.  
  
 Mausaktionen zählen klicken und halten die Maus auf ein Formular oder ein Steuerelement oder Vorgang ausführen einer Maus ziehen. Wenn Sie bei der Formularübermittlung zu erkennen oder ein Steuerelement, Mauseingaben aufzufangen für diese verliert und ähnliche Szenarien unerwarteter, können Sie die <xref:System.Windows.Forms.Control.MouseCaptureChanged> Ereignis.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Windows.Forms.Control.MouseCaptureChanged> -Ereignis für ein <xref:System.Windows.Forms.Button> Steuerelement.  
  
 [!code-csharp[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/vb/form1.vb#1)]  
  
 Um dieses Beispiel zu testen, führen Sie es im Debugger durch Drücken von F5 aus. Öffnen der **Ausgabe** Fenster in Visual Studio, damit Sie sehen können, wenn Ereignisse ausgelöst werden. Klicken Sie auf die <xref:System.Windows.Forms.Button> , und beachten Sie die folgende Ausgabe.  
  
 `button1_MouseDown`  
  
 `button1_MouseUp`  
  
 `button1_MouseCaptureChanged`  
  
 Jetzt klicken und halten Sie die linke Maustaste gedrückt, auf die <xref:System.Windows.Forms.Button> Steuerelement. Drücken Sie ALT + TAB, um in ein anderes Programm zu wechseln, während Sie weiterhin auf die Maus. Beachten Sie, dass die <xref:System.Windows.Forms.Control.MouseCaptureChanged> Ereignis wird ausgelöst, wodurch Sie potenziell dieses Szenario zu behandeln. Je nach Ihrer Aktionen die <xref:System.Windows.Forms.Control.MouseUp> Ereignis möglicherweise nicht ausgegeben. Sie können auch versuchen, diesen Test mit der Windows-Taste oder STRG + ESC.  
  
 `button1_MouseDown`  
  
 `button1_MouseCaptureChanged`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseClick" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn mit der Maus auf das Steuerelement geklickt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Drücken einer Maustaste, wenn der Cursor in der Regel über ein Steuerelement befindet, löst die folgende Reihe von Ereignissen für das Steuerelement aus:  
  
1.  <xref:System.Windows.Forms.Control.MouseDown>-Ereignis.  
  
2.  <xref:System.Windows.Forms.Control.Click>-Ereignis.  
  
3.  <xref:System.Windows.Forms.Control.MouseClick>-Ereignis.  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>-Ereignis.  
  
 Damit dies eintritt können die verschiedenen Ereignisse in der Klasse des Steuerelements deaktiviert werden.  
  
 Zwei einfache klickt, die auftreten, ausreichend Zeit, durch die mauseinstellungen des Betriebssystems des Benutzers, generiert eine <xref:System.Windows.Forms.Control.MouseDoubleClick> Ereignisses statt auf die zweite <xref:System.Windows.Forms.Control.MouseClick> Ereignis.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.Click>-Ereignisse sind logisch auf höherer Ebene eines Steuerelements. Sie werden häufig ausgelöst von anderen Aktionen, z. B. durch Drücken der EINGABETASTE, wenn das Steuerelement den Fokus besitzt.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.MouseClick> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.MouseClick> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#54](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#54)]
 [!code-vb[System.Windows.Forms.EventExamples#54](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#54)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDoubleClick" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn mit der Maus auf das Steuerelement doppelgeklickt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.MouseDoubleClick> Ereignis tritt auf, wenn der Benutzer eine Maustaste zweimal in schneller Folge drückt, wenn der Cursor über dem Steuerelement befindet. Das Zeitintervall, das eine Trennung von zwei einzelne aufeinander folgende Mausklicks aus einem Doppelklick wird durch die mauseinstellungen des Betriebssystems des Benutzers bestimmt.  
  
 Die folgende Reihe von Ereignissen wird vom Steuerelement ausgelöst, wenn eine entsprechende Benutzeraktion stattfindet:  
  
1.  <xref:System.Windows.Forms.Control.MouseDown>-Ereignis.  
  
2.  <xref:System.Windows.Forms.Control.Click>-Ereignis.  
  
3.  <xref:System.Windows.Forms.Control.MouseClick>-Ereignis.  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>-Ereignis.  
  
5.  <xref:System.Windows.Forms.Control.MouseDown>-Ereignis.  
  
6.  <xref:System.Windows.Forms.Control.DoubleClick>-Ereignis.  
  
7.  <xref:System.Windows.Forms.Control.MouseDoubleClick>-Ereignis.  
  
8.  <xref:System.Windows.Forms.Control.MouseUp>-Ereignis.  
  
 Damit dies eintritt können die verschiedenen Ereignisse in der Klasse des Steuerelements deaktiviert werden.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.DoubleClick>-Ereignisse sind logisch auf höherer Ebene eines Steuerelements. Sie können von anderen Benutzeraktionen, wie z. B. Tastenkombinationen ausgelöst werden.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.MouseDoubleClick> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.MouseDoubleClick> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#55)]
 [!code-vb[System.Windows.Forms.EventExamples#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#55)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich der Mauszeiger über dem Steuerelement befindet und eine Maustaste gedrückt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mausereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Die folgenden Ereignisse werden nicht ausgelöst, für die <xref:System.Windows.Forms.TabControl> -Klasse, es sei denn, es ist mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> Auflistung: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn mindestens ein ist <xref:System.Windows.Forms.TabPage> in der Auflistung und Interaktion des Benutzers mit dem Registerkarten-Steuerelement-Header (, in dem die <xref:System.Windows.Forms.TabPage> Namen angezeigt werden), wird die <xref:System.Windows.Forms.TabControl> des entsprechenden Ereignisses. Jedoch, wenn das Eingreifen des Benutzers innerhalb der Clientbereich der Registerkartenseite der <xref:System.Windows.Forms.TabPage> des entsprechenden Ereignisses.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von verschiedene Mausereignisse, zeichnen Sie den Pfad der Maus auf einen <xref:System.Windows.Forms.Panel>. Liniensegment wird hinzugefügt, um die <xref:System.Drawing.Drawing2D.GraphicsPath> für jede <xref:System.Windows.Forms.Control.MouseMove> und <xref:System.Windows.Forms.Control.MouseDown> Ereignisse, die auftreten. Zum Aktualisieren der Grafik die <xref:System.Windows.Forms.Control.Invalidate%2A> Methode wird aufgerufen, für die <xref:System.Windows.Forms.Panel> auf jedem `MouseDown` und `MouseUp` Ereignis. Darüber hinaus den Grafikpfad wird durch einen Bildlauf nach oben oder unten, wenn die <xref:System.Windows.Forms.Control.MouseWheel> Ereignis auftritt. Zusätzliche Mausereignisse, z. B. <xref:System.Windows.Forms.Control.MouseHover>, auf dem Bildschirm ebenfalls identifiziert werden. Auch auf dem Bildschirm angezeigt werden, zusätzliche Informationen über die Maus über die <xref:System.Windows.Forms.SystemInformation> Klasse.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event EventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Mauszeiger in den Bereich des Steuerelements eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mausereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Die folgenden Ereignisse werden nicht ausgelöst, für die <xref:System.Windows.Forms.TabControl> -Klasse, es sei denn, es ist mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> Auflistung: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn mindestens ein ist <xref:System.Windows.Forms.TabPage> in der Auflistung und Interaktion des Benutzers mit dem Registerkarten-Steuerelement-Header (, in dem die <xref:System.Windows.Forms.TabPage> Namen angezeigt werden), wird die <xref:System.Windows.Forms.TabControl> des entsprechenden Ereignisses. Jedoch, wenn das Eingreifen des Benutzers innerhalb der Clientbereich der Registerkartenseite der <xref:System.Windows.Forms.TabPage> des entsprechenden Ereignisses.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von verschiedene Mausereignisse, zeichnen Sie den Pfad der Maus auf einen <xref:System.Windows.Forms.Panel>. Liniensegment wird hinzugefügt, um die <xref:System.Drawing.Drawing2D.GraphicsPath> für jede <xref:System.Windows.Forms.Control.MouseMove> und <xref:System.Windows.Forms.Control.MouseDown> Ereignisse, die auftreten. Zum Aktualisieren der Grafik die <xref:System.Windows.Forms.Control.Invalidate%2A> Methode wird aufgerufen, für die <xref:System.Windows.Forms.Panel> auf jedem `MouseDown` und `MouseUp` Ereignis. Darüber hinaus den Grafikpfad wird durch einen Bildlauf nach oben oder unten, wenn die <xref:System.Windows.Forms.Control.MouseWheel> Ereignis auftritt. Zusätzliche Mausereignisse, z. B. <xref:System.Windows.Forms.Control.MouseHover>, auf dem Bildschirm ebenfalls identifiziert werden. Auch auf dem Bildschirm angezeigt werden, zusätzliche Informationen über die Maus über die <xref:System.Windows.Forms.SystemInformation> Klasse.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseHover">
      <MemberSignature Language="C#" Value="public event EventHandler MouseHover;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseHover" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseHover" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Mauszeiger auf dem Steuerelement verbleibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein typisches Einsatzgebiet von <xref:System.Windows.Forms.Control.MouseHover> besteht darin, eine QuickInfo angezeigt wird, wenn die Maus auf ein Steuerelement in einem angegebenen Bereich um das Steuerelement ("Hoverrechteck") befindet. Die erforderliche Pause für dieses Ereignis ausgelöst werden soll, angegeben in Millisekunden von der <xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A> Eigenschaft.  
  
 Die <xref:System.Windows.Forms.Control.MouseHover> Ereignis definiert und ermittelt, die in Verbindung mit der <xref:System.Windows.Forms.SystemInformation.MouseHoverSize%2A> und <xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A> Eigenschaften.  
  
 Mausereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Die folgenden Ereignisse werden nicht ausgelöst, für die <xref:System.Windows.Forms.TabControl> -Klasse, es sei denn, es ist mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> Auflistung: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn mindestens ein ist <xref:System.Windows.Forms.TabPage> in der Auflistung und Interaktion des Benutzers mit dem Registerkarten-Steuerelement-Header (, in dem die <xref:System.Windows.Forms.TabPage> Namen angezeigt werden), wird die <xref:System.Windows.Forms.TabControl> des entsprechenden Ereignisses. Jedoch, wenn das Eingreifen des Benutzers innerhalb der Clientbereich der Registerkartenseite der <xref:System.Windows.Forms.TabPage> des entsprechenden Ereignisses.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von verschiedene Mausereignisse, zeichnen Sie den Pfad der Maus auf einen <xref:System.Windows.Forms.Panel>. Liniensegment wird hinzugefügt, um die <xref:System.Drawing.Drawing2D.GraphicsPath> für jede <xref:System.Windows.Forms.Control.MouseMove> und <xref:System.Windows.Forms.Control.MouseDown> Ereignisse, die auftreten. Zum Aktualisieren der Grafik die <xref:System.Windows.Forms.Control.Invalidate%2A> Methode wird aufgerufen, für die <xref:System.Windows.Forms.Panel> auf jedem `MouseDown` und `MouseUp` Ereignis. Darüber hinaus den Grafikpfad wird durch einen Bildlauf nach oben oder unten, wenn die <xref:System.Windows.Forms.Control.MouseWheel> Ereignis auftritt. Zusätzliche Mausereignisse, z. B. <xref:System.Windows.Forms.Control.MouseHover>, auf dem Bildschirm ebenfalls identifiziert werden. Auch auf dem Bildschirm angezeigt werden, zusätzliche Informationen über die Maus über die <xref:System.Windows.Forms.SystemInformation> Klasse.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event EventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Mauszeiger den Bereich des Steuerelements verlässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mausereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Die folgenden Ereignisse werden nicht ausgelöst, für die <xref:System.Windows.Forms.TabControl> -Klasse, es sei denn, es ist mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> Auflistung: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn mindestens ein ist <xref:System.Windows.Forms.TabPage> in der Auflistung und Interaktion des Benutzers mit dem Registerkarten-Steuerelement-Header (, in dem die <xref:System.Windows.Forms.TabPage> Namen angezeigt werden), wird die <xref:System.Windows.Forms.TabControl> des entsprechenden Ereignisses. Jedoch, wenn das Eingreifen des Benutzers innerhalb der Clientbereich der Registerkartenseite der <xref:System.Windows.Forms.TabPage> des entsprechenden Ereignisses.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von verschiedene Mausereignisse, zeichnen Sie den Pfad der Maus auf einen <xref:System.Windows.Forms.Panel>. Liniensegment wird hinzugefügt, um die <xref:System.Drawing.Drawing2D.GraphicsPath> für jede <xref:System.Windows.Forms.Control.MouseMove> und <xref:System.Windows.Forms.Control.MouseDown> Ereignisse, die auftreten. Zum Aktualisieren der Grafik die <xref:System.Windows.Forms.Control.Invalidate%2A> Methode wird aufgerufen, für die <xref:System.Windows.Forms.Panel> auf jedem `MouseDown` und `MouseUp` Ereignis. Darüber hinaus den Grafikpfad wird durch einen Bildlauf nach oben oder unten, wenn die <xref:System.Windows.Forms.Control.MouseWheel> Ereignis auftritt. Zusätzliche Mausereignisse, z. B. <xref:System.Windows.Forms.Control.MouseHover>, auf dem Bildschirm ebenfalls identifiziert werden. Auch auf dem Bildschirm angezeigt werden, zusätzliche Informationen über die Maus über die <xref:System.Windows.Forms.SystemInformation> Klasse.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Mauszeiger über dem Steuerelement bewegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typische Verwendungen von <xref:System.Windows.Forms.Control.MouseMove> so ändern Sie das Steuerelement Farbe oder ein Rechteck ausgelöst, um das Steuerelement gezeichnet werden.  
  
 Mausereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Die folgenden Ereignisse werden nicht ausgelöst, für die <xref:System.Windows.Forms.TabControl> -Klasse, es sei denn, es ist mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> Auflistung: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn mindestens ein ist <xref:System.Windows.Forms.TabPage> in der Auflistung und Interaktion des Benutzers mit dem Registerkarten-Steuerelement-Header (, in dem die <xref:System.Windows.Forms.TabPage> Namen angezeigt werden), wird die <xref:System.Windows.Forms.TabControl> des entsprechenden Ereignisses. Jedoch, wenn das Eingreifen des Benutzers innerhalb der Clientbereich der Registerkartenseite der <xref:System.Windows.Forms.TabPage> des entsprechenden Ereignisses.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von verschiedene Mausereignisse, zeichnen Sie den Pfad der Maus auf einen <xref:System.Windows.Forms.Panel>. Liniensegment wird hinzugefügt, um die <xref:System.Drawing.Drawing2D.GraphicsPath> für jede <xref:System.Windows.Forms.Control.MouseMove> und <xref:System.Windows.Forms.Control.MouseDown> Ereignisse, die auftreten. Zum Aktualisieren der Grafik die <xref:System.Windows.Forms.Control.Invalidate%2A> Methode wird aufgerufen, für die <xref:System.Windows.Forms.Panel> auf jedem `MouseDown` und `MouseUp` Ereignis. Darüber hinaus den Grafikpfad wird durch einen Bildlauf nach oben oder unten, wenn die <xref:System.Windows.Forms.Control.MouseWheel> Ereignis auftritt. Zusätzliche Mausereignisse, z. B. <xref:System.Windows.Forms.Control.MouseHover>, auf dem Bildschirm ebenfalls identifiziert werden. Auch auf dem Bildschirm angezeigt werden, zusätzliche Informationen über die Maus über die <xref:System.Windows.Forms.SystemInformation> Klasse.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MousePosition">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point MousePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point MousePosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MousePosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position des Mauszeigers in Bildschirmkoordinaten ab.</summary>
        <value>Ein <see cref="T:System.Drawing.Point" />, der die Koordinaten des Mauszeigers relativ zur linken oberen Ecke des Bildschirms enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.MousePosition%2A> -Eigenschaft gibt ein <xref:System.Drawing.Point> , das die Position des Mauszeigers darstellt, die zum Zeitpunkt der Eigenschaft verwiesen wurde. Die Koordinaten geben die Position auf dem Bildschirm nicht relativ zum Steuerelement, und werden zurückgegeben, unabhängig davon, ob der Cursor über dem Steuerelement positioniert ist. Die Koordinaten der oberen linken Ecke des Bildschirms werden 0,0.  
  
 Die <xref:System.Windows.Forms.Control.MousePosition%2A> Eigenschaft ist identisch mit der <xref:System.Windows.Forms.Cursor.Position%2A?displayProperty=nameWithType> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel Beispiel setzt eine <xref:System.Windows.Forms.TreeNode> Bezeichnung in einem bearbeitbaren Zustand, wenn der Benutzer ALT + E drückt, während der Mauszeiger über dem Strukturknoten befindet. Nach Abschluss der Benutzer Bearbeiten der Bezeichnung, die Bezeichnungen können nicht bearbeitet werden erneut aus, bis die Tastenkombination ALT + E erneut gedrückt wird. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.TreeView> auf eine <xref:System.Windows.Forms.Form>. Die Strukturansicht sollte auch verfügen über mindestens einen <xref:System.Windows.Forms.TreeNode> in seiner <xref:System.Windows.Forms.TreeView.Nodes%2A> Auflistung.  
  
 [!code-cpp[Windows.Forms.Control Members4#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members4#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#3)]
 [!code-vb[Windows.Forms.Control Members4#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich der Mauszeiger über dem Steuerelement befindet und eine Maustaste losgelassen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mausereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Die folgenden Ereignisse werden nicht ausgelöst, für die <xref:System.Windows.Forms.TabControl> -Klasse, es sei denn, es ist mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> Auflistung: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn mindestens ein ist <xref:System.Windows.Forms.TabPage> in der Auflistung und Interaktion des Benutzers mit dem Registerkarten-Steuerelement-Header (, in dem die <xref:System.Windows.Forms.TabPage> Namen angezeigt werden), wird die <xref:System.Windows.Forms.TabControl> des entsprechenden Ereignisses. Jedoch, wenn das Eingreifen des Benutzers innerhalb der Clientbereich der Registerkartenseite der <xref:System.Windows.Forms.TabPage> des entsprechenden Ereignisses.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von verschiedene Mausereignisse, zeichnen Sie den Pfad der Maus auf einen <xref:System.Windows.Forms.Panel>. Liniensegment wird hinzugefügt, um die <xref:System.Drawing.Drawing2D.GraphicsPath> für jede <xref:System.Windows.Forms.Control.MouseMove> und <xref:System.Windows.Forms.Control.MouseDown> Ereignisse, die auftreten. Zum Aktualisieren der Grafik die <xref:System.Windows.Forms.Control.Invalidate%2A> Methode wird aufgerufen, für die <xref:System.Windows.Forms.Panel> auf jedem `MouseDown` und `MouseUp` Ereignis. Darüber hinaus den Grafikpfad wird durch einen Bildlauf nach oben oder unten, wenn die <xref:System.Windows.Forms.Control.MouseWheel> Ereignis auftritt. Zusätzliche Mausereignisse, z. B. <xref:System.Windows.Forms.Control.MouseHover>, auf dem Bildschirm ebenfalls identifiziert werden. Auch auf dem Bildschirm angezeigt werden, zusätzliche Informationen über die Maus über die <xref:System.Windows.Forms.SystemInformation> Klasse.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseWheel" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Mausrad gedreht wird, während das Steuerelement fokussiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Verarbeiten der <xref:System.Windows.Forms.Control.MouseWheel> Ereignis es wichtig ist, die das Mausrad zugeordneten Benutzer Benutzeroberfläche (UI)-Standards entsprechen. Die <xref:System.Windows.Forms.MouseEventArgs.Delta%2A?displayProperty=nameWithType> Eigenschaftswert gibt an, die Menge des Mausrads verschoben wurde. Die Benutzeroberfläche sollte einen Bildlauf durchführen, wird das Delta plus oder minus 120. Die Benutzeroberfläche sollte die Anzahl der logischen von zurückgegebenen Zeilen Bildlauf der <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType> -Eigenschaft für jeden Deltawert erreicht. Sie können auch einen Bildlauf durchführen reibungslos kleinere, 120 Einheit erhöht werden, aber das Verhältnis, d. h. gleich bleibt, sollten <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType> Zeilen durch einen Bildlauf pro 120 Delta Einheiten der Bewegung.  
  
 Weitere Informationen zur Behandlung von Maus Wheel Nachrichten finden Sie unter der[WM_MOUSEWHEEL](http://msdn.microsoft.com/library/windows/desktop/ms645617\(v=vs.85\).aspx)Thema.  
  
 Mausereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von verschiedene Mausereignisse, zeichnen Sie den Pfad der Maus auf einen <xref:System.Windows.Forms.Panel>. Liniensegment wird hinzugefügt, um die <xref:System.Drawing.Drawing2D.GraphicsPath> für jede <xref:System.Windows.Forms.Control.MouseMove> und <xref:System.Windows.Forms.Control.MouseDown> Ereignisse, die auftreten. Zum Aktualisieren der Grafik die <xref:System.Windows.Forms.Control.Invalidate%2A> Methode wird aufgerufen, für die <xref:System.Windows.Forms.Panel> auf jedem `MouseDown` und `MouseUp` Ereignis. Darüber hinaus den Grafikpfad wird durch einen Bildlauf nach oben oder unten, wenn die <xref:System.Windows.Forms.Control.MouseWheel> Ereignis auftritt. Zusätzliche Mausereignisse, z. B. <xref:System.Windows.Forms.Control.MouseHover>, auf dem Bildschirm ebenfalls identifiziert werden. Auch auf dem Bildschirm angezeigt werden, zusätzliche Informationen über die Maus über die <xref:System.Windows.Forms.SystemInformation> Klasse.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public event EventHandler Move;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Move" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Move" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Verschieben des Steuerelements ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.Move> Ereignis, um die Position des Formulars in Bildschirmkoordinaten auf der Titelleiste des Formulars angezeigt.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Steuerelements ab oder legt diesen fest.</summary>
        <value>Der Name des Steuerelements. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Name%2A> Eigenschaft genutzt werden zur Laufzeit jedoch stattdessen das Auswerten von Namen statt der Typ und der programmgesteuerte Name. Da die <xref:System.Windows.Forms.Control.Name%2A> Eigenschaft gibt eine <xref:System.String> Typ, kann Sie in logischen Case Anweisungen ausgewertet werden (`Select` -Anweisung in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)], `switch` -Anweisung in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] und [!INCLUDE[vcprvc](~/includes/vcprvc-md.md)]).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.Name%2A> eines Steuerelements in einem <xref:System.Windows.Forms.MessageBox> Wenn das Steuerelement hinzugefügt oder aus einem Formular entfernt.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyInvalidate">
      <MemberSignature Language="C#" Value="protected virtual void NotifyInvalidate (System.Drawing.Rectangle invalidatedArea);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void NotifyInvalidate(valuetype System.Drawing.Rectangle invalidatedArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.NotifyInvalidate(System.Drawing.Rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidatedArea" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="invalidatedArea">Ein <see cref="T:System.Drawing.Rectangle" />, das den für ungültig erklärten Bereich darstellt.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Invalidated" />-Ereignis aus, wobei ein angegebener Bereich des Steuerelements für ungültig erklärt wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAutoSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAutoSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAutoSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.AutoSizeChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnAutoSizeChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BackColorChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnBackColorChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnBackgroundImageChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BindingContextChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnBindingContextChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCausesValidationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCausesValidationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCausesValidationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.CausesValidationChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnCausesValidationChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnChangeUICues">
      <MemberSignature Language="C#" Value="protected virtual void OnChangeUICues (System.Windows.Forms.UICuesEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChangeUICues(class System.Windows.Forms.UICuesEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.UICuesEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.UICuesEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ChangeUICues" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnChangeUICues%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Click" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnClick%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Überschreiben der <xref:System.Windows.Forms.Control.OnClick%2A> Methode in einer abgeleiteten Klasse. Um das Beispiel auszuführen, fügen Sie den folgenden Code nach einer Form-Klasse, in der gleichen Datei. Fügen Sie ein Textfeld vom Typ `SingleClickTextBox` in das Formular.  
  
 [!code-cpp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/VB/form1.vb#1)]  
  
 Das folgende Codebeispiel zeigt einen viele Verwendungen der <xref:System.Windows.Forms.Control.Click> Ereignis und Ereignishandler.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnClientSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnClientSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClientSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ClientSizeChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnClientSizeChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ContextMenuChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnContextMenuChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuStripChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuStripChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuStripChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ContextMenuStripChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnContextMenuStripChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnControlAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnControlAdded (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlAdded(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.ControlEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ControlAdded" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird aufgerufen, wenn das Steuerelement ein untergeordnetes Steuerelement hinzugefügt wird.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnControlAdded%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit <xref:System.Windows.Forms.Control.ControlAdded> Hinzufügen des Steuerelements zu einem Formular und zeigt den Namen des hinzugefügten Steuerelements in einer <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnControlRemoved">
      <MemberSignature Language="C#" Value="protected virtual void OnControlRemoved (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlRemoved(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.ControlEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ControlRemoved" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird aufgerufen, wenn ein untergeordnetes Steuerelement aus dem Steuerelement entfernt wird.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnControlRemoved%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit <xref:System.Windows.Forms.Control.ControlRemoved> ein Steuerelement aus einem Formular zu entfernen und zeigt den Namen des entfernten Steuerelements in einer <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected virtual void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCreateControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst die <see cref="M:System.Windows.Forms.Control.CreateControl" />-Methode aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.OnCreateControl%2A> Methode wird aufgerufen, wenn das Steuerelement zum ersten Mal erstellt wird.  
  
 Mit der <xref:System.Windows.Forms.Control.OnCreateControl%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnCreateControl" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.CursorChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnCursorChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDockChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDockChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDockChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DockChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnDockChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnDoubleClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoubleClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DoubleClick" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnDoubleClick%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.DoubleClick> -Ereignis für ein <xref:System.Windows.Forms.ListBox> aufgeführt, die Textdateien laden die <xref:System.Windows.Forms.ListBox> in einer <xref:System.Windows.Forms.TextBox> Steuerelement.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedAfterParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedAfterParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedAfterParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedAfterParent(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DpiChangedAfterParent" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedBeforeParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedBeforeParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedBeforeParent(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DpiChangedBeforeParent" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDragDrop (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragDrop(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Ein <see cref="T:System.Windows.Forms.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragDrop" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnDragDrop%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Ein <see cref="T:System.Windows.Forms.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragEnter" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnDragEnter%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragLeave" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnDragLeave%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Ein <see cref="T:System.Windows.Forms.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragOver" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnDragOver%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.EnabledChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnEnabledChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Enter" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnEnter%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.Enter> Ereignis so ändern Sie die Vordergrund- und Hintergrundfarben von einem <xref:System.Windows.Forms.TextBox> unter bestimmten Bedingungen.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.FontChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnFontChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ForeColorChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnForeColorChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.Forms.GiveFeedbackEventArgs gfbevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.Forms.GiveFeedbackEventArgs gfbevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gfbevent" Type="System.Windows.Forms.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="gfbevent">Ein <see cref="T:System.Windows.Forms.GiveFeedbackEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.GiveFeedback" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnGiveFeedback%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.GotFocus" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnGotFocus%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.HandleCreated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnHandleCreated%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.HandleDestroyed" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnHandleDestroyed%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnHelpRequested">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpRequested (System.Windows.Forms.HelpEventArgs hevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpRequested(class System.Windows.Forms.HelpEventArgs hevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hevent" Type="System.Windows.Forms.HelpEventArgs" />
      </Parameters>
      <Docs>
        <param name="hevent">Ein <see cref="T:System.Windows.Forms.HelpEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.HelpRequested" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnHelpRequested%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnImeModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnImeModeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeModeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ImeModeChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnImeModeChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInvalidated">
      <MemberSignature Language="C#" Value="protected virtual void OnInvalidated (System.Windows.Forms.InvalidateEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInvalidated(class System.Windows.Forms.InvalidateEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InvalidateEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.InvalidateEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Invalidated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnInvalidated%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.KeyEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.KeyDown" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnKeyDown%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.KeyDown> Ereignis, um den Typ der Zeichen in das Steuerelement eingegeben bestimmen.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyPress">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyPress (System.Windows.Forms.KeyPressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyPress(class System.Windows.Forms.KeyPressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyPressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.KeyPressEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.KeyPress" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnKeyPress%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.KeyPress> Ereignis, um zu verhindern, dass die Zeichen Eintreten in das Steuerelement.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.KeyEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.KeyUp" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnKeyUp%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.KeyUp> Ereignis mit der <xref:System.Windows.Forms.Help> Klasse, um dem Benutzer die Hilfe als Popup anzuzeigen.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected virtual void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">Ein <see cref="T:System.Windows.Forms.LayoutEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Layout" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnLayout%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> Methode, damit registrierte Delegaten das Ereignis empfangen und für typische Andocken und Verankern funktioniert. Abgeleitete Klassen müssen diese Methode, um benutzerdefinierte Layoutlogik führen überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Leave" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnLeave%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.Leave> Ereignis ein Steuerelements auf seinen ursprünglichen Zustand zurückgesetzt.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.LocationChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnLocationChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.LostFocus" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnLostFocus%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMarginChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMarginChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMarginChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MarginChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMarginChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseCaptureChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseCaptureChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseCaptureChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseCaptureChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseCaptureChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseClick" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseClick%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDoubleClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDoubleClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseDoubleClick" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseDoubleClick%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseDown" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseDown%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseEnter" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseEnter%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseHover">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseHover (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseHover(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseHover" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseHover%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Überschreiben der <xref:System.Windows.Forms.Control.OnMouseHover%2A> und <xref:System.Windows.Forms.Control.OnMouseMove%2A> Methoden in einer abgeleiteten Klasse. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein neues Formular, und fügen Sie diese Klasse in der gleichen Datei nach dem Formular. Fügen Sie eine Schaltfläche vom Typ `FunButton` in das Formular.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseLeave" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseLeave%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseMove" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseMove%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Überschreiben der <xref:System.Windows.Forms.Control.OnMouseHover%2A> und <xref:System.Windows.Forms.Control.OnMouseMove%2A> Methoden in einer abgeleiteten Klasse. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein neues Formular, und fügen Sie diese Klasse in der gleichen Datei nach dem Formular. Fügen Sie eine Schaltfläche vom Typ `FunButton` in das Formular.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseUp" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseUp%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseWheel" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseWheel%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMove (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMove(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Move" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMove%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.Move> Ereignis, um die Position des Formulars in Bildschirmkoordinaten auf der Titelleiste des Formulars angezeigt.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnNotifyMessage">
      <MemberSignature Language="C#" Value="protected virtual void OnNotifyMessage (System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNotifyMessage(valuetype System.Windows.Forms.Message m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" />
      </Parameters>
      <Docs>
        <param name="m">Eine <see cref="T:System.Windows.Forms.Message" />, die die Windows-Meldung darstellt.</param>
        <summary>Benachrichtigt das Steuerelement über Windows-Meldungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.OnNotifyMessage%2A> Methode wird aufgerufen, wenn des Steuerelements `EnableNotifyMessage` Stil Bit ist gesetzt, <xref:System.Windows.Forms.ControlStyles>. Die `EnableNotifyMessage` in ein Format zuzuweisen <xref:System.Windows.Forms.ControlStyles> aktiviert das Steuerelement beim benachrichtigt werden, die <xref:System.Windows.Forms.Control.WndProc%2A> Methode empfängt eine Windows-Meldung. Mit dieser Methode können teilweise vertrauenswürdige Steuerelemente für Windows-Meldungen lauschen, ohne dass sie die Nachricht zu ändern.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> Aufrufen von in einer abgeleiteten Klasse der Basisklasse <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> Methode ist nicht erforderlich, da es keine anfänglichen Implementierung ist.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPaddingChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPaddingChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaddingChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.PaddingChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnPaddingChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected virtual void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.PaintEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Paint" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnPaint%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermöglicht den Benutzer, ein Bild oder eine Bilddatei in das Formular ziehen und dann angezeigt werden, an dem Punkt, an dem sie gelöscht wird. Die <xref:System.Windows.Forms.Control.OnPaint%2A> Methode wird überschrieben, um das Bild gezeichnet werden jedes Mal der Form gezeichnet wird, andernfalls das Bild nur bis zum nächsten Neuzeichnen beibehalten möchten. Die <xref:System.Windows.Forms.Control.DragEnter> Ereignisbehandlungsmethode bestimmt den Typ der Daten in das Formular gezogen wird, und das entsprechende Feedback enthält. Die <xref:System.Windows.Forms.Control.DragDrop> Ereignisbehandlungsmethode zeigt das Bild auf dem Formular ein, wenn ein <xref:System.Drawing.Image> aus Daten erstellt werden können. Da die <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> und <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> Werte sind Bildschirmkoordinaten, die im Beispiel wird die <xref:System.Windows.Forms.Control.PointToClient%2A> Methode, um sie in Clientkoordinaten zu konvertieren.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPaintBackground">
      <MemberSignature Language="C#" Value="protected virtual void OnPaintBackground (System.Windows.Forms.PaintEventArgs pevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaintBackground(class System.Windows.Forms.PaintEventArgs pevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pevent" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="pevent">Ein <see cref="T:System.Windows.Forms.PaintEventArgs" /> mit Informationen zum zu zeichnenden Steuerelement.</param>
        <summary>Zeichnet den Hintergrund des Steuerelements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.OnPaintBackground%2A> Methode ermöglicht das abgeleitete Klassen Windows Hintergrund behandeln Anforderungen zu löschen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Erbende Klassen sollten diese Methode, um die Behandlung der Anforderung zum Löschen Hintergrund, aus Windows überschreiben. Zum Überschreiben <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" /> in einer abgeleiteten Klasse ist es nicht erforderlich, der Basisklasse aufgerufen <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BackColorChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.BackColor" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnParentBackColorChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.BackgroundImage" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnParentBackgroundImageChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BindingContextChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.BindingContext" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnParentBindingContextChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ParentChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnParentChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.CursorChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnParentCursorChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.EnabledChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.Enabled" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnParentEnabledChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.FontChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.Font" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnParentFontChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ForeColorChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.ForeColor" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnParentForeColorChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.RightToLeft" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnParentRightToLeftChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.VisibleChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.Visible" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnParentVisibleChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Forms.PreviewKeyDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Forms.PreviewKeyDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PreviewKeyDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.PreviewKeyDownEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.PreviewKeyDown" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnPreviewKeyDown%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPrint">
      <MemberSignature Language="C#" Value="protected virtual void OnPrint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPrint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.PaintEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Paint" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `UserPaint` -Bit von der <xref:System.Windows.Forms.ControlStyles> festgelegt ist, können Sie überschreiben <xref:System.Windows.Forms.Control.OnPrint%2A> um Ebenen zu zeichnen. Weitere Informationen finden Sie unter <xref:System.Windows.Forms.Control.SetStyle%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="e" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.Forms.QueryContinueDragEventArgs qcdevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.Forms.QueryContinueDragEventArgs qcdevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qcdevent" Type="System.Windows.Forms.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="qcdevent">Ein <see cref="T:System.Windows.Forms.QueryContinueDragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.QueryContinueDrag" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem Ziehen begonnen hat, diese Methode wird aufgerufen wiederholt von der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] bis des Ziehvorgangs abgebrochen oder beendet wird.  
  
> [!NOTE]
>  Überschreiben Sie diese Methode, wenn Sie den Punkt, an welche ziehen abgebrochen wird oder ein Ablagevorgang erfolgt ändern möchten.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnQueryContinueDrag%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRegionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRegionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRegionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.RegionChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Windows.Forms.Control.OnRegionChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected virtual void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Resize" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnResize%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen. Die <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> Methode kann aufgerufen werden, während der Erstellung, wenn Sie außer Kraft setzen <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> kann aufgerufen werden, bevor das Steuerelement-Konstruktor aufgerufen wird.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnRightToLeftChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.SizeChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnSizeChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.StyleChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnStyleChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSystemColorsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSystemColorsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSystemColorsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.SystemColorsChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnSystemColorsChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTabIndexChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabIndexChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabIndexChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.TabIndexChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnTabIndexChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTabStopChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabStopChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabStopChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.TabStopChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnTabStopChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.TextChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnTextChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnValidated">
      <MemberSignature Language="C#" Value="protected virtual void OnValidated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Validated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnValidated%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnValidating">
      <MemberSignature Language="C#" Value="protected virtual void OnValidating (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidating(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.ComponentModel.CancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Validating" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnValidating%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.VisibleChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Die <xref:System.Windows.Forms.Control.OnVisibleChanged%2A> -Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignis auslösen Methode, die ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster `On` *PropertyName* `Changed` , das Auslösen der entsprechenden *PropertyName* `Changed` Ereignis bei der *PropertyName* -Wert ändert (*PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> abgeleitete Klasse Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Für dieses Beispiel benötigen Sie eine Klasse, die abgeleitet haben die <xref:System.Windows.Forms.TextBox> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, welche Abstände innerhalb des Steuerelements verwendet werden.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Padding" />, das die internen Abstandsmerkmale des Steuerelements darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Container wie <xref:System.Windows.Forms.GroupBox> und <xref:System.Windows.Forms.TabControl>, <xref:System.Windows.Forms.Control.Padding%2A> Eigenschaft ruft ab oder legt ihn fest ihren jeweiligen <xref:System.Windows.Forms.Control.DisplayRectangle%2A> Eigenschaften. Die <xref:System.Windows.Forms.ScrollableControl.DockPadding%2A?displayProperty=nameWithType> Eigenschaft gleich der <xref:System.Windows.Forms.Control.Padding%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Steuerelemente erhalten Standardwerte für <xref:System.Windows.Forms.Control.Padding%2A> , sind ausreichend nahe bei Richtlinien für Windows-Benutzeroberfläche. Einige Anpassungen der möglicherweise weiterhin für bestimmte Anwendungen erforderlich sind.  
  
 Alle Steuerelemente, die implementieren <xref:System.Windows.Forms.Control.GetPreferredSize%2A> vergrößert werden, um den Wert <xref:System.Windows.Forms.Control.Padding%2A> Wenn <xref:System.Windows.Forms.Control.AutoSize%2A> ist `true`.  
  
 Verwenden Sie die folgenden Steuerelemente nicht <xref:System.Windows.Forms.Control.Padding%2A>:  
  
-   Steuerelemente, die keine implementieren <xref:System.Windows.Forms.Control.AutoSize%2A> über<xref:System.Windows.Forms.Control.GetPreferredSize%2A>  
  
-   Benutzerdefinierte Steuerelemente erben, die direkt von.<xref:System.Windows.Forms.Control>  
  
-   <xref:System.Windows.Forms.AxHost>  
  
-   <xref:System.Windows.Forms.ComboBox>  
  
-   <xref:System.Windows.Forms.DataGridView>  
  
-   <xref:System.Windows.Forms.DateTimePicker>  
  
-   <xref:System.Windows.Forms.HScrollBar>  
  
-   <xref:System.Windows.Forms.ListView>  
  
-   <xref:System.Windows.Forms.MaskedTextBox>  
  
-   <xref:System.Windows.Forms.MonthCalendar>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.PropertyGrid>  
  
-   <xref:System.Windows.Forms.RichTextBox>  
  
-   <xref:System.Windows.Forms.SplitContainer>  
  
-   <xref:System.Windows.Forms.TextBox>  
  
-   <xref:System.Windows.Forms.TextBoxBase>  
  
-   <xref:System.Windows.Forms.TreeView>  
  
-   <xref:System.Windows.Forms.VScrollBar>  
  
-   <xref:System.Windows.Forms.WebBrowser>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PaddingChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Abstand des Steuerelements geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.PaddingChanged> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.PaddingChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#41](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#41)]
 [!code-vb[System.Windows.Forms.EventExamples#41](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#41)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Paint" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Steuerelement neu gezeichnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Paint> Ereignis wird ausgelöst, wenn das Steuerelement neu gezeichnet wird. Es übergibt eine Instanz des <xref:System.Windows.Forms.PaintEventArgs> an die Methoden, die behandelt die <xref:System.Windows.Forms.Control.Paint> Ereignis.  
  
 Wenn Sie ein neues benutzerdefiniertes Steuerelement oder ein geerbtes Steuerelement mit einer anderen visuellen Darstellung zu erstellen, geben Sie Code zum Rendern des Steuerelements durch Überschreiben der <xref:System.Windows.Forms.Control.OnPaint%2A> Methode. Weitere Informationen finden Sie unter [Überschreiben der OnPaint-Methode](~/docs/framework/winforms/controls/overriding-the-onpaint-method.md) und [benutzerdefinierte Steuerelement zeichnen und ausgeben](~/docs/framework/winforms/controls/custom-control-painting-and-rendering.md).  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Windows.Forms.PictureBox> Steuerelement auf das Formular und verwendet die <xref:System.Windows.Forms.Control.Paint> Ereignis darauf gezeichnet werden soll.  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control Parent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den übergeordneten Container des Steuerelements ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Control" />, das das übergeordnete Element oder das Container-Steuerelement des Steuerelements darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen der <xref:System.Windows.Forms.Control.Parent%2A> Eigenschaftswert an `null` entfernt das Steuerelement aus der <xref:System.Windows.Forms.Control.ControlCollection> des aktuellen übergeordneten Steuerelements.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.Control.Parent%2A> Eigenschaft und die <xref:System.Windows.Forms.Control.FindForm%2A> Methode zum Festlegen von Eigenschaften für das übergeordnete Steuerelement der eine Schaltfläche und das Formular.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, um diesen Eigenschaftswert abzurufen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ParentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ParentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ParentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ParentChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.Parent" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Parent%2A> -Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt die Anwendung von Layoutlogik durch das Steuerelement auf sämtliche diesem untergeordneten Steuerelemente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.SuspendLayout%2A> Methode wurde aufgerufen, vor dem Aufruf der <xref:System.Windows.Forms.Control.PerformLayout%2A> -Methode, die <xref:System.Windows.Forms.Control.Layout> Ereignis unterdrückt wird.  
  
 Die <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> und <xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A> Eigenschaften der <xref:System.Windows.Forms.LayoutEventArgs> erstellt werden, legen Sie auf `null` , wenn keine Werte beim bereitgestellt wurden die <xref:System.Windows.Forms.Control.PerformLayout%2A> Methode wurde aufgerufen.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Windows.Forms.Control.PerformLayout%2A>-Methode verwenden. Außerdem zeigt es die Möglichkeiten, die <xref:System.Windows.Forms.Control.Layout> Ereignis wird ausgelöst. In diesem Beispiel wird die `Click` -Ereignishandler für `Button1` explizit aufruft <xref:System.Windows.Forms.Control.PerformLayout%2A>. Die `Click` -Ereignishandler für `Button2` ruft implizit <xref:System.Windows.Forms.Control.PerformLayout%2A>. <xref:System.Windows.Forms.Control.PerformLayout%2A>wird auch aufgerufen werden, wenn das Formular geladen wird. `Button3`das Steuerelement zurück, das beim Laden in den Zustand. In jedem Fall die <xref:System.Windows.Forms.Control.Layout> Ereignis wird ausgelöst.  
  
 Dies ist ein vollständiges Beispiel. Fügen Sie zum Ausführen des Beispiels den folgenden Code in ein leeres Formular ein.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout (System.Windows.Forms.Control affectedControl, string affectedProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout(class System.Windows.Forms.Control affectedControl, string affectedProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout(System.Windows.Forms.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="affectedControl" Type="System.Windows.Forms.Control" />
        <Parameter Name="affectedProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="affectedControl">Ein <see cref="T:System.Windows.Forms.Control" />, das das zuletzt geänderte Steuerelement darstellt.</param>
        <param name="affectedProperty">Der Name der zuletzt geänderten Eigenschaft des Steuerelements.</param>
        <summary>Erzwingt die Anwendung von Layoutlogik durch das Steuerelement auf sämtliche diesem untergeordneten Steuerelemente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.SuspendLayout%2A> Methode wurde aufgerufen, vor dem Aufruf der <xref:System.Windows.Forms.Control.PerformLayout%2A> -Methode, die <xref:System.Windows.Forms.Control.Layout> Ereignis unterdrückt wird.  
  
 Die `affectedControl` und `affectedProperty` Parameter können festgelegt sein, sodass `null`. Dadurch die <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> und <xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A> Eigenschaften der <xref:System.Windows.Forms.LayoutEventArgs> erstellt, um die festgelegt werden, um `null`.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Windows.Forms.Control.PerformLayout%2A>-Methode verwenden. Außerdem zeigt es die Möglichkeiten, die <xref:System.Windows.Forms.Control.Layout> Ereignis wird ausgelöst. In diesem Beispiel wird die `Click` -Ereignishandler für `Button1` explizit aufruft <xref:System.Windows.Forms.Control.PerformLayout%2A>. Die `Click` -Ereignishandler für `Button2` ruft implizit <xref:System.Windows.Forms.Control.PerformLayout%2A>. <xref:System.Windows.Forms.Control.PerformLayout%2A>wird auch aufgerufen werden, wenn das Formular geladen wird. `Button3`das Steuerelement zurück, das beim Laden in den Zustand. In jedem Fall die <xref:System.Windows.Forms.Control.Layout> Ereignis wird ausgelöst.  
  
 Dies ist ein vollständiges Beispiel. Fügen Sie zum Ausführen des Beispiels den folgenden Code in ein leeres Formular ein.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToClient (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToClient(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">Der zu konvertierende Bildschirmkoordinaten-<see cref="T:System.Drawing.Point" />.</param>
        <summary>Rechnet die Position des angegebenen Bildschirmpunkts in Clientkoordinaten um.</summary>
        <returns>Ein <see cref="T:System.Drawing.Point" />, der den konvertierten <see cref="T:System.Drawing.Point" />, <paramref name="p" />, in Clientkoordinaten darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Code Beispiel kann der Benutzer ein Bild oder eine Bilddatei in das Formular ziehen und an dem Punkt darauf angezeigt werden, gelöscht wird. Die <xref:System.Windows.Forms.Control.OnPaint%2A> Methode wird überschrieben, um das Bild gezeichnet werden jedes Mal der Form gezeichnet wird, andernfalls das Bild nur bis zum nächsten Neuzeichnen beibehalten möchten. Die <xref:System.Windows.Forms.Control.DragEnter> Ereignisbehandlungsmethode bestimmt den Typ der Daten in das Formular gezogen wird, und das entsprechende Feedback enthält. Die <xref:System.Windows.Forms.Control.DragDrop> Ereignisbehandlungsmethode zeigt das Bild auf dem Formular ein, wenn ein <xref:System.Drawing.Image> aus Daten erstellt werden können. Da die <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> und <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> Werte sind Bildschirmkoordinaten, die im Beispiel wird die <xref:System.Windows.Forms.Control.PointToClient%2A> Methode, um sie in Clientkoordinaten zu konvertieren.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToScreen (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToScreen(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">Der zu konvertierende Clientkoordinaten-<see cref="T:System.Drawing.Point" />.</param>
        <summary>Rechnet die Position des angegebenen Clientpunkts in Bildschirmkoordinaten um.</summary>
        <returns>Ein <see cref="T:System.Drawing.Point" />, der den konvertierten <see cref="T:System.Drawing.Point" />, <paramref name="p" />, in Bildschirmkoordinaten darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>, und <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> Elemente. Um das Beispiel auszuführen, fügen Sie den folgenden Code in das Formular Form1 mehrere Steuerelemente enthält. Dieses Beispiel erfordert, dass die <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, und <xref:System.Windows.Forms.Control.MouseUp> Ereignisse an die Ereignishandler, die im Beispiel definierte verbunden sind.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size PreferredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size PreferredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PreferredSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe eines rechteckigen Bereichs ab, in den das Steuerelement eingepasst werden kann.</summary>
        <value>Eine <see cref="T:System.Drawing.Size" />, die die Höhe und Breite in Pixel enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessControlMessage">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.PreProcessControlState PreProcessControlMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.PreProcessControlState PreProcessControlMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessControlMessage(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreProcessControlState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">Eine <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Meldung angibt.</param>
        <summary>Führt eine Vorverarbeitung der Tastatur- oder Eingabemeldungen in der Nachrichtenschleife aus, bevor sie gesendet werden.</summary>
        <returns>Einer der <see cref="T:System.Windows.Forms.PreProcessControlState" />-Werte, je nachdem, ob <see cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" /> den Wert <see langword="true" /> oder <see langword="false" /> besitzt und ob <see cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" /> oder <see cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" /> den Wert <see langword="true" /> oder <see langword="false" /> besitzt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessMessage">
      <MemberSignature Language="C#" Value="public virtual bool PreProcessMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PreProcessMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">Eine als Verweis übergebene <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Meldung darstellt. Die möglichen Werte sind WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR und WM_SYSCHAR.</param>
        <summary>Führt eine Vorverarbeitung der Tastatur- oder Eingabemeldungen in der Nachrichtenschleife aus, bevor sie gesendet werden.</summary>
        <returns>
          <see langword="true" />, wenn die Meldung vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.PreProcessMessage%2A>wird aufgerufen, durch die Anwendung die Meldungsschleife um eingabemeldungen vor dem sie gesendet werden. Mögliche Werte für die `msg` Parameter sind WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR und WM_SYSCHAR.  
  
 Zum Überschreiben <xref:System.Windows.Forms.Control.PreProcessMessage%2A>, ein Steuerelement sollte zurückgeben `true` um anzugeben, dass er die Nachricht verarbeitet hat. Für das Steuerelement, das Ergebnis nicht verarbeiteten Nachrichten `base.PreProcessMessage` zurückgegeben werden soll. Steuerelemente werden in der Regel außer Kraft setzen eines spezifischen Methoden wie z. B. <xref:System.Windows.Forms.Control.IsInputChar%2A>, <xref:System.Windows.Forms.Control.IsInputKey%2A>, <xref:System.Windows.Forms.Control.ProcessCmdKey%2A>, <xref:System.Windows.Forms.Control.ProcessDialogChar%2A>, oder <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> anstelle von <xref:System.Windows.Forms.Control.PreProcessMessage%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für den unmittelbaren Aufrufer zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PreviewKeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreviewKeyDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt vor dem <see cref="E:System.Windows.Forms.Control.KeyDown" />-Ereignis ein, wenn eine Taste gedrückt wird, während dieses Steuerelement den Fokus besitzt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Tastatureingaben, z. B. die Registerkarte, RETURN, ESC und Pfeiltasten, werden in der Regel von einigen Steuerelementen ignoriert, da sie nicht als Eingabe von Eingabetasten betrachtet werden. Beispielsweise wird standardmäßig ein <xref:System.Windows.Controls.Button> -Steuerelement ignoriert die Pfeiltasten. Drücken die Pfeiltasten in der Regel führt dazu, dass den Fokus auf das vorherige oder nächste Steuerelement. Navigationstasten und diese Schlüssel in der Regel keine auslösen drücken die Pfeiltasten gelten die <xref:System.Windows.Forms.Control.KeyDown> -Ereignis für ein <xref:System.Windows.Controls.Button>. Drücken der Taste Schlüssel jedoch für eine <xref:System.Windows.Controls.Button> löst die <xref:System.Windows.Forms.Control.PreviewKeyDown> Ereignis. Durch Behandeln der <xref:System.Windows.Forms.Control.PreviewKeyDown> -Ereignis für ein <xref:System.Windows.Controls.Button> verwendet wird und die <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> Eigenschaft, um `true`, können die <xref:System.Windows.Forms.Control.KeyDown> Ereignis aus, wenn die Taste gedrückt werden. Wenn Sie über die Pfeiltasten behandelt, wird der Fokus nicht mehr auf das vorherige oder nächste Steuerelement verschoben.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht eine <xref:System.Windows.Forms.Button> , umfasst eine <xref:System.Windows.Forms.ContextMenuStrip>. Wenn die <xref:System.Windows.Forms.Button> den Fokus besitzt, und drücken Sie die nach-oben oder nach-unten-Tasten, die <xref:System.Windows.Forms.ContextMenuStrip> angezeigt wird. Die <xref:System.Windows.Forms.Control.PreviewKeyDown> Ereignishandler erkennt, wenn die nach-oben oder nach-unten-Taste gedrückt wird, und setzt die <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> Eigenschaft `true`. Dies löst die <xref:System.Windows.Forms.Control.KeyDown> Ereignis, damit Sie anzeigen können, die <xref:System.Windows.Forms.ContextMenuStrip>. Jeder Datenzugriffslogik sollten nicht abgelegt werden, der <xref:System.Windows.Forms.Control.PreviewKeyDown> Ereignishandler, d. h. außer zum Festlegen der <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> Eigenschaft. Sie sollten stattdessen die Logik der <xref:System.Windows.Forms.Control.KeyDown> -Ereignishandler.  
  
 [!code-csharp[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/vb/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">Eine als Verweis übergebene <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Fenstermeldung darstellt.</param>
        <param name="keyData">Einer der <see cref="T:System.Windows.Forms.Keys" />-Werte, die die zu verarbeitende Taste darstellen.</param>
        <summary>Verarbeitet eine Befehlstaste.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, während der Nachricht vorverarbeitung zum Befehl Schlüssel behandelt. Befehl Schlüssel sind Schlüssel, die immer Vorrang gegenüber regulären Eingabetasten besitzen. Beispiele für Befehl Schlüssel sind im Menü Tastenkombinationen und Zugriffstasten. Die Methode muss zurückgeben `true` , um anzugeben, dass die Befehlstaste verarbeitet wurde oder `false` , um anzugeben, dass der Schlüssel keine Befehlstaste. Diese Methode wird nur aufgerufen, wenn das Steuerelement in Windows Forms-Anwendung oder als ein ActiveX-Steuerelement gehostet wird.  
  
 Die <xref:System.Windows.Forms.Control.ProcessCmdKey%2A> Methode zunächst ermittelt, ob das Steuerelement hat eine <xref:System.Windows.Forms.ContextMenu>, und wenn dies der Fall ist, können Sie mit der <xref:System.Windows.Forms.ContextMenu> die Befehlstaste verarbeitet. Wenn die Befehlstaste keine Verknüpfung im und das Steuerelement ein übergeordnetes Element besitzt, wird der Schlüssel mit dem übergeordneten übergeben <xref:System.Windows.Forms.Control.ProcessCmdKey%2A> Methode. Im Endeffekt ist dieses Befehls mit dem Schlüssel "der Steuerelementhierarchie nach oben weitergegeben werden". Zusätzlich zu dem Schlüssel, die der Benutzer geklickt hat, die Schlüsseldaten gibt außerdem an, die ggf. auf Modifizierertasten wurden zur gleichen Zeit wie der Schlüssel. Modifizierertasten einschließen UMSCHALTTASTE, STRG und ALT-Tasten  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer und erbende Klassen zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> Methode in einer abgeleiteten Klasse ein Steuerelement sollte zurückgeben <see langword="true" /> um anzugeben, dass sie die Taste verarbeitet wurde. Für Schlüssel, die vom Steuerelement, das Ergebnis des Aufrufs der Basisklasse nicht verarbeitet werden <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> Methode zurückgegeben werden soll. Steuerelemente nur in seltenen Fällen, müssen wenn überhaupt, diese Methode überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Das zu verarbeitende Zeichen.</param>
        <summary>Verarbeitet ein Dialogfeldzeichen.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird während der vorverarbeitung zum Behandeln von Dialogfeldzeichen, z. B. Steuerelement Mnemonik Nachricht aufgerufen. Diese Methode wird aufgerufen, wenn nur die <xref:System.Windows.Forms.Control.IsInputChar%2A> Methode gibt an, dass das Steuerelement nicht das Zeichen verarbeitet. Die <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> -Methode sendet einfach das Zeichen an der übergeordneten <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> -Methode, oder gibt `false` das Steuerelement kein übergeordnetes Element besitzt. Die <xref:System.Windows.Forms.Form> Klasse überschreibt diese Methode, um die tatsächliche Verarbeitung der Dialogfeldzeichen durchzuführen. Diese Methode wird nur aufgerufen, wenn das Steuerelement in Windows Forms-Anwendung oder als ein ActiveX-Steuerelement gehostet wird.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> Methode in einer abgeleiteten Klasse ein Steuerelement sollte zurückgeben <see langword="true" /> , um anzugeben, dass das Zeichen verarbeitet wurde. Für Zeichen, die vom Steuerelement, das Ergebnis des Aufrufs der Basisklasse nicht verarbeitet werden <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> Methode zurückgegeben werden soll. Steuerelemente nur in seltenen Fällen, müssen wenn überhaupt, diese Methode überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Einer der <see cref="T:System.Windows.Forms.Keys" />-Werte, die die zu verarbeitende Taste darstellen.</param>
        <summary>Verarbeitet eine Tastatureingabe im Dialogfeld.</summary>
        <returns>
          <see langword="true" />, wenn die Taste vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, während der Nachricht zum Behandeln von Dialogfeldzeichen, z. B. TAB, RETURN, ESC und Pfeil vorverarbeitung. Diese Methode wird aufgerufen, wenn nur die <xref:System.Windows.Forms.Control.IsInputKey%2A> Methode gibt an, dass das Steuerelement den Schlüssel nicht verarbeitet wird. Die <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> sendet einfach das Zeichen an der übergeordneten <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> -Methode, oder gibt `false` das Steuerelement kein übergeordnetes Element besitzt. Die <xref:System.Windows.Forms.Form> Klasse überschreibt diese Methode, um die tatsächliche Verarbeitung der Dialogfeld-Schlüssel ausführen. Diese Methode wird nur aufgerufen, wenn das Steuerelement in Windows Forms-Anwendung oder als ein ActiveX-Steuerelement gehostet wird.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" /> Methode in einer abgeleiteten Klasse ein Steuerelement sollte zurückgeben <see langword="true" /> um anzugeben, dass sie die Taste verarbeitet wurde. Für Schlüssel, die vom Steuerelement, das Ergebnis des Aufrufs der Basisklasse nicht verarbeitet werden <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> Methode zurückgegeben werden soll. Steuerelemente nur in seltenen Fällen, müssen wenn überhaupt, diese Methode überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyEventArgs">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyEventArgs (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyEventArgs(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Eine als Verweis übergebene <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Fenstermeldung darstellt.</param>
        <summary>Verarbeitet eine Tastenmeldung und generiert die entsprechenden Steuerelementereignisse.</summary>
        <returns>
          <see langword="true" />, wenn die Meldung vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn ein Steuerelement eine tastaturmeldung empfängt. Die Methode ist verantwortlich für das Generieren der entsprechenden Tastaturereignisse für die Nachricht durch Aufrufen der <xref:System.Windows.Forms.Control.OnKeyPress%2A>, <xref:System.Windows.Forms.Control.OnKeyDown%2A>, oder <xref:System.Windows.Forms.Control.OnKeyUp%2A> Methoden. Die `m` Parameter enthält die Meldung für das Fenster, die verarbeitet werden müssen. Mögliche Werte für die <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> -Eigenschaft sind WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP, WM_SYSKEYUP und WM_IME_CHAR.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> Methode in einer abgeleiteten Klasse ein Steuerelement sollte zurückgeben <see langword="true" /> um anzugeben, dass sie die Taste verarbeitet wurde. Für Schlüssel, die vom Steuerelement, das Ergebnis des Aufrufs der Basisklasse nicht verarbeitet werden <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> Methode zurückgegeben werden soll. Steuerelemente nur in seltenen Fällen, müssen wenn überhaupt, diese Methode überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyMessage">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyMessage (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessKeyMessage(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Eine als Verweis übergebene <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Fenstermeldung darstellt.</param>
        <summary>Verarbeitet eine Tastaturmeldung.</summary>
        <returns>
          <see langword="true" />, wenn die Meldung vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn ein Steuerelement eine tastaturmeldung empfängt. Die Methode ermittelt zunächst, ob das Steuerelement ein übergeordnetes Element besitzt; Wenn daher des übergeordnetes ruft <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> Methode. Wenn des übergeordnetes <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> Methode wird die Nachricht nicht verarbeiten und dann die <xref:System.Windows.Forms.Control.ProcessKeyEventArgs%2A> Methode wird aufgerufen, um die entsprechenden Tastaturereignisse zu generieren. Die `m` Parameter enthält die Meldung für das Fenster, die verarbeitet werden müssen. Mögliche Werte für die <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> -Eigenschaft sind WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP und WM_SYSKEYUP.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" /> -Methode, ein Steuerelement sollte zurückgeben <see langword="true" /> um anzugeben, dass sie die Taste verarbeitet wurde. Für Schlüssel, die vom Steuerelement, das Ergebnis von der Basisklasse nicht verarbeitet werden <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> zurückgegeben werden soll. Steuerelemente nur in seltenen Fällen, müssen wenn überhaupt, diese Methode überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Eine als Verweis übergebene <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Fenstermeldung darstellt.</param>
        <summary>Zeigt eine Tastaturmeldung in der Vorschau an.</summary>
        <returns>
          <see langword="true" />, wenn die Meldung vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von einem untergeordneten Steuerelement aufgerufen, wenn das untergeordnete Steuerelement eine tastaturmeldung empfängt. Das untergeordnete Steuerelement ruft diese Methode vor dem Generieren von Tastaturereignissen für die Nachricht an. Wenn diese Methode zurückgibt `true`, das untergeordnete Steuerelement betrachtet die Nachricht verarbeitet und keine Tastaturereignisse generiert. Die `m` Parameter enthält die Meldung für das Fenster, in der Vorschau anzeigen. Mögliche Werte für die <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> -Eigenschaft sind WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP und WM_SYSKEYUP. Die <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> -Methode sendet einfach das Zeichen an der übergeordneten <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> -Methode, oder gibt `false` das Steuerelement kein übergeordnetes Element besitzt. Die <xref:System.Windows.Forms.Form> Klasse überschreibt diese Methode, um die tatsächliche Verarbeitung der Dialogfeld-Schlüssel ausführen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" /> Methode in einer abgeleiteten Klasse ein Steuerelement sollte zurückgeben <see langword="true" /> um anzugeben, dass sie die Taste verarbeitet wurde. Für Schlüssel, die vom Steuerelement, das Ergebnis des Aufrufs der Basisklasse nicht verarbeitet werden <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" /> Methode zurückgegeben werden soll.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Das zu verarbeitende Zeichen.</param>
        <summary>Verarbeitet ein mnemonisches Zeichen.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen als mnemonisches Zeichen vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, um ein Steuerelement auf ein mnemonisches Zeichen verarbeiten können. Die Methode bestimmt, ob das Steuerelement in einem Zustand, der Prozess Mnemonik ist und ob, ob das angegebene Zeichen das mnemonische Zeichen darstellt. Wenn also die Methode die Aktion zugeordnete mnemonische Zeichen und der Rückgabewert durchführen sollten `true`. Wenn nicht, der Methodenrückgabewert `false`. Implementierungen dieser Methode verwenden häufig die <xref:System.Windows.Forms.Control.IsMnemonic%2A> Methode, um zu bestimmen, ob das angegebene Zeichen das mnemonische Zeichen im Text des Steuerelements übereinstimmt.  
  
 Zum Beispiel:  
  
```csharp  
if (CanSelect && IsMnemonic(charCode, MyControl.Text) {  
      // Perform action associated with mnemonic.  
       }  
```  
  
 Diese Standardimplementierung von der <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> einfach Methodenrückgabe `false` um anzugeben, dass das Steuerelement keine mnemonische Zeichen hat.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, eine Erweiterung der Schaltfläche-Klasse, überschreibt die <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> Methode, um benutzerdefiniertes Verhalten bereitzustellen. Das Beispiel zeigt auch die Verwendung der <xref:System.Windows.Forms.Control.CanSelect%2A> und <xref:System.Windows.Forms.Control.IsMnemonic%2A> Eigenschaften. Fügen zum Ausführen dieses Beispiel den folgenden Code nach einer Form-Klasse, in der gleichen Datei. Fügen Sie eine Schaltfläche vom Typ `MnemonicButton` in das Formular.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Produktnamen der Assembly ab, die das Steuerelement enthält.</summary>
        <value>Der Produktname der Assembly, die das Steuerelement enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.ProductName%2A> Eigenschaft ist eine schreibgeschützte Eigenschaft. Um den Wert dieser Eigenschaft ändern, legen die <xref:System.Reflection.AssemblyProductAttribute.Product%2A> Eigenschaftswert, der die <xref:System.Reflection.AssemblyProductAttribute>. Die folgende Zeile der C#-Code legt die <xref:System.Windows.Forms.Control.ProductName%2A> Eigenschaft.  
  
```  
[assembly: AssemblyProduct("MyApplication")]  
```  
  
> [!NOTE]
>  Es wird dringend empfohlen, dass Sie den Firmennamen, Produktname und Produktversion angeben. Diese Informationen ermöglicht die Verwendung von Windows Forms-Features wie z. B. <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType> , erleichtern zum Schreiben von Anwendungen, die mit dem Programm "Certified for Windows" erfüllen. Weitere Informationen über das Certified for Windows-Programm finden Sie unter http://msdn.microsoft.com/certification.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt Informationen über die Anwendung in einem <xref:System.Windows.Forms.Label> enthalten eine <xref:System.Windows.Forms.Form>. Dieses Beispiel erfordert, dass die <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> und <xref:System.Windows.Forms.Control.ProductVersion%2A> festgelegt wurden.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Version der Assembly ab, die das Steuerelement enthält.</summary>
        <value>Die Dateiversion der Assembly, die das Steuerelement enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.ProductVersion%2A> Eigenschaft ist eine schreibgeschützte Eigenschaft. Um den Wert dieser Eigenschaft ändern, legen die <xref:System.Reflection.AssemblyVersionAttribute.Version%2A> Eigenschaftswert, der die <xref:System.Reflection.AssemblyVersionAttribute>. Die folgende Zeile der C#-Code legt die <xref:System.Windows.Forms.Control.ProductVersion%2A> Eigenschaft.  
  
```  
[assembly: AssemblyVersion("1.0.1")]  
```  
  
> [!NOTE]
>  Es wird dringend empfohlen, dass Sie den Firmennamen, Produktname und Produktversion angeben. Diese Informationen ermöglicht die Verwendung von Windows Forms-Features wie z. B. <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType> , erleichtern zum Schreiben von Anwendungen, die mit dem Programm "Certified for Windows" erfüllen. Weitere Informationen über das Certified for Windows-Programm finden Sie unter http://msdn.microsoft.com/certification.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt Informationen über die Anwendung in einem <xref:System.Windows.Forms.Label> enthalten eine <xref:System.Windows.Forms.Form>. Dieses Beispiel erfordert, dass die <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> und <xref:System.Windows.Forms.Control.ProductVersion%2A> festgelegt wurden.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropagatingImeMode">
      <MemberSignature Language="C#" Value="protected static System.Windows.Forms.ImeMode PropagatingImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.ImeMode PropagatingImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, das einen IME-Modus für Weitergabevorgänge darstellt.</summary>
        <value>Ein Objekt, das einen IME-Modus für Weitergabevorgänge darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAccessibilityHelp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryAccessibilityHelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn <see cref="T:System.Windows.Forms.AccessibleObject" /> Hilfe für barrierefreie Anwendungen bereitstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Forms.HelpProvider> Klasse, um Benutzer durch Drücken der F1-Taste die Hilfe zu Ihrem zugreifbaren Objekt aufrufen können. Mithilfe der <xref:System.Windows.Forms.HelpProvider> bietet Ihnen ausführliche Informationen in den <xref:System.Windows.Forms.QueryAccessibilityHelpEventArgs>. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Erstellung eines Diagramms Eingabehilfen-fähig zu steuern, mit der <xref:System.Windows.Forms.AccessibleObject> und <xref:System.Windows.Forms.Control.ControlAccessibleObject> Klassen zum Offenlegen von Informationen zugegriffen werden kann. Das Steuerelement zeichnet zwei Kurven geteilt zusammen mit einer Legende an. Die `ChartControlAccessibleObject` -Klasse, abgeleitet von `ControlAccessibleObject`, werden in der <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> Methode, um benutzerdefinierte barrierefreie Informationen für das Diagrammsteuerelement bereitzustellen. Da die Diagrammlegende nicht tatsächlich <xref:System.Windows.Forms.Control> -basierte Steuerelement, sondern gezeichnet wird vom Diagrammsteuerelement, ist es aber keine integrierten barrierefreien Informationen. Aus diesem Grund die `ChartControlAccessibleObject` -Klasse überschreibt die <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> -Methode zur Rückgabe der `CurveLegendAccessibleObject` , zugegriffen werden Informationen für jeden Teil der Legende darstellt. Wenn eine zugänglich-fähige Anwendung dieses Steuerelement verwendet wird, bieten das Steuerelement die erforderlichen Informationen zugegriffen werden kann.  
  
 Dieser Code veranschaulicht die Behandlung der <xref:System.Windows.Forms.Control.QueryAccessibilityHelp> Ereignis. Finden Sie unter der <xref:System.Windows.Forms.AccessibleObject> Übersicht über die Klasse für das gesamte Codebeispiel dargestellt.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#3)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#3)]
 [!code-vb[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryContinueDrag" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt während eines Drag &amp; Drop-Vorgangs ein. Dadurch kann die Quelle des Ziehvorgangs bestimmen, ob der Drag &amp; Drop-Vorgang abgebrochen werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.QueryContinueDrag> Ereignis wird ausgelöst, wenn eine Änderung in der Tastatur- oder Maustastenzustands während eines Drag & Drop-Vorgangs. Die <xref:System.Windows.Forms.Control.QueryContinueDrag> Ereignis ermöglicht die Quelle des Ziehvorgangs bestimmen, ob der Drag-and-Drop-Vorgang abgebrochen werden soll.  
  
 Nachfolgend wird beschrieben, wie und wann Ereignisse für Drag & Drop-Vorgänge ausgelöst werden.  
  
 Die <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode bestimmt die unter der aktuellen Cursorposition. Er überprüft dann um festzustellen, ob das Steuerelement ein gültiges Ablageziel ist.  
  
 Wenn das Steuerelement ein gültiges Ablageziel ist die <xref:System.Windows.Forms.Control.GiveFeedback> Ereignis wird mit dem angegebenen Drag & Drop-Effekt ausgelöst. Eine Liste der Drag & Drop-Effekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
 Änderungen der Mauszeigerposition, des Tastaturzustands und des Zustands der Maustasten werden verfolgt.  
  
-   Wenn die Benutzeraktion das Fenster verlässt, wird das <xref:System.Windows.Forms.Control.DragLeave>-Ereignis ausgelöst.  
  
-   Wenn der Mauszeiger in ein anderes Steuerelement bewegt wird, wird das <xref:System.Windows.Forms.Control.DragEnter>-Ereignis für dieses Steuerelement ausgelöst.  
  
-   Wenn die Maus bewegt wird, ohne das Steuerelement zu verlassen, wird das <xref:System.Windows.Forms.Control.DragOver>-Ereignis ausgelöst.  
  
 Wenn es eine Änderung in der Tastatur- oder Maustastenzustands der <xref:System.Windows.Forms.Control.QueryContinueDrag> Ereignis wird ausgelöst, und bestimmt, ob der Ziehvorgang, der Daten gelöscht werden, fortgesetzt oder Abbrechen des Vorgangs basierend auf den Wert der <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> Eigenschaft, der des Ereignis <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Continue`, <xref:System.Windows.Forms.Control.DragOver> Ereignis wird ausgelöst, um den Vorgang fortzusetzen und die <xref:System.Windows.Forms.Control.GiveFeedback> Ereignis mit dem neuen Effekt ausgelöst, damit eine entsprechende visuelle Rückmeldung festgelegt werden kann. Eine Liste der gültigen Ablageeffekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
    > [!NOTE]
    >  Die <xref:System.Windows.Forms.Control.DragOver> und <xref:System.Windows.Forms.Control.GiveFeedback> Ereignisse werden kombiniert, damit der Benutzer die Maus über das Ablageziel bewegen, aktuelle Rückmeldung auf beiden Seiten der Maus gewährt wird.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Drop`, ist der Wert des Ablageeffekts an die Quelle zurückgegeben, die Source-Anwendung auf den entsprechenden Vorgang für die Quelldaten; ausführen kann z. B. dadurch die Daten Ausschneiden, wenn der Vorgang einen Verschiebevorgang handelt.  
  
-   Wenn der Wert der <xref:System.Windows.Forms.DragAction> ist `Cancel`die <xref:System.Windows.Forms.Control.DragLeave> Ereignis wird ausgelöst.  
  
 Wird standardmäßig die <xref:System.Windows.Forms.Control.QueryContinueDrag> Ereignis legt <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> auf `Cancel` in <xref:System.Windows.Forms.DragAction> Wenn die ESC-Taste gedrückt wurde, und legt <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> auf `Drop` in <xref:System.Windows.Forms.DragAction> , wenn die linke, mittlere oder rechte Maustaste gedrückt wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, einen Drag-and-Drop-Vorgang zwischen zwei <xref:System.Windows.Forms.ListBox> Steuerelemente. Im Beispiel wird die <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode, wenn der Ziehvorgang beginnt. Der Ziehvorgang beginnt, wenn die Maus bewegt hat mehr als <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> aus die Position des Mauszeigers während der <xref:System.Windows.Forms.Control.MouseDown> Ereignis. Die <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> Methode wird verwendet, um zu bestimmen, den Index des Elements, das beim Ziehen die `MouseDown` Ereignis.  
  
 Das Beispiel veranschaulicht außerdem die Verwendung von benutzerdefiniertem Cursor für den Drag & Drop-Vorgang. Das Beispiel erfordert, dass zwei Cursordateien`3dwarro.cur` und `3dwno.cur`, im Anwendungsverzeichnis, für den benutzerdefinierten vorhanden und Drop bzw. den Cursor. Die benutzerdefinierte Cursor verwendet werden, wenn die `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> aktiviert ist. Die benutzerdefinierte Cursor werden festgelegt, der <xref:System.Windows.Forms.Control.GiveFeedback> -Ereignishandler.  
  
 Die Tastaturstatus wird ausgewertet, der <xref:System.Windows.Forms.Control.DragOver> -Ereignishandler für das Recht `ListBox`, um zu bestimmen, welche des Ziehvorgangs werden basierend auf den Zustand der Tasten UMSCHALT, STRG, ALT oder STRG + ALT. Die Position in der `ListBox` , in die Dropdownliste käme werden auch während des bestimmt die `DragOver` Ereignis. Wenn die Daten so löschen Sie keine `String`, die <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> auf festgelegt ist `None` in <xref:System.Windows.Forms.DragDropEffects>. Schließlich wird der Status des im Dropdownmenü angezeigt, der `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 Die Daten für das Recht löschen `ListBox` wird bestimmt, der <xref:System.Windows.Forms.Control.DragDrop> -Ereignishandler und die `String` Wert wird an die entsprechende Stelle im hinzugefügt der `ListBox`. Wenn der Ziehvorgang außerhalb der Grenzen des Formulars verschoben, der Drag-and-Drop-Vorgang abgebrochen wird, der <xref:System.Windows.Forms.Control.QueryContinueDrag> -Ereignishandler.  
  
 Dieser Code veranschaulicht die Verwendung der <xref:System.Windows.Forms.Control.QueryContinueDrag> Ereignis. Finden Sie unter der <xref:System.Windows.Forms.Control.DoDragDrop%2A> Methode für das gesamte Codebeispiel dargestellt.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseDragEvent">
      <MemberSignature Language="C#" Value="protected void RaiseDragEvent (object key, System.Windows.Forms.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseDragEvent(object key, class System.Windows.Forms.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Das auszulösende Ereignis.</param>
        <param name="e">Ein <see cref="T:System.Windows.Forms.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das entsprechende Ziehereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseKeyEvent">
      <MemberSignature Language="C#" Value="protected void RaiseKeyEvent (object key, System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseKeyEvent(object key, class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Das auszulösende Ereignis.</param>
        <param name="e">Ein <see cref="T:System.Windows.Forms.KeyEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das entsprechende Tastenereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseMouseEvent">
      <MemberSignature Language="C#" Value="protected void RaiseMouseEvent (object key, System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseMouseEvent(object key, class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Das auszulösende Ereignis.</param>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das entsprechende Mausereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePaintEvent">
      <MemberSignature Language="C#" Value="protected void RaisePaintEvent (object key, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaisePaintEvent(object key, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Das auszulösende Ereignis.</param>
        <param name="e">Ein <see cref="T:System.Windows.Forms.PaintEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das entsprechende Paint-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RecreateHandle">
      <MemberSignature Language="C#" Value="protected void RecreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RecreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RecreateHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt ein erneutes Erstellen des Handles für das Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.RecreateHandle%2A> Methode wird aufgerufen, wenn Parameter für ein neues Steuerelement benötigt werden, aber über einen Aufruf von <xref:System.Windows.Forms.Control.UpdateStyles%2A> auf <xref:System.Windows.Forms.Control.CreateParams%2A> reicht nicht aus. Diese Methode ruft auch <xref:System.Windows.Forms.Control.DestroyHandle%2A> und <xref:System.Windows.Forms.Control.CreateHandle%2A> und legt <xref:System.Windows.Forms.Control.RecreatingHandle%2A> auf `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecreatingHandle">
      <MemberSignature Language="C#" Value="public bool RecreatingHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RecreatingHandle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RecreatingHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement gerade das zugehörige Handle neu erstellt.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement gerade das Handle neu erstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.RecreatingHandle%2A> -Eigenschaft gibt `true` Wenn die <xref:System.Windows.Forms.Control.RecreateHandle%2A> Methode weiterhin auf das Steuerelement ausgeführt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RectangleToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToClient (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToClient(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">Der zu konvertierende Bildschirmkoordinaten-<see cref="T:System.Drawing.Rectangle" />.</param>
        <summary>Berechnet die Größe und die Position des angegebenen Bildschirmrechtecks in Clientkoordinaten.</summary>
        <returns>Ein <see cref="T:System.Drawing.Rectangle" />, der den konvertierten <see cref="T:System.Drawing.Rectangle" />, <paramref name="r" />, in Clientkoordinaten darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RectangleToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToScreen (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToScreen(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">Der zu konvertierende Clientkoordinaten-<see cref="T:System.Drawing.Rectangle" />.</param>
        <summary>Berechnet die Größe und die Position des angegebenen Clientrechtecks in Bildschirmkoordinaten.</summary>
        <returns>Ein <see cref="T:System.Drawing.Rectangle" />, der den konvertierten <see cref="T:System.Drawing.Rectangle" />, <paramref name="p" />, in Bildschirmkoordinaten darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>, und <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> Elemente. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular namens **Form1** mehrere Steuerelemente enthält. Dieses Beispiel erfordert, dass die <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, und <xref:System.Windows.Forms.Control.MouseUp> Ereignisse an die Ereignishandler, die im Beispiel definierte verbunden sind.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectMessage">
      <MemberSignature Language="C#" Value="protected static bool ReflectMessage (IntPtr hWnd, ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool ReflectMessage(native int hWnd, valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ReflectMessage(System.IntPtr,System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hWnd" Type="System.IntPtr" />
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="hWnd">Ein <see cref="T:System.IntPtr" />, der das Handle des Steuerelements darstellt, an das die Meldung zurückgesendet werden soll.</param>
        <param name="m">Eine <see cref="T:System.Windows.Forms.Message" />, die die Windows-Meldung darstellt, die zurückgesendet werden soll.</param>
        <summary>Reflektiert die angegebene Meldung an das Steuerelement, das an das angegebene Handle gebunden ist.</summary>
        <returns>
          <see langword="true" />, wenn die Meldung reflektiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.ReflectMessage%2A> Methode ist eine Infrastrukturmethode und sollte in der Regel nicht aus dem Code aufgerufen werden.  
  
 Wenn die `hWnd` -Parameter nicht darstellen kann, ein gültiges Steuerelement die <xref:System.Windows.Forms.Control.ReflectMessage%2A> -Methode zurückkehrt `false`.  
  
 Da Windows-Meldungen an das Fenster der obersten Ebene zurückgegeben werden die <xref:System.Windows.Forms.Control.ReflectMessage%2A> Methode wird verwendet, um die Antwortnachricht an das Steuerelement weitergegeben werden, die die Nachricht gesendet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster zum Aufrufen dieser Methode. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Refresh" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt, dass das Steuerelement seinen Clientbereich für ungültig erklärt und sich sowie alle untergeordneten Steuerelemente sofort selbst neu zeichnet.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.Forms.Control.Refresh" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Windows.Forms.Control.Refresh" /> Methode, sodass das Steuerelement und seine untergeordneten Steuerelemente für ungültig erklärt und neu gezeichnet werden.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Region">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Region { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Region Region" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Region" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den dem Steuerelement zugeordneten Fensterbereich ab oder legt diesen fest.</summary>
        <value>Die dem Steuerelement zugeordnete Fenster-<see cref="T:System.Drawing.Region" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Fensterbereich ist eine Auflistung von Pixeln innerhalb des Fensters, in dem das Betriebssystem Zeichnen zulässt. Das Betriebssystem zeigt kein Teils eines Fensters, die sich außerhalb der Fensterbereich befindet. Die Koordinaten des Bereichs eines Steuerelements werden relativ zur linken oberen Ecke des Steuerelements nicht den Clientbereich des Steuerelements.  
  
> [!NOTE]
>  Die Auflistung der Pixel innerhalb des Bereichs kann nicht zusammenhängende sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Control.Region%2A> Eigenschaft durch das Erstellen einer runden Schaltfläche. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular mit einer Schaltfläche namens `roundButton`. Dieses Beispiel erfordert, dass die <xref:System.Windows.Forms.Control.Paint> Ereignis an den Ereignishandler, die im Beispiel definierte verbunden ist.  
  
 [!code-cpp[System.Windows.Forms.Control.Region#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.Region#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.Region#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster zum Wert dieser Eigenschaft festgelegt. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="RegionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RegionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RegionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RegionChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.Region" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.RegionChanged> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.RegionChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#22)]
 [!code-vb[System.Windows.Forms.EventExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderRightToLeft">
      <MemberSignature Language="C#" Value="protected bool RenderRightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RenderRightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. Please use RightToLeft instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Diese Eigenschaft ist jetzt veraltet.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement von rechts nach links gerendert wird, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RescaleConstantsForDpi">
      <MemberSignature Language="C#" Value="protected virtual void RescaleConstantsForDpi (int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RescaleConstantsForDpi(int32 deviceDpiOld, int32 deviceDpiNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RescaleConstantsForDpi(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">Der DPI-Wert vor der Änderung.</param>
        <param name="deviceDpiNew">Der DPI-Wert nach der Änderung.</param>
        <summary>Stellt Konstanten für die Größenänderung des Steuerelements bereit, wenn ein DPI-Wert geändert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBackColor">
      <MemberSignature Language="C#" Value="public virtual void ResetBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBackColor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="P:System.Windows.Forms.Control.BackColor" />-Eigenschaft auf den Standardwert zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBindings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt dazu, dass in ein an <see cref="T:System.Windows.Forms.BindingSource" /> gebundenes Steuerelement alle Elemente in der Liste erneut eingelesen und ihre angezeigten Werte aktualisiert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetCursor">
      <MemberSignature Language="C#" Value="public virtual void ResetCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetCursor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="P:System.Windows.Forms.Control.Cursor" />-Eigenschaft auf den Standardwert zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetFont">
      <MemberSignature Language="C#" Value="public virtual void ResetFont ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetFont() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetFont" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="P:System.Windows.Forms.Control.Font" />-Eigenschaft auf den Standardwert zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetForeColor">
      <MemberSignature Language="C#" Value="public virtual void ResetForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetForeColor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="P:System.Windows.Forms.Control.ForeColor" />-Eigenschaft auf den Standardwert zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetImeMode">
      <MemberSignature Language="C#" Value="public void ResetImeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetImeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetImeMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="P:System.Windows.Forms.Control.ImeMode" />-Eigenschaft auf den Standardwert zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetMouseEventArgs">
      <MemberSignature Language="C#" Value="protected void ResetMouseEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ResetMouseEventArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetMouseEventArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt das Steuerelement zurück, um das <see cref="E:System.Windows.Forms.Control.MouseLeave" />-Ereignis zu behandeln.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetRightToLeft">
      <MemberSignature Language="C#" Value="public virtual void ResetRightToLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetRightToLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetRightToLeft" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="P:System.Windows.Forms.Control.RightToLeft" />-Eigenschaft auf den Standardwert zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetText">
      <MemberSignature Language="C#" Value="public virtual void ResetText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetText" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="P:System.Windows.Forms.Control.Text" />-Eigenschaft auf den Standardwert zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird in der Regel verwenden, wenn Sie entweder einen Designer für das Erstellen der <xref:System.Windows.Forms.Control> oder durch das Erstellen eigener Steuerelement einbinden der <xref:System.Windows.Forms.Control>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resize">
      <MemberSignature Language="C#" Value="public event EventHandler Resize;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Resize" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Resize" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Ändern der Größe des Steuerelements ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu bestimmen, die <xref:System.Windows.Forms.Control.Size%2A> des Steuerelements dessen Größe geändert wurde, können Sie eine Umwandlung der `sender` Parameter des registrierten <xref:System.Windows.Forms.ControlEventHandler> Methode, um eine <xref:System.Windows.Forms.Control> und seine <xref:System.Windows.Forms.Control.Size%2A> Eigenschaft (oder <xref:System.Windows.Forms.Control.Height%2A> und <xref:System.Windows.Forms.Control.Width%2A> Eigenschaften einzeln).  
  
 Um benutzerdefinierte Layouts zu behandeln, verwenden die <xref:System.Windows.Forms.Control.Layout> Ereignisses statt auf das Resize-Ereignis. Die <xref:System.Windows.Forms.Control.Layout> Ereignis wird ausgelöst, als Antwort auf eine <xref:System.Windows.Forms.Control.Resize> Ereignis, sondern auch als Reaktion auf andere Änderungen, die das Layout des Steuerelements beeinflussen.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel behandelt die <xref:System.Windows.Forms.Control.Resize> -Ereignis für ein <xref:System.Windows.Forms.Form>. Beim Ändern der Größe des Formulars, wird der Ereignishandler sichergestellt, dass das Formular quadratisch bleibt (dessen <xref:System.Windows.Forms.Control.Height%2A> und <xref:System.Windows.Forms.Control.Width%2A> bleiben gleich). Um dieses Beispiel auszuführen, stellen Sie sicher, und ordnen diese Ereignisbehandlungsmethode des Formulars <xref:System.Windows.Forms.Control.Resize> Ereignis.  
  
 [!code-cpp[WinForms.Control.Resize#1](~/samples/snippets/cpp/VS_Snippets_Winforms/WinForms.Control.Resize/CPP/form1.cpp#1)]
 [!code-csharp[WinForms.Control.Resize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/WinForms.Control.Resize/CS/form1.cs#1)]
 [!code-vb[WinForms.Control.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/WinForms.Control.Resize/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResizeRedraw">
      <MemberSignature Language="C#" Value="protected bool ResizeRedraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResizeRedraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ResizeRedraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement beim Ändern seiner Größe sich selbst neu zeichnet, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement beim Ändern seiner Größe sich selbst neu zeichnet, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.ResizeRedraw%2A> Eigenschaftswert entspricht der Rückgabewert von der <xref:System.Windows.Forms.Control.GetStyle%2A> Methode beim Übergeben von in der <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> Wert als Parameter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nimmt die übliche Layoutlogik wieder auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Windows.Forms.Control.ResumeLayout%2A> Methode erzwingt ein sofortiges Layout, sofern es ausstehende layoutanforderungen.  
  
 Die <xref:System.Windows.Forms.Control.SuspendLayout%2A> und <xref:System.Windows.Forms.Control.ResumeLayout%2A> Methoden werden zusammen verwendet, um mehrere unterdrücken <xref:System.Windows.Forms.Control.Layout> Ereignisse während mehrere Attribute des Steuerelements angepasst. Beispielsweise würden Sie in der Regel rufen die <xref:System.Windows.Forms.Control.SuspendLayout%2A> -Methode, legen Sie dann die <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, oder <xref:System.Windows.Forms.Control.Dock%2A> Eigenschaften des Steuerelements, und rufen Sie dann die <xref:System.Windows.Forms.Control.ResumeLayout%2A> Methode, um die Änderungen wirksam werden zu aktivieren.  
  
 Es muss keine ausstehende Aufrufe <xref:System.Windows.Forms.Control.SuspendLayout%2A> für <xref:System.Windows.Forms.Control.ResumeLayout%2A> erfolgreich aufgerufen werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Formular zwei Schaltflächen hinzugefügt. Die Beispiel-Transaktionen das Hinzufügen der Schaltflächen mit der <xref:System.Windows.Forms.Control.SuspendLayout%2A> und <xref:System.Windows.Forms.Control.ResumeLayout%2A> Methoden.  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout (bool performLayout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout(bool performLayout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="performLayout" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="performLayout">
          <see langword="true" />, um ausstehende Layoutanforderungen auszuführen, andernfalls <see langword="false" />.</param>
        <summary>Nimmt die übliche Layoutlogik wieder auf und erzwingt optional ein sofortiges Layout für ausstehende Layoutanforderungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Windows.Forms.Control.ResumeLayout%2A> Methode erzwingt ein sofortiges Layout, sofern es ausstehende layoutanforderungen. Wenn die `performLayout` Parametersatz auf `true`, ein sofortiges Layout für tritt auf, wenn ausstehende layoutanforderungen vorhanden sind.  
  
 Die <xref:System.Windows.Forms.Control.SuspendLayout%2A> und <xref:System.Windows.Forms.Control.ResumeLayout%2A> Methoden werden zusammen verwendet, um mehrere unterdrücken <xref:System.Windows.Forms.Control.Layout> Ereignisse während mehrere Attribute des Steuerelements angepasst. Beispielsweise würden Sie in der Regel rufen die <xref:System.Windows.Forms.Control.SuspendLayout%2A> -Methode, legen Sie dann die <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, oder <xref:System.Windows.Forms.Control.Dock%2A> Eigenschaften des Steuerelements, und rufen Sie dann die <xref:System.Windows.Forms.Control.ResumeLayout%2A> Methode, um die Änderungen wirksam werden zu aktivieren.  
  
 Es muss keine ausstehende Aufrufe <xref:System.Windows.Forms.Control.SuspendLayout%2A> für <xref:System.Windows.Forms.Control.ResumeLayout%2A> erfolgreich aufgerufen werden.  
  
> [!NOTE]
>  Wenn mehrere Steuerelemente einem übergeordneten Steuerelement hinzufügen, wird empfohlen, Sie rufen die <xref:System.Windows.Forms.Control.SuspendLayout%2A> -Methode vor dem Initialisieren der Steuerelemente hinzugefügt werden. Rufen Sie nach dem Hinzufügen der Steuerelemente an das übergeordnete Steuerelement an, die <xref:System.Windows.Forms.Control.ResumeLayout%2A> Methode. Dies erhöht die Leistung von Anwendungen mit viele Steuerelemente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Right">
      <MemberSignature Language="C#" Value="public int Right { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Right" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Right" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Abstand zwischen dem rechten Rand des Steuerelements und dem linken Rand des Clientbereichs des zugehörigen Containers in Pixel ab.</summary>
        <value>Ein <see cref="T:System.Int32" />-Wert, der den Abstand zwischen dem rechten Rand des Steuerelements und dem linken Rand des Clientbereichs des zugehörigen Containers in Pixel darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert von der <xref:System.Windows.Forms.Control.Right%2A> Eigenschaft entspricht der Summe der der <xref:System.Windows.Forms.Control.Left%2A> Eigenschaftswert und die <xref:System.Windows.Forms.Control.Width%2A> Eigenschaftswert.  
  
 Die <xref:System.Windows.Forms.Control.Right%2A> Eigenschaft ist schreibgeschützt. Sie können den Wert dieser Eigenschaft indirekt durch Ändern des Werts der Ändern der <xref:System.Windows.Forms.Control.Left%2A> oder <xref:System.Windows.Forms.Control.Width%2A> Eigenschaften oder das Aufrufen der <xref:System.Windows.Forms.Control.SetBounds%2A>, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, <xref:System.Windows.Forms.Control.UpdateBounds%2A>, oder <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt drei <xref:System.Windows.Forms.Button> Steuerelemente eines Formulars und legt deren Größe und Position mithilfe der verschiedenen hinsichtlich der Größe und Position-bezogene Eigenschaften. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> , besitzt eine Breite und Höhe von mindestens 300 Pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.RightToLeft RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RightToLeft RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RightToLeft</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Elemente des Steuerelements für die Unterstützung von Gebietsschemas ausgerichtet sind, die von rechts nach links geschriebene Schriftarten verwenden, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Windows.Forms.RightToLeft" />-Werte. Die Standardeinstellung ist <see cref="F:System.Windows.Forms.RightToLeft.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.RightToLeft%2A> Eigenschaft ist eine ambient-Eigenschaft. Eine Ambiente-Eigenschaft ist eine Steuerelementeigenschaft, wenn nicht festgelegt ist, wird vom übergeordneten Steuerelement abgerufen. Z. B. eine <xref:System.Windows.Forms.Button> verfügen über denselben <xref:System.Windows.Forms.Control.BackColor%2A> wie das übergeordnete Objekt <xref:System.Windows.Forms.Form> standardmäßig. Weitere Informationen zu Umgebungseigenschaften, finden Sie unter der <xref:System.Windows.Forms.AmbientProperties> Klasse oder die <xref:System.Windows.Forms.Control> -Klassenübersicht.  
  
 Die <xref:System.Windows.Forms.Control.RightToLeft%2A> Eigenschaft für internationale Anwendungen verwendet wird, in die Sprache von rechts nach links, z. B. Hebräisch oder Arabisch geschrieben wird. Wenn diese Eigenschaft festgelegt wird, um <xref:System.Windows.Forms.RightToLeft?displayProperty=nameWithType>, Steuerelemente, die Text enthalten, werden von rechts nach links angezeigt.  
  
> [!NOTE]
>  Wenn der Wert, der die <xref:System.Windows.Forms.Control.RightToLeft%2A> Eigenschaft zur Laufzeit geändert wird, werden nur die unformatierten Text ohne Formatierung wird beibehalten.  
  
 Im folgenden sind einige Beispiele der Auswirkungen der Elemente des Steuerelements durch die <xref:System.Windows.Forms.Control.RightToLeft%2A> Eigenschaftswert <xref:System.Windows.Forms.RightToLeft?displayProperty=nameWithType> :  
  
-   Vertikale Bildlaufleisten werden auf der linken Seite statt auf der rechten Seite von bildlauffähigen Steuerelementen angezeigt (z. B. <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Panel>, mehrzeilige <xref:System.Windows.Forms.TextBox>, und <xref:System.Windows.Forms.RichTextBox>).  
  
-   Horizontale Bildlaufleisten beginnen mit einem rechtsbündigen Bildlauffeld (Ziehpunkt).  
  
-   Das Element Ausrichtung für Kontrollkästchen gesteuert wird, indem Sie die `CheckAlign` -Eigenschaft wird für umgekehrt <xref:System.Windows.Forms.CheckBox> und <xref:System.Windows.Forms.RadioButton> Steuerelemente.  
  
-   Elemente im Kombinationsfeld, Listenfelder und auf-ab-Steuerelemente werden rechts ausgerichtet.  
  
-   Nach oben oder unten Schaltflächen sind auf Linksbündig <xref:System.Windows.Forms.NumericUpDown> und <xref:System.Windows.Forms.DomainUpDown> Steuerelemente.  
  
-   Menüs (<xref:System.Windows.Forms.MainMenu>, <xref:System.Windows.Forms.MenuItem>, und <xref:System.Windows.Forms.ContextMenu>) rechtsbündig angezeigt werden.  
  
-   Die Ausrichtung des Symbolleistenschaltflächen auf eine <xref:System.Windows.Forms.ToolBar> Steuerelement oder die Ausrichtung von Text in eine <xref:System.Windows.Forms.ToolBarButton> keinen Einfluss auf die <xref:System.Windows.Forms.Control.RightToLeft%2A> Eigenschaft.  
  
-   <xref:System.Windows.Forms.AxHost>unterstützt die Ausrichtung von rechts nach links. Allerdings hängt die Auswirkung auf ein ActiveX-Steuerelement das Ausmaß, in dem Autor des Steuerelements implementiert wird Unterstützung für die Anzeige von rechts nach links.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der zugewiesene Wert ist nicht der <see cref="T:System.Windows.Forms.RightToLeft" /> Werte.</exception>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.RightToLeft" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.RightToLeft" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen. Sie müssen nicht beide außer Kraft setzen der <see langword="get" /> und <see langword="set" /> Accessoren der der <see cref="P:System.Windows.Forms.Control.RightToLeft" /> Eigenschaft; Sie können nur eine bei Bedarf überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RightToLeftChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RightToLeftChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.RightToLeft" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.RightToLeft%2A> -Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignishandler, der ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaftswert ändert. Die <xref:System.Windows.Forms.Control> -Klasse verfügt über mehrere Methoden mit dem Namensmuster *PropertyName* `Changed` , sind wird ausgelöst, wenn das entsprechende *PropertyName* -Wert ändert (* PropertyName* stellt den Namen der entsprechenden Eigenschaft dar).  
  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> , enthält eine <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Drawing.ContentAlignment RtlTranslateAlignment (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateAlignment(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Drawing.ContentAlignment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Einer der <see cref="T:System.Drawing.ContentAlignment" />-Werte.</param>
        <summary>Konvertiert das angegebene <see cref="T:System.Drawing.ContentAlignment" /> in das entsprechende <see cref="T:System.Drawing.ContentAlignment" /> für die Unterstützung der Schriftrichtung von rechts nach links.</summary>
        <returns>Einer der <see cref="T:System.Drawing.ContentAlignment" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.RightToLeft%2A> Eigenschaft <xref:System.Windows.Forms.RightToLeft> festgelegt ist, um `No`, der zurückgegebene Wert ist gleich der `align` übergebene Parameter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Einer der <see cref="T:System.Windows.Forms.HorizontalAlignment" />-Werte.</param>
        <summary>Konvertiert das angegebene <see cref="T:System.Windows.Forms.HorizontalAlignment" /> in das entsprechende <see cref="T:System.Windows.Forms.HorizontalAlignment" /> für die Unterstützung der Schriftrichtung von rechts nach links.</summary>
        <returns>Einer der <see cref="T:System.Windows.Forms.HorizontalAlignment" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.RightToLeft%2A> Eigenschaft <xref:System.Windows.Forms.RightToLeft> festgelegt ist, um `No`, der zurückgegebene Wert ist gleich der `align` übergebene Parameter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.LeftRightAlignment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Einer der <see cref="T:System.Windows.Forms.LeftRightAlignment" />-Werte.</param>
        <summary>Konvertiert das angegebene <see cref="T:System.Windows.Forms.LeftRightAlignment" /> in das entsprechende <see cref="T:System.Windows.Forms.LeftRightAlignment" /> für die Unterstützung der Schriftrichtung von rechts nach links.</summary>
        <returns>Einer der <see cref="T:System.Windows.Forms.LeftRightAlignment" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.RightToLeft%2A> Eigenschaft <xref:System.Windows.Forms.RightToLeft> festgelegt ist, um `No`, der zurückgegebene Wert ist gleich der `align` übergebene Parameter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateContent">
      <MemberSignature Language="C#" Value="protected System.Drawing.ContentAlignment RtlTranslateContent (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateContent(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Einer der <see cref="T:System.Drawing.ContentAlignment" />-Werte.</param>
        <summary>Konvertiert das angegebene <see cref="T:System.Drawing.ContentAlignment" /> in das entsprechende <see cref="T:System.Drawing.ContentAlignment" /> für die Unterstützung der Schriftrichtung von rechts nach links.</summary>
        <returns>Einer der <see cref="T:System.Drawing.ContentAlignment" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.RightToLeft%2A> Eigenschaft <xref:System.Windows.Forms.RightToLeft> festgelegt ist, um `No`, der zurückgegebene Wert ist gleich der `align` übergebene Parameter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateHorizontal">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Einer der <see cref="T:System.Windows.Forms.HorizontalAlignment" />-Werte.</param>
        <summary>Konvertiert das angegebene <see cref="T:System.Windows.Forms.HorizontalAlignment" /> in das entsprechende <see cref="T:System.Windows.Forms.HorizontalAlignment" /> für die Unterstützung der Schriftrichtung von rechts nach links.</summary>
        <returns>Einer der <see cref="T:System.Windows.Forms.HorizontalAlignment" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.RightToLeft%2A> Eigenschaft <xref:System.Windows.Forms.RightToLeft> festgelegt ist, um `No`, der zurückgegebene Wert ist gleich der `align` übergebene Parameter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateLeftRight">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Einer der <see cref="T:System.Windows.Forms.LeftRightAlignment" />-Werte.</param>
        <summary>Konvertiert das angegebene <see cref="T:System.Windows.Forms.LeftRightAlignment" /> in das entsprechende <see cref="T:System.Windows.Forms.LeftRightAlignment" /> für die Unterstützung der Schriftrichtung von rechts nach links.</summary>
        <returns>Einer der <see cref="T:System.Windows.Forms.LeftRightAlignment" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.RightToLeft%2A> Eigenschaft <xref:System.Windows.Forms.RightToLeft> festgelegt ist, um `No`, der zurückgegebene Wert ist gleich der `align` übergebene Parameter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (System.Drawing.SizeF factor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(valuetype System.Drawing.SizeF factor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Drawing.SizeF)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
      </Parameters>
      <Docs>
        <param name="factor">Ein <see cref="T:System.Drawing.SizeF" />, das die horizontalen und vertikalen Skalierungsfaktoren enthält.</param>
        <summary>Skaliert das Steuerelement und alle untergeordneten Steuerelemente entsprechend dem angegebenen Skalierungsfaktor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Scale%2A> Methode skaliert das Steuerelement, um den angegebenen Skalierungsfaktor `factor`. Es auch rekursiv alle untergeordneten Steuerelemente skaliert, wenn die <xref:System.Windows.Forms.Control.ScaleChildren%2A> Eigenschaft ist `true`. Intern ruft diese Methode <xref:System.Windows.Forms.Control.ScaleControl%2A> jedes Steuerelement zu skalieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float ratio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 ratio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ratio" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="ratio">Das für die Skalierung zu verwendende Verhältnis.</param>
        <summary>Skaliert das Steuerelement und alle untergeordneten Steuerelemente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Der Faktor für die horizontale Skalierung.</param>
        <param name="dy">Der Faktor für die vertikale Skalierung.</param>
        <summary>Skaliert das gesamte Steuerelement und alle untergeordneten Steuerelemente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleBitmapLogicalToDevice">
      <MemberSignature Language="C#" Value="public void ScaleBitmapLogicalToDevice (ref System.Drawing.Bitmap logicalBitmap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleBitmapLogicalToDevice(class System.Drawing.Bitmap&amp; logicalBitmap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleBitmapLogicalToDevice(System.Drawing.Bitmap@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalBitmap" Type="System.Drawing.Bitmap&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="logicalBitmap">Die zu skalierende Bitmap.</param>
        <summary>Skaliert, wenn DPI-Wert geändert wird, einen logischen Bitmapwert in den entsprechenden Wert in der Geräteeinheit.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleChildren">
      <MemberSignature Language="C#" Value="protected virtual bool ScaleChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScaleChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ScaleChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Skalierung der untergeordneten Steuerelemente bestimmt.</summary>
        <value>
          <see langword="true" />, wenn untergeordnete Steuerelemente beim Aufrufen dieser <see cref="M:System.Windows.Forms.Control.Scale(System.Single)" />-Methode für dieses Steuerelement skaliert werden, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.ScaleChildren%2A> Eigenschaft ist `true`, und klicken Sie dann die <xref:System.Windows.Forms.Control.Scale%2A> Methode wird rekursiv Aufruf der <xref:System.Windows.Forms.Control.ScaleControl%2A> -Methode aller seiner untergeordneten Steuerelemente.  
  
 Die standardmäßige Implementierung des <xref:System.Windows.Forms.Control.ScaleChildren%2A> gibt immer `true`. Abgeleitete Klassen können überschreiben <xref:System.Windows.Forms.Control.ScaleChildren%2A> zurückzugebenden `false` um anzugeben, dass die Skalierung auf deren untergeordnete Elemente nicht ausgeführt werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected virtual void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="factor">Der Faktor, um den die Höhe und die Breite des Steuerelements skaliert werden.</param>
        <param name="specified">Ein <see cref="T:System.Windows.Forms.BoundsSpecified" />-Wert, der die Begrenzungen des Steuerelements angibt und bei der Definition von Größe und Position verwendet wird.</param>
        <summary>Skaliert Speicherort, Größe, Textabstand und Rand eines Steuerelements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Steuerelement der obersten Ebene ist, wird dies nicht die Position des Steuerelements skaliert. Dies skaliert nicht untergeordneten oder der Größe von Steuerelementen automatisch so angepasst wird. Sie können die Skalierung in beliebiger Richtung durch Ändern des Werts der weglassen der `specified` Parameter.  
  
   
  
## Examples  
 <xref:System.Windows.Forms.BoundsSpecified>  
  
 <xref:System.Windows.Forms.Control.Scale%2A>  
  
 <xref:System.Windows.Forms.Control.GetScaledBounds%2A>  
  
 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected virtual void ScaleCore (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleCore(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Der Faktor für die horizontale Skalierung.</param>
        <param name="dy">Der Faktor für die vertikale Skalierung.</param>
        <summary>Diese Methode ist für diese Klasse nicht relevant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktiviert das Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Select%2A> Methode aktiviert das Steuerelement aus, wenn des Steuerelements `Selectable` -Formatbit auf festgelegt ist `true` in <xref:System.Windows.Forms.ControlStyles>in ein anderes Steuerelement enthalten ist und alle übergeordneten Steuerelemente werden sichtbar und aktiviert.  
  
 Windows Forms-Steuerelemente in der folgenden Liste sind nicht auswählbar. Von Steuerelementen in der Liste abgeleitete Steuerelemente werden ebenfalls nicht ausgewählt werden.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel>(Wenn kein Link im Steuerelement vorhanden ist)  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das angegebene wählt <xref:System.Windows.Forms.Control>, wenn er ausgewählt werden kann.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected virtual void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select(System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">
          <see langword="true" />, um die Richtung für die Auswahl des Steuerelements anzugeben, andernfalls <see langword="false" />.</param>
        <param name="forward">
          <see langword="true" />, um sich in der Aktivierreihenfolge vorwärts zu bewegen, <see langword="false" />, um sich rückwärts zu bewegen.</param>
        <summary>Aktiviert ein untergeordnetes Steuerelement. Gibt optional die Richtung in der Aktivierreihenfolge für die Auswahl des Steuerelements an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `directed` und `forward` Parameter werden von Containersteuerelementen verwendet. Wenn die `directed` Parameter auf festgelegt ist `true`die `forward` Parameter wird ausgewertet, um zu bestimmen, welches Steuerelement auswählen. Wenn `forward` festgelegt ist, um `true`, das nächste Steuerelement in der Aktivierreihenfolge aktiviert ist; Wenn `false`, das vorherige Steuerelement in der Aktivierreihenfolge ausgewählt ist.  
  
 Die <xref:System.Windows.Forms.Control.Select%2A> Methode aktiviert das Steuerelement aus, wenn des Steuerelements `Selectable` -Formatbit auf festgelegt ist `true` in <xref:System.Windows.Forms.ControlStyles>in ein anderes Steuerelement enthalten ist und alle übergeordneten Steuerelemente werden sichtbar und aktiviert.  
  
 Windows Forms-Steuerelemente in der folgenden Liste sind nicht auswählbar. Von Steuerelementen in der Liste abgeleitete Steuerelemente werden ebenfalls nicht ausgewählt werden.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel>(Wenn kein Link im Steuerelement vorhanden ist)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectNextControl">
      <MemberSignature Language="C#" Value="public bool SelectNextControl (System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SelectNextControl(class System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
        <Parameter Name="tabStopOnly" Type="System.Boolean" />
        <Parameter Name="nested" Type="System.Boolean" />
        <Parameter Name="wrap" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">Das <see cref="T:System.Windows.Forms.Control" />, bei dem mit der Suche begonnen werden soll.</param>
        <param name="forward">
          <see langword="true" />, um sich in der Aktivierreihenfolge vorwärts zu bewegen, <see langword="false" />, um sich rückwärts zu bewegen.</param>
        <param name="tabStopOnly">
          <see langword="true" />, um Steuerelemente zu ignorieren, deren <see cref="P:System.Windows.Forms.Control.TabStop" />-Eigenschaft auf <see langword="false" /> festgelegt ist, andernfalls <see langword="false" />.</param>
        <param name="nested">
          <see langword="true" />, um geschachtelte untergeordnete (d. h. untergeordneten Steuerelementen untergeordnete) Steuerelemente einzuschließen, andernfalls <see langword="false" />.</param>
        <param name="wrap">
          <see langword="true" />, um die Suche beim ersten Steuerelement der Aktivierreihenfolge fortzusetzen, nachdem das letzte Steuerelement erreicht wurde, andernfalls <see langword="false" />.</param>
        <summary>Aktiviert das nächste Steuerelement.</summary>
        <returns>
          <see langword="true" />, wenn ein Steuerelement aktiviert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.SelectNextControl%2A> Methode aktiviert das nächste Steuerelement in der Aktivierreihenfolge, wenn des Steuerelements `Selectable` -Formatbit auf festgelegt ist `true` in <xref:System.Windows.Forms.ControlStyles>in ein anderes Steuerelement enthalten ist und alle übergeordneten Steuerelemente werden sichtbar und aktiviert.  
  
 Windows Forms-Steuerelemente in der folgenden Liste sind nicht auswählbar. Von Steuerelementen in der Liste abgeleitete Steuerelemente werden ebenfalls nicht ausgewählt werden.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel>(Wenn kein Link im Steuerelement vorhanden ist)  
  
 Wenn Sie den Fokus ändern, indem Sie mithilfe der Tastatur (Registerkarte, UMSCHALT + TAB usw.), durch Aufrufen der <xref:System.Windows.Forms.Control.Select%2A> oder <xref:System.Windows.Forms.Control.SelectNextControl%2A> Methoden, oder durch Festlegen der <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> Eigenschaft auf das aktuelle Formular den Fokusereignisse auftreten, in der folgenden Reihenfolge:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A> -Eigenschaftensatz auf `false`, <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> Ereignisse werden unterdrückt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel Beispiel veranschaulicht die <xref:System.Windows.Forms.Control.SelectNextControl%2A> Methode, die in ein Formular, das einige Steuerelemente verfügt verwendet wird. Jedes Mal, wenn Sie auf das Formular klicken, wird das nächste Steuerelement aktiviert. Die <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> Eigenschaft ruft das derzeit aktive Steuerelement im Containersteuerelement.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#1)]  
  
 Das folgende Codebeispiel zeigt die <xref:System.Windows.Forms.Control.SelectNextControl%2A> Methode verwendet wird, in einem Formular, besitzt eine <xref:System.Windows.Forms.Button> und einige andere Steuerelemente. Beim Klicken auf die <xref:System.Windows.Forms.Button>, das nächste Steuerelement nach dem <xref:System.Windows.Forms.Button> aktiviert ist. Beachten Sie, dass Sie das übergeordnete Element des machen müssen, die <xref:System.Windows.Forms.Button> Steuerelement. Da <xref:System.Windows.Forms.Button> ist kein Container, Aufrufen von <xref:System.Windows.Forms.Control.SelectNextControl%2A> direkt auf die <xref:System.Windows.Forms.Button> würde die Aktivierung nicht ändern.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#2)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendToBack">
      <MemberSignature Language="C#" Value="public void SendToBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendToBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SendToBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sendet das Steuerelement ans Ende der z-Reihenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Steuerelement wird ans Ende der Z-Reihenfolge verschoben. Wenn das Steuerelement ein untergeordnetes Element eines anderen Steuerelements ist, wird das untergeordnete Steuerelement ans Ende der Z-Reihenfolge verschoben. Wenn das Steuerelement ein Steuerelement der obersten Ebene ist, ist diese Methode nicht funktionsfähig, wenn das Steuerelement aktiv ist. Ein Steuerelement der obersten Ebene ist ein Steuerelement, z. B. eine <xref:System.Windows.Forms.Form>, d. h. kein untergeordnetes Element eines anderen Steuerelements. Ein aktives Steuerelement ist ein sichtbar Steuerelement, das den Eingabefokus besitzt. Verwenden der <xref:System.Windows.Forms.Control.SendToBack%2A> Methode mit einem Steuerelement inaktive, auf der obersten Ebene, rufen Sie zuerst die <xref:System.Windows.Forms.Control.BringToFront%2A> Methode für das Steuerelement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected void SetAutoSizeMode (System.Windows.Forms.AutoSizeMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetAutoSizeMode(valuetype System.Windows.Forms.AutoSizeMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetAutoSizeMode(System.Windows.Forms.AutoSizeMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.AutoSizeMode" />
      </Parameters>
      <Docs>
        <param name="mode">Einer der <see cref="T:System.Windows.Forms.AutoSizeMode" />-Werte.</param>
        <summary>Legt einen Wert fest, der angibt, wie sich ein Steuerelement verhält, wenn seine <see cref="P:System.Windows.Forms.Control.AutoSize" />-Eigenschaft aktiviert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Der neue <see cref="P:System.Windows.Forms.Control.Left" />-Eigenschaftswert des Steuerelements.</param>
        <param name="y">Der neue <see cref="P:System.Windows.Forms.Control.Top" />-Eigenschaftswert des Steuerelements.</param>
        <param name="width">Der neue <see cref="P:System.Windows.Forms.Control.Width" />-Eigenschaftswert des Steuerelements.</param>
        <param name="height">Der neue <see cref="P:System.Windows.Forms.Control.Height" />-Eigenschaftswert des Steuerelements.</param>
        <summary>Legt die Begrenzungen des Steuerelements auf die angegebene Position und Größe fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Der neue <see cref="P:System.Windows.Forms.Control.Left" />-Eigenschaftswert des Steuerelements.</param>
        <param name="y">Der neue <see cref="P:System.Windows.Forms.Control.Top" />-Eigenschaftswert des Steuerelements.</param>
        <param name="width">Der neue <see cref="P:System.Windows.Forms.Control.Width" />-Eigenschaftswert des Steuerelements.</param>
        <param name="height">Der neue <see cref="P:System.Windows.Forms.Control.Height" />-Eigenschaftswert des Steuerelements.</param>
        <param name="specified">Eine bitweise Kombination der <see cref="T:System.Windows.Forms.BoundsSpecified" />-Werte. Für jeden nicht angegebenen Parameter wird der aktuelle Wert verwendet.</param>
        <summary>Legt die angegebenen Begrenzungen des Steuerelements auf die angegebene Position und Größe fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird Rechenzentren eine <xref:System.Windows.Forms.Form> auf dem Bildschirm in der <xref:System.Windows.Forms.Control.Layout> Ereignis. Dadurch wird das Formular zentriert, wenn der Benutzer die Größe ändern lassen möchten. Dieses Beispiel benötigen Sie nach der Erstellung einer <xref:System.Windows.Forms.Form> Steuerelement.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected virtual void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Der neue <see cref="P:System.Windows.Forms.Control.Left" />-Eigenschaftswert des Steuerelements.</param>
        <param name="y">Der neue <see cref="P:System.Windows.Forms.Control.Top" />-Eigenschaftswert des Steuerelements.</param>
        <param name="width">Der neue <see cref="P:System.Windows.Forms.Control.Width" />-Eigenschaftswert des Steuerelements.</param>
        <param name="height">Der neue <see cref="P:System.Windows.Forms.Control.Height" />-Eigenschaftswert des Steuerelements.</param>
        <param name="specified">Eine bitweise Kombination der <see cref="T:System.Windows.Forms.BoundsSpecified" />-Werte.</param>
        <summary>Legt die angegebenen Begrenzungen dieses Steuerelements fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel die Parameter, die die Grenzen, die nicht in enthalten entsprechen den `specified` Parameter sich ihre aktuellen Werte übergeben werden. Z. B. die <xref:System.Windows.Forms.Control.Height%2A>, <xref:System.Windows.Forms.Control.Width%2A>, oder die <xref:System.Drawing.Point.X%2A> oder <xref:System.Drawing.Point.Y%2A> Eigenschaften der <xref:System.Windows.Forms.Control.Location%2A> Eigenschaft mit einem Verweis auf die aktuelle Instanz des Steuerelements übergeben werden kann. Alle übergebenen Werte werden jedoch berücksichtigt, und klicken Sie auf das Steuerelement angewendet.  
  
 Die `boundsSpecified` Parameter darstellt, die Elemente der Steuerelemente <xref:System.Windows.Forms.Control.Bounds%2A> von der Anwendung geändert. Angenommen, Sie ändern die <xref:System.Windows.Forms.Control.Size%2A> des Steuerelements, das `boundsSpecified` Parameterwert ist die `Size` Wert <xref:System.Windows.Forms.BoundsSpecified>. Jedoch wenn die <xref:System.Windows.Forms.Control.Size%2A> wird angepasst, als Antwort auf die <xref:System.Windows.Forms.Control.Dock%2A> -Eigenschaft festgelegt wird, die `boundsSpecified` Parameterwert ist die `None` Wert <xref:System.Windows.Forms.BoundsSpecified>.  
  
> [!NOTE]
>  In Windows Server 2003-Systemen, die Größe des eine <xref:System.Windows.Forms.Form> wird durch die maximale Pixelbreite und Höhe des Monitors eingeschränkt.  
  
   
  
## Examples  
 Das folgende Codebeispiel setzt die <xref:System.Windows.Forms.Control.SetBoundsCore%2A> Methode, um sicherzustellen, dass das Steuerelement über eine feste Größe bleibt. Dieses Beispiel benötigen Sie, dass Sie eine Klasse haben, die entweder direkt oder indirekt von abgeleitet ist die <xref:System.Windows.Forms.Control> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_Methods#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#1)]
 [!code-csharp[Windows.Forms.Control_Methods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#1)]
 [!code-vb[Windows.Forms.Control_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> Methode, um die Grenzen des Steuerelements ändern zu erzwingen. Abgeleitete Klassen können Größe Einschränkungen beim Hinzufügen der <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected virtual void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die Breite des Clientbereichs in Pixel.</param>
        <param name="y">Die Höhe des Clientbereichs in Pixel.</param>
        <summary>Legt die Größe für den Clientbereich des Steuerelements fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Clientbereich beginnt an der (0, 0) Speicherort und erstreckt sich auch auf die (`x`, `y`) Speicherort.  
  
 In der Regel sollten Sie nicht Festlegen der <xref:System.Windows.Forms.Control.ClientSize%2A> des Steuerelements.  
  
   
  
## Examples  
 Das folgende Codebeispiel setzt die <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> Methode, um sicherzustellen, dass das Steuerelement quadratische bleibt. Dieses Beispiel benötigen Sie, dass Sie eine Klasse haben, die entweder direkt oder indirekt von abgeleitet ist die <xref:System.Windows.Forms.Control> Klasse.  
  
 [!code-cpp[Windows.Forms.Control_Methods#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#2)]
 [!code-csharp[Windows.Forms.Control_Methods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#2)]
 [!code-vb[Windows.Forms.Control_Methods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" /> Methode, damit die <see cref="P:System.Windows.Forms.Control.ClientSize" /> Eigenschaft angepasst wird.  
  
 Weitere Informationen zum Zeichnen auf Steuerelementen finden Sie unter [Rendern eines Windows Forms-Steuerelements](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetStyle">
      <MemberSignature Language="C#" Value="protected void SetStyle (System.Windows.Forms.ControlStyles flag, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetStyle(valuetype System.Windows.Forms.ControlStyles flag, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flag">Das <see cref="T:System.Windows.Forms.ControlStyles" />-Bit, das festgelegt werden soll.</param>
        <param name="value">
          <see langword="true" />, um das angegebene Format auf das Steuerelement anzuwenden, andernfalls <see langword="false" />.</param>
        <summary>Legt ein angegebenes <see cref="T:System.Windows.Forms.ControlStyles" />-Flag auf <see langword="true" /> oder <see langword="false" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerelement-Stil Bitflags dienen zum Kategorisieren unterstützten Verhalten. Ein Steuerelement kann ein Format aktivieren, durch Aufrufen der <xref:System.Windows.Forms.Control.SetStyle%2A> -Methode und übergeben die entsprechende <xref:System.Windows.Forms.ControlStyles> Bit (oder Bits) und den booleschen Wert auf die Bit(s) festgelegt werden soll. Zum Bestimmen des Werts, der mit einem angegebenen zugewiesen <xref:System.Windows.Forms.ControlStyles> bit, verwenden Sie die <xref:System.Windows.Forms.Control.GetStyle%2A> -Methode und übergeben Sie die <xref:System.Windows.Forms.ControlStyles> Element ausgewertet.  
  
> [!CAUTION]
>  Stilbits für das Steuerelement festlegen, kann im Wesentlichen das Verhalten des Steuerelements ändern. Überprüfen Sie die <xref:System.Windows.Forms.ControlStyles> Enumeration-Dokumentation, um zu verstehen, die Auswirkungen einer Änderung der Formatvorlage Steuerungsbits vor dem Aufruf der <xref:System.Windows.Forms.Control.SetStyle%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermöglicht Doppelpufferung auf eine <xref:System.Windows.Forms.Form> und die Stile entsprechend aktualisiert.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTopLevel">
      <MemberSignature Language="C#" Value="protected void SetTopLevel (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTopLevel(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          <see langword="true" />, um das Steuerelement als Steuerelement der obersten Ebene festzulegen, andernfalls <see langword="false" />.</param>
        <summary>Legt das Steuerelement als Steuerelement der obersten Ebene fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen der <xref:System.Windows.Forms.Control.SetTopLevel%2A> Methode von einer <xref:System.Windows.Forms.Form> und übergeben den Wert der `false`, Form ist nicht sichtbar, bis Sie aufrufen <xref:System.Windows.Forms.Control.SetTopLevel%2A> übergibt erneut, sich der Wert `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <paramref name="value" /> Parametersatz auf <see langword="true" /> und das Steuerelement wird ein ActiveX-Steuerelement.</exception>
        <exception cref="T:System.Exception">Die <see cref="M:System.Windows.Forms.Control.GetTopLevel" /> zurückgegebene Wert ist nicht gleich der <paramref name="value" /> Parameter und die <see cref="P:System.Windows.Forms.Control.Parent" /> Eigenschaft ist nicht <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">um das Steuerelement als Steuerelement der obersten Ebene festzulegen, wird jedoch von beliebigen Typs außer <see cref="T:System.Windows.Forms.Form" />. Durch diese Berechtigung wird nur gefordert, wenn die <paramref name="value" /> Parameter ist <see langword="true" /> und das Steuerelement ist kein ActiveX-Steuerelement. Zugeordnete Enumeration: <see langword="AllWindows" /> Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected virtual void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          <see langword="true" />, um das Steuerelement sichtbar zu machen, andernfalls <see langword="false" />.</param>
        <summary>Legt das Steuerelement auf den angegebenen sichtbaren Zustand fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie würden diese Methode, um die Sichtbarkeitsverhalten des Steuerelements ändern, in der Regel überschreiben.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" /> Methode, um die Sichtbarkeit des Steuerelements ändern zu erzwingen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Show" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zeigt dem Benutzer das Steuerelement an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anzeigen des Steuerelements entspricht dem Festlegen der <xref:System.Windows.Forms.Control.Visible%2A> Eigenschaft `true`. Nach der <xref:System.Windows.Forms.Control.Show%2A> -Methode aufgerufen wird, die <xref:System.Windows.Forms.Control.Visible%2A> Eigenschaft gibt einen Wert von `true` bis die <xref:System.Windows.Forms.Control.Hide%2A> Methode wird aufgerufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Info (Dialogfeld), und zeichnet vorübergehend ein blaues Quadrat auf seiner Oberfläche. Für dieses Beispiel benötigen Sie eine Klasse definiert haben, die abgeleitet <xref:System.Windows.Forms.Form> mit dem Namen `AboutDialog`.  
  
 [!code-cpp[Windows.Forms.Control Members2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#1)]
 [!code-vb[Windows.Forms.Control Members2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowFocusCues">
      <MemberSignature Language="C#" Value="protected virtual bool ShowFocusCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowFocusCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowFocusCues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement Fokusrechtecke anzeigen soll.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement Fokusrechtecke anzeigen soll, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu diesem Feature finden Sie unter der[Themen WM_CHANGEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx),[WM_QUERYUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx), und die [WM_UPDATEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx)Themen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.ShowFocusCues" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.ShowFocusCues" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ShowKeyboardCues">
      <MemberSignature Language="C#" Value="protected virtual bool ShowKeyboardCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowKeyboardCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob sich die Benutzeroberfläche in einem entsprechenden Zustand befindet, um Zugriffstasten anzuzeigen bzw. auszublenden.</summary>
        <value>
          <see langword="true" />, wenn die Zugriffstasten sichtbar sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Steuerelementen in Windows Forms-Designer erstellt wurden sind die Zugriffstasten standardmäßig sichtbar.  
  
 Weitere Informationen zu diesem Feature finden Sie unter der[Themen WM_CHANGEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx),[WM_QUERYUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx), und die [WM_UPDATEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx)Themen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Site des Steuerelements ab oder legt diese fest.</summary>
        <value>Die <see cref="T:System.ComponentModel.ISite" />, die <see cref="T:System.Windows.Forms.Control" /> zugeordnet ist, sofern vorhanden.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe und Breite des Steuerelements ab oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Drawing.Size" />, die die Höhe und Breite des Steuerelements in Pixel darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da die <xref:System.Drawing.Size> Klasse ist ein Werttyp (`Structure` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)], `struct` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)]), es wird zurückgegeben, mit dem Wert, d. h., den Zugriff auf die Eigenschaft gibt eine Kopie der Größe des Steuerelements zurück. Anpassen der <xref:System.Drawing.Size.Width%2A> oder <xref:System.Drawing.Size.Height%2A> Eigenschaften der <xref:System.Drawing.Size> zurückgegeben, die von dieser Eigenschaft wirkt sich nicht die <xref:System.Windows.Forms.Control.Width%2A> oder <xref:System.Windows.Forms.Control.Height%2A> des Steuerelements. Anpassen der <xref:System.Windows.Forms.Control.Width%2A> oder <xref:System.Windows.Forms.Control.Height%2A> des Steuerelements müssen Sie festlegen, welches Steuerelement <xref:System.Windows.Forms.Control.Width%2A> oder <xref:System.Windows.Forms.Control.Height%2A> Eigenschaft oder eine Gruppe die <xref:System.Windows.Forms.Control.Size%2A> Eigenschaft mit einem neuen <xref:System.Drawing.Size>.  
  
> [!NOTE]
>  Um eine bessere Leistung zu gewährleisten, stellen Sie keine der <xref:System.Drawing.Size> eines Steuerelements in seinem Konstruktor. Die bevorzugte Methode ist, überschreiben die <xref:System.Windows.Forms.Control.DefaultSize%2A> Eigenschaft.  
  
> [!NOTE]
>  In Windows Server 2003-Systemen, die Größe des eine <xref:System.Windows.Forms.Form> wird durch die maximale Pixelbreite und Höhe des Monitors eingeschränkt.  
  
   
  
## Examples  
 Das folgende Codebeispiel fügt ein <xref:System.Windows.Forms.Button> zu einem Formular und legt einige gemeinsamen Eigenschaften. Im Beispiel verankert die Schaltfläche, um der unteren rechten Ecke des Formulars, daher die relative Position behält der Größe des Formulars. Als Nächstes wird die <xref:System.Windows.Forms.Control.BackgroundImage%2A> und ändert die Größe der Schaltfläche, um die gleiche Größe wie die <xref:System.Drawing.Image>. Klicken Sie dann im Beispiel wird die <xref:System.Windows.Forms.Control.TabStop%2A> auf `true` und legt die <xref:System.Windows.Forms.Control.TabIndex%2A> Eigenschaft. Schließlich Fügt einen Ereignishandler behandeln die <xref:System.Windows.Forms.Control.Click> -Ereignis der Schaltfläche. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.ImageList> mit dem Namen `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SizeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.Size" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ist es besser, verwenden Sie die <xref:System.Windows.Forms.Control.Layout> Ereignis, um benutzerdefinierte Layouts zu behandeln. Die <xref:System.Windows.Forms.Control.Layout> Ereignis wird ausgelöst, als Antwort auf <xref:System.Windows.Forms.Control.Resize> Ereignisse, sondern auch bei anderen Bedingungen, wenn das Layout angewendet werden muss.  
  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Size%2A> -Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Windows.Forms.Control.SizeChanged> Ereignis. Eine Instanz von einem <xref:System.Windows.Forms.Button> Steuerelement wurde bereitgestellt, die horizontal und vertikal skaliert werden kann. Ein <xref:System.Windows.Forms.NumericUpDown> Instanz stellt den Skalierungswert für die horizontale und vertikale. Die <xref:System.Windows.Forms.Button> Instanz mit dem Namen **OK** wird verwendet, um die skalawerte für Festlegen der <xref:System.Windows.Forms.Button> Instanz des Steuerelements. Sobald die Größe des Steuerelements ändert, das zugeordnete Ereignishandler die <xref:System.Windows.Forms.Control.SizeChanged> -Ereignisses des Steuerelements aufgerufen wird. Dieser Ereignishandler zeigt eine Meldung an, das angibt, dass die Größe des Steuerelements geändert wurde.  
  
 [!code-cpp[Control_Scale1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Scale1/CPP/control_scale1.cpp#2)]
 [!code-csharp[Control_Scale1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Scale1/CS/control_scale1.cs#2)]
 [!code-vb[Control_Scale1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Scale1/VB/control_scale1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeFromClientSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size SizeFromClientSize (System.Drawing.Size clientSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Size SizeFromClientSize(valuetype System.Drawing.Size clientSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SizeFromClientSize(System.Drawing.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="clientSize">Ein <see cref="T:System.Drawing.Size" />-Wert, der die Höhe und Breite des Clientbereichs des Steuerelements darstellt.</param>
        <summary>Bestimmt die Größe des gesamten Steuerelements anhand der Höhe und Breite seines Clientbereichs.</summary>
        <returns>Ein <see cref="T:System.Drawing.Size" />-Wert, der die Höhe und die Breite des gesamten Steuerelements darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StyleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StyleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.StyleChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich das Format des Steuerelements ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.StyleChanged> Ereignis tritt auf, wenn <xref:System.Windows.Forms.ControlStyles> Flags hinzugefügt oder geändert wurden.  
  
 Dieses Ereignis wird ausgelöst, wenn das Format des Steuerelements durch eine programmgesteuerte Änderung oder die Interaktion des Benutzers geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.StyleChanged> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.StyleChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#68](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#68)]
 [!code-vb[System.Windows.Forms.EventExamples#68](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#68)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuspendLayout">
      <MemberSignature Language="C#" Value="public void SuspendLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SuspendLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterbricht vorübergehend die Layoutlogik für das Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Layoutlogik des Steuerelements wird angehalten, bis die <xref:System.Windows.Forms.Control.ResumeLayout%2A> -Methode aufgerufen wird.  
  
 Die <xref:System.Windows.Forms.Control.SuspendLayout%2A> und <xref:System.Windows.Forms.Control.ResumeLayout%2A> Methoden werden zusammen verwendet, um mehrere unterdrücken <xref:System.Windows.Forms.Control.Layout> Ereignisse während mehrere Attribute des Steuerelements angepasst. Beispielsweise würden Sie in der Regel rufen die <xref:System.Windows.Forms.Control.SuspendLayout%2A> -Methode, legen Sie dann die <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, oder <xref:System.Windows.Forms.Control.Dock%2A> Eigenschaften des Steuerelements, und rufen Sie dann die <xref:System.Windows.Forms.Control.ResumeLayout%2A> Methode, um die Änderungen wirksam werden zu aktivieren.  
  
 Es muss keine ausstehende Aufrufe <xref:System.Windows.Forms.Control.SuspendLayout%2A> für <xref:System.Windows.Forms.Control.ResumeLayout%2A> erfolgreich aufgerufen werden.  
  
> [!NOTE]
>  Wenn mehrere Steuerelemente einem übergeordneten Steuerelement hinzufügen, wird empfohlen, Sie rufen die <xref:System.Windows.Forms.Control.SuspendLayout%2A> -Methode vor dem Initialisieren der Steuerelemente hinzugefügt werden. Rufen Sie nach dem Hinzufügen der Steuerelemente an das übergeordnete Steuerelement an, die <xref:System.Windows.Forms.Control.ResumeLayout%2A> Methode. Dies erhöht die Leistung von Anwendungen mit viele Steuerelemente.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Formular zwei Schaltflächen hinzugefügt. Die Beispiel-Transaktionen das Hinzufügen der Schaltflächen mit der <xref:System.Windows.Forms.Control.SuspendLayout%2A> und <xref:System.Windows.Forms.Control.ResumeLayout%2A> Methoden.  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragDrop">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragDrop (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragDrop(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Ein <see cref="T:System.Windows.Forms.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragDrop" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragEnter">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragEnter (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragEnter(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Ein <see cref="T:System.Windows.Forms.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragEnter" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragLeave">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragLeave(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragLeave" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragOver">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragOver (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragOver(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Ein <see cref="T:System.Windows.Forms.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragOver" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemColorsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SystemColorsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SystemColorsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SystemColorsChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich die Systemfarben ändern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Drawing.SystemColors> durch eine programmgesteuerte Änderung oder die Interaktion des Benutzers geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.SystemColorsChanged> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.SystemColorsChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#69](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#69)]
 [!code-vb[System.Windows.Forms.EventExamples#69](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#69)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Aktivierreihenfolge des Steuerelements in dessen Container ab oder legt diese fest.</summary>
        <value>Der Indexwert des Steuerelements in einer Gruppe von Steuerelementen in dessen Container. Die Steuerelemente im Container werden in die Aktivierreihenfolge aufgenommen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Registerkartenindex kann eine beliebige gültige ganze Zahl größer als oder gleich 0 (null), niedrigeren Zahlen werden weiter oben in der Aktivierreihenfolge bestehen. Wenn mehr als ein Steuerelement auf dem gleichen übergeordneten Steuerelement den gleiche Registerkartenindex aufweist, bestimmt die Z-Reihenfolge der Steuerelemente die Reihenfolge der Steuerelemente zu durchlaufen.  
  
 Für ein Steuerelement in der Aktivierreihenfolge aufgenommen werden seine <xref:System.Windows.Forms.Control.TabStop%2A> Eigenschaft muss festgelegt werden, um `true`.  
  
   
  
## Examples  
 Das folgende Codebeispiel fügt ein <xref:System.Windows.Forms.Button> zu einem Formular und legt einige gemeinsamen Eigenschaften. Im Beispiel verankert die Schaltfläche, um der unteren rechten Ecke des Formulars, daher die relative Position behält der Größe des Formulars. Als Nächstes wird die <xref:System.Windows.Forms.Control.BackgroundImage%2A> und ändert die Größe der Schaltfläche, um die gleiche Größe wie die <xref:System.Drawing.Image>. Klicken Sie dann im Beispiel wird die <xref:System.Windows.Forms.Control.TabStop%2A> auf `true` und legt die <xref:System.Windows.Forms.Control.TabIndex%2A> Eigenschaft. Schließlich Fügt einen Ereignishandler behandeln die <xref:System.Windows.Forms.Control.Click> -Ereignis der Schaltfläche. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.ImageList> mit dem Namen `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabIndexChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.TabIndex" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.TabIndex%2A> -Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.TabIndexChanged> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.TabIndexChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#25)]
 [!code-vb[System.Windows.Forms.EventExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#25)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Benutzer den Fokus mit der TAB-TASTE auf dieses Steuerelement setzen können, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn der Fokus mit der TAB-TASTE auf dieses Steuerelement gesetzt werden kann, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.  
  
 <block subset="none" type="note"><para>  
 Diese Eigenschaft gibt immer <see langword="true" /> für eine Instanz der <see cref="T:System.Windows.Forms.Form" />-Klasse zurück.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Benutzer die TAB-Taste drückt, wird der Eingabefokus auf das nächste Steuerelement in der Aktivierreihenfolge festgelegt. Steuert die <xref:System.Windows.Forms.Control.TabStop%2A> Eigenschaftswert `false` sind nicht in die Auflistung der Steuerelemente in der Aktivierreihenfolge enthalten. Die Reihenfolge der Registerkarten kann bearbeitet werden, indem Sie des Steuerelements festlegen <xref:System.Windows.Forms.Control.TabIndex%2A> Eigenschaftswert.  
  
   
  
## Examples  
 Das folgende Codebeispiel fügt ein <xref:System.Windows.Forms.Button> zu einem Formular und legt einige gemeinsamen Eigenschaften. Im Beispiel verankert die Schaltfläche, um der unteren rechten Ecke des Formulars, daher die relative Position behält der Größe des Formulars. Als Nächstes wird die <xref:System.Windows.Forms.Control.BackgroundImage%2A> und ändert die Größe der Schaltfläche, um die gleiche Größe wie die <xref:System.Drawing.Image>. Klicken Sie dann im Beispiel wird die <xref:System.Windows.Forms.Control.TabStop%2A> auf `true` und legt die <xref:System.Windows.Forms.Control.TabIndex%2A> Eigenschaft. Schließlich Fügt einen Ereignishandler behandeln die <xref:System.Windows.Forms.Control.Click> -Ereignis der Schaltfläche. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.ImageList> mit dem Namen `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabStopChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.TabStop" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.TabStop%2A> -Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieses Elements. Im Beispiel meldet ein Ereignishandler für das Vorkommen der <xref:System.Windows.Forms.Control.TabStopChanged> Ereignis. Dieser Bericht hilft Ihnen, um zu erfahren, wann das Ereignis tritt auf, und unterstützen Sie beim Debuggen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, sollten Sie ersetzen <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, das eine Instanz eines Typs, die enthält von erben <xref:System.Windows.Forms.Control>, z. B. eine <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Geben Sie den Namen der Instanz `Control1` und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Control.TabStopChanged> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#26)]
 [!code-vb[System.Windows.Forms.EventExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das Daten über das Steuerelement enthält, oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Object" />, das Daten über das Steuerelement enthält. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Typ abgeleitet wurde. die <xref:System.Object> Klasse kann diese Eigenschaft zugewiesen werden. Wenn die <xref:System.Windows.Forms.Control.Tag%2A> Eigenschaft mit dem Windows Forms-Designer festgelegt wird, kann nur Text zugewiesen werden.  
  
 Eine übliche Verwendung für die <xref:System.Windows.Forms.Control.Tag%2A> Eigenschaft besteht darin, Daten zu speichern, die eng mit dem Steuerelement zugeordnet ist. Z. B. Wenn Sie ein Steuerelement, das Informationen zu einem Kunden anzeigt, Sie können Speichern einer <xref:System.Data.DataSet> , enthält die kundenbestellungsverlauf in diesem Steuerelement <xref:System.Windows.Forms.Control.Tag%2A> Eigenschaft, sodass die Daten schnell zugegriffen werden kann.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt ein Formular an und speichert eine `Customer` in seiner <xref:System.Windows.Forms.Control.Tag%2A> Eigenschaft. Für dieses Beispiel benötigen Sie eine Klasse definiert haben, die abgeleitet <xref:System.Windows.Forms.Form> mit dem Namen `CustomerForm` und, die Sie definiert haben eine `Customer`.  
  
 [!code-cpp[Windows.Forms.Control Members2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#3)]
 [!code-vb[Windows.Forms.Control Members2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public virtual string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-517)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den diesem Steuerelement zugeordneten Text ab oder legt diesen fest.</summary>
        <value>Der diesem Steuerelement zugeordnete Text.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaft des Steuerelements wird von jeder abgeleiteten Klasse unterschiedlich verwendet. Z. B. die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaft von einem <xref:System.Windows.Forms.Form> in der Titelleiste am oberen Rand des Formulars angezeigt wird, ist ziemlich klein in Anzahl der Zeichen, und in der Regel zeigt den Namen der Anwendung oder Dokument. Allerdings die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaft eine <xref:System.Windows.Forms.RichTextBox> können groß sein und zahlreiche verwendete, um den Text zu formatieren, nicht sichtbare Zeichen enthalten. Z. B. den in angezeigten Text eine <xref:System.Windows.Forms.RichTextBox> formatiert werden kann, durch Anpassen der <xref:System.Drawing.Font> Eigenschaften, oder durch das Hinzufügen von Leerzeichen oder Tabulatorzeichen zum Ausrichten von Text.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Windows.Forms.GroupBox> und legt einige gemeinsamen Eigenschaften. Das Beispiel erstellt eine <xref:System.Windows.Forms.TextBox> und legt seine <xref:System.Windows.Forms.Control.Location%2A> innerhalb der Gruppenfeld. Als Nächstes wird die <xref:System.Windows.Forms.Control.Text%2A> Eigenschaft der Gruppenfeld und wird das Gruppenfeld am oberen Rand des Formulars angedockt. Abschließend wird das Gruppenfeld deaktiviert, indem die <xref:System.Windows.Forms.Control.Enabled%2A> Eigenschaft `false`, die bewirkt, dass alle Steuerelemente, die deaktiviert werden in der Gruppe enthaltenen.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben der <see cref="P:System.Windows.Forms.Control.Text" /> verwenden Sie Eigenschaft in einer abgeleiteten Klasse der Basisklasse <see cref="P:System.Windows.Forms.Control.Text" /> Eigenschaft, um die grundlegende Implementierung zu erweitern. Andernfalls müssen Sie alle Implementierung bereitstellen. Sie müssen nicht beide außer Kraft setzen der <see langword="get" /> und <see langword="set" /> Accessoren der der <see cref="P:System.Windows.Forms.Control.Text" /> Eigenschaft; Sie können nur eine bei Bedarf überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TextChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.Text" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Text%2A> -Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Beispiel ändert der folgende code die <xref:System.Windows.Forms.Control.ForeColor%2A> von einem <xref:System.Windows.Forms.TextBox> Währungsdaten. Im Beispiel konvertiert den Text in eine Dezimalzahl und ändert die <xref:System.Windows.Forms.Control.ForeColor%2A> auf <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , wenn die Zahl negativ ist, und um <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , wenn die Zahl positiv ist. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> , enthält eine <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public int Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Abstand zwischen dem oberen Rand des Steuerelements und dem oberen Rand des Clientbereichs des zugehörigen Containers in Pixel ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Int32" />-Wert, der den Abstand zwischen dem unteren Rand des Steuerelements und dem oberen Rand des Clientbereichs des zugehörigen Containers in Pixel darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Top%2A> Eigenschaftswert entspricht der <xref:System.Drawing.Point.Y%2A?displayProperty=nameWithType> Eigenschaft von der <xref:System.Windows.Forms.Control.Location%2A> Eigenschaftswert des Steuerelements.  
  
 Änderungen an der <xref:System.Windows.Forms.Control.Height%2A> und <xref:System.Windows.Forms.Control.Top%2A> Eigenschaft Werte bewirken, dass die <xref:System.Windows.Forms.Control.Bottom%2A> Eigenschaftswert des Steuerelements ändern.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt drei <xref:System.Windows.Forms.Button> Steuerelemente eines Formulars und legt deren Größe und Position mithilfe der verschiedenen hinsichtlich der Größe und Position-bezogene Eigenschaften. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> , besitzt eine Breite und Höhe von mindestens 300 Pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TopLevelControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control TopLevelControl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control TopLevelControl" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TopLevelControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das übergeordnete Steuerelement ab, dem kein anderes Windows Forms-Steuerelement übergeordnet ist. Dies ist i. d. R. das äußerste <see cref="T:System.Windows.Forms.Form" />, in dem das Steuerelement enthalten ist.</summary>
        <value>Das <see cref="T:System.Windows.Forms.Control" />, das das Steuerelement der obersten Ebene darstellt, das das aktuelle Steuerelement enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Steuerelement der obersten Ebene ist als das übergeordnete Steuerelement definiert, die nicht von einem anderen Windows Forms-Steuerelement übergeordnet ist. Dies ist i. d. R. das äußerste <xref:System.Windows.Forms.Form>, in dem das Steuerelement enthalten ist. Wenn das Steuerelement auf eine untergeordnete MDI-Element enthalten ist z. B. <xref:System.Windows.Forms.Form>, wird das Steuerelement der obersten Ebene der übergeordneten (MDI, Multiple Document Interface) <xref:System.Windows.Forms.Form>. Wenn das Steuerelement nicht auf ein übergeordnetes Element ist ein <xref:System.Windows.Forms.Form>, gibt diese Eigenschaft zurück `null`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, um diesen Eigenschaftswert abzurufen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public void Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Update() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Update" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass das Steuerelement die für ungültig erklärten Bereiche im Clientbereich neu zeichnet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Führt alle ausstehenden Anforderungen für die Zeichnung.  
  
 Es gibt zwei Möglichkeiten, ein Formular und seinen Inhalt zu aktualisieren:  
  
-   Sie können eine der Überladungen der der <xref:System.Windows.Forms.Control.Invalidate%2A> Methode mit der <xref:System.Windows.Forms.Control.Update%2A> Methode.  
  
-   Sie erreichen die <xref:System.Windows.Forms.Control.Refresh%2A> -Methode, die das Steuerelement zum Neuzeichnen von sich selbst und alle untergeordneten erzwingt. Dies entspricht dem Festlegen der <xref:System.Windows.Forms.Control.Invalidate%2A> aufzurufende Methode `true` und zusammen mit <xref:System.Windows.Forms.Control.Update%2A>.  
  
 Die <xref:System.Windows.Forms.Control.Invalidate%2A> Methode steuert, welche gezeichnet oder neu gezeichnet wird. Die <xref:System.Windows.Forms.Control.Update%2A> -Methode steuert, wann gezeichnet oder neu gezeichnet wird. Bei Verwendung der <xref:System.Windows.Forms.Control.Invalidate%2A> und <xref:System.Windows.Forms.Control.Update%2A> zusammen statt Aufrufen von Methoden <xref:System.Windows.Forms.Control.Refresh%2A>, was neu gezeichnet wird, hängt davon ab, welche Überladung von <xref:System.Windows.Forms.Control.Invalidate%2A> Sie verwenden. Die <xref:System.Windows.Forms.Control.Update%2A> Methode erzwingt einfach das Steuerelement sofort gezeichnet werden, aber die <xref:System.Windows.Forms.Control.Invalidate%2A> Methode steuert, welche gezeichnet wird, beim Aufrufen der <xref:System.Windows.Forms.Control.Update%2A> Methode.  
  
 Weitere Informationen finden Sie unter der[WM_PAINT](http://msdn.microsoft.com/library/dd145213\(v=vs.85\).aspx)Thema.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void UpdateBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktualisiert die Begrenzungen des Steuerelements mit der aktuellen Größe und Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die neue <xref:System.Windows.Forms.Control.Size%2A> des Steuerelements unterscheidet sich von der vorherigen <xref:System.Drawing.Size>die <xref:System.Windows.Forms.Control.SizeChanged> Ereignis wird ausgelöst. Ebenso, wenn die <xref:System.Windows.Forms.Control.Location%2A> des Steuerelements ändert die <xref:System.Windows.Forms.Control.LocationChanged> Ereignis wird ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die <see cref="P:System.Drawing.Point.X" />-Koordinate des Steuerelements.</param>
        <param name="y">Die <see cref="P:System.Drawing.Point.Y" />-Koordinate des Steuerelements.</param>
        <param name="width">Der <see cref="P:System.Drawing.Size.Width" /> des Steuerelements.</param>
        <param name="height">Der <see cref="P:System.Drawing.Size.Height" /> des Steuerelements.</param>
        <summary>Aktualisiert die Begrenzungen des Steuerelements mit der angegebenen Größe und Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die neue <xref:System.Windows.Forms.Control.Size%2A> des Steuerelements, falls abweichend vom vorherigen <xref:System.Drawing.Size>die <xref:System.Windows.Forms.Control.SizeChanged> Ereignis wird ausgelöst. Ebenso ist die <xref:System.Windows.Forms.Control.Location%2A> des Steuerelements ändert die <xref:System.Windows.Forms.Control.LocationChanged> Ereignis wird ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height, int32 clientWidth, int32 clientHeight) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="clientWidth" Type="System.Int32" />
        <Parameter Name="clientHeight" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die <see cref="P:System.Drawing.Point.X" />-Koordinate des Steuerelements.</param>
        <param name="y">Die <see cref="P:System.Drawing.Point.Y" />-Koordinate des Steuerelements.</param>
        <param name="width">Der <see cref="P:System.Drawing.Size.Width" /> des Steuerelements.</param>
        <param name="height">Der <see cref="P:System.Drawing.Size.Height" /> des Steuerelements.</param>
        <param name="clientWidth">Die Client-<see cref="P:System.Drawing.Size.Width" /> des Steuerelements.</param>
        <param name="clientHeight">Die Client-<see cref="P:System.Drawing.Size.Height" /> des Steuerelements.</param>
        <summary>Aktualisiert die Begrenzungen des Steuerelements mit der angegebenen Größe, Position und Größe des Clients.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die neue <xref:System.Windows.Forms.Control.Size%2A> des Steuerelements unterscheidet sich von der vorherigen <xref:System.Drawing.Size>die <xref:System.Windows.Forms.Control.SizeChanged> Ereignis wird ausgelöst. Ebenso, wenn die <xref:System.Windows.Forms.Control.Location%2A> des Steuerelements ändert die <xref:System.Windows.Forms.Control.LocationChanged> Ereignis wird ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateStyles">
      <MemberSignature Language="C#" Value="protected void UpdateStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateStyles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt ein erneutes Anwenden der zugewiesenen Formate auf das Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft die <xref:System.Windows.Forms.Control.CreateParams%2A> Methode zum Abrufen der Stile angewendet. Die Stile zugewiesen der <xref:System.Windows.Forms.CreateParams.Style%2A> und <xref:System.Windows.Forms.CreateParams.ExStyle%2A> Eigenschaften der <xref:System.Windows.Forms.CreateParams> dem Steuerelement zugewiesene <xref:System.Windows.Forms.Control.CreateParams%2A> Eigenschaft werden erneut angewendet. Das Steuerelement wird entsprechend Stil bei Bedarf aktualisiert.  
  
 Die <xref:System.Windows.Forms.Control.UpdateStyles%2A> Methode hat keine Auswirkung, wenn die <xref:System.Windows.Forms.Control.IsHandleCreated%2A> Eigenschaftswert ist `false`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermöglicht Doppelpufferung auf eine <xref:System.Windows.Forms.Form> und die Stile entsprechend aktualisiert.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateZOrder">
      <MemberSignature Language="C#" Value="protected void UpdateZOrder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateZOrder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateZOrder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktualisiert das Steuerelement in der z-Reihenfolge des übergeordneten Elements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.UpdateZOrder%2A> Methode aktualisiert die Position des Steuerelements in der Z-Reihenfolge des übergeordneten Steuerelements. Z. B., wenn dieses Steuerelement ist ein neu erstelltes zu steuern, wurde hinzugefügt ein <xref:System.Windows.Forms.Control.ControlCollection>, die Z-Reihenfolge wird aktualisiert, mit dem neuen Steuerelement hinzugefügt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Wartecursor für das aktuelle Steuerelement und alle untergeordneten Steuerelemente verwendet werden soll.</summary>
        <value>
          <see langword="true" />, wenn der Wartecursor für das aktuelle Steuerelement und alle untergeordneten Steuerelemente verwendet werden soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie einen Wartecursor, wenn Sie einen Vorgang ausführen, der eine spürbar Zeit akzeptiert. Beachten Sie jedoch, dass Vorgänge, die im UI-Thread blockieren Acursor Änderung auch blockiert werden. Diese Eigenschaft sollte daher nur verwendet werden, wenn zeitaufwändige Operationen in einem anderen Thread ausgeführt. Zum Ändern des Cursors global und sofort seethe <xref:System.Windows.Forms.Cursor.Current%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validated">
      <MemberSignature Language="C#" Value="public event EventHandler Validated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Validated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Steuerelement die Überprüfung abgeschlossen hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Fokus ändern, indem Sie mithilfe der Tastatur (Registerkarte, UMSCHALT + TAB usw.), durch Aufrufen der <xref:System.Windows.Forms.Control.Select%2A> oder <xref:System.Windows.Forms.Control.SelectNextControl%2A> Methoden, oder durch Festlegen der <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> Eigenschaft auf das aktuelle Formular den Fokusereignisse auftreten, in der folgenden Reihenfolge:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Wenn Sie den Fokus ändern, mit der Maus oder durch Aufrufen der <xref:System.Windows.Forms.Control.Focus%2A> -Methode, den Fokusereignisse auftreten, in der folgenden Reihenfolge:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A> -Eigenschaftensatz auf `false`, <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> Ereignisse werden unterdrückt.  
  
 Wenn der <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.ComponentModel.CancelEventArgs> auf festgelegt ist `true` in der <xref:System.Windows.Forms.Control.Validating> Ereignisdelegaten, der alle Ereignisse, die in der Regel nach dem auftreten würden die <xref:System.Windows.Forms.Control.Validating> Ereignis werden unterdrückt.  
  
> [!CAUTION]
>  Versuchen Sie nicht, legen Sie den Fokus innerhalb der <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, oder <xref:System.Windows.Forms.Control.Validated> -Ereignishandler. Auf diese Weise kann dazu führen, dass die Anwendung oder das Betriebssystem nicht mehr reagiert. Weitere Informationen finden Sie unter der[WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx)Thema und im Abschnitt "Message Deadlocks", der die [zu Nachrichten und Warteschlangen](http://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx) Thema.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die abgeleitete Klasse <xref:System.Windows.Forms.TextBox> und überprüft eine e-Mail-Adresse, die der Benutzer eingibt. Wenn die e-Mail-Adresse nicht in das Standardformat ist (mit "@" and "."), die Überprüfung fehlschlägt, eine <xref:System.Windows.Forms.ErrorProvider> -Symbol wird angezeigt, und das Ereignis abgebrochen wird. Dieses Beispiel erfordert, dass eine <xref:System.Windows.Forms.TextBox> und <xref:System.Windows.Forms.ErrorProvider> Steuerelement in einem Formular erstellt wurden.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validating">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Validating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Validating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validating" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Steuerelement eine Validierung ausführt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Fokus ändern, indem Sie mithilfe der Tastatur (Registerkarte, UMSCHALT + TAB usw.), durch Aufrufen der <xref:System.Windows.Forms.Control.Select%2A> oder <xref:System.Windows.Forms.Control.SelectNextControl%2A> Methoden, oder durch Festlegen der <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> Eigenschaft auf das aktuelle Formular den Fokusereignisse auftreten, in der folgenden Reihenfolge:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Wenn Sie den Fokus ändern, mit der Maus oder durch Aufrufen der <xref:System.Windows.Forms.Control.Focus%2A> -Methode, den Fokusereignisse auftreten, in der folgenden Reihenfolge:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A> -Eigenschaftensatz auf `false`, <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> Ereignisse werden unterdrückt.  
  
 Wenn der <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.ComponentModel.CancelEventArgs> auf festgelegt ist `true` in der <xref:System.Windows.Forms.Control.Validating> Ereignisdelegaten, der alle Ereignisse, die in der Regel nach dem auftreten würden die <xref:System.Windows.Forms.Control.Validating> Ereignis werden unterdrückt.  
  
> [!CAUTION]
>  Versuchen Sie nicht, legen Sie den Fokus innerhalb der <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating>, oder <xref:System.Windows.Forms.Control.Validated> -Ereignishandler. Auf diese Weise kann dazu führen, dass die Anwendung oder das Betriebssystem nicht mehr reagiert. Weitere Informationen finden Sie unter der `WM_KILLFOCUS` Thema im Abschnitt "Keyboard Input Reference" und im Abschnitt "Message Deadlocks" des Themas in der MSDN Library unter http://msdn.microsoft.com/library "Informationen zu Nachrichten und Warteschlangen".  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die abgeleitete Klasse <xref:System.Windows.Forms.TextBox> und überprüft eine e-Mail-Adresse, die der Benutzer eingibt. Wenn die e-Mail-Adresse nicht in das Standardformat ist (mit "@" and "."), die Überprüfung fehlschlägt, eine <xref:System.Windows.Forms.ErrorProvider> -Symbol wird angezeigt, und das Ereignis abgebrochen wird. Dieses Beispiel erfordert, dass eine <xref:System.Windows.Forms.TextBox> und <xref:System.Windows.Forms.ErrorProvider> Steuerelement in einem Formular erstellt wurden.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob das Steuerelement und alle untergeordneten Steuerelemente angezeigt werden, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn das Steuerelement und alle untergeordneten Steuerelemente angezeigt werden, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass selbst bei `Visible` festgelegt ist, um `true`, das Steuerelement möglicherweise nicht für den Benutzer sichtbar sein, wenn es hinter dem andere Steuerelemente verdeckt wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet die abgeleiteten Klassen <xref:System.Windows.Forms.VScrollBar> und <xref:System.Windows.Forms.HScrollBar> und legt sie fest ihre <xref:System.Windows.Forms.Control.Visible%2A> Eigenschaftswerte, basierend auf der Größe des ein <xref:System.Drawing.Image> angezeigt wird, eine <xref:System.Windows.Forms.PictureBox> Steuerelement. In diesem Beispiel erfordert, dass eine <xref:System.Windows.Forms.PictureBox> erstellt wurde, die in einem Formular und die <xref:System.Windows.Forms.HScrollBar> und <xref:System.Windows.Forms.VScrollBar> Steuerelemente auf erstellt wurden die <xref:System.Windows.Forms.PictureBox>. Dieser Code sollte aufgerufen werden, wenn das Bild geladen wird in das Bildfeld und durch die <xref:System.Windows.Forms.Control.Resize> -Ereignis des Formulars.  
  
 [!code-cpp[Classic Control.Visible Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.Visible Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.Visible Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.Visible Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Visible Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.Visible Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisibleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler VisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.VisibleChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.Visible" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Visible%2A> -Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 Im folgenden Codebeispiel Beispiel löst die <xref:System.Windows.Forms.Control.VisibleChanged> Ereignis bei der <xref:System.Windows.Forms.Control.Visible%2A> Eigenschaftswert, der die <xref:System.Windows.Forms.Label> -Steuerelements geändert hat.  
  
 [!code-cpp[Control_VisibleChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_VisibleChanged/CPP/control_visiblechanged.cpp#1)]
 [!code-csharp[Control_VisibleChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_VisibleChanged/CS/control_visiblechanged.cs#1)]
 [!code-vb[Control_VisibleChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_VisibleChanged/VB/control_visiblechanged.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public int Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Breite des Steuerelements ab bzw. legt diese fest.</summary>
        <value>Die Breite des Steuerelements in Pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Änderungen an der <xref:System.Windows.Forms.Control.Width%2A> und <xref:System.Windows.Forms.Control.Left%2A> Eigenschaft Werte bewirken, dass die <xref:System.Windows.Forms.Control.Right%2A> Eigenschaftswert des Steuerelements ändern.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt drei <xref:System.Windows.Forms.Button> Steuerelemente eines Formulars und legt deren Größe und Position mithilfe der verschiedenen hinsichtlich der Größe und Position-bezogene Eigenschaften. Dieses Beispiel benötigen Sie ein <xref:System.Windows.Forms.Form> , besitzt eine Breite und Höhe von mindestens 300 Pixel.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowTarget">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IWindowTarget WindowTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IWindowTarget WindowTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.WindowTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IWindowTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Diese Eigenschaft ist für diese Klasse nicht relevant.</summary>
        <value>Das NativeWindow, das innerhalb des Steuerelements enthalten ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected virtual void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Die zu verarbeitende Windows-<see cref="T:System.Windows.Forms.Message" />.</param>
        <summary>Verarbeitet Windows-Meldungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Nachrichten gesendet, um die <xref:System.Windows.Forms.Control.WndProc%2A> Methode auf, nachdem die erste gefiltert, über die <xref:System.Windows.Forms.Control.PreProcessMessage%2A> Methode.  
  
 Die <xref:System.Windows.Forms.Control.WndProc%2A>-Methode entspricht genau der `WindowProc`-Funktion von Windows. Weitere Informationen zu Windows-Meldungen verarbeitet, finden Sie unter der [WindowProc-Funktion](http://go.microsoft.com/fwlink/?LinkId=181565).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Überschreiben der <xref:System.Windows.Forms.Control.WndProc%2A> Methode zum Behandeln von Betriebssystem-Nachrichten, die im identifiziert die <xref:System.Windows.Forms.Message> Struktur. Die[WM_ACTIVATEAPP](http://msdn.microsoft.com/en-us/library/windows/desktop/ms632614\(v=vs.85\).aspx)Betriebssystem Nachricht erfolgt in diesem Beispiel bekannt sein, wenn eine andere Anwendung active aufgefüllt wird. Finden Sie unter den folgenden Themen zu den verfügbaren verstehen <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Message.LParam%2A?displayProperty=nameWithType>, und <xref:System.Windows.Forms.Message.WParam%2A?displayProperty=nameWithType> Werte. Die tatsächlichen Konstanten Werte können in der Headerdatei Windows.h gefunden werden.  
  
 [!code-cpp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides">
          <para>Erbende Steuerelemente müssen der Basisklasse <see cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" /> Methode, um alle Nachrichten zu verarbeiten, die sie nicht behandeln.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
