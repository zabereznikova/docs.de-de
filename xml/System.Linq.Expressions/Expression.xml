<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt die Basisklasse bereit, aus der die Klassen abgeleitet werden, die die Knoten in der Ausdrucksbaumstruktur darstellen. Sie enthält auch <see langword="static" />-Factorymethoden (<see langword="Shared" /> in Visual Basic), um die verschiedenen Knotentypen zu erstellen. Dies ist eine <see langword="abstract" /> Klasse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Erstellen eines Block-Ausdrucks. Der Blockausdruck besteht aus zwei <xref:System.Linq.Expressions.MethodCallExpression> Objekte und eine <xref:System.Linq.Expressions.ConstantExpression> Objekt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Instanz von <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="nodeType">Der als Knotentyp festzulegende <see cref="T:System.Linq.Expressions.ExpressionType" />.</param>
        <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" /> dieses <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Linq.Expressions.Expression" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird von Konstruktoren in abgeleiteten Klassen aufgerufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
        <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp. Beispielsweise ruft <see cref="T:System.Linq.Expressions.MethodCallExpression" /> die Methode <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> auf.</summary>
        <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Standardimplementierung für <xref:System.Linq.Expressions.ExpressionType.Extension> Knoten Aufrufe <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>. Überschreiben Sie diese Methode in eine genauere Methode für eine Besucherklasse abgeleiteten von Aufrufen der <xref:System.Linq.Expressions.ExpressionVisitor> Klasse. Sie sollten dennoch unbekannte Besucher unterstützen, durch den Aufruf <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition ohne Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die ausgewählte implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Addition-Operator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten Additionsoperators.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten Additionsoperators entspricht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, der zwei ganze Zahlen addiert.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Addition-Operator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition ohne Überlaufprüfung darstellt. Die implementierende Methode kann angegeben werden.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Addition-Operator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten Additionsoperators.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten Additionsoperators entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> ist <see langword="null" />, und der Additionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, der eine ganzzahlige Variable einen Wert hinzugefügt, und klicken Sie dann die Variable weist das Ergebnis des Vorgangs.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition mit Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Addition-Operator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten Additionsoperators.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten Additionsoperators entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Addition-Operator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition mit Überlaufprüfung darstellt. Die implementierende Methode kann angegeben werden.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die implementierende Methode für den Vorgang wird basierend auf den folgenden Regeln ausgewählt:  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Addition-Operator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten Additionsoperators.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten Additionsoperators entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> ist <see langword="null" />, und der Additionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen <see langword="AND" />-Vorgang darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.And" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, das bitweise überlädt `AND` -Operator, der <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Type ganzzahlige oder boolesche Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten bitweise `AND` Operator.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten bitweise entspricht `AND` Operator.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, der eine logische AND-Operation für zwei boolesche Werte darstellt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der bitweise <see langword="AND" /> Operator ist nicht definiert, für <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen <see langword="AND" />-Vorgang darstellt. Die implementierende Methode kann angegeben werden.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.And" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die implementierende Methode für den Vorgang wird basierend auf den folgenden Regeln ausgewählt:  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, das bitweise überlädt `AND` -Operator, der <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Type ganzzahlige oder boolesche Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten bitweise `AND` Operator.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten bitweise entspricht `AND` Operator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> ist <see langword="null" />, und der bitweise <see langword="AND" />-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bedingten <see langword="AND" />-Vorgang darstellt, bei dem der zweite Operand nur ausgewertet wird, wenn der erste Operand als <see langword="true" /> ausgewertet wird.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, das bitweise überlädt `AND` -Operator, der <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
    > [!NOTE]
    >  Der bedingte `AND` Operator kann nicht überladen werden, in c# oder [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]. Allerdings die bedingte `AND` Operator wird ausgewertet, mit dem bitweisen `AND` Operator. Daher eine benutzerdefinierte Überladung des bitweisen `AND` Operator kann sein, dass die implementierende Methode für diesen Knotentyp.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Type booleschen Typen, die die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt, und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   `left`. Typ und `right`. Sind die gleichen Boolean-Typ.  
  
-   Wenn `left`. Typ und `right`. Typ NULL-Werte zulässt, der Knoten wird nicht transformiert. Der Typ des Knotens ist der Ergebnistyp des vordefinierten bedingten `AND` Operator.  
  
-   Wenn `left`. Typ und `right`. Sind NULL-Werte zulässt, ist der Knoten transformiert. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten bedingten entspricht `AND` Operator.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen eines Ausdrucks führt, die eine logische und -Vorgang für seine beiden Operanden nur, wenn der erste Operand als zu `true`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der bitweise <see langword="AND" /> Operator ist nicht definiert, für <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.  
  
 - oder -   
  
 <paramref name="left" />. Typ und <paramref name="right" />. Typ sind nicht die gleichen Boolean-Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bedingte <see langword="AND" />-Operation darstellt, bei der der zweite Operand nur ausgewertet wird, wenn der erste Operand zu true aufgelöst wird. Die implementierende Methode kann angegeben werden.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die implementierende Methode für den Vorgang wird basierend auf den folgenden Regeln ausgewählt:  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, das bitweise überlädt `AND` -Operator, der <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
    > [!NOTE]
    >  Der bedingte `AND` Operator kann nicht überladen werden, in c# oder [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]. Allerdings die bedingte `AND` Operator wird ausgewertet, mit dem bitweisen `AND` Operator. Daher eine benutzerdefinierte Überladung des bitweisen `AND` Operator kann sein, dass die implementierende Methode für diesen Knotentyp.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Type booleschen Typen, die die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt, und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   `left`. Typ und `right`. Sind die gleichen Boolean-Typ.  
  
-   Wenn `left`. Typ und `right`. Typ NULL-Werte zulässt, der Knoten wird nicht transformiert. Der Typ des Knotens ist der Ergebnistyp des vordefinierten bedingten `AND` Operator.  
  
-   Wenn `left`. Typ und `right`. Sind NULL-Werte zulässt, ist der Knoten transformiert. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten bedingten entspricht `AND` Operator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> ist <see langword="null" />, und der bitweise <see langword="AND" />-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.  
  
 - oder -   
  
 <paramref name="method" />ist <see langword="null" /> und <paramref name="left" />. Typ und <paramref name="right" />. Typ sind nicht die gleichen Boolean-Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise AND-Zuweisungsoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise AND-Zuweisungsoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise AND-Zuweisungsoperation darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">Ein Ausdruck, der das mehrdimensionale Array darstellt.</param>
        <param name="indexes">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> mit Ausdrücken, die zum Indizieren des Arrays verwendet werden.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, um auf ein mehrdimensionales Array zuzugreifen.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Ausdruck, der das Array abgerufen werden kann, mithilfe der <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> -Methode, oder über <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> oder <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie so ändern Sie den Wert eines Elements in einem mehrdimensionalen Array mithilfe der `ArrayAccess` Methode.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">Ein Ausdruck, der das zu indizierende Array darstellt.</param>
        <param name="indexes">Ein Array mit Ausdrücken, die zum Indizieren des Arrays verwendet werden.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, um auf ein Array zuzugreifen.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Ausdruck, der das Array abgerufen werden kann, mithilfe der <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> -Methode, oder über <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> oder <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.  
  
 Für mehrdimensionale Arrays, verwenden die <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit den Wert eines Arrayelements ändern die `ArrayAccess` Methode.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft festgelegt werden soll.</param>
        <param name="indexes">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die das Anwenden eines Arrayindexoperators auf ein Array mit einem Rang größer als eins darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element der `indexes` benötigen <xref:System.Linq.Expressions.Expression.Type%2A> gleich <xref:System.Int32>. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `array` muss einen Arraytyp, dessen Rang der Anzahl der Elemente im entspricht, darstellen `indexes`.  
  
 Wenn der Rang des `array`. Typ 1, diese Methode gibt ein <xref:System.Linq.Expressions.BinaryExpression>. Die <xref:System.Linq.Expressions.BinaryExpression.Left%2A> -Eigenschaftensatz auf `array` und <xref:System.Linq.Expressions.BinaryExpression.Right%2A> Eigenschaft wird festgelegt, um das einzige Element der `indexes`. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft von der <xref:System.Linq.Expressions.BinaryExpression> stellt den Elementtyp des `array`. Geben Sie ein.  
  
 Wenn der Rang des `array`. Typ ist mehr als eine, diese Methode gibt ein <xref:System.Linq.Expressions.MethodCallExpression>. Die <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> Eigenschaft auf festgelegt ist die <xref:System.Reflection.MethodInfo> , die die öffentliche Instanzmethode beschreibt `Get` für den Typ, dargestellt durch die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `array`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> Methode zum Erstellen einer <xref:System.Linq.Expressions.MethodCallExpression> , die Indizierung in ein zweidimensionales Array darstellt.  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> oder <paramref name="indexes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />. Typ ist kein Arraytyp dar.  
  
 - oder -   
  
 Der Rang des <paramref name="array" />. Typ entspricht nicht der Anzahl der Elemente im <paramref name="indexes" />.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft von einem oder mehreren Elementen der <paramref name="indexes" /> stellt keinen dar. die <see cref="T:System.Int32" /> Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="index">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Anwenden eines Arrayindexoperators auf ein Array mit Rang eins darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index`muss einen Index vom Typ darstellen <xref:System.Int32>.  
  
 Die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.BinaryExpression> ist `null`, und die beiden <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> festgelegt `false`. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entspricht dem Elementtyp des `array`. Geben Sie ein. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> oder <paramref name="index" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />. Typ ist kein Arraytyp dar.  
  
 - oder -   
  
 <paramref name="array" />. Typ stellt einen Arraytyp, dessen Rang ungleich 1 ist.  
  
 - oder -   
  
 <paramref name="index" />. Stellt keinen Typ dar. die <see cref="T:System.Int32" /> Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Instanzen - Indizes für den Arrayindizierungsvorgang.</param>
        <param name="indexes">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die das Anwenden eines Arrayindexoperators auf ein mehrdimensionales Array darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element der `indexes` benötigen <xref:System.Linq.Expressions.Expression.Type%2A> gleich <xref:System.Int32>. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `array` muss einen Arraytyp, dessen Rang der Anzahl der Elemente im entspricht, darstellen `indexes`.  
  
 Wenn der Rang des `array`. Typ 1, diese Methode gibt ein <xref:System.Linq.Expressions.BinaryExpression>. Die <xref:System.Linq.Expressions.BinaryExpression.Left%2A> -Eigenschaftensatz auf `array` und <xref:System.Linq.Expressions.BinaryExpression.Right%2A> Eigenschaft wird festgelegt, um das einzige Element der `indexes`. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft von der <xref:System.Linq.Expressions.BinaryExpression> stellt den Elementtyp des `array`. Geben Sie ein.  
  
 Wenn der Rang des `array`. Typ ist mehr als eine, diese Methode gibt ein <xref:System.Linq.Expressions.MethodCallExpression>. Die <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> Eigenschaft auf festgelegt ist die <xref:System.Reflection.MethodInfo> , die die öffentliche Instanzmethode beschreibt `Get` für den Typ, dargestellt durch die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `array`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> Methode zum Erstellen einer <xref:System.Linq.Expressions.MethodCallExpression> , die Indizierung in ein zweidimensionales Array darstellt.  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> oder <paramref name="indexes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />. Typ ist kein Arraytyp dar.  
  
 - oder -   
  
 Der Rang des <paramref name="array" />. Typ entspricht nicht der Anzahl der Elemente im <paramref name="indexes" />.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft von einem oder mehreren Elementen der <paramref name="indexes" /> stellt keinen dar. die <see cref="T:System.Int32" /> Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die einen Ausdruck zum Abrufen der Länge eines eindimensionalen Arrays darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft gleich <paramref name="array" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `array` muss einen Arraytyp darstellen.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> gleich <xref:System.Int32>. Die <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Eigenschaft `null`, und die beiden <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> festgelegt `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />. Typ ist kein Arraytyp dar.</exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Zuweisungsoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Assign` Ausdruck kopiert einen Wert für Werttypen und kopiert einen Verweis für Verweistypen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, der eine Zuweisungsoperation darstellt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member">Ein <see cref="T:System.Reflection.MemberInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft festgelegt werden soll.</param>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberAssignment" />, das die Initialisierung eines Felds oder einer Eigenschaft darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MemberAssignment" />, bei dem <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> gleich <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> ist und die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `expression` muss der Typ von dargestellt zugewiesen werden können die <xref:System.Reflection.FieldInfo.FieldType%2A> oder <xref:System.Reflection.PropertyInfo.PropertyType%2A> Eigenschaft `member`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> oder <paramref name="expression" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" />stellt keine Felds oder einer Eigenschaft dar.  
  
 - oder -   
  
 Die dargestellte Eigenschaft <paramref name="member" /> verfügt nicht über eine <see langword="set" /> Accessor.  
  
 - oder -   
  
 <paramref name="expression" />.Type kann dem Typ des Felds oder der Eigenschaft, die <paramref name="member" /> darstellt, nicht zugewiesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberAssignment" />, das die Initialisierung eines Members durch Verwendung einer Eigenschaftenaccessormethode darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MemberAssignment" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> ist, die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird, und die <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `expression` muss der Typ von dargestellt zugewiesen werden können die <xref:System.Reflection.PropertyInfo.PropertyType%2A> -Eigenschaft der Eigenschaft auf den zugegriffen `propertyAccessor`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> oder <paramref name="expression" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> stellt keine Eigenschaftenzugriffsmethode dar.  
  
 - oder -   
  
 Die-Eigenschaft, auf die <paramref name="propertyAccessor" /> zugreift, verfügt nicht über einen <see langword="set" />-Accessor.  
  
 - oder -   
  
 <paramref name="expression" />.Type kann dem Typ des Felds oder der Eigenschaft, die <paramref name="member" /> darstellt, nicht zugewiesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expressions">Die Ausdrücke im Block.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BlockExpression" />, die die angegebenen Ausdrücke und keine Variablen enthält.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Blockausdruck ausgeführt wird, wird der Wert des letzten Ausdrucks im Block zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions">Die Ausdrücke im Block.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BlockExpression" />, die die angegebenen Ausdrücke und keine Variablen enthält.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Blockausdruck ausgeführt wird, wird der Wert des letzten Ausdrucks im Block zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Erstellen eines Block-Ausdrucks. Der Blockausdruck besteht aus zwei <xref:System.Linq.Expressions.MethodCallExpression> Objekte und eine <xref:System.Linq.Expressions.ConstantExpression> Objekt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">Die Variablen im Block.</param>
        <param name="expressions">Die Ausdrücke im Block.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Variablen und Ausdrücke enthält.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Blockausdruck ausgeführt wird, wird der Wert des letzten Ausdrucks im Block zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Übergeben eines Parameters zu einem Blockausdruck und verarbeitet diesen Parameter innerhalb eines Blocks.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">Die Variablen im Block.</param>
        <param name="expressions">Die Ausdrücke im Block.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Variablen und Ausdrücke enthält.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Blockausdruck ausgeführt wird, wird der Wert des letzten Ausdrucks im Block zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Der erste Ausdruck im Block.</param>
        <param name="arg1">Der zweite Ausdruck im Block.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BlockExpression" />, die zwei Ausdrücke und keine Variablen enthält.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Blockausdruck ausgeführt wird, wird der Wert des letzten Ausdrucks im Block zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Der Ergebnistyp des Blocks.</param>
        <param name="expressions">Die Ausdrücke im Block.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Ausdrücke enthält, nicht über Variablen verfügt und von einem bestimmten Ergebnistyp ist.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Der Ergebnistyp des Blocks.</param>
        <param name="expressions">Die Ausdrücke im Block.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Ausdrücke enthält, nicht über Variablen verfügt und von einem bestimmten Ergebnistyp ist.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Der erste Ausdruck im Block.</param>
        <param name="arg1">Der zweite Ausdruck im Block.</param>
        <param name="arg2">Der dritte Ausdruck im Block.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das drei Ausdrücke und keine Variablen enthält.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Blockausdruck ausgeführt wird, wird der Wert des letzten Ausdrucks im Block zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Der Ergebnistyp des Blocks.</param>
        <param name="variables">Die Variablen im Block.</param>
        <param name="expressions">Die Ausdrücke im Block.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Variablen und Ausdrücke enthält.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Der Ergebnistyp des Blocks.</param>
        <param name="variables">Die Variablen im Block.</param>
        <param name="expressions">Die Ausdrücke im Block.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Variablen und Ausdrücke enthält.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Der erste Ausdruck im Block.</param>
        <param name="arg1">Der zweite Ausdruck im Block.</param>
        <param name="arg2">Der dritte Ausdruck im Block.</param>
        <param name="arg3">Der vierte Ausdruck im Block.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das vier Ausdrücke und keine Variablen enthält.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Blockausdruck ausgeführt wird, wird der Wert des letzten Ausdrucks im Block zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Der erste Ausdruck im Block.</param>
        <param name="arg1">Der zweite Ausdruck im Block.</param>
        <param name="arg2">Der dritte Ausdruck im Block.</param>
        <param name="arg3">Der vierte Ausdruck im Block.</param>
        <param name="arg4">Der fünfte Ausdruck im Block.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das fünf Ausdrücke und keine Variablen enthält.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Blockausdruck ausgeführt wird, wird der Wert des letzten Ausdrucks im Block zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Break-Anweisung darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Break", die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und ein NULL-Wert beim Springen an die Zielbezeichnung übergeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einen Ausdruck zu erstellen, enthält eine <xref:System.Linq.Expressions.LoopExpression> -Objekt, verwendet die <xref:System.Linq.Expressions.Expression.Break%2A> Methode.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
        <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Break-Anweisung darstellt. Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.GotoExpression" />, bei dem <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Break" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
        <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.GotoExpression" />, das eine Break-Anweisung mit dem angegebenen Typ darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.GotoExpression" />, bei dem <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Break" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
        <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
        <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.GotoExpression" />, das eine Break-Anweisung mit dem angegebenen Typ darstellt. Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.GotoExpression" />, bei dem <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Break" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance">Ein <see cref="T:System.Linq.Expressions.Expression" />, das die Instanz für einen Instanzmethodenaufruf angibt (übergeben Sie <see langword="null" /> für eine <see langword="static" />-Methode bzw. in Visual Basic eine <see langword="Shared" />-Methode).</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode darstellt, die keine Argumente akzeptiert.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zur Darstellung von eines Aufrufs einer `static` (`Shared` in Visual Basic)-Methode übergeben `null` für die `instance` -Parameter, wenn Sie diese Methode aufrufen.  
  
 Wenn `method` eine Instanzmethode darstellt, die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `instance` muss der deklarierende Typ der dargestellte Methode zugewiesen werden `method`.  
  
 Die <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MethodCallExpression> ist leer. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entspricht der Rückgabetyp der Methode dargestellte `method`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie einen Ausdruck erstellen, der eine Methode ohne Argumente aufgerufen werden.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="instance" /> ist <see langword="null" />, und <paramref name="method" /> stellt eine Instanzmethode dar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="instance" />.Type kann dem deklarierenden Typ der durch <paramref name="method" /> dargestellten Methode nicht zugewiesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="method">Das <see cref="T:System.Reflection.MethodInfo" />, das die Zielmethode darstellt.</param>
        <param name="arguments">Ein Auflistung von <see cref="T:System.Linq.Expressions.Expression" />, die die Aufrufargumente darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer statischen Methode (Shared in Visual Basic) darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer <see langword="static" />-Methode (<see langword="Shared" /> in Visual Basic) mit einem Argument darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einen Ausdruck zu erstellen, die aufruft, ein `static` (`Shared` in Visual Basic) Methode, die ein Argument übergeben.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine <see langword="static" />-Methode (<see langword="Shared" /> in Visual Basic) darstellt, auf die die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer <see langword="static" />-Methode (<see langword="Shared" /> in Visual Basic) mit Argumenten darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `arguments` nicht `null`, muss die gleiche Anzahl von Elementen wie die Anzahl von Parametern für vom dargestellten Methode `method`. Jedes Element im `arguments` muss `null` und müssen dem entsprechenden Parameter zugewiesen werden `method`, möglicherweise nach dem *Zitieren*.  
  
> [!NOTE]
>  Ein Element wird in Anführungszeichen eingeschlossen werden nur, wenn der entsprechende Methodenparameter des Typs <xref:System.Linq.Expressions.Expression>. Zitieren bedeutet, dass das Element umschlossen ist ein <xref:System.Linq.Expressions.ExpressionType.Quote> Knoten. Der resultierende Knoten ist ein <xref:System.Linq.Expressions.UnaryExpression> , deren <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> Eigenschaft ist für das Element der `arguments`.  
  
 Die <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MethodCallExpression> ist leer Wenn `arguments` ist `null`. Andernfalls enthält die gleichen Elemente wie `arguments`, von denen einige möglicherweise in Anführungszeichen eingeschlossen werden.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MethodCallExpression> ist der Rückgabetyp der Methode dargestellte gleich `method`. Die <xref:System.Linq.Expressions.MethodCallExpression.Object%2A>-Eigenschaft ist `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in <paramref name="arguments" /> stimmt nicht mit der Anzahl der Parameter für die durch <paramref name="method" /> dargestellte Methode dar.  
  
 - oder -   
  
 Mindestens ein Element von <paramref name="arguments" /> kann nicht dem entsprechenden Parameter für die durch <paramref name="method" /> dargestellte Methode zugewiesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft festgelegt werden soll. Übergeben Sie <see langword="null" /> für eine <see langword="static" />-Methode (<see langword="Shared" /> in Visual Basic).</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode darstellt, die Argumente akzeptiert.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> und <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zur Darstellung von eines Aufrufs einer `static` (`Shared` in Visual Basic)-Methode übergeben `null` für die `instance` -Parameter, wenn Sie diese Methode aufrufen, oder rufen Sie <xref:System.Linq.Expressions.Expression.Call%2A> stattdessen.  
  
 Wenn `method` eine Instanzmethode darstellt, die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `instance` muss der deklarierende Typ der dargestellte Methode zugewiesen werden `method`.  
  
 Wenn `arguments` nicht `null`, muss die gleiche Anzahl von Elementen wie die Anzahl von Parametern für vom dargestellten Methode `method`. Jedes Element im `arguments` muss `null` und müssen dem entsprechenden Parameter zugewiesen werden `method`, möglicherweise nach dem *Zitieren*.  
  
> [!NOTE]
>  Ein Element wird in Anführungszeichen eingeschlossen werden nur, wenn der entsprechende Methodenparameter des Typs <xref:System.Linq.Expressions.Expression>. Zitieren bedeutet, dass das Element umschlossen ist ein <xref:System.Linq.Expressions.ExpressionType.Quote> Knoten. Der resultierende Knoten ist ein <xref:System.Linq.Expressions.UnaryExpression> , deren <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> Eigenschaft ist für das Element der `arguments`.  
  
 Die <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MethodCallExpression> ist leer Wenn `arguments` ist `null`. Andernfalls enthält die gleichen Elemente wie `arguments`, von denen einige möglicherweise in Anführungszeichen eingeschlossen werden.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MethodCallExpression> ist der Rückgabetyp der Methode dargestellte gleich `method`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="instance" /> ist <see langword="null" />, und <paramref name="method" /> stellt eine Instanzmethode dar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="instance" />.Type kann dem deklarierenden Typ der durch <paramref name="method" /> dargestellten Methode nicht zugewiesen werden.  
  
 - oder -   
  
 Die Anzahl der Elemente in <paramref name="arguments" /> stimmt nicht mit der Anzahl der Parameter für die durch <paramref name="method" /> dargestellte Methode dar.  
  
 - oder -   
  
 Mindestens ein Element von <paramref name="arguments" /> kann nicht dem entsprechenden Parameter für die durch <paramref name="method" /> dargestellte Methode zugewiesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Ein <see cref="T:System.Linq.Expressions.Expression" />, das die Instanz für einen Instanzmethodenaufruf angibt (übergeben Sie <see langword="null" /> für eine <see langword="static" />-Methode bzw. in Visual Basic eine <see langword="Shared" />-Methode).</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode darstellt, die Argumente akzeptiert.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> und <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zur Darstellung von eines Aufrufs einer `static` (`Shared` in Visual Basic)-Methode übergeben `null` für die `instance` -Parameter, wenn Sie diese Methode aufrufen, oder rufen Sie <xref:System.Linq.Expressions.Expression.Call%2A> stattdessen.  
  
 Wenn `method` eine Instanzmethode darstellt, die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `instance` muss der deklarierende Typ der dargestellte Methode zugewiesen werden `method`.  
  
 Wenn `arguments` nicht `null`, muss die gleiche Anzahl von Elementen wie die Anzahl von Parametern für vom dargestellten Methode `method`. Jedes Element im `arguments` muss `null` und müssen dem entsprechenden Parameter zugewiesen werden `method`, möglicherweise nach dem *Zitieren*.  
  
> [!NOTE]
>  Ein Element wird in Anführungszeichen eingeschlossen werden nur, wenn der entsprechende Methodenparameter des Typs <xref:System.Linq.Expressions.Expression>. Zitieren bedeutet, dass das Element umschlossen ist ein <xref:System.Linq.Expressions.ExpressionType.Quote> Knoten. Der resultierende Knoten ist ein <xref:System.Linq.Expressions.UnaryExpression> , deren <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> Eigenschaft ist für das Element der `arguments`.  
  
 Die <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MethodCallExpression> ist leer Wenn `arguments` ist `null`. Andernfalls enthält die gleichen Elemente wie `arguments`, von denen einige möglicherweise in Anführungszeichen eingeschlossen werden.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MethodCallExpression> ist der Rückgabetyp der Methode dargestellte gleich `method`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="instance" /> ist <see langword="null" />, und <paramref name="method" /> stellt eine Instanzmethode dar.  
  
 - oder -   
  
 <paramref name="arguments" /> ist nicht <see langword="null" />, und mindestens ein Element davon ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="instance" />.Type kann dem deklarierenden Typ der durch <paramref name="method" /> dargestellten Methode nicht zugewiesen werden.  
  
 - oder -   
  
 Die Anzahl der Elemente in <paramref name="arguments" /> stimmt nicht mit der Anzahl der Parameter für die durch <paramref name="method" /> dargestellte Methode dar.  
  
 - oder -   
  
 Mindestens ein Element von <paramref name="arguments" /> kann nicht dem entsprechenden Parameter für die durch <paramref name="method" /> dargestellte Methode zugewiesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
        <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer statischen Methode darstellt, die zwei Argumente akzeptiert.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">Ein <see cref="T:System.Linq.Expressions.Expression" />, das die Instanz für einen Instanzaufruf angibt. (Übergeben Sie NULL für eine statische Methode bzw. eine Shared-Methode in Visual Basic.)</param>
        <param name="method">Das <see cref="T:System.Reflection.MethodInfo" />, das die Zielmethode darstellt.</param>
        <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
        <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode darstellt, die zwei Argumente akzeptiert.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie auf einen Ausdruck zu erstellen, der eine Instanzmethode aufruft, die über zwei Argumente verfügt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Eine <see cref="T:System.Linq.Expressions.Expression" />, deren <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaftswert nach einer bestimmten Methode durchsucht wird.</param>
        <param name="methodName">Der Name der Methode.</param>
        <param name="typeArguments">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typparameter der generischen Methode angeben. Dieses Argument muss NULL sein, wenn durch methodName eine nicht generische Methode angegeben wird.</param>
        <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, das die Argumente der Methode darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode durch das Aufrufen der entsprechenden Factorymethode darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist, die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft gleich <paramref name="instance" /> ist, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> auf die <see cref="T:System.Reflection.MethodInfo" /> festgelegt ist, die die angegebene Instanzmethode darstellt, und <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> auf die angegebenen Argumente festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MethodCallExpression> ist der Rückgabetyp der Methode gekennzeichnet durch gleich `methodName`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> oder <paramref name="methodName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Keine Methode mit dem Namen <paramref name="methodName" />, deren Type-Parameter entsprechen <paramref name="typeArguments" />, und deren Parametertypen Übereinstimmung <paramref name="arguments" /> befindet sich im <paramref name="instance" />. Typ oder dessen Basistypen.  
  
 - oder -   
  
 Mehr als eine Methode mit dem Namen <paramref name="methodName" />, deren Type-Parameter entsprechen <paramref name="typeArguments" />, und deren Parametertypen Übereinstimmung <paramref name="arguments" /> befindet sich im <paramref name="instance" />. Typ oder dessen Basistypen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
        <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
        <param name="arg2">Das <see cref="T:System.Linq.Expressions.Expression" />, das das dritte Argument darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer statischen Methode darstellt, die drei Argumente akzeptiert.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" />, der den Typ angibt, der die angegebene <see langword="static" />-Methode (<see langword="Shared" /> in Visual Basic) enthält.</param>
        <param name="methodName">Der Name der Methode.</param>
        <param name="typeArguments">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typparameter der generischen Methode angeben. Dieses Argument muss NULL sein, wenn durch methodName eine nicht generische Methode angegeben wird.</param>
        <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, das die Argumente der Methode darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer <see langword="static" />-Methode (<see langword="Shared" /> in Visual Basic) durch das Aufrufen der entsprechenden Factorymethode darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist, die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die <see cref="T:System.Reflection.MethodInfo" /> festgelegt ist, die die angegebene <see langword="static" />-Methode (<see langword="Shared" /> in Visual Basic) darstellt, und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Eigenschaft auf die angegebenen Argumente festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MethodCallExpression> ist der Rückgabetyp der Methode gekennzeichnet durch gleich `methodName`. Die <xref:System.Linq.Expressions.MethodCallExpression.Object%2A>-Eigenschaft ist `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> oder <paramref name="methodName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Keine Methode mit dem Namen <paramref name="methodName" />, deren Type-Parameter entsprechen <paramref name="typeArguments" />, und deren Parametertypen Übereinstimmung <paramref name="arguments" /> befindet sich im <paramref name="type" /> oder dessen Basistypen.  
  
 - oder -   
  
 Mehr als eine Methode mit dem Namen <paramref name="methodName" />, deren Type-Parameter entsprechen <paramref name="typeArguments" />, und deren Parametertypen Übereinstimmung <paramref name="arguments" /> befindet sich im <paramref name="type" /> oder dessen Basistypen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">Ein <see cref="T:System.Linq.Expressions.Expression" />, das die Instanz für einen Instanzaufruf angibt. (Übergeben Sie NULL für eine statische Methode bzw. eine Shared-Methode in Visual Basic.)</param>
        <param name="method">Das <see cref="T:System.Reflection.MethodInfo" />, das die Zielmethode darstellt.</param>
        <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
        <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
        <param name="arg2">Das <see cref="T:System.Linq.Expressions.Expression" />, das das dritte Argument darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode darstellt, die drei Argumente akzeptiert.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
        <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
        <param name="arg2">Das <see cref="T:System.Linq.Expressions.Expression" />, das das dritte Argument darstellt.</param>
        <param name="arg3">Das <see cref="T:System.Linq.Expressions.Expression" />, das das vierte Argument darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer statischen Methode darstellt, die vier Argumente akzeptiert.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
        <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
        <param name="arg2">Das <see cref="T:System.Linq.Expressions.Expression" />, das das dritte Argument darstellt.</param>
        <param name="arg3">Das <see cref="T:System.Linq.Expressions.Expression" />, das das vierte Argument darstellt.</param>
        <param name="arg4">Das <see cref="T:System.Linq.Expressions.Expression" />, das das fünfte Argument darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer statischen Methode darstellt, die fünf Argumente akzeptiert.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass der Knoten zu einem einfacheren Knoten reduziert werden kann. Wenn true zurückgegeben wird, kann Reduce() aufgerufen werden, um das reduzierte Formular zu erzeugen.</summary>
        <value>True, wenn der Knoten reduziert werden kann, andernfalls False.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">Eine <see cref="T:System.Linq.Expressions.ParameterExpression" />, die einen Verweis auf das von diesem Handler aufgefangene <see cref="T:System.Exception" />-Objekt darstellt.</param>
        <param name="body">Der Text der Catch-Anweisung.</param>
        <summary>Erstellt einen <see cref="T:System.Linq.Expressions.CatchBlock" />, der eine Catch-Anweisung mit einem Verweis auf das aufgefangene <see cref="T:System.Exception" />-Objekt zur Verwendung im Handlertext darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" /> von <see cref="T:System.Exception" />, der von diesem <see cref="T:System.Linq.Expressions.CatchBlock" /> behandelt wird.</param>
        <param name="body">Der Text der Catch-Anweisung.</param>
        <summary>Erstellt einen <see cref="T:System.Linq.Expressions.CatchBlock" />, der eine Catch-Anweisung darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> von <xref:System.Exception> bereits aufgefangen werden kann angegeben werden, jedoch kein Verweis auf die <xref:System.Exception> Objekt stehen dann für die Verwendung in der <xref:System.Linq.Expressions.CatchBlock>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">Eine <see cref="T:System.Linq.Expressions.ParameterExpression" />, die einen Verweis auf das von diesem Handler aufgefangene <see cref="T:System.Exception" />-Objekt darstellt.</param>
        <param name="body">Der Text der Catch-Anweisung.</param>
        <param name="filter">Der Text des <see cref="T:System.Exception" />-Filters.</param>
        <summary>Erstellt einen <see cref="T:System.Linq.Expressions.CatchBlock" />, der eine Catch-Anweisung mit einem <see cref="T:System.Exception" />-Filter und einem Verweis auf das aufgefangene <see cref="T:System.Exception" />-Objekt darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" /> von <see cref="T:System.Exception" />, der von diesem <see cref="T:System.Linq.Expressions.CatchBlock" /> behandelt wird.</param>
        <param name="body">Der Text der Catch-Anweisung.</param>
        <param name="filter">Der Text des <see cref="T:System.Exception" />-Filters.</param>
        <summary>Erstellt einen <see cref="T:System.Linq.Expressions.CatchBlock" />, der eine Catch-Anweisung mit einem <see cref="T:System.Exception" />-Filter, aber keinem Verweis auf das aufgefangene <see cref="T:System.Exception" />-Objekt darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
      </Parameters>
      <Docs>
        <param name="document">Die <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, die die Quelldatei darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> zum Löschen eines Sequenzpunkts.</summary>
        <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> zum Löschen eines Sequenzpunkts.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine zusammenfügende Operation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.BinaryExpression> ist `null` und die beiden <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> festgelegt `false`. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entspricht dem Ergebnistyp des zusammenfügende Operation. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
#### <a name="result-type"></a>Ergebnistyp  
 Die folgenden Regeln bestimmen den Ergebnistyp.  
  
-   Wenn `left`. Typ darstellt, den nullable-Typ und `right`. Type implizit in den entsprechenden Typ NULL-Werte zulässt, ist der Ergebnistyp entspricht dem NULL- `left`. Geben Sie ein.  
  
-   Andernfalls gilt: Wenn `right`. Typ ist implizit in `left`. Der Typ, der Ergebnistyp ist `left`. Geben Sie ein.  
  
-   Andernfalls gilt: Wenn die NULL-Entsprechung des `left`. Typ ist implizit in `right`. Der Typ, der Ergebnistyp ist `right`. Geben Sie ein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft <paramref name="left" /> stellt keinen dar, ein Verweistyp oder ein NULL-Werte zulassen.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" />. Typ und <paramref name="right" />. Typ können nicht miteinander konvertiert werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die bei einer gegebenen Konvertierungsfunktion eine zusammenfügende Operation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.BinaryExpression> ist `null` und die beiden <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> festgelegt `false`.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.BinaryExpression> ist der Ergebnistyp der zusammenfügende Operation gleich.  
  
 Die folgenden Regeln bestimmen den Ergebnistyp.  
  
-   Wenn `left`. Typ darstellt, den nullable-Typ und `right`. Type implizit in den entsprechenden Typ NULL-Werte zulässt, ist der Ergebnistyp entspricht dem NULL- `left`. Geben Sie ein.  
  
-   Andernfalls gilt: Wenn `right`. Typ ist implizit in `left`. Der Typ, der Ergebnistyp ist `left`. Geben Sie ein.  
  
-   Andernfalls gilt: Wenn die NULL-Entsprechung des `left`. Typ ist implizit in `right`. Der Typ, der Ergebnistyp ist `right`. Geben Sie ein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" />. Typ und <paramref name="right" />. Typ können nicht miteinander konvertiert werden.  
  
 - oder -   
  
 <paramref name="conversion" />ist kein <see langword="null" /> und <paramref name="conversion" />. Typ ist ein Delegattyp, der keine genau ein Argument akzeptiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft <paramref name="left" /> stellt keinen dar, ein Verweistyp oder ein NULL-Werte zulassen.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft <paramref name="left" /> stellt einen Typ, der nicht den Parametertyp des Delegattyps <paramref name="conversion" />. Geben Sie ein.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft <paramref name="right" /> stimmt nicht mit dem Rückgabetyp des Delegattyps <paramref name="conversion" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft festgelegt werden soll.</param>
        <param name="ifTrue">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft festgelegt werden soll.</param>
        <param name="ifFalse">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die eine bedingte Anweisung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ConditionalExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> und <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.ConditionalExpression> ist gleich der <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `ifTrue`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, der eine bedingte Anweisung darstellt. Wenn das erste Argument ergibt `true`das zweite Argument ausgeführt wird; andernfalls, wird das dritte Argument ausgeführt wird.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="test" /> oder <paramref name="ifTrue" /> oder <paramref name="ifFalse" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="test" />. Ist keine <see cref="T:System.Boolean" />.  
  
 - oder -   
  
 <paramref name="ifTrue" />. Typ stimmt nicht mit <paramref name="ifFalse" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="test">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft festgelegt werden soll.</param>
        <param name="ifTrue">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft festgelegt werden soll.</param>
        <param name="ifFalse">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft festgelegt werden soll.</param>
        <param name="type">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die eine bedingte Anweisung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ConditionalExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> und <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode können explizit Vereinheitlichung der Ergebnistyp des bedingten Ausdrucks in Fällen, in denen die Typen von `ifTrue` und `ifFalse` Ausdrücke ungleich sind. Die Typen beider `ifTrue` und `ifFalse` muss implizit Verweis dem Ergebnistyp zugewiesen werden. Die `type` darf erfolgen <xref:System.Void>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Ein <see cref="T:System.Object" />, auf den die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConstantExpression" />, bei der die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ConstantExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> und die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.ConstantExpression> entspricht der Typ des `value`. Wenn `value` ist `null`, <xref:System.Linq.Expressions.Expression.Type%2A> gleich <xref:System.Object>.  
  
 Zur Darstellung `null`, können Sie auch die <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> Methode, mit denen Sie den Typ explizit angeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, der einen konstanten Wert darstellt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">Ein <see cref="T:System.Object" />, auf den die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft festgelegt werden soll.</param>
        <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConstantExpression" />, bei der die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ConstantExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> ist und die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann für die Darstellung der Werte der Typen mit Nullwert nützlich sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie erstellen Sie einen Ausdruck, der eine Konstante vom nullable-Typ darstellt, und legen Sie dessen Wert auf `null`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />ist kein <see langword="null" /> und <paramref name="type" /> abfragesichtausdrucks kann nicht aus der dynamische Typ der <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Continue-Anweisung darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Continue", die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einen Schleifenausdruck zu erstellen, verwendet die <xref:System.Linq.Expressions.Expression.Continue%2A> Methode.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
        <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Continue-Anweisung mit dem angegebenen Typ darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.GotoExpression" />, bei dem <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Continue" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
        <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, das einen Typkonvertierungsvorgang darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.UnaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> auf die implementierende Methode festgelegt ist. Die <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A>-Eigenschaft ist `false`. Wenn der Knoten transformiert wird, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> ist `true`. Andernfalls ist der Wert `false`.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn entweder `expression`. Typ oder `type` ist ein benutzerdefinierte Typ, der einen implizite oder explizite Konvertierungsoperator definiert die <xref:System.Reflection.MethodInfo> , darstellt, der Operator ist die implementierende Methode.  
  
-   Andernfalls gilt:  
  
    -   Wenn beide `expression`. Typ und `type` darstellen, numerische oder boolesche Typen bzw. NULL-Werte zulässt oder NULL-Enumeration, die die implementierende Methode `null`.  
  
    -   Wenn entweder `expression`. Typ oder `type` ist ein Verweistyp handelt, und ein explizites Boxing unboxing oder verweiskonvertierung vorhanden ist, von `expression`. Geben Sie auf `type`, die implementierende Methode `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `expression`. Typ der Argumenttyp der implementierenden Methode zugeordnet werden kann und der Rückgabetyp der implementierenden Methode zugewiesen werden `type`, der Knoten nicht transformiert.  
  
-   Wenn einer oder beide der `expression`. Typ oder `type` ist ein NULL-Werte zulassen und die entsprechenden Typen für die NULL-Werte sind gleich der Argumenttyp und der Rückgabetyp der implementierenden Methode bzw. der Knoten transformiert.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn beide `expression`. Typ und `type` sind keine NULL-Werte zulässt, der Knoten nicht transformiert.  
  
-   Andernfalls ist der Knoten transformiert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie auf einen Ausdruck zu erstellen, der einen Typ konvertiert Vorgang darstellt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> oder <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Konvertierungsoperator zwischen <paramref name="expression" />. Typ und <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
        <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine Konvertierungsoperation darstellt, für die die implementierende Methode angegeben ist.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> und <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.UnaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> auf die implementierende Methode festgelegt ist. Die <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A>-Eigenschaft ist `false`. Wenn der Knoten transformiert wird, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> ist `true`. Andernfalls ist der Wert `false`.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn die Methode nicht ist `null`, ist die implementierende Methode. Es muss eine nicht-Void darstellen `static` (`Shared` in Visual Basic) Methode, die ein Argument übergeben.  
  
-   Andernfalls, wenn entweder `expression`. Typ oder `type` ist ein benutzerdefinierte Typ, der einen implizite oder explizite Konvertierungsoperator definiert die <xref:System.Reflection.MethodInfo> , darstellt, der Operator ist die implementierende Methode.  
  
-   Andernfalls gilt:  
  
    -   Wenn beide `expression`. Typ und `type` darstellen, numerische oder boolesche Typen bzw. NULL-Werte zulässt oder NULL-Enumeration, die die implementierende Methode `null`.  
  
    -   Wenn entweder `expression`. Typ oder `type` ist ein Verweistyp handelt, und ein explizites Boxing unboxing oder verweiskonvertierung vorhanden ist, von `expression`. Geben Sie auf `type`, die implementierende Methode `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `expression`. Typ der Argumenttyp der implementierenden Methode zugeordnet werden kann und der Rückgabetyp der implementierenden Methode zugewiesen werden `type`, der Knoten nicht transformiert.  
  
-   Wenn eine oder beide der `expression`. Typ oder `type` sind ein NULL-Werte zulassen und die entsprechenden Werttypen für die NULL-gleich der Argumenttyp und der Rückgabetyp der implementierenden Methode bzw., der Knoten transformiert.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn beide `expression`. Typ und `type` sind keine NULL-Werte zulässt, der Knoten nicht transformiert.  
  
-   Andernfalls ist der Knoten transformiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> oder <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" />ist kein <see langword="null" /> und die Methode dar, gibt <see langword="void" />, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic), oder ist nicht genau ein Argument annehmen.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Konvertierungsoperator zwischen <paramref name="expression" />. Typ und <paramref name="type" />.  
  
 - oder -   
  
 <paramref name="expression" />. Typ abfragesichtausdrucks kann nicht in den Argumenttyp der dargestellte Methode <paramref name="method" />.  
  
 - oder -   
  
 Der Rückgabetyp der Methode dargestellte <paramref name="method" /> abfragesichtausdrucks kann nicht auf <paramref name="type" />.  
  
 - oder -   
  
 <paramref name="expression" />. Typ oder <paramref name="type" /> ist ein NULL-Werte zulassen und der entsprechenden NULL-Werttyp entspricht nicht den Typ des Arguments oder der Rückgabetyp, der dargestellte Methode <paramref name="method" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mehr als eine Methode, die entspricht der <paramref name="method" /> Beschreibung wurde gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
        <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine Konvertierungsoperation darstellt, die eine Ausnahme auslöst, wenn ein Überlauf im Zieltyp auftritt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.UnaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> auf die implementierende Methode festgelegt ist. Die <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A>-Eigenschaft ist `false`. Wenn der Knoten transformiert wird, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> ist `true`. Andernfalls ist der Wert `false`.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn entweder `expression`. Typ oder `type` ist ein benutzerdefinierte Typ, der einen implizite oder explizite Konvertierungsoperator definiert die <xref:System.Reflection.MethodInfo> , darstellt, der Operator ist die implementierende Methode.  
  
-   Andernfalls gilt:  
  
    -   Wenn beide `expression`. Typ und `type` darstellen, numerische oder boolesche Typen bzw. NULL-Werte zulässt oder NULL-Enumeration, die die implementierende Methode `null`.  
  
    -   Wenn entweder `expression`. Typ oder `type` ist ein Verweistyp handelt, und ein explizites Boxing unboxing oder verweiskonvertierung vorhanden ist, von `expression`. Geben Sie auf `type`, die implementierende Methode `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `expression`. Typ der Argumenttyp der implementierenden Methode zugeordnet werden kann und der Rückgabetyp der implementierenden Methode zugewiesen werden `type`, der Knoten nicht transformiert.  
  
-   Wenn eine oder beide der `expression`. Typ oder `type` sind ein NULL-Werte zulassen und die entsprechenden Werttypen für die NULL-gleich der Argumenttyp und der Rückgabetyp der implementierenden Methode bzw., der Knoten transformiert.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn beide `expression`. Typ und `type` sind keine NULL-Werte zulässt, der Knoten nicht transformiert.  
  
-   Andernfalls ist der Knoten transformiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> oder <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Konvertierungsoperator zwischen <paramref name="expression" />. Typ und <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
        <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine Konvertierungsoperation darstellt, für die die implementierende Methode angegeben ist und die eine Ausnahme auslöst, wenn ein Überlauf im Zieltyp auftritt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> und <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.UnaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> auf die implementierende Methode festgelegt ist. Die <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A>-Eigenschaft ist `false`. Wenn der Knoten transformiert wird, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> ist `true`. Andernfalls ist der Wert `false`.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn die Methode nicht ist `null`, ist die implementierende Methode. Es muss eine nicht-Void darstellen `static` (`Shared` in Visual Basic) Methode, die ein Argument übergeben.  
  
-   Andernfalls, wenn entweder `expression`. Typ oder `type` ist ein benutzerdefinierte Typ, der einen implizite oder explizite Konvertierungsoperator definiert die <xref:System.Reflection.MethodInfo> , darstellt, der Operator ist die implementierende Methode.  
  
-   Andernfalls gilt:  
  
    -   Wenn beide `expression`. Typ und `type` darstellen, numerische oder boolesche Typen bzw. NULL-Werte zulässt oder NULL-Enumeration, die die implementierende Methode `null`.  
  
    -   Wenn entweder `expression`. Typ oder `type` ist ein Verweistyp handelt, und ein explizites Boxing unboxing oder verweiskonvertierung vorhanden ist, von `expression`. Geben Sie auf `type`, die implementierende Methode `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `expression`. Typ der Argumenttyp der implementierenden Methode zugeordnet werden kann und der Rückgabetyp der implementierenden Methode zugewiesen werden `type`, der Knoten nicht transformiert.  
  
-   Wenn eine oder beide der `expression`. Typ oder `type` sind ein NULL-Werte zulassen und die entsprechenden Werttypen für die NULL-gleich der Argumenttyp und der Rückgabetyp der implementierenden Methode bzw., der Knoten transformiert.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn beide `expression`. Typ und `type` sind keine NULL-Werte zulässt, der Knoten nicht transformiert.  
  
-   Andernfalls ist der Knoten transformiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> oder <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" />ist kein <see langword="null" /> und die Methode dar, gibt <see langword="void" />, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic), oder ist nicht genau ein Argument annehmen.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Konvertierungsoperator zwischen <paramref name="expression" />. Typ und <paramref name="type" />.  
  
 - oder -   
  
 <paramref name="expression" />. Typ abfragesichtausdrucks kann nicht in den Argumenttyp der dargestellte Methode <paramref name="method" />.  
  
 - oder -   
  
 Der Rückgabetyp der Methode dargestellte <paramref name="method" /> abfragesichtausdrucks kann nicht auf <paramref name="type" />.  
  
 - oder -   
  
 <paramref name="expression" />. Typ oder <paramref name="type" /> ist ein NULL-Werte zulassen und der entsprechenden NULL-Werttyp entspricht nicht den Typ des Arguments oder der Rückgabetyp, der dargestellte Methode <paramref name="method" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mehr als eine Methode, die entspricht der <paramref name="method" /> Beschreibung wurde gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document">Die <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, die die Quelldatei darstellt.</param>
        <param name="startLine">Die Startzeile dieser <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Muss größer als 0 sein.</param>
        <param name="startColumn">Die Startspalte dieser <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Muss größer als 0 sein.</param>
        <param name="endLine">Die Endzeile dieser <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Muss größer oder gleich der Startzeile sein.</param>
        <param name="endColumn">Die Endspalte dieser <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Wenn die Endzeile und die Startzeile identisch sind, muss die Endzeile größer oder gleich der Startspalte sein. Muss in jedem Fall größer als 0 sein.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> mit der angegebenen Spanne.</summary>
        <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Ein zu verringerndes <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Verringern des Ausdruckswerts um 1 darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den verringerten Ausdruckswert darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Ausdruck ist funktionsfähig und ändert sich nicht auf den Wert des Objekts übergeben wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie einen Ausdruck, subtrahiert 1 aus einem angegebenen Wert erstellt wird.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Ein zu verringerndes <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Verringern des Ausdruckswerts um 1 darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den verringerten Ausdruckswert darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Ausdruck ist funktionsfähig und ändert sich nicht auf den Wert des Objekts übergeben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.DefaultExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf den angegebenen Typ festgelegt ist.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.DefaultExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf den angegebenen Typ festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, der einen Standardwert für einen angegebenen Typ darstellt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Division darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, der den Divisionsoperator überlädt die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten Divisionsoperators.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten Divisionsoperators entspricht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, der sich teilt erste Argument durch das zweite Argument.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Divisionsoperator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Division darstellt. Die implementierende Methode kann angegeben werden.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, der den Divisionsoperator überlädt die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten Divisionsoperators.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten Divisionsoperators entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> ist <see langword="null" />, und der Divisionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Divisionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Divisionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Divisionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="binder">Der Laufzeitbinder für den dynamischen Vorgang.</param>
        <param name="returnType">Der Ergebnistyp des dynamischen Ausdrucks.</param>
        <param name="arguments">Die Argumente des dynamischen Vorgangs.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.DynamicExpression" />, das einen dynamischen, vom bereitgestellten <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> gebundenen Vorgang darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.DynamicExpression" />, bei dem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> gleich <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> ist und die <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> -Eigenschaft des Ergebnisses wird von den Typen der Argumente abgeleitet werden und dem angegebenen Rückgabetyp.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Der Laufzeitbinder für den dynamischen Vorgang.</param>
        <param name="returnType">Der Ergebnistyp des dynamischen Ausdrucks.</param>
        <param name="arg0">Das erste Argument des dynamischen Vorgangs.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.DynamicExpression" />, das einen dynamischen, vom bereitgestellten <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> gebundenen Vorgang darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.DynamicExpression" />, bei dem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> gleich <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> ist und die <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> -Eigenschaft des Ergebnisses wird von den Typen der Argumente abgeleitet werden und dem angegebenen Rückgabetyp.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder">Der Laufzeitbinder für den dynamischen Vorgang.</param>
        <param name="returnType">Der Ergebnistyp des dynamischen Ausdrucks.</param>
        <param name="arguments">Die Argumente des dynamischen Vorgangs.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.DynamicExpression" />, das einen dynamischen, vom bereitgestellten <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> gebundenen Vorgang darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.DynamicExpression" />, bei dem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> gleich <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> ist und die <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> -Eigenschaft des Ergebnisses wird von den Typen der Argumente abgeleitet werden und dem angegebenen Rückgabetyp.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Der Laufzeitbinder für den dynamischen Vorgang.</param>
        <param name="returnType">Der Ergebnistyp des dynamischen Ausdrucks.</param>
        <param name="arg0">Das erste Argument des dynamischen Vorgangs.</param>
        <param name="arg1">Das zweite Argument des dynamischen Vorgangs.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.DynamicExpression" />, das einen dynamischen, vom bereitgestellten <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> gebundenen Vorgang darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.DynamicExpression" />, bei dem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> gleich <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> ist und die <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> -Eigenschaft des Ergebnisses wird von den Typen der Argumente abgeleitet werden und dem angegebenen Rückgabetyp.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Der Laufzeitbinder für den dynamischen Vorgang.</param>
        <param name="returnType">Der Ergebnistyp des dynamischen Ausdrucks.</param>
        <param name="arg0">Das erste Argument des dynamischen Vorgangs.</param>
        <param name="arg1">Das zweite Argument des dynamischen Vorgangs.</param>
        <param name="arg2">Das dritte Argument des dynamischen Vorgangs.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.DynamicExpression" />, das einen dynamischen, vom bereitgestellten <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> gebundenen Vorgang darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.DynamicExpression" />, bei dem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> gleich <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> ist und die <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> -Eigenschaft des Ergebnisses wird von den Typen der Argumente abgeleitet werden und dem angegebenen Rückgabetyp.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Der Laufzeitbinder für den dynamischen Vorgang.</param>
        <param name="returnType">Der Ergebnistyp des dynamischen Ausdrucks.</param>
        <param name="arg0">Das erste Argument des dynamischen Vorgangs.</param>
        <param name="arg1">Das zweite Argument des dynamischen Vorgangs.</param>
        <param name="arg2">Das dritte Argument des dynamischen Vorgangs.</param>
        <param name="arg3">Das vierte Argument des dynamischen Vorgangs.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.DynamicExpression" />, das einen dynamischen, vom bereitgestellten <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> gebundenen Vorgang darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.DynamicExpression" />, bei dem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> gleich <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> ist und die <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> -Eigenschaft des Ergebnisses wird von den Typen der Argumente abgeleitet werden und dem angegebenen Rückgabetyp.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />-Eigenschaft festgelegt werden soll.</param>
        <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> mit <see cref="T:System.Linq.Expressions.Expression" />-Objekten, auf das die <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.ElementInit" />, dessen zweites Argument ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> ist.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ElementInit" />, bei dem die <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `addMethod` Parameter muss eine Instanzmethode namens "Add" (Groß-/Kleinschreibung beachten) darstellen. Die Add-Methode muss die gleiche Anzahl von Parametern wie die Anzahl der Elemente im haben `arguments`. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft jedes Elements im `arguments` muss den Typ des entsprechenden Parameters der Methode hinzufügen zugewiesen werden möglicherweise nach dem *Zitieren*.  
  
> [!NOTE]
>  Ein Element wird in Anführungszeichen eingeschlossen werden nur, wenn der entsprechende Methodenparameter des Typs <xref:System.Linq.Expressions.Expression>. Zitieren bedeutet, dass das Element umschlossen ist ein <xref:System.Linq.Expressions.ExpressionType.Quote> Knoten. Der resultierende Knoten ist ein <xref:System.Linq.Expressions.UnaryExpression> , deren <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> Eigenschaft ist für das Element der `arguments`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> Methode zum Erstellen einer <xref:System.Linq.Expressions.ElementInit> , Aufruf darstellt die <xref:System.Collections.Generic.Dictionary%602.Add%2A> Methode, um ein Element einer Dictionary-Auflistung zu initialisieren.  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addMethod" /> oder <paramref name="arguments" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Methode, die durch <paramref name="addMethod" /> dargestellt wird, heißt nicht „Add“ (Groß-/Kleinschreibung wird nicht unterschieden).  
  
 - oder -   
  
 Die Methode, die durch <paramref name="addMethod" /> dargestellt wird, ist keine Instanzmethode.  
  
 - oder -   
  
 Die Anzahl der Elemente in <paramref name="arguments" /> stimmt nicht mit der Anzahl der Parameter für die Methode überein, die durch <paramref name="addMethod" /> dargestellt wird.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft von mindestens einem Element von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters der Methode zugewiesen werden, die durch <paramref name="addMethod" /> dargestellt wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />-Eigenschaft festgelegt werden soll.</param>
        <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, auf das die <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.ElementInit" />, dessen zweites Argument ein Wertearray ist.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ElementInit" />, bei dem die <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `addMethod` Parameter muss eine Instanzmethode namens "Add" (Groß-/Kleinschreibung beachten) darstellen. Die Add-Methode muss die gleiche Anzahl von Parametern wie die Anzahl der Elemente im haben `arguments`. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft jedes Elements im `arguments` muss den Typ des entsprechenden Parameters der Methode hinzufügen zugewiesen werden möglicherweise nach dem *Zitieren*.  
  
> [!NOTE]
>  Ein Element wird in Anführungszeichen eingeschlossen werden nur, wenn der entsprechende Methodenparameter des Typs <xref:System.Linq.Expressions.Expression>. Zitieren bedeutet, dass das Element umschlossen ist ein <xref:System.Linq.Expressions.ExpressionType.Quote> Knoten. Der resultierende Knoten ist ein <xref:System.Linq.Expressions.UnaryExpression> , deren <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> Eigenschaft ist für das Element der `arguments`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> Methode zum Erstellen einer <xref:System.Linq.Expressions.ElementInit> , Aufruf darstellt die <xref:System.Collections.Generic.Dictionary%602.Add%2A> Methode, um ein Element einer Dictionary-Auflistung zu initialisieren.  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addMethod" /> oder <paramref name="arguments" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Methode für die AddMethod ist namens "Add" (Groß-/Kleinschreibung beachten).  
  
 - oder -   
  
 Die Methode AddMethod stellt ist keine Instanzenmethode.  
  
 - oder -   
  
 Arguments enthält nicht die gleiche Anzahl von Elementen als die Anzahl von Parametern für die Methode AddMethod darstellt.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft von mindestens einem Element von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters der Methode zugewiesen werden, die durch <paramref name="addMethod" /> dargestellt wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen leeren Ausdruck vom Typ <see cref="T:System.Void" />.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.DefaultExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <see cref="T:System.Void" /> festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein leerer Ausdruck kann verwendet werden, in denen ein Ausdruck wurde erwartet, jedoch keine Aktion gewünscht ist. Beispielsweise können Sie einen leeren Ausdruck als letzten Ausdruck in einem Blockausdruck. In diesem Fall wird der Blockausdruck zurückgegebene Wert "void".  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie auf einen leeren Ausdruck zu erstellen und ein Blockausdruck hinzuzufügen.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Gleichheitsvergleich darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> Eigenschaft ist `true`. Andernfalls ist der Wert `false`. Die <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>-Eigenschaft ist immer `false`. Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Gleichheitsoperator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Ansonsten ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Wenn die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist <xref:System.Boolean>:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist <xref:System.Boolean>.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, der überprüft, ob die Werte der beiden Argumente gleich sind.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Gleichheitsoperator ist nicht für <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="liftToNull">
          <see langword="true" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="true" /> festzulegen, und <see langword="false" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="false" /> festzulegen.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Gleichheitsvergleich darstellt. Die implementierende Methode kann angegeben werden.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> Eigenschaft ist `true` und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> -Eigenschaft gleich `liftToNull`. Andernfalls sind sie beide `false`. Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Gleichheitsoperator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Ansonsten ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Wenn die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert; Darüber hinaus ist der Typ des Knotens zulässig <xref:System.Boolean> Wenn `liftToNull` ist `true` oder <xref:System.Boolean> Wenn `liftToNull` ist `false`:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist <xref:System.Boolean>.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist auf NULL festlegbar <xref:System.Boolean> Wenn `liftToNull` ist `true` oder <xref:System.Boolean> Wenn `liftToNull` ist `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />ist <see langword="null" /> und der Gleichheitsoperator ist nicht definiert, für <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" /> , die eine bitweise darstellt <see langword="XOR" /> -Vorgang mit <c>Op_ExclusiveOr</c> für benutzerdefinierte Typen.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, überlädt die `XOR` -Operator, der <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Type ganzzahlige oder boolesche Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten `XOR` Operator.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten entspricht `XOR` Operator.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck zu erstellen, der die logische XOR-Operation darstellt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see langword="XOR" /> Operator ist nicht definiert, für <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" /> , die eine bitweise darstellt <see langword="XOR" /> -Vorgang mit <c>Op_ExclusiveOr</c> für benutzerdefinierte Typen. Die implementierende Methode kann angegeben werden.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen das ausgewählte gegebener implementierender Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, überlädt die `XOR` -Operator, der <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Type ganzzahlige oder boolesche Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten `XOR` Operator.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten entspricht `XOR` Operator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> ist <see langword="null" />, und der <see langword="XOR" />-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" /> , die eine bitweise XOR-Zuweisungsoperation darstellt mit <c>Op_ExclusiveOr</c> für benutzerdefinierte Typen.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" /> , die eine bitweise XOR-Zuweisungsoperation darstellt mit <c>Op_ExclusiveOr</c> für benutzerdefinierte Typen.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" /> , die eine bitweise XOR-Zuweisungsoperation darstellt mit <c>Op_ExclusiveOr</c> für benutzerdefinierte Typen.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft festgelegt werden soll. Für <see langword="static" /> (<see langword="Shared" /> in Visual Basic), <c>Ausdruck</c> muss <see langword="null" />.</param>
        <param name="field">Die <see cref="T:System.Reflection.FieldInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf ein Feld darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MemberExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MemberExpression> ist gleich der <xref:System.Reflection.FieldInfo.FieldType%2A> Eigenschaft `field`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="field" /> ist <see langword="null" />.  
  
 - oder -   
  
 Das Feld dargestellt von <paramref name="field" /> nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) und <paramref name="expression" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. Typ ist nicht zugewiesen werden, zu der deklarierende Typ von Feld dargestellt von <paramref name="field" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" /> , deren <see cref="P:System.Linq.Expressions.Expression.Type" /> enthält ein Feld mit dem Namen <c>FieldName</c>. Dies kann für statische Felder NULL sein.</param>
        <param name="fieldName">Der Name des Felds, auf das zugegriffen werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die bei einem gegebenen Feldnamen den Zugriff auf ein Feld darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.FieldInfo" /> festgelegt ist, die das durch <paramref name="fieldName" /> angegebene Feld darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MemberExpression> ist gleich der <xref:System.Reflection.FieldInfo.FieldType%2A> Eigenschaft von der <xref:System.Reflection.FieldInfo> , die durch das Feld darstellt `fieldName`.  
  
 Diese Methode sucht `expression`. Typ und dessen Basistypen für ein Feld mit dem Namen `fieldName`. Öffentliche Felder sind über nicht öffentliche Felder verhaltensabschnitten. Wenn ein übereinstimmendes Feld gefunden wird, wird diese Methode transferiert `expression` und <xref:System.Reflection.FieldInfo> , die das Feld dem darstellt <xref:System.Linq.Expressions.Expression.Field%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, der Zugriff auf ein Feld darstellt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> oder <paramref name="fieldName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Kein Feld mit dem Namen <paramref name="fieldName" /> ist definiert <paramref name="expression" />. Typ oder dessen Basistypen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Das enthaltende Objekt des Felds. Dies kann für statische Felder NULL sein.</param>
        <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" />, der das Feld enthält.</param>
        <param name="fieldName">Das Feld, auf das zugegriffen werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf ein Feld darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Ein Array mit maximal 16 <see cref="T:System.Type" />-Objekten, die die Typargumente für den <see langword="System.Action" />-Delegattyp angeben.</param>
        <summary>Erstellt eine <see cref="T:System.Type" /> Objekt, das einen generischen darstellt <c>System.Action</c> Delegattyp, der bestimmten Typargumenten.</summary>
        <returns>Der Typ des eine <c>System.Action</c> Delegaten, der das angegebene Typargument aufweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Als Beispiel wenn die Elemente der `typeArgs` die Typen darstellen `T1…Tn`, das resultierende <xref:System.Type> Objekt darstellt, den Typ des erstellten Delegaten `System.Action<T1,…,Tn>` in c# oder `System.Action(Of T1,…,Tn)` in Visual Basic.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeArgs" />enthält mehr als 16-Elemente.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArgs" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Die Typargumente des Delegaten.</param>
        <summary>Ruft eine <see cref="P:System.Linq.Expressions.Expression.Type" /> Objekt, das einen generischen darstellt <c>System.Func</c> oder <c>System.Action</c> Delegattyp, der bestimmten Typargumenten.</summary>
        <returns>Der Delegattyp.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das letzte Typargument bestimmt den Rückgabetyp des Delegaten. Wenn keine Funktion oder Aktion groß genug ist, wird einen benutzerdefinierter Delegattyp generiert.  
  
 Wie bei Func ist das letzte Argument der Rückgabetyp. Er kann auf System.Void festgelegt werden, um eine Aktion zu erstellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Ein Array mit einem bis 17 <see cref="T:System.Type" />-Objekten, die die Typargumente für den <see langword="System.Func" />-Delegattyp angeben.</param>
        <summary>Erstellt eine <see cref="P:System.Linq.Expressions.Expression.Type" /> Objekt, das einen generischen darstellt <c>System.Func</c> Delegattyp, der bestimmten Typargumenten. Das letzte Typargument gibt den Rückgabetyp des erstellten Delegaten an.</summary>
        <returns>Der Typ des eine <c>System.Func</c> Delegaten, der das angegebene Typargument aufweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `typeArgs`muss mindestens einem und höchstens siebzehn Elemente enthalten.  
  
 Als Beispiel wenn die Elemente der `typeArgs` die Typen darstellen `T1…Tn`, das resultierende <xref:System.Type> Objekt darstellt, den Typ des erstellten Delegaten `System.Func<T1,…,Tn>` in c# oder `System.Func(Of T1,…,Tn)` in Visual Basic.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeArgs" />enthält weniger als ein oder mehr als siebzehn Elemente.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArgs" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine "Go to"-Anweisung darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf den angegebenen Wert festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einen Ausdruck zu erstellen, enthält ein <xref:System.Linq.Expressions.GotoExpression> Objekt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
        <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine "Go to"-Anweisung darstellt. Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.GotoExpression" />, bei dem <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
        <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.GotoExpression" />, das eine "Go to"-Anweisung mit dem angegebenen Typ darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf den angegebenen Wert festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
        <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
        <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.GotoExpression" />, das eine "Go to"-Anweisung mit dem angegebenen Typ darstellt. Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer als"-Vergleich darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> Eigenschaft ist `true`. Andernfalls ist der Wert `false`. Die <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>-Eigenschaft ist immer `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, der den Operator "größer als" overloads der <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Wenn die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist <xref:System.Boolean>:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist <xref:System.Boolean>.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der zwei ganze Zahlen vergleicht einen Ausdruck zu erstellen.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Operator "größere als" ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="liftToNull">
          <see langword="true" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="true" /> festzulegen, und <see langword="false" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="false" /> festzulegen.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer als"-Vergleich darstellt. Die implementierende Methode kann angegeben werden.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> Eigenschaft ist `true` und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> -Eigenschaft gleich `liftToNull`. Andernfalls sind sie beide `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, der den Operator "größer als" overloads der <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Wenn die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert; Darüber hinaus ist der Typ des Knotens zulässig <xref:System.Boolean> Wenn `liftToNull` ist `true` oder <xref:System.Boolean> Wenn `liftToNull` ist `false`:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist <xref:System.Boolean>.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist auf NULL festlegbar <xref:System.Boolean> Wenn `liftToNull` ist `true` oder <xref:System.Boolean> Wenn `liftToNull` ist `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />ist <see langword="null" /> und der Operator "größere als" ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer oder gleich"-Vergleich darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> Eigenschaft ist `true`. Andernfalls ist der Wert `false`. Die <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>-Eigenschaft ist immer `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` stellt einen benutzerdefinierten Typ, der den Operator "größer als oder gleich" überlädt die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Wenn die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist <xref:System.Boolean>:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist <xref:System.Boolean>.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der zwei ganze Zahlen vergleicht einen Ausdruck zu erstellen.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Operator "größere als oder gleich" ist nicht definiert, für <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="liftToNull">
          <see langword="true" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="true" /> festzulegen, und <see langword="false" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="false" /> festzulegen.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer oder gleich"-Vergleich darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> Eigenschaft ist `true` und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> -Eigenschaft gleich `liftToNull`. Andernfalls sind sie beide `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` stellt einen benutzerdefinierten Typ, der den Operator "größer als oder gleich" überlädt die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Wenn die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert; Darüber hinaus ist der Typ des Knotens zulässig <xref:System.Boolean> Wenn `liftToNull` ist `true` oder <xref:System.Boolean> Wenn `liftToNull` ist `false`:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist <xref:System.Boolean>.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist auf NULL festlegbar <xref:System.Boolean> Wenn `liftToNull` ist `true` oder <xref:System.Boolean> Wenn `liftToNull` ist `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die darstellende Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> ist <see langword="null" />, und der „größer oder gleich“-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft festgelegt werden soll.</param>
        <param name="ifTrue">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die einen bedingten Block mit einer <see langword="if" />-Anweisung darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> ist und die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft auf die angegebenen Werte festgelegt sind. Die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft ist auf den Standardausdruck festgelegt, und der Typ der resultierenden <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die von dieser Methode zurückgegeben wird, ist <see cref="T:System.Void" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, der einen bedingten Block darstellt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft festgelegt werden soll.</param>
        <param name="ifTrue">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft festgelegt werden soll.</param>
        <param name="ifFalse">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die einen bedingten Block mit <see langword="if" />- und <see langword="else" />-Anweisungen darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ConditionalExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> und <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> auf die angegebenen Werte festgelegt sind. Der Typ der resultierenden <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die von dieser Methode zurückgegeben wird, ist <see cref="T:System.Void" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, der einen bedingten Block darstellt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Ein zu erhöhendes <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Erhöhen des Ausdruckswerts um 1 darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den erhöhten Ausdruckswert darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Ausdruck ist funktionsfähig und ändert sich nicht auf den Wert des Objekts, das an sie übergeben wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie auf einen Ausdruck zu erstellen, der einen Inkrement Vorgang darstellt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Ein zu erhöhendes <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Erhöhen des Ausdrucks um 1 darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den erhöhten Ausdruckswert darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Ausdruck ist funktionsfähig und ändert sich nicht auf den Wert des Objekts, das an sie übergeben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, das den anzuwendenden Delegaten oder Lambda-Ausdruck darstellt.</param>
        <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> mit den <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente darstellen, auf die der Delegat oder Lambda-Ausdruck angewendet wird.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das einen Delegaten oder einen Lambda-Ausdruck auf eine Liste von Argumentausdrücken anwendet.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das den angegebenen Delegaten oder Lambda-Ausdruck auf die bereitgestellten Argumente anwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.InvocationExpression> stellt dar, den Rückgabetyp des Delegaten, die von dargestellte `expression`. Geben Sie ein.  
  
 Die <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.InvocationExpression> ist leer Wenn `arguments` ist `null`. Andernfalls enthält die gleichen Elemente wie `arguments` , wobei einige dieser <xref:System.Linq.Expressions.Expression> Objekte möglicherweise *in Anführungszeichen*.  
  
> [!NOTE]
>  Ein Element wird in Anführungszeichen eingeschlossen werden nur dann, wenn der entsprechende Parameter eines Delegaten dargestellt `expression` ist vom Typ <xref:System.Linq.Expressions.Expression>. Zitieren bedeutet, dass das Element umschlossen ist ein <xref:System.Linq.Expressions.ExpressionType.Quote> Knoten. Der resultierende Knoten ist ein <xref:System.Linq.Expressions.UnaryExpression> , deren <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> Eigenschaft ist für das Element der `arguments`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> Methode zum Erstellen einer <xref:System.Linq.Expressions.InvocationExpression> , die den Aufruf eines Lambdaausdrucks mit angegebenen Argumenten darstellt.  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. Typ stellt keinen Delegattyp dar oder ein <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft eines Elements <paramref name="arguments" /> abfragesichtausdrucks kann nicht in den Typ des entsprechenden Parameters des Delegaten dargestellte <paramref name="expression" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="arguments" />enthält nicht die gleiche Anzahl von Elementen wie die Liste der Parameter für den Delegaten dargestellte <paramref name="expression" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, das den anzuwendenden Delegaten oder Lambda-Ausdruck darstellt.</param>
        <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente darstellen, auf die der Delegat oder der Lambda-Ausdruck angewendet wird.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das einen Delegaten oder einen Lambda-Ausdruck auf eine Liste von Argumentausdrücken anwendet.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das den angegebenen Delegaten oder Lambda-Ausdruck auf die bereitgestellten Argumente anwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.InvocationExpression> stellt dar, den Rückgabetyp des Delegaten, die von dargestellte `expression`. Geben Sie ein.  
  
 Die <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.InvocationExpression> ist leer Wenn `arguments` ist `null`. Andernfalls enthält die gleichen Elemente wie `arguments` , wobei einige dieser <xref:System.Linq.Expressions.Expression> Objekte möglicherweise *in Anführungszeichen*.  
  
> [!NOTE]
>  Ein Element wird in Anführungszeichen eingeschlossen werden nur dann, wenn der entsprechende Parameter eines Delegaten dargestellt `expression` ist vom Typ <xref:System.Linq.Expressions.Expression>. Zitieren bedeutet, dass das Element umschlossen ist ein <xref:System.Linq.Expressions.ExpressionType.Quote> Knoten. Der resultierende Knoten ist ein <xref:System.Linq.Expressions.UnaryExpression> , deren <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> Eigenschaft ist für das Element der `arguments`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> Methode zum Erstellen einer <xref:System.Linq.Expressions.InvocationExpression> , die den Aufruf eines Lambdaausdrucks mit angegebenen Argumenten darstellt.  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. Typ stellt keinen Delegattyp dar oder ein <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft eines Elements <paramref name="arguments" /> abfragesichtausdrucks kann nicht in den Typ des entsprechenden Parameters des Delegaten dargestellte <paramref name="expression" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="arguments" />enthält nicht die gleiche Anzahl von Elementen wie die Liste der Parameter für den Delegaten dargestellte <paramref name="expression" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck False ergibt.</summary>
        <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck False ergibt.</summary>
        <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck True ergibt.</summary>
        <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck True ergibt.</summary>
        <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.LabelTarget" />, das eine Bezeichnung mit Void-Typ und ohne Namen darstellt.</summary>
        <returns>Die neue <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einen Ausdruck zu erstellen, enthält ein <xref:System.Linq.Expressions.LabelTarget> Objekt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, dem diese <see cref="T:System.Linq.Expressions.LabelExpression" /> zugeordnet wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LabelExpression" />, die eine Bezeichnung ohne Standardwert darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.LabelExpression" /> ohne Standardwert.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Sprungmarke.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.LabelTarget" />, das eine Bezeichnung mit Void-Typ und dem angegebenen Namen darstellt.</summary>
        <returns>Die neue <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der Werttyp, der beim Springen zur Bezeichnung übergeben wird.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.LabelTarget" />, das eine Bezeichnung mit dem angegebenen Typ darstellt.</summary>
        <returns>Die neue <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein <xref:System.Linq.Expressions.LabelTarget> Objekt in einem Loop-Ausdruck.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, dem diese <see cref="T:System.Linq.Expressions.LabelExpression" /> zugeordnet wird.</param>
        <param name="defaultValue">Der Wert dieses <see cref="T:System.Linq.Expressions.LabelExpression" />, wenn die Bezeichnung über die normale Ablaufsteuerung erreicht wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LabelExpression" />, die eine Bezeichnung mit dem angegebenen Standardwert darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.LabelExpression" /> mit dem angegebenen Standardwert.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Werttyp, der beim Springen zur Bezeichnung übergeben wird.</param>
        <param name="name">Der Name der Sprungmarke.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.LabelTarget" />, das eine Bezeichnung mit dem angegebenen Typ und Namen darstellt.</summary>
        <returns>Die neue <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="parameters">Ein Array von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LambdaExpression" />, indem zuerst ein Delegattyp konstruiert wird.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `parameters` -Parameter darf nicht mehr als 16 Elemente aufweisen.  
  
 Die Elemente der `parameters` muss identisch sein, Verweis auf die Parameter-Ausdrücke in `body`.  
  
 Diese Methode erstellt einen geeigneten Delegattyp eines der `System.Func` generischen Delegaten. Es übergibt dann den Delegattyp in eines der <xref:System.Linq.Expressions.ExpressionType.Lambda> Factorymethoden zum Erstellen einer <xref:System.Linq.Expressions.LambdaExpression>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens ein Element von <paramref name="parameters" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameters" />enthält mehr als 16-Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
        <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
        <param name="parameters">Ein Array, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, die zum Auffüllen der <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung verwendet werden.</param>
        <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="name">Der Name für den Lambdaausdruck. Wird zum Ausgeben von Debuginformationen verwendet.</param>
        <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">Ein <see cref="T:System.Type" />, das eine Delegatsignatur für das Lambda darstellt.</param>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LambdaExpression" />, indem zuerst ein Delegattyp konstruiert wird. Kann verwendet werden, wenn der Delegattyp zur Kompilierzeit nicht bekannt ist.</summary>
        <returns>Ein Objekt, das einen Lambdaausdruck darstellt, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Objekt, das von dieser Funktion zurückgegeben wird, ist vom Typ <xref:System.Linq.Expressions.Expression%601>. Die <xref:System.Linq.Expressions.LambdaExpression> Typ wird verwendet, um das zurückgegebene Objekt dar, da es sich bei der konkrete Typ des Lambda-Ausdruck zur Kompilierzeit nicht bekannt ist.  
  
 Die Anzahl von Parametern für den Delegattyp dargestellte`delegateType` muss gleich der Länge des `parameters`.  
  
 Die Elemente der `parameters` muss identisch sein, Verweis auf die Parameter-Ausdrücke in `body`.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden Objekts gleich `delegateType`. Wenn `parameters` ist `null`die <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> -Eigenschaft des resultierenden Objekts ist eine leere Auflistung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einen Ausdruck zu erstellen, der einen Lambda-Ausdruck darstellt, der das übergebene Argument 1 hinzufügt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="delegateType" /> oder <paramref name="body" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens ein <paramref name="parameters" />-Element ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" />stellt keinen Delegattyp dar.  
  
 - oder -   
  
 <paramref name="body" />. Typ darstellt, einen Typ, der nicht der Rückgabetyp des Delegattyps dargestellte <paramref name="delegateType" />.  
  
 - oder -   
  
 <paramref name="parameters" />enthält nicht die gleiche Anzahl von Elementen wie die Liste der Parameter für den Delegattyp dargestellte <paramref name="delegateType" />.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft eines Elements <paramref name="parameters" /> abfragesichtausdrucks kann nicht aus dem Typ des entsprechenden Parametertyps des Delegattyps dargestellte <paramref name="delegateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">Ein <see cref="T:System.Type" />, das eine Delegatsignatur für das Lambda darstellt.</param>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="parameters">Ein Array von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LambdaExpression" />, indem zuerst ein Delegattyp konstruiert wird. Kann verwendet werden, wenn der Delegattyp zur Kompilierzeit nicht bekannt ist.</summary>
        <returns>Ein Objekt, das einen Lambdaausdruck darstellt, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Objekt, das von dieser Funktion zurückgegeben wird, ist vom Typ <xref:System.Linq.Expressions.Expression%601>. Die <xref:System.Linq.Expressions.LambdaExpression> Typ wird verwendet, um das zurückgegebene Objekt dar, da es sich bei der konkrete Typ des Lambda-Ausdruck zur Kompilierzeit nicht bekannt ist.  
  
 Die Anzahl von Parametern für den Delegattyp dargestellte `delegateType` muss gleich der Länge des `parameters`.  
  
 Die Elemente der `parameters` muss identisch sein, Verweis auf die Parameter-Ausdrücke in `body`.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden Objekts gleich `delegateType`. Wenn `parameters` ist `null`die <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> -Eigenschaft des resultierenden Objekts ist eine leere Auflistung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="delegateType" /> oder <paramref name="body" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens ein <paramref name="parameters" />-Element ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" />stellt keinen Delegattyp dar.  
  
 - oder -   
  
 <paramref name="body" />. Typ darstellt, einen Typ, der nicht der Rückgabetyp des Delegattyps dargestellte <paramref name="delegateType" />.  
  
 - oder -   
  
 <paramref name="parameters" />enthält nicht die gleiche Anzahl von Elementen wie die Liste der Parameter für den Delegattyp dargestellte <paramref name="delegateType" />.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft eines Elements <paramref name="parameters" /> abfragesichtausdrucks kann nicht aus dem Typ des entsprechenden Parametertyps des Delegattyps dargestellte <paramref name="delegateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="name">Der Name für den Lambdaausdruck. Wird zum Ausgeben von Debuginformationen verwendet.</param>
        <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
        <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, die die Delegatsignatur für das Lambda darstellt.</param>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
        <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, die die Delegatsignatur für das Lambda darstellt.</param>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
        <param name="parameters">Ein Array, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, die zum Auffüllen der <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung verwendet werden.</param>
        <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, die die Delegatsignatur für das Lambda darstellt.</param>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="name">Der Name für den Lambdaausdruck. Wird zum Ausgeben von Debuginformationen verwendet.</param>
        <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, die die Delegatsignatur für das Lambda darstellt.</param>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="name">Der Name für den Lambdaausdruck. Wird zum Ausgeben von Debuginformationen verwendet.</param>
        <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
        <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Ein Delegattyp.</typeparam>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl von Parametern für den Delegattyp `TDelegate` muss gleich der Anzahl der Elemente im `parameters`.  
  
 Die Elemente der `parameters` muss identisch sein, Verweis auf die Parameter-Ausdrücke in `body`.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden Objekts repräsentiert den Typ `TDelegate`. Wenn `parameters` ist `null`die <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> -Eigenschaft des resultierenden Objekts ist eine leere Auflistung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens ein <paramref name="parameters" />-Element ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="TDelegate" />ein Delegattyp ist.  
  
 - oder -   
  
 <paramref name="body" />. Typ darstellt, einen Typ, der nicht der Rückgabetyp der <paramref name="TDelegate" />.  
  
 - oder -   
  
 <paramref name="parameters" />enthält nicht die gleiche Anzahl von Elementen wie die Liste der Parameter für <paramref name="TDelegate" />.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft eines Elements <paramref name="parameters" /> abfragesichtausdrucks kann nicht vom Typ des entsprechenden Parametertyp der <paramref name="TDelegate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Ein Delegattyp.</typeparam>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="parameters">Ein Array von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl von Parametern für den Delegattyp `TDelegate` muss gleich der Anzahl der Elemente im `parameters`.  
  
 Die Elemente der `parameters` muss identisch sein, Verweis auf die Parameter-Ausdrücke in`body`.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden Objekts repräsentiert den Typ `TDelegate`. Wenn `parameters` ist `null`die <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> -Eigenschaft des resultierenden Objekts ist eine leere Auflistung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens ein <paramref name="parameters" />-Element ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="TDelegate" />ein Delegattyp ist.  
  
 - oder -   
  
 <paramref name="body" />. Typ darstellt, einen Typ, der nicht der Rückgabetyp der <paramref name="TDelegate" />.  
  
 - oder -   
  
 <paramref name="parameters" />enthält nicht die gleiche Anzahl von Elementen wie die Liste der Parameter für <paramref name="TDelegate" />.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft eines Elements <paramref name="parameters" /> abfragesichtausdrucks kann nicht vom Typ des entsprechenden Parametertyp der <paramref name="TDelegate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Der Delegattyp.</typeparam>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
        <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Der Delegattyp.</typeparam>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
        <param name="parameters">Ein Array, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, die zum Auffüllen der <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung verwendet werden.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Der Delegattyp.</typeparam>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="name">Der Name des Lambdaausdrucks. Wird zum Generieren von Debuginformationen verwendet.</param>
        <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Der Delegattyp.</typeparam>
        <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
        <param name="name">Der Name des Lambdaausdrucks. Wird zum Generieren von Debuginformationen verwendet.</param>
        <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
        <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Linksschiebeoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die ausgewählte implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Left Shift-Operator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ ist ein integraler Typ (eines <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, oder die entsprechenden Typen mit Nullwert) und `right`. Der Typ ist <xref:System.Int32>, die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des der vordefinierten Left Shift-Operator.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des der vordefinierten Left Shift-Operator entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Left Shift-Operator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Linksschiebeoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die ausgewählte implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Left Shift-Operator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ ist ein integraler Typ (eines <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, oder die entsprechenden Typen mit Nullwert) und `right`. Der Typ ist <xref:System.Int32>, die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des der vordefinierten Left Shift-Operator.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des der vordefinierten Left Shift-Operator entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />ist <see langword="null" /> und der Left Shift-Operator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Linksschiebe-Zuweisungsoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Linksschiebe-Zuweisungsoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Linksschiebe-Zuweisungsoperation darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Kleiner als"-Vergleich darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> Eigenschaft ist `true`. Andernfalls ist der Wert `false`. Die <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>-Eigenschaft ist immer `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die implementierende Methode für den Vorgang wird basierend auf den folgenden Regeln ausgewählt:  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, der den Operator "kleiner als" overloads der <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Wenn die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist <xref:System.Boolean>:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist <xref:System.Boolean>.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der zwei ganze Zahlen vergleicht einen Ausdruck zu erstellen.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Operator "kleiner als" ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="liftToNull">
          <see langword="true" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="true" /> festzulegen, und <see langword="false" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="false" /> festzulegen.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Kleiner als"-Vergleich darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> Eigenschaft ist `true` und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> -Eigenschaft gleich `liftToNull`. Andernfalls sind sie beide `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, der den Operator "kleiner als" overloads der <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Wenn die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert; Darüber hinaus ist der Typ des Knotens zulässig <xref:System.Boolean> Wenn `liftToNull` ist `true` oder <xref:System.Boolean> Wenn `liftToNull` ist `false`:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist <xref:System.Boolean>.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist auf NULL festlegbar <xref:System.Boolean> Wenn `liftToNull` ist `true` oder <xref:System.Boolean> Wenn `liftToNull` ist `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> ist <see langword="null" />, und der „Kleiner als“-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Kleiner oder gleich"-Vergleich darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> Eigenschaft ist `true`. Andernfalls ist der Wert `false`. Die <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>-Eigenschaft ist immer `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` stellt einen benutzerdefinierten Typ, der den Operator "kleiner oder gleich" überlädt die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Wenn die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist <xref:System.Boolean>:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist <xref:System.Boolean>.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, der zwei ganze Zahlen vergleicht einen Ausdruck zu erstellen.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Operator "kleiner oder gleich" ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="liftToNull">
          <see langword="true" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="true" /> festzulegen, und <see langword="false" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="false" /> festzulegen.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Kleiner oder gleich"-Vergleich darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> Eigenschaft ist `true` und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> -Eigenschaft gleich `liftToNull`. Andernfalls sind sie beide `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` stellt einen benutzerdefinierten Typ, der den Operator "kleiner oder gleich" überlädt die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Wenn die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert; Darüber hinaus ist der Typ des Knotens zulässig <xref:System.Boolean> Wenn `liftToNull` ist `true` oder <xref:System.Boolean> Wenn `liftToNull` ist `false`:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist <xref:System.Boolean>.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist auf NULL festlegbar <xref:System.Boolean> Wenn `liftToNull` ist `true` oder <xref:System.Boolean> Wenn `liftToNull` ist `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />ist <see langword="null" /> und der Operator "kleiner oder gleich" ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member">Eine <see cref="T:System.Reflection.MemberInfo" />, die ein Feld oder eine Eigenschaft darstellt, auf die die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft festgelegt werden soll.</param>
        <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ElementInit" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem der Member ein Feld oder eine Eigenschaft ist.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> ist und die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens ein Element von <paramref name="initializers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" />stellt keine Felds oder einer Eigenschaft dar.  
  
 - oder -   
  
 Die <see cref="P:System.Reflection.FieldInfo.FieldType" /> oder <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> des Felds oder der Eigenschaft, die <paramref name="member" /> darstellt, implementiert nicht <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">Eine <see cref="T:System.Reflection.MemberInfo" />, die ein Feld oder eine Eigenschaft darstellt, auf die die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft festgelegt werden soll.</param>
        <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.ElementInit" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem der Member ein Feld oder eine Eigenschaft ist.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> ist und die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens ein Element von <paramref name="initializers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" />stellt keine Felds oder einer Eigenschaft dar.  
  
 - oder -   
  
 Die <see cref="P:System.Reflection.FieldInfo.FieldType" /> oder <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> des Felds oder der Eigenschaft, die <paramref name="member" /> darstellt, implementiert nicht <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
        <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ElementInit" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt auf der Grundlage einer angegebenen Eigenschaftenaccessormethode ein <see cref="T:System.Linq.Expressions.MemberListBinding" />-Objekt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> ist, die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.MemberInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird, und <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> mit den Elementen von <paramref name="initializers" /> aufgefüllt ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens ein Element von <paramref name="initializers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> stellt keine Eigenschaftenzugriffsmethode dar.  
  
 - oder -   
  
 Die <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> der Eigenschaft, die die Methode szenariobeschreibungen <paramref name="propertyAccessor" /> greift nicht implementiert <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
        <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.ElementInit" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt auf der Grundlage einer angegebenen Eigenschaftenaccessormethode ein <see cref="T:System.Linq.Expressions.MemberListBinding" />-Objekt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> ist, die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.MemberInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird, und <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> mit den Elementen von <paramref name="initializers" /> aufgefüllt ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens ein Element von <paramref name="initializers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> stellt keine Eigenschaftenzugriffsmethode dar.  
  
 - oder -   
  
 Die <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> der Eigenschaft, die die Methode szenariobeschreibungen <paramref name="propertyAccessor" /> greift nicht implementiert <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
        <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ElementInit" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die die angegebenen <see cref="T:System.Linq.Expressions.ElementInit" />-Objekte verwendet, um eine Auflistung zu initialisieren.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> ist und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `newExpression` muss einen Typ, der implementiert darstellen <xref:System.Collections.IEnumerable>.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.ListInitExpression> gleich `newExpression`. Geben Sie ein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> Methode zum Erstellen einer <xref:System.Linq.Expressions.ListInitExpression> , die die Initialisierung einer neuen Wörterbuchinstanz mit zwei Schlüssel-Wert-Paare darstellt.  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> oder <paramref name="initializers" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens ein Element von <paramref name="initializers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />.Type implementiert nicht <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
        <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die eine Methode mit dem Namen "Add" verwendet, um einer Auflistung Elemente hinzuzufügen.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `newExpression` muss einen Typ, der implementiert darstellen <xref:System.Collections.IEnumerable>.  
  
 Um dieser Überladung der <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`. Typ oder den Basistyp muss eine einzelne Methode namens "Add" (Groß-/Kleinschreibung beachten) deklarieren, die genau ein Argument akzeptiert. Der Typ des Arguments muss vom Typ dargestellte zuweisbar sein der <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft des ersten Elements der `initializers`.  
  
 Die <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> -Eigenschaft des zurückgegebenen <xref:System.Linq.Expressions.ListInitExpression> enthält ein Element vom Typ <xref:System.Linq.Expressions.ElementInit> für jedes Element der `initializers`. Die <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Eigenschaft jedes Elements des <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> ist eine singletonauflistung, die das entsprechende Element des enthält `initializers`. Die <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Eigenschaft jedes Elements des <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> stellt die Add-Methode, die auf ermittelt wurde `newExpression`. Typ oder den Basistyp.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.ListInitExpression> gleich `newExpression`. Geben Sie ein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> oder <paramref name="initializers" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens ein Element von <paramref name="initializers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />.Type implementiert nicht <see cref="T:System.Collections.IEnumerable" />.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine Instanzmethode namens „Add“ (ohne Beachtung der Groß-/Kleinschreibung) in <paramref name="newExpression" />.Type oder dessen Basistyp deklariert.  
  
 - oder -   
  
 Die Add-Methode in <paramref name="newExpression" />.Type oder dessen Basistyp nimmt nicht genau ein Argument entgegen.  
  
 - oder -   
  
 Der durch die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft dargestellte Typ des ersten Elements von <paramref name="initializers" /> lässt sich nicht dem Argumenttyp der Add-Methode in <paramref name="newExpression" />.Type oder dessen Basistyp zuweisen.  
  
 - oder -   
  
 Mehrere argumentkompatible Methoden namens „Add“ (ohne Beachtung der Groß-/Kleinschreibung) sind in <paramref name="newExpression" />.Type und/oder dessen Basistyp vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
        <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.ElementInit" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die die angegebenen <see cref="T:System.Linq.Expressions.ElementInit" />-Objekte verwendet, um eine Auflistung zu initialisieren.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> ist und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `newExpression` muss einen Typ, der implementiert darstellen <xref:System.Collections.IEnumerable>.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.ListInitExpression> gleich `newExpression`. Geben Sie ein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> Methode zum Erstellen einer <xref:System.Linq.Expressions.ListInitExpression> , die die Initialisierung einer neuen Wörterbuchinstanz mit zwei Schlüssel-Wert-Paare darstellt.  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> oder <paramref name="initializers" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens ein Element von <paramref name="initializers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />.Type implementiert nicht <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
        <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die eine Methode mit dem Namen "Add" verwendet, um einer Auflistung Elemente hinzuzufügen.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `newExpression` muss einen Typ, der implementiert darstellen <xref:System.Collections.IEnumerable>.  
  
 Um dieser Überladung der <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`. Typ oder den Basistyp muss eine einzelne Methode namens "Add" (Groß-/Kleinschreibung beachten) deklarieren, die genau ein Argument akzeptiert. Der Typ des Arguments muss vom Typ dargestellte zuweisbar sein der <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft des ersten Elements der `initializers`.  
  
 Die <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> -Eigenschaft des zurückgegebenen <xref:System.Linq.Expressions.ListInitExpression> enthält ein Element vom Typ <xref:System.Linq.Expressions.ElementInit> für jedes Element der `initializers`. Die <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Eigenschaft jedes Elements des <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> ist eine singletonauflistung, die das entsprechende Element des enthält `initializers`. Die <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Eigenschaft jedes Elements des <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> stellt die Add-Methode, die auf ermittelt wurde `newExpression`. Typ oder den Basistyp.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.ListInitExpression> gleich `newExpression`. Geben Sie ein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> oder <paramref name="initializers" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens ein Element von <paramref name="initializers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />.Type implementiert nicht <see cref="T:System.Collections.IEnumerable" />.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine Instanzmethode namens „Add“ (ohne Beachtung der Groß-/Kleinschreibung) in <paramref name="newExpression" />.Type oder dessen Basistyp deklariert.  
  
 - oder -   
  
 Die Add-Methode in <paramref name="newExpression" />.Type oder dessen Basistyp nimmt nicht genau ein Argument entgegen.  
  
 - oder -   
  
 Der durch die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft dargestellte Typ des ersten Elements von <paramref name="initializers" /> lässt sich nicht dem Argumenttyp der Add-Methode in <paramref name="newExpression" />.Type oder dessen Basistyp zuweisen.  
  
 - oder -   
  
 Mehrere argumentkompatible Methoden namens „Add“ (ohne Beachtung der Groß-/Kleinschreibung) sind in <paramref name="newExpression" />.Type und/oder dessen Basistyp vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
        <param name="addMethod">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Instanzmethode namens "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) darstellt, die einer Auflistung ein Element hinzufügt.</param>
        <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die eine angegebene Methode verwendet, um einer Auflistung Elemente hinzuzufügen.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `newExpression` muss einen Typ, der implementiert darstellen <xref:System.Collections.IEnumerable>.  
  
 Wenn `addMethod` ist `null`, `newExpression`. Typ oder den Basistyp muss eine einzelne Methode namens "Add" (Groß-/Kleinschreibung beachten) deklarieren, die genau ein Argument akzeptiert. Wenn `addMethod` nicht `null`, es muss eine Instanzmethode namens "Add" (Groß-/Kleinschreibung beachten) mit genau einen Parameter dar. Der Typ von dargestellt die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft jedes Elements des `initializers` muss dem Argumenttyp der Add-Methode zugewiesen werden können.  
  
 Die <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> -Eigenschaft des zurückgegebenen <xref:System.Linq.Expressions.ListInitExpression> enthält ein Element vom Typ <xref:System.Linq.Expressions.ElementInit> für jedes Element der `initializers`. Die <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Eigenschaft jedes Elements des <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> ist eine singletonauflistung, die das entsprechende Element des enthält `initializers`. Die <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Eigenschaft jedes Elements des <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> gleich `addMethod`.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.ListInitExpression> gleich `newExpression`. Geben Sie ein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> oder <paramref name="initializers" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens ein Element von <paramref name="initializers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />.Type implementiert nicht <see cref="T:System.Collections.IEnumerable" />.  
  
 - oder -   
  
 <paramref name="addMethod" />ist kein <see langword="null" /> und es stellt eine Instanzmethode namens "Add" (Groß-/Kleinschreibung beachten), die genau ein Argument dar.  
  
 - oder -   
  
 <paramref name="addMethod" />ist nicht <see langword="null" /> und der Typ von dargestellt die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft von einem oder mehreren Elementen der <paramref name="initializers" /> abfragesichtausdrucks kann nicht in den Argumenttyp der Methode, die <paramref name="addMethod" /> darstellt.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="addMethod" />ist <see langword="null" /> und keine Instanzmethode mit dem Namen "Hinzufügen", die einen kompatiblen Typ Argument vorhanden ist, auf <paramref name="newExpression" />. Typ oder den Basistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
        <param name="addMethod">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Instanzmethode darstellt, die ein Argument akzeptiert und einer Auflistung ein Element hinzufügt.</param>
        <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die eine angegebene Methode verwendet, um einer Auflistung Elemente hinzuzufügen.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `newExpression` muss einen Typ, der implementiert darstellen <xref:System.Collections.IEnumerable>.  
  
 Wenn `addMethod` ist `null`, `newExpression`. Typ oder den Basistyp muss eine einzelne Methode namens "Add" (Groß-/Kleinschreibung beachten) deklarieren, die genau ein Argument akzeptiert. Wenn `addMethod` nicht `null`, es muss eine Instanzmethode namens "Add" (Groß-/Kleinschreibung beachten) mit genau einen Parameter dar. Der Typ von dargestellt die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft jedes Elements des `initializers` muss dem Argumenttyp der Add-Methode zugewiesen werden können.  
  
 Die <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> -Eigenschaft des zurückgegebenen <xref:System.Linq.Expressions.ListInitExpression> enthält ein Element vom Typ <xref:System.Linq.Expressions.ElementInit> für jedes Element der `initializers`. Die <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Eigenschaft jedes Elements des <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> ist eine singletonauflistung, die das entsprechende Element des enthält `initializers`. Die <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Eigenschaft jedes Elements des <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> gleich `addMethod`.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.ListInitExpression> gleich `newExpression`. Geben Sie ein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> oder <paramref name="initializers" /> ist <see langword="null" />.  
  
 - oder -   
  
 Mindestens ein Element von <paramref name="initializers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />.Type implementiert nicht <see cref="T:System.Collections.IEnumerable" />.  
  
 - oder -   
  
 <paramref name="addMethod" />ist kein <see langword="null" /> und es stellt eine Instanzmethode namens "Add" (Groß-/Kleinschreibung beachten), die genau ein Argument dar.  
  
 - oder -   
  
 <paramref name="addMethod" />ist nicht <see langword="null" /> und der Typ von dargestellt die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft von einem oder mehreren Elementen der <paramref name="initializers" /> abfragesichtausdrucks kann nicht in den Argumenttyp der Methode, die <paramref name="addMethod" /> darstellt.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="addMethod" />ist <see langword="null" /> und keine Instanzmethode mit dem Namen "Hinzufügen", die einen kompatiblen Typ Argument vorhanden ist, auf <paramref name="newExpression" />. Typ oder den Basistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">Der Text der Schleife.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LoopExpression" /> mit dem angegebenen Text.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">Der Text der Schleife.</param>
        <param name="break">Das vom Schleifentext verwendete Break-Ziel.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LoopExpression" /> mit dem angegebenen Text und Break-Ziel.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einen Blockausdruck erstellen, enthält ein <xref:System.Linq.Expressions.LoopExpression> Objekt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">Der Text der Schleife.</param>
        <param name="break">Das vom Schleifentext verwendete Break-Ziel.</param>
        <param name="continue">Das vom Schleifentext verwendete Continue-Ziel.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LoopExpression" /> mit dem angegebenen Text.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType">Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der den Typ der binären Operation angibt.</param>
        <param name="left">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den linken Operanden darstellt.</param>
        <param name="right">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den rechten Operanden darstellt.</param>
        <summary>Erstellt bei gegebenem linken und rechten Operanden durch Aufrufen einer geeigneten Factorymethode eine <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
        <returns>Der <see cref="T:System.Linq.Expressions.BinaryExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `binaryType` Parameter bestimmt, welche <xref:System.Linq.Expressions.BinaryExpression> Factorymethode, die diese Methode aufruft. Z. B. wenn `binaryType` ist <xref:System.Linq.Expressions.ExpressionType.Subtract>, diese Methode ruft <xref:System.Linq.Expressions.Expression.Subtract%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> Methode zum Erstellen einer <xref:System.Linq.Expressions.BinaryExpression> , der die Subtraktion von eine Zahl aus einer anderen darstellt.  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="binaryType" />Knoten mit einem binären Ausdruck entspricht.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType">Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der den Typ der binären Operation angibt.</param>
        <param name="left">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den linken Operanden darstellt.</param>
        <param name="right">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den rechten Operanden darstellt.</param>
        <param name="liftToNull">
          <see langword="true" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="true" /> festzulegen, und <see langword="false" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="false" /> festzulegen.</param>
        <param name="method">Eine <see cref="T:System.Reflection.MethodInfo" />, die die implementierende Methode angibt.</param>
        <summary>Erstellt bei gegebenem linken und rechten Operanden sowie gegebener implementierender Methode eine <see cref="T:System.Linq.Expressions.BinaryExpression" /> durch Aufrufen der geeigneten Factorymethode.</summary>
        <returns>Der <see cref="T:System.Linq.Expressions.BinaryExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `binaryType` Parameter bestimmt, welche <xref:System.Linq.Expressions.BinaryExpression> Factorymethode, die diese Methode aufgerufen wird. Z. B. wenn `binaryType` ist <xref:System.Linq.Expressions.ExpressionType.Subtract>, diese Methode ruft <xref:System.Linq.Expressions.Expression.Subtract%2A>. Die `liftToNull` und `method` Parameter werden ignoriert, wenn die geeigneten Factorymethode keinen entsprechenden Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="binaryType" />Knoten mit einem binären Ausdruck entspricht.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType">Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der den Typ der binären Operation angibt.</param>
        <param name="left">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den linken Operanden darstellt.</param>
        <param name="right">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den rechten Operanden darstellt.</param>
        <param name="liftToNull">
          <see langword="true" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="true" /> festzulegen, und <see langword="false" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="false" /> festzulegen.</param>
        <param name="method">Eine <see cref="T:System.Reflection.MethodInfo" />, die die implementierende Methode angibt.</param>
        <param name="conversion">Eine <see cref="T:System.Linq.Expressions.LambdaExpression" />, die eine Typkonvertierungsfunktion darstellt. Dieser Parameter wird nur verwendet, wenn <c>BinaryType</c> ist <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> oder eine zusammengesetzte Zuweisung...</param>
        <summary>Erstellt bei gegebenem linken und rechten Operanden sowie gegebener implementierender Methode und Typkonvertierungsfunktion eine <see cref="T:System.Linq.Expressions.BinaryExpression" /> durch Aufrufen der geeigneten Factorymethode.</summary>
        <returns>Der <see cref="T:System.Linq.Expressions.BinaryExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `binaryType` Parameter bestimmt, welche <xref:System.Linq.Expressions.BinaryExpression> Factorymethode, die diese Methode aufgerufen wird. Z. B. wenn `binaryType` ist <xref:System.Linq.Expressions.ExpressionType.Subtract>, diese Methode ruft <xref:System.Linq.Expressions.Expression.Subtract%2A>. Die `liftToNull`, `method` und `conversion` Parameter werden ignoriert, wenn die geeigneten Factorymethode keinen entsprechenden Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="binaryType" />Knoten mit einem binären Ausdruck entspricht.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" /> von <see cref="T:System.Exception" />, der von diesem <see cref="T:System.Linq.Expressions.CatchBlock" /> behandelt wird.</param>
        <param name="variable">Eine <see cref="T:System.Linq.Expressions.ParameterExpression" />, die einen Verweis auf das von diesem Handler aufgefangene <see cref="T:System.Exception" />-Objekt darstellt.</param>
        <param name="body">Der Text der Catch-Anweisung.</param>
        <param name="filter">Der Text des <see cref="T:System.Exception" />-Filters.</param>
        <summary>Erstellt einen <see cref="T:System.Linq.Expressions.CatchBlock" />, der eine Catch-Anweisung mit den angegebenen Elementen darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `type`muss ungleich Null sein und mit dem Typ des `variable` (falls angegeben).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">Der Typ des vom <see cref="T:System.Runtime.CompilerServices.CallSite" /> verwendeten Delegaten.</param>
        <param name="binder">Der Laufzeitbinder für den dynamischen Vorgang.</param>
        <param name="arguments">Die Argumente des dynamischen Vorgangs.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.DynamicExpression" />, das einen dynamischen, vom bereitgestellten <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> gebundenen Vorgang darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.DynamicExpression" />, bei der <see cref="P:System.Linq.Expressions.Expression.NodeType" /> gleich <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> und <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Der Typ des vom <see cref="T:System.Runtime.CompilerServices.CallSite" /> verwendeten Delegaten.</param>
        <param name="binder">Der Laufzeitbinder für den dynamischen Vorgang.</param>
        <param name="arg0">Das Argument des dynamischen Vorgangs.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.DynamicExpression" />, die einen dynamischen, vom bereitgestellten <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> gebundenen Vorgang und ein Argument darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.DynamicExpression" />, bei der <see cref="P:System.Linq.Expressions.Expression.NodeType" /> gleich <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> und <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">Der Typ des vom <see cref="T:System.Runtime.CompilerServices.CallSite" /> verwendeten Delegaten.</param>
        <param name="binder">Der Laufzeitbinder für den dynamischen Vorgang.</param>
        <param name="arguments">Die Argumente des dynamischen Vorgangs.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.DynamicExpression" />, das einen dynamischen, vom bereitgestellten <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> gebundenen Vorgang darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.DynamicExpression" />, bei der <see cref="P:System.Linq.Expressions.Expression.NodeType" /> gleich <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> und <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Der Typ des vom <see cref="T:System.Runtime.CompilerServices.CallSite" /> verwendeten Delegaten.</param>
        <param name="binder">Der Laufzeitbinder für den dynamischen Vorgang.</param>
        <param name="arg0">Das erste Argument des dynamischen Vorgangs.</param>
        <param name="arg1">Das zweite Argument des dynamischen Vorgangs.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.DynamicExpression" />, die einen dynamischen, vom bereitgestellten <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> gebundenen Vorgang und zwei Argumente darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.DynamicExpression" />, bei der <see cref="P:System.Linq.Expressions.Expression.NodeType" /> gleich <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> und <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Der Typ des vom <see cref="T:System.Runtime.CompilerServices.CallSite" /> verwendeten Delegaten.</param>
        <param name="binder">Der Laufzeitbinder für den dynamischen Vorgang.</param>
        <param name="arg0">Das erste Argument des dynamischen Vorgangs.</param>
        <param name="arg1">Das zweite Argument des dynamischen Vorgangs.</param>
        <param name="arg2">Das dritte Argument des dynamischen Vorgangs.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.DynamicExpression" />, die einen dynamischen, vom bereitgestellten <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> gebundenen Vorgang und drei Argumente darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.DynamicExpression" />, bei der <see cref="P:System.Linq.Expressions.Expression.NodeType" /> gleich <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> und <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Der Typ des vom <see cref="T:System.Runtime.CompilerServices.CallSite" /> verwendeten Delegaten.</param>
        <param name="binder">Der Laufzeitbinder für den dynamischen Vorgang.</param>
        <param name="arg0">Das erste Argument des dynamischen Vorgangs.</param>
        <param name="arg1">Das zweite Argument des dynamischen Vorgangs.</param>
        <param name="arg2">Das dritte Argument des dynamischen Vorgangs.</param>
        <param name="arg3">Das vierte Argument des dynamischen Vorgangs.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.DynamicExpression" />, die einen dynamischen, vom bereitgestellten <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> gebundenen Vorgang und vier Argumente darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.DynamicExpression" />, bei der <see cref="P:System.Linq.Expressions.Expression.NodeType" /> gleich <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> und <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="kind">Die <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> des <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
        <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
        <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die einen Sprung der angegebenen <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> darstellt. Der beim Springen an die Bezeichnung übergebene Wert kann ebenfalls angegeben werden.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich <paramref name="kind" /> ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">Das Objekt, zu dem die Eigenschaft gehört. Sollte NULL sein, wenn die Eigenschaft <see langword="static" /> (<see langword="shared" /> in Visual Basic) ist.</param>
        <param name="indexer">Eine <see cref="T:System.Linq.Expressions.Expression" />, die die zu indizierende Eigenschaft darstellt.</param>
        <param name="arguments">Ein <c>IEnumerable&lt;Ausdruck&gt; </c> (<c>IEnumerable (Of Expression)</c> in Visual Basic), enthält die Argumente, die zum Indizieren der Eigenschaft verwendet werden.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, die den Zugriff auf eine indizierte Eigenschaft in einem Objekt darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das das Objekt darstellt, dem der Member angehört. Kann für statische Member NULL sein.</param>
        <param name="member">Die <see cref="T:System.Reflection.MemberInfo" />, die das Feld oder die Eigenschaft beschreibt, auf das bzw. die ein Zugriff erfolgen soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf ein Feld oder eine Eigenschaft darstellt.</summary>
        <returns>Der <see cref="T:System.Linq.Expressions.MemberExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, zum Erstellen einer <xref:System.Linq.Expressions.MemberExpression> , die Zugriff auf ein Feld oder eine Eigenschaft, je nach Art des darstellt `member`. Wenn `member` ist vom Typ <xref:System.Reflection.FieldInfo>, diese Methode ruft <xref:System.Linq.Expressions.Expression.Field%2A> zum Erstellen der <xref:System.Linq.Expressions.MemberExpression>. Wenn `member` ist vom Typ <xref:System.Reflection.PropertyInfo>, diese Methode ruft <xref:System.Linq.Expressions.Expression.Property%2A> zum Erstellen der <xref:System.Linq.Expressions.MemberExpression>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" />stellt keine Felds oder einer Eigenschaft dar.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Der Ergebnistyp des Try-Ausdrucks. Bei NULL müssen Text und alle Handler vom selben Typ sein.</param>
        <param name="body">Der Text des Try-Blocks.</param>
        <param name="finally">Der Text des Finally-Blocks. Übergeben Sie NULL, wenn dem Try-Block kein Finally-Block zugeordnet ist.</param>
        <param name="fault">Der Text des Fault-Blocks. Übergeben Sie NULL, wenn dem Try-Block kein Fault-Block zugeordnet ist.</param>
        <param name="handlers">Eine Auflistung von <see cref="T:System.Linq.Expressions.CatchBlock" />s, die die dem Try-Block zugeordneten Catch-Anweisungen darstellen.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit den angegebenen Elementen darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType">Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der den Typ der unären Operation angibt.</param>
        <param name="operand">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Operanden darstellt.</param>
        <param name="type">Der <see cref="T:System.Type" />, der den zu konvertierenden Typ angibt (übergeben Sie <see langword="null" />, wenn dies nicht benötigt wird).</param>
        <summary>Erstellt bei gegebenem Operanden eine <see cref="T:System.Linq.Expressions.UnaryExpression" /> durch Aufrufen der entsprechenden Factorymethode.</summary>
        <returns>Der <see cref="T:System.Linq.Expressions.UnaryExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `unaryType` Parameter bestimmt, welche <xref:System.Linq.Expressions.UnaryExpression> Factorymethode, die diese Methode aufruft. Z. B. wenn `unaryType` gleich <xref:System.Linq.Expressions.ExpressionType.Convert>, diese Methode ruft <xref:System.Linq.Expressions.Expression.Convert%2A>. Die `type`Parameter wird ignoriert, wenn es nicht für die Factory-Methode gilt, die aufgerufen wird.  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="operand" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="unaryType" />eine unäre Ausdrucksknoten entspricht nicht.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType">Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der den Typ der unären Operation angibt.</param>
        <param name="operand">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Operanden darstellt.</param>
        <param name="type">Der <see cref="T:System.Type" />, der den zu konvertierenden Typ angibt (übergeben Sie <see langword="null" />, wenn dies nicht benötigt wird).</param>
        <param name="method">Die <see cref="T:System.Reflection.MethodInfo" />, die die implementierende Methode darstellt.</param>
        <summary>Erstellt bei gegebenem Operanden und gegebener implementierenden Methode eine <see cref="T:System.Linq.Expressions.UnaryExpression" /> durch Aufrufen der entsprechenden Factorymethode.</summary>
        <returns>Der <see cref="T:System.Linq.Expressions.UnaryExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `unaryType` Parameter bestimmt, welche <xref:System.Linq.Expressions.UnaryExpression> Factorymethode, die diese Methode aufruft. Z. B. wenn `unaryType` gleich <xref:System.Linq.Expressions.ExpressionType.Convert>, diese Methode ruft <xref:System.Linq.Expressions.Expression.Convert%2A>. Die `type` und `method` Parameter werden ignoriert, wenn sie nicht für die Factory-Methode gelten, die aufgerufen wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="operand" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="unaryType" />eine unäre Ausdrucksknoten entspricht nicht.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member">Die <see cref="T:System.Reflection.MemberInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft festgelegt werden soll.</param>
        <param name="bindings">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, das die rekursive Initialisierung der Member eines Felds oder einer Eigenschaft darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> ist und die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `member` Parameter muss ein Feld oder eine Eigenschaft darstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> oder <paramref name="bindings" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" />stellt keine Felds oder einer Eigenschaft dar.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Eigenschaft eines Elements <paramref name="bindings" /> ein Mitglied der Typ des Felds oder der Eigenschaft stellt keinen dar, die <paramref name="member" /> darstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">Die <see cref="T:System.Reflection.MemberInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft festgelegt werden soll.</param>
        <param name="bindings">Ein Array von <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, das die rekursive Initialisierung der Member eines Felds oder einer Eigenschaft darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> ist und die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `member` Parameter muss ein Feld oder eine Eigenschaft darstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> oder <paramref name="bindings" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" />stellt keine Felds oder einer Eigenschaft dar.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Eigenschaft eines Elements <paramref name="bindings" /> ein Mitglied der Typ des Felds oder der Eigenschaft stellt keinen dar, die <paramref name="member" /> darstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">Die <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
        <param name="bindings">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, das die rekursive Initialisierung der Member eines Members darstellt, auf den durch eine Eigenschaftenaccessormethode zugegriffen wird.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> ist, die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird, und die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Eigenschaften auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> oder <paramref name="bindings" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> stellt keine Eigenschaftenzugriffsmethode dar.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Eigenschaft eines Elements <paramref name="bindings" /> stellt kein Element vom Typ der Eigenschaft zugegriffen wird, von der Methode dar, die <paramref name="propertyAccessor" /> darstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">Die <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
        <param name="bindings">Ein Array von <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, das die rekursive Initialisierung der Member eines Members darstellt, auf den durch eine Eigenschaftenaccessormethode zugegriffen wird.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> ist, die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird, und die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Eigenschaften auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> oder <paramref name="bindings" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> stellt keine Eigenschaftenzugriffsmethode dar.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Eigenschaft eines Elements <paramref name="bindings" /> stellt kein Element vom Typ der Eigenschaft zugegriffen wird, von der Methode dar, die <paramref name="propertyAccessor" /> darstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
        <param name="bindings">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Stellt einen Ausdruck dar, der ein neues Objekt erstellt und eine Eigenschaft des Objekts initialisiert.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MemberInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> ist und die <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MemberInitExpression> ist gleich der <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `newExpression`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einen Ausdruck, der ein neues Objekt erstellt und eine Eigenschaft des Objekts initialisiert.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> oder <paramref name="bindings" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Eigenschaft eines Elements <paramref name="bindings" /> stellt keinen Member des Typs dar, die <paramref name="newExpression" />. Geben Sie darstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
        <param name="bindings">Ein Array von <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MemberInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> ist und die <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MemberInitExpression> ist gleich der <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft `newExpression`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> Methode zum Erstellen einer <xref:System.Linq.Expressions.MemberInitExpression> , die die Initialisierung von zwei Elementen eines neuen Objekts darstellt.  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> oder <paramref name="bindings" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Eigenschaft eines Elements <paramref name="bindings" /> stellt keinen Member des Typs dar, die <paramref name="newExpression" />. Geben Sie darstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Restoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die ausgewählte implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Modulo-Operator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten Modulo-Operators.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten Modulo-Operators entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Modulo-Operator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Restoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die implementierende Methode für den Vorgang wird basierend auf den folgenden Regeln ausgewählt:  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Modulo-Operator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten Modulo-Operators.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten Modulo-Operators entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die darstellende Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> ist <see langword="null" />, und der Modulusoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine Restzuweisungsoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine Restzuweisungsoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine Restzuweisungsoperation darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation ohne Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die ausgewählte implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` stellt einen benutzerdefinierten Typ, der den Multiplikationsoperator überlädt die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des der vordefinierten Multiplikationsoperator.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des der vordefinierten Multiplikationsoperator entspricht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, der zwei Werte multipliziert.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Multiplikationsoperator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation ohne Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` stellt einen benutzerdefinierten Typ, der den Multiplikationsoperator überlädt die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des der vordefinierten Multiplikationsoperator.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des der vordefinierten Multiplikationsoperator entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />ist <see langword="null" /> und der Multiplikationsoperator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation mit Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die ausgewählte implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` stellt einen benutzerdefinierten Typ, der den Multiplikationsoperator überlädt die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des der vordefinierten Multiplikationsoperator.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des der vordefinierten Multiplikationsoperator entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Multiplikationsoperator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation mit Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` stellt einen benutzerdefinierten Typ, der den Multiplikationsoperator überlädt die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des der vordefinierten Multiplikationsoperator.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des der vordefinierten Multiplikationsoperator entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />ist <see langword="null" /> und der Multiplikationsoperator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die einen arithmetischen Negationsvorgang darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.UnaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> auf die implementierende Methode festgelegt ist. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie "false".  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `expression`. Typ ist ein vom benutzerdefinierten Typ, den unären Minusoperator, definiert, die <xref:System.Reflection.MethodInfo> , darstellt, der Operator ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `expression`. Ein numerischer Typ ist, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `expression`. Typ ist der Argumenttyp der implementierenden Methode zugeordnet werden kann, die Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `expression`. Typ ist ein Typ NULL-Werte zulassen, und der entsprechende Werttyp der NULL-gleich dem Argumenttyp der implementierenden Methode.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`, ist der Typ des Knotens `expression`. Geben Sie ein. Wenn `expression`. Typ: NULL-Werte zulässt, der Knoten nicht transformiert. Andernfalls ist der Knoten transformiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einen Ausdruck erstellt, der einen arithmetischen negationsvorgang darstellt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der unäre Operator wird nicht für definiert <paramref name="expression" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die einen arithmetischen Negationsvorgang darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.UnaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> auf die implementierende Methode festgelegt ist. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie "false".  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die ein Argument akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Wenn `expression`. Typ ist ein vom benutzerdefinierten Typ, den unären Minusoperator, definiert, die <xref:System.Reflection.MethodInfo> , darstellt, der Operator ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `expression`. Ein numerischer Typ ist, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `expression`. Typ ist der Argumenttyp der implementierenden Methode zugeordnet werden kann, die Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `expression`. Typ ist ein Typ NULL-Werte zulassen, und der entsprechende Werttyp der NULL-gleich dem Argumenttyp der implementierenden Methode.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`, ist der Typ des Knotens `expression`. Geben Sie ein. Wenn `expression`. Typ: NULL-Werte zulässt, der Knoten nicht transformiert. Andernfalls ist der Knoten transformiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" />ist kein <see langword="null" /> und die Methode dar, gibt <see langword="void" />, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic), oder ist nicht genau ein Argument annehmen.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />ist <see langword="null" /> und der unären Minusoperator ist nicht definiert <paramref name="expression" />. Geben Sie ein.  
  
 - oder -   
  
 <paramref name="expression" />. Typ (oder der entsprechende NULL-Typ, wenn es sich um einen Werttyp handelt) ist nicht zugewiesen werden, in den Argumenttyp der dargestellte Methode <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine arithmetische Negationsoperation mit Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.UnaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> auf die implementierende Methode festgelegt ist. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie "false".  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `expression`. Typ ist ein vom benutzerdefinierten Typ, den unären Minusoperator, definiert, die <xref:System.Reflection.MethodInfo> , darstellt, der Operator ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `expression`. Ein numerischer Typ ist, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `expression`. Typ ist der Argumenttyp der implementierenden Methode zugeordnet werden kann, die Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `expression`. Typ ist ein Typ NULL-Werte zulassen, und der entsprechende Werttyp der NULL-gleich dem Argumenttyp der implementierenden Methode.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`, ist der Typ des Knotens `expression`. Geben Sie ein. Wenn `expression`. Typ: NULL-Werte zulässt, der Knoten nicht transformiert. Andernfalls ist der Knoten transformiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der unäre Operator wird nicht für definiert <paramref name="expression" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine arithmetische Negationsoperation mit Überlaufprüfung darstellt. Die implementierende Methode kann angegeben werden.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.UnaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> auf die implementierende Methode festgelegt ist. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie "false".  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die ein Argument akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Wenn `expression`. Typ ist ein vom benutzerdefinierten Typ, den unären Minusoperator, definiert, die <xref:System.Reflection.MethodInfo> , darstellt, der Operator ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `expression`. Ein numerischer Typ ist, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `expression`. Typ ist der Argumenttyp der implementierenden Methode zugeordnet werden kann, die Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `expression`. Typ ist ein Typ NULL-Werte zulassen, und der entsprechende Werttyp der NULL-gleich dem Argumenttyp der implementierenden Methode.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`, ist der Typ des Knotens `expression`. Geben Sie ein. Wenn `expression`. Typ: NULL-Werte zulässt, der Knoten nicht transformiert. Andernfalls ist der Knoten transformiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" />ist kein <see langword="null" /> und die Methode dar, gibt <see langword="void" />, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic), oder ist nicht genau ein Argument annehmen.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />ist <see langword="null" /> und der unären Minusoperator ist nicht definiert <paramref name="expression" />. Geben Sie ein.  
  
 - oder -   
  
 <paramref name="expression" />. Typ (oder der entsprechende NULL-Typ, wenn es sich um einen Werttyp handelt) ist nicht zugewiesen werden, in den Argumenttyp der dargestellte Methode <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors darstellt, der keine Argumente akzeptiert.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.NewExpression.Arguments%2A> und <xref:System.Linq.Expressions.NewExpression.Members%2A> Eigenschaften des resultierenden <xref:System.Linq.Expressions.NewExpression> leere Sammlungen sind. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft darstellt, den deklarierenden Typ des Konstruktors dargestellte `constructor`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Konstruktor, <paramref name="constructor" /> stellt über mindestens einen Parameter verfügt.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Ein <see cref="T:System.Type" /> mit einem Konstruktor, der keine Argumente akzeptiert.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des Konstruktors vom angegebenen Typ ohne Parameter darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft auf die <see cref="T:System.Reflection.ConstructorInfo" /> festgelegt ist, die den Konstruktor ohne Parameter für den angegebenen Typ darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `type` Parameter muss einen Typ, der einen Konstruktor ohne Parameter darstellen.  
  
 Die <xref:System.Linq.Expressions.NewExpression.Arguments%2A> und <xref:System.Linq.Expressions.NewExpression.Members%2A> Eigenschaften des resultierenden <xref:System.Linq.Expressions.NewExpression> leere Sammlungen sind. Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft gleich `type`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.New%28System.Type%29> Methode zum Erstellen einer <xref:System.Linq.Expressions.NewExpression> , erstellen eine neue Instanz der ein Dictionary-Objekt, durch den Aufruf des Konstruktors ohne Parameter darstellt.  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Typ, der <paramref name="type" /> darstellt, verfügt nicht über einen Konstruktor ohne Parameter.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
        <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `arguments` Parameter muss die gleiche Anzahl von Elementen wie die Anzahl der Parameter des Konstruktors dargestellte enthalten `constructor`. Wenn `arguments` ist `null`, er wird als leer betrachtet und der <xref:System.Linq.Expressions.NewExpression.Arguments%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.NewExpression> ist eine leere Auflistung.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.NewExpression> stellt den deklarierenden Typ des Konstruktors dargestellte `constructor`. Die <xref:System.Linq.Expressions.NewExpression.Members%2A> Eigenschaft ist eine leere Auflistung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Element von <paramref name="arguments" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="arguments" /> Parameter enthält nicht die gleiche Anzahl von Elementen wie die Anzahl der Parameter des Konstruktors, die <paramref name="constructor" /> darstellt.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des Konstruktors zugewiesen werden, der durch <paramref name="constructor" /> dargestellt wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
        <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `arguments` Parameter muss die gleiche Anzahl von Elementen wie die Anzahl der Parameter des Konstruktors dargestellte enthalten `constructor`. Wenn `arguments` ist `null`, er wird als leer betrachtet und der <xref:System.Linq.Expressions.NewExpression.Arguments%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.NewExpression> ist eine leere Auflistung.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.NewExpression> stellt den deklarierenden Typ des Konstruktors dargestellte `constructor`. Die <xref:System.Linq.Expressions.NewExpression.Members%2A> Eigenschaft ist eine leere Auflistung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Element von <paramref name="arguments" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="arguments" /> entspricht der Anzahl von Parametern für den Konstruktor, der durch <paramref name="constructor" /> dargestellt wird.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des Konstruktors zugewiesen werden, der durch <paramref name="constructor" /> dargestellt wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
        <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
        <param name="members">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Reflection.MemberInfo" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Members" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt. Es werden die Member angegeben, die auf die durch den Konstruktor initialisierten Felder zugreifen.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> und <see cref="P:System.Linq.Expressions.NewExpression.Members" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `arguments` Parameter muss die gleiche Anzahl von Elementen wie die Anzahl der Parameter des Konstruktors dargestellte enthalten `constructor`. Wenn `arguments` ist `null`, er wird als leer betrachtet und der <xref:System.Linq.Expressions.NewExpression.Arguments%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.NewExpression> ist eine leere Auflistung.  
  
 Wenn `members` ist `null`, <xref:System.Linq.Expressions.NewExpression.Members%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.NewExpression> ist eine leere Auflistung. Wenn `members` nicht `null`, muss die gleiche Anzahl von Elementen als `arguments` und jedes Element darf nicht `null`. Jedes Element der `members` muss ein <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> oder <xref:System.Reflection.MethodInfo> , die einen Instanzmember des deklarierenden Typs des Konstruktors dargestellte darstellt `constructor`. Wenn es sich um eine Eigenschaft darstellt, muss die Eigenschaft haben eine `get` Accessor. Dem entsprechenden Element des `arguments` für jedes Element der `members` benötigen eine <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft, die einen Typ darstellt, der in den Typ des Elements zugeordnet werden, die die `members` Element darstellt.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.NewExpression> den deklarierenden Typ des Konstruktors darstellt, die `constructor` darstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Element von <paramref name="arguments" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Element von <paramref name="members" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="arguments" /> Parameter enthält nicht die gleiche Anzahl von Elementen wie die Anzahl der Parameter des Konstruktors, die <paramref name="constructor" /> darstellt.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des Konstruktors zugewiesen werden, der durch <paramref name="constructor" /> dargestellt wird.  
  
 - oder -   
  
 Die <paramref name="members" /> Parameter verfügt nicht über die gleiche Anzahl von Elementen als <paramref name="arguments" />.  
  
 - oder -   
  
 Ein Element von <paramref name="arguments" /> hat eine <see cref="P:System.Linq.Expressions.Expression.Type" /> -Eigenschaft, die einen Typ darstellt, die nicht in den Typ des Elements zugeordnet werden, die von dem entsprechenden Element des dargestellte <paramref name="members" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
        <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
        <param name="members">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Members" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt. Es werden die Member als Array angegeben, die auf die durch den Konstruktor initialisierten Felder zugreifen.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> und <see cref="P:System.Linq.Expressions.NewExpression.Members" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `arguments` Parameter muss die gleiche Anzahl von Elementen wie die Anzahl der Parameter des Konstruktors dargestellte enthalten `constructor`. Wenn `arguments` ist `null`, er wird als leer betrachtet und der <xref:System.Linq.Expressions.NewExpression.Arguments%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.NewExpression> ist eine leere Auflistung.  
  
 Wenn `members` ist `null`, <xref:System.Linq.Expressions.NewExpression.Members%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.NewExpression> ist eine leere Auflistung. Wenn `members` nicht `null`, muss die gleiche Anzahl von Elementen als `arguments` und jedes Element darf nicht `null`. Jedes Element der `members` muss ein <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> oder <xref:System.Reflection.MethodInfo> , die einen Instanzmember des deklarierenden Typs des Konstruktors dargestellte darstellt `constructor`. Wenn es sich um eine Eigenschaft darstellt, muss die Eigenschaft kann zum Abrufen des Werts des Felds zugeordnet sein. Dem entsprechenden Element des `arguments` für jedes Element der `members` benötigen eine <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft, die einen Typ darstellt, der in den Typ des Elements zugeordnet werden, die die `members` Element darstellt.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.NewExpression> den deklarierenden Typ des Konstruktors darstellt, die `constructor` darstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Element von <paramref name="arguments" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Element von <paramref name="members" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="arguments" /> Parameter enthält nicht die gleiche Anzahl von Elementen wie die Anzahl der Parameter des Konstruktors, die <paramref name="constructor" /> darstellt.  
  
 - oder -   
  
 Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des Konstruktors zugewiesen werden, der durch <paramref name="constructor" /> dargestellt wird.  
  
 - oder -   
  
 Die <paramref name="members" /> Parameter verfügt nicht über die gleiche Anzahl von Elementen als <paramref name="arguments" />.  
  
 - oder -   
  
 Ein Element von <paramref name="arguments" /> hat eine <see cref="P:System.Linq.Expressions.Expression.Type" /> -Eigenschaft, die einen Typ darstellt, die nicht in den Typ des Elements zugeordnet werden, die von dem entsprechenden Element des dargestellte <paramref name="members" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
        <param name="bounds">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines Arrays mit dem angegebenen Rang darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.NewArrayExpression> stellt einen Arraytyp, dessen Rang gleich der Länge des ist `bounds` und, dessen Elementtyp `type`.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft jedes Elements des `bounds` muss einen ganzzahligen Typ darstellen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> Methode, um eine Ausdrucksbaumstruktur zu erstellen, das darstellt, erstellen ein Array von Zeichenfolgen, hat den Rang 2.  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> oder <paramref name="bounds" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Element von <paramref name="bounds" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft eines Elements <paramref name="bounds" /> stellt keinen ganzzahligen Typ dar.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
        <param name="bounds">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines Arrays mit dem angegebenen Rang darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.NewArrayExpression> stellt einen Arraytyp, dessen Rang gleich der Länge des ist `bounds` und, dessen Elementtyp `type`.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft jedes Elements des `bounds` muss einen ganzzahligen Typ darstellen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> Methode, um eine Ausdrucksbaumstruktur zu erstellen, das darstellt, erstellen ein Array von Zeichenfolgen, hat den Rang 2.  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> oder <paramref name="bounds" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Element von <paramref name="bounds" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft eines Elements <paramref name="bounds" /> stellt keinen ganzzahligen Typ dar.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
        <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines eindimensionalen Arrays und Initialisieren dieses Arrays aus einer Liste von Elementen darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft jedes Elements des `initializers` muss einen Typ, der zugeordnet werden kann der Typ von dargestellt darstellen `type`, möglicherweise ist *in Anführungszeichen*.  
  
> [!NOTE]
>  Ein Element in Anführungszeichen, nur wenn `type` ist <xref:System.Linq.Expressions.Expression>. Zitieren bedeutet, dass das Element umschlossen ist ein <xref:System.Linq.Expressions.ExpressionType.Quote> Knoten. Der resultierende Knoten ist ein <xref:System.Linq.Expressions.UnaryExpression> , deren <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> Eigenschaft ist für das Element der `initializers`.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.NewArrayExpression> stellt einen Arraytyp, dessen Rang 1 und, dessen Elementtyp `type`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> Methode, um eine Ausdrucksbaumstruktur zu erstellen, die darstellt, erstellen ein eindimensionales Zeichenfolgenarray, das mit einer Liste der Ausdrücke initialisiert wird.  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> oder <paramref name="initializers" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Element von <paramref name="initializers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft eines Elements <paramref name="initializers" /> einen Typ, der nicht den Typ darstellt, die <paramref name="type" /> darstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
        <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines eindimensionalen Arrays und Initialisieren dieses Arrays aus einer Liste von Elementen darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft jedes Elements des `initializers` muss einen Typ, der zugeordnet werden kann der Typ von dargestellt darstellen `type`, möglicherweise ist *in Anführungszeichen*.  
  
> [!NOTE]
>  Ein Element in Anführungszeichen, nur wenn `type` ist <xref:System.Linq.Expressions.Expression>. Zitieren bedeutet, dass das Element umschlossen ist ein <xref:System.Linq.Expressions.ExpressionType.Quote> Knoten. Der resultierende Knoten ist ein <xref:System.Linq.Expressions.UnaryExpression> , deren <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> Eigenschaft ist für das Element der `initializers`.  
  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.NewArrayExpression> stellt einen Arraytyp, dessen Rang 1 und, dessen Elementtyp `type`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> Methode, um eine Ausdrucksbaumstruktur zu erstellen, die darstellt, erstellen ein eindimensionales Zeichenfolgenarray, das mit einer Liste der Ausdrücke initialisiert wird.  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> oder <paramref name="initializers" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Element von <paramref name="initializers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Linq.Expressions.Expression.Type" /> Eigenschaft eines Elements <paramref name="initializers" /> stellt einen Typ, der nicht den Typ <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> ab.</summary>
        <value>Einer der <see cref="T:System.Linq.Expressions.ExpressionType" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.NodeType%2A> Eigenschaft beschreibt spezialisierter ein <xref:System.Linq.Expressions.Expression> als einfach davon abgeleitete Typ. Z. B. eine <xref:System.Linq.Expressions.BinaryExpression> können verwendet werden, um viele verschiedene Arten von binären Ausdrücken, z. B. eine Division oder -Operation "größer als" darstellen. Die <xref:System.Linq.Expressions.Expression.NodeType%2A> -Eigenschaft würde diese binäre Ausdrücke als beschreiben <xref:System.Linq.Expressions.ExpressionType.Divide> und <xref:System.Linq.Expressions.ExpressionType.GreaterThan>zugeordnet.  
  
 Der statische CLR-Typ des Ausdrucks, der <xref:System.Linq.Expressions.Expression> dargestellte Objekt stellt der <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine bitweise Komplementoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.UnaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> auf die implementierende Methode festgelegt ist. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `expression`. Typ ist ein vom benutzerdefinierten Typ, der unäre Operator not definiert, die <xref:System.Reflection.MethodInfo> , darstellt, der Operator ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `expression`. Ist eine numerische oder boolesche Typ, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `expression`. Typ ist der Argumenttyp der implementierenden Methode zugeordnet werden kann, die Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `expression`. Typ ist ein Typ NULL-Werte zulassen, und der entsprechende NULL-Typ mit dem Argumenttyp der implementierenden Methode identisch ist.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`, ist der Typ des Knotens `expression`. Geben Sie ein. Wenn `expression`. Typ: NULL-Werte zulässt, der Knoten nicht transformiert. Andernfalls ist der Knoten transformiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einen Ausdruck zu erstellen, die eine logische stellt NOT-Operation.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der unäre Operator not ist nicht für <paramref name="expression" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine bitweise Komplementoperation darstellt. Die implementierende Methode kann angegeben werden.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.UnaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> auf die implementierende Methode festgelegt ist. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die ein Argument akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Wenn `expression`. Typ ist ein vom benutzerdefinierten Typ, der unäre Operator not definiert, die <xref:System.Reflection.MethodInfo> , darstellt, der Operator ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `expression`. Ein numerischer Typ ist, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `expression`. Typ ist der Argumenttyp der implementierenden Methode zugeordnet werden kann, die Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `expression`. Typ ist ein Typ NULL-Werte zulassen, und der entsprechende Werttyp der NULL-gleich dem Argumenttyp der implementierenden Methode.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`, ist der Typ des Knotens `expression`. Geben Sie ein. Wenn `expression`. Typ: NULL-Werte zulässt, der Knoten nicht transformiert. Andernfalls ist der Knoten transformiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" />ist kein <see langword="null" /> und die Methode dar, gibt <see langword="void" />, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic), oder ist nicht genau ein Argument annehmen.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />ist <see langword="null" /> und der unäre Operator not ist nicht für <paramref name="expression" />. Geben Sie ein.  
  
 - oder -   
  
 <paramref name="expression" />. Typ (oder der entsprechende NULL-Typ, wenn es sich um einen Werttyp handelt) ist nicht zugewiesen werden, in den Argumenttyp der dargestellte Methode <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Ungleichheitsvergleich darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> Eigenschaft ist `true`. Andernfalls ist der Wert `false`. Die <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A>-Eigenschaft ist immer `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, der den Ungleichheitsoperator überlädt die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Ansonsten ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Wenn die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist <xref:System.Boolean>:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist <xref:System.Boolean>.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Ungleichheitsoperator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="liftToNull">
          <see langword="true" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="true" /> festzulegen, und <see langword="false" />, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf <see langword="false" /> festzulegen.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Ungleichheitsvergleich darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> Eigenschaft ist `true` und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> -Eigenschaft gleich `liftToNull`. Andernfalls sind sie beide `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, der den Ungleichheitsoperator überlädt die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Ansonsten ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Wenn die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert; Darüber hinaus ist der Typ des Knotens zulässig <xref:System.Boolean> Wenn `liftToNull` ist `true` oder <xref:System.Boolean> Wenn `liftToNull` ist `false`:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist <xref:System.Boolean>.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist <xref:System.Boolean>.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist auf NULL festlegbar <xref:System.Boolean> Wenn `liftToNull` ist `true` oder <xref:System.Boolean> Wenn `liftToNull` ist `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />ist <see langword="null" /> und der Ungleichheitsoperator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Gibt den Ausdruck zurück, der das Ones-Komplement darstellt.</summary>
        <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
        <summary>Gibt den Ausdruck zurück, der das Ones-Komplement darstellt.</summary>
        <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen <see langword="OR" />-Vorgang darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, das bitweise überlädt `OR` -Operator, der <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Type ganzzahlige oder boolesche Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten bitweise `OR` Operator.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten bitweise entspricht `OR` Operator.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, der eine logische OR-Operation darstellt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der bitweise <see langword="OR" /> Operator ist nicht definiert, für <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen <see langword="OR" />-Vorgang darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, das bitweise überlädt `OR` -Operator, der <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Type ganzzahlige oder boolesche Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten bitweise `OR` Operator.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten bitweise entspricht `OR` Operator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> ist <see langword="null" />, und der bitweise <see langword="OR" />-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise OR-Zuweisungsoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise OR-Zuweisungsoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise OR-Zuweisungsoperation darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bedingten <see langword="OR" />-Vorgang darstellt, bei dem der zweite Operand nur ausgewertet wird, wenn der erste Operand als <see langword="false" /> ausgewertet wird.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, das bitweise überlädt `OR` -Operator, der <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
    > [!NOTE]
    >  Der bedingte `OR` Operator kann nicht überladen werden, in c# oder [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]. Allerdings die bedingte `OR` Operator wird ausgewertet, mit dem bitweisen `OR` Operator. Daher eine benutzerdefinierte Überladung des bitweisen `OR` Operator kann sein, dass die implementierende Methode für diesen Knotentyp.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Type booleschen Typen, die die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt, und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   `left`. Typ und `right`. Sind die gleichen Boolean-Typ.  
  
-   Wenn `left`. Typ und `right`. Typ NULL-Werte zulässt, der Knoten wird nicht transformiert. Der Typ des Knotens ist der Ergebnistyp des vordefinierten bedingten `OR` Operator.  
  
-   Wenn `left`. Typ und `right`. Sind NULL-Werte zulässt, ist der Knoten transformiert. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten bedingten entspricht `OR` Operator.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, die eine logische darstellt `OR` Vorgang, der der zweite Operand ausgewertet wird, nur dann, wenn der erste Operand als `false`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der bitweise <see langword="OR" /> Operator ist nicht definiert, für <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.  
  
 - oder -   
  
 <paramref name="left" />. Typ und <paramref name="right" />. Typ sind nicht die gleichen Boolean-Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bedingten <see langword="OR" />-Vorgang darstellt, bei dem der zweite Operand nur ausgewertet wird, wenn der erste Operand als <see langword="false" /> ausgewertet wird.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, das bitweise überlädt `OR` -Operator, der <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
    > [!NOTE]
    >  Der bedingte `OR` Operator kann nicht überladen werden, in c# oder [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]. Allerdings die bedingte `OR` Operator wird ausgewertet, mit dem bitweisen `OR` Operator. Daher eine benutzerdefinierte Überladung des bitweisen `OR` Operator kann sein, dass die implementierende Methode für diesen Knotentyp.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Type booleschen Typen, die die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt, und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   `left`. Typ und `right`. Sind die gleichen Boolean-Typ.  
  
-   Wenn `left`. Typ und `right`. Typ NULL-Werte zulässt, der Knoten wird nicht transformiert. Der Typ des Knotens ist der Ergebnistyp des vordefinierten bedingten `OR` Operator.  
  
-   Wenn `left`. Typ und `right`. Sind NULL-Werte zulässt, ist der Knoten transformiert. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten bedingten entspricht `OR` Operator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> ist <see langword="null" />, und der bitweise <see langword="OR" />-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.  
  
 - oder -   
  
 <paramref name="method" />ist <see langword="null" /> und <paramref name="left" />. Typ und <paramref name="right" />. Typ sind nicht die gleichen Boolean-Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des Parameters oder der Variable.</param>
        <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten mit dem angegebenen Namen und Typ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie eine <xref:System.Linq.Expressions.MethodCallExpression> -Objekt, das den Wert der Druckt ein <xref:System.Linq.Expressions.ParameterExpression> Objekt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des Parameters oder der Variable.</param>
        <param name="name">Der Name des Parameters oder der Variable (wird nur zum Debuggen oder Drucken verwendet).</param>
        <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> ist und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.ParameterExpression.Name" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Verringerung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Verringerung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Erhöhung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Erhöhung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren einer Zahl darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` stellt einen benutzerdefinierten Typ, der den Potenzierungsoperator überlädt die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Sind beide <xref:System.Double>, die implementierende Methode <xref:System.Math.Pow%2A>.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Potenzierungsoperator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.  
  
 - oder -   
  
 <paramref name="left" />. Typ und/oder <paramref name="right" />. Nicht <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren einer Zahl darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` stellt einen benutzerdefinierten Typ, der den Potenzierungsoperator überlädt die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Sind beide <xref:System.Double>, die implementierende Methode <xref:System.Math.Pow%2A>.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> ist <see langword="null" />, und der Exponentialoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.  
  
 - oder -   
  
 <paramref name="method" /> ist <see langword="null" />, und <paramref name="left" />.Type und/oder <paramref name="right" />.Type sind nicht <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren eines Ausdrucks und erneute Zuordnen des Ergebnisses zum Ausdruck darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren eines Ausdrucks und erneute Zuordnen des Ergebnisses zum Ausdruck darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren eines Ausdrucks und erneute Zuordnen des Ergebnisses zum Ausdruck darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 verringert und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 verringert und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 erhöht und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 erhöht und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft festgelegt werden soll. Dies kann für statische Eigenschaften NULL sein.</param>
        <param name="propertyAccessor">Die <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft durch das Verwenden einer Eigenschaftenaccessormethode darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MemberExpression> ist gleich der <xref:System.Reflection.PropertyInfo.PropertyType%2A> Eigenschaft <xref:System.Linq.Expressions.MemberExpression.Member%2A>.  
  
 Wenn die Methode szenariobeschreibungen `propertyAccessor` ist `static` (`Shared` in Visual Basic), `expression` kann `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die Methode, die <paramref name="propertyAccessor" /> ist <see langword="static" /> (<see langword="Shared" /> in Visual Basic) und <paramref name="expression" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />.Type kann dem deklarierenden Typ der durch <paramref name="propertyAccessor" /> dargestellten Methode nicht zugewiesen werden.  
  
 - oder -   
  
 Die Methode, die <paramref name="propertyAccessor" /> ist eine eigenschaftenzugriffsmethode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft festgelegt werden soll. Dies kann für statische Eigenschaften NULL sein.</param>
        <param name="property">Die <see cref="T:System.Reflection.PropertyInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.MemberExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MemberExpression> ist gleich der <xref:System.Reflection.PropertyInfo.PropertyType%2A> Eigenschaft <xref:System.Linq.Expressions.MemberExpression.Member%2A>.  
  
 Wenn die Eigenschaft szenariobeschreibungen `property` ist `static` (`Shared` in Visual Basic), `expression` kann `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="property" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die Eigenschaft, die <paramref name="property" /> ist <see langword="static" /> (<see langword="Shared" /> in Visual Basic) und <paramref name="expression" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. Ist keine der deklarierende Typ der Eigenschaft zugewiesen werden, die <paramref name="property" /> darstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" /> , deren <see cref="P:System.Linq.Expressions.Expression.Type" /> enthält eine Eigenschaft mit dem Namen <c>PropertyName</c>. Dies kann für statische Eigenschaften <see langword="null" /> sein.</param>
        <param name="propertyName">Der Name der Eigenschaft, auf die zugegriffen werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die durch <paramref name="propertyName" /> angegebene Eigenschaft darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MemberExpression> ist gleich der <xref:System.Reflection.PropertyInfo.PropertyType%2A> Eigenschaft von der <xref:System.Reflection.PropertyInfo> , die durch angegebene Eigenschaft darstellt `propertyName`.  
  
 Diese Methode sucht `expression`. Typ und dessen Basistypen für eine Eigenschaft mit dem Namen `propertyName`. Öffentliche Eigenschaften sind nicht öffentlichen Eigenschaften verhaltensabschnitten. Wenn eine übereinstimmende Eigenschaft gefunden wird, wird diese Methode transferiert `expression` und <xref:System.Reflection.PropertyInfo> , darstellt, ist diese Eigenschaft <xref:System.Linq.Expressions.Expression.Property%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie einen Ausdruck erstellt, der Zugriff auf eine Eigenschaft darstellt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> oder <paramref name="propertyName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Keine Eigenschaft mit dem Namen <paramref name="propertyName" /> ist definiert <paramref name="expression" />. Typ oder dessen Basistypen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">Das Objekt, zu dem die Eigenschaft gehört. Wenn die Eigenschaft statisch/freigegeben ist, muss sie NULL sein.</param>
        <param name="indexer">Das <see cref="T:System.Reflection.PropertyInfo" />, das die zu indizierende Eigenschaft darstellt.</param>
        <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die zum Indizieren der Eigenschaft verwendet werden.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, die den Zugriff auf eine indizierte Eigenschaft darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Das Objekt, zu dem die Eigenschaft gehört. Wenn die Eigenschaft statisch/freigegeben ist, muss sie NULL sein.</param>
        <param name="indexer">Das <see cref="T:System.Reflection.PropertyInfo" />, das die zu indizierende Eigenschaft darstellt.</param>
        <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die zum Indizieren der Eigenschaft verwendet werden.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, die den Zugriff auf eine indizierte Eigenschaft darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Das Objekt, zu dem die Eigenschaft gehört. Wenn die Eigenschaft statisch/freigegeben ist, muss sie NULL sein.</param>
        <param name="propertyName">Der Name des Indexers.</param>
        <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die zum Indizieren der Eigenschaft verwendet werden.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, die den Zugriff auf eine indizierte Eigenschaft darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Das enthaltende Objekt der Eigenschaft. Dies kann für statische Eigenschaften NULL sein.</param>
        <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" />, der die Eigenschaft enthält.</param>
        <param name="propertyName">Die Eigenschaft, auf die zugegriffen werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die auf eine Eigenschaft zugreift.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" /> , deren <see cref="P:System.Linq.Expressions.Expression.Type" /> enthält eine Eigenschaft oder ein Feld mit dem Namen <c>PropertyOrFieldName</c>. Kann für statische Member NULL sein.</param>
        <param name="propertyOrFieldName">Der Name einer Eigenschaft oder eines Felds, auf die bzw. das zugegriffen werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft oder ein Feld darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> oder <see cref="T:System.Reflection.FieldInfo" /> festgelegt ist, die die durch <paramref name="propertyOrFieldName" /> angegebene Eigenschaft bzw. das Feld darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.MemberExpression> ist gleich der <xref:System.Reflection.PropertyInfo.PropertyType%2A> oder <xref:System.Reflection.FieldInfo.FieldType%2A> Eigenschaften der <xref:System.Reflection.PropertyInfo> oder <xref:System.Reflection.FieldInfo>nahezu, Eigenschaft oder des Felds gekennzeichnet durch darstellt `propertyOrFieldName`.  
  
 Diese Methode sucht `expression`. Typ und dessen Basistypen für eine Eigenschaft oder ein Feld mit dem Namen `propertyOrFieldName`. Öffentliche Eigenschaften und Felder werden über den nicht öffentlichen Eigenschaften und Felder verhaltensabschnitten. Außerdem sind Eigenschaften über Felder verhaltensabschnitten. Wenn eine übereinstimmende Eigenschaft oder ein Feld gefunden wird, wird diese Methode transferiert `expression` und <xref:System.Reflection.PropertyInfo> oder <xref:System.Reflection.FieldInfo> , darstellt, Eigenschaft oder ein Feld an <xref:System.Linq.Expressions.Expression.Property%2A> oder <xref:System.Linq.Expressions.Expression.Field%2A>bzw..  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie einen Ausdruck erstellen, der Zugriff auf eine Eigenschaft oder ein Feld darstellt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> oder <paramref name="propertyOrFieldName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Keine Eigenschaft oder ein Feld namens <paramref name="propertyOrFieldName" /> ist definiert <paramref name="expression" />. Typ oder dessen Basistypen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die einen Ausdruck mit einem konstanten Wert vom Typ <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> stellt den konstruierten Typ <xref:System.Linq.Expressions.Expression%601>, wobei das Typargument der Typ von dargestellt ist `expression`. Geben Sie ein. Die <xref:System.Linq.Expressions.UnaryExpression.Method%2A>-Eigenschaft ist `null`. Beide <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> sind `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reduziert diesen Knoten zu einem einfacheren Ausdruck. Wenn CanReduce true zurückgibt, sollte ein gültiger Ausdruck zurückgegeben werden. Diese Methode kann einen anderen Knoten zurückgeben, der selbst reduziert werden muss.</summary>
        <returns>Der reduzierte Ausdruck.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reduziert diesen Knoten zu einem einfacheren Ausdruck. Wenn CanReduce true zurückgibt, sollte ein gültiger Ausdruck zurückgegeben werden. Diese Methode kann einen anderen Knoten zurückgeben, der selbst reduziert werden muss.</summary>
        <returns>Der reduzierte Ausdruck.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu reduzieren überprüft diese Methode an, dass der reduzierte Knoten bestimmte invarianten erfüllt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reduziert den Ausdruck zu einem bekannten Knotentyp (kein Erweiterungsknoten) oder gibt nur den Ausdruck zurück, wenn es sich um einen bereits bekannten Typ handelt.</summary>
        <returns>Der reduzierte Ausdruck.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Verweisgleichheitsvergleich darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Verweisungleichheitsvergleich darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der neue <see cref="T:System.Type" /> des Ausdrucks.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme eines angegebenen Typs darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Return", die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
        <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung darstellt. Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Continue" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einen Ausdruck zu erstellen, enthält die <xref:System.Linq.Expressions.Expression.Return%2A> Methode.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
        <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung mit dem angegebenen Typ darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Return" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
        <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
        <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung mit dem angegebenen Typ darstellt. Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Continue" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebeoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die ausgewählte implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Right-Shift-Operator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ ist ein integraler Typ (eines <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, oder die entsprechenden Typen mit Nullwert) und `right`. Der Typ ist <xref:System.Int32>, die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des der vordefinierten Right-Shift-Operator.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des der vordefinierten Right-Shift-Operator entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Right Shift Operator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebeoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die ausgewählte implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Right-Shift-Operator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ ist ein integraler Typ (eines <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, oder die entsprechenden Typen mit Nullwert) und `right`. Der Typ ist <xref:System.Int32>, die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des der vordefinierten Right-Shift-Operator.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des der vordefinierten Right-Shift-Operator entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die dargestellte Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />ist <see langword="null" /> und der Right Shift Operator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebe-Zuweisungsoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebe-Zuweisungsoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebe-Zuweisungsoperation darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">Eine Auflistung von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
        <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> ist und die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">Ein Array von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Auflistung aufgefüllt wird.</param>
        <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
        <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> ist und die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion ohne Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die ausgewählte implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Subtraktionsoperator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten Subtraktionsoperators.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten Subtraktionsoperators entspricht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Ausdruck erstellt, der das Argument aus dem ersten Argument subtrahiert.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Subtraktionsoperator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion ohne Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Subtraktionsoperator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten Subtraktionsoperators.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten Subtraktionsoperators entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die darstellende Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> ist <see langword="null" />, und der Subtraktionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion mit Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die ausgewählte implementierende Methode für den Vorgang.  
  
-   Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Subtraktionsoperator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten Subtraktionsoperators.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten Subtraktionsoperators entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Subtraktionsoperator ist nicht definiert <paramref name="left" />. Typ und <paramref name="right" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
        <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion mit Überlaufprüfung darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das resultierende <xref:System.Linq.Expressions.BinaryExpression> hat die <xref:System.Linq.Expressions.BinaryExpression.Method%2A> -Eigenschaft auf die implementierende Methode festgelegt. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie `false`. Die <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A>-Eigenschaft ist `null`.  
  
 Die folgenden Informationen beschreiben die implementierende Methode, des Knotentyps und gibt an, ob ein Knoten transformiert wird.  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die zwei Argumente akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Andernfalls gilt: Wenn die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft entweder `left` oder `right` einen benutzerdefinierten Typ darstellt, den Subtraktionsoperator überlädt, die <xref:System.Reflection.MethodInfo> , die Methode darstellt, die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `left`. Typ und `right`. Numerische Typen sind, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `left`. Typ und `right`. Typ werden den entsprechenden Argumenttypen der implementierenden Methode zugeordnet werden kann, ist der Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `left`. Typ und `right`. Sind beide Werttypen, von denen mindestens eine NULL-Werte zulässt und die entsprechenden NULL-Typen mit den entsprechenden Argumenttypen der implementierenden Methode identisch sind.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`:  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten nicht transformiert wird. Der Typ des Knotens ist der Ergebnistyp des vordefinierten Subtraktionsoperators.  
  
-   Wenn `left`. Typ und `right`. Sind beide NULL-Werte zulässt, der Knoten transformiert wird. Der Typ des Knotens ist die nullable-Typ, der den Ergebnistyp des vordefinierten Subtraktionsoperators entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> ist nicht <see langword="null" />, und die darstellende Methode gibt <see langword="void" /> zurück, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> ist <see langword="null" />, und der Subtraktionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
        <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine <see langword="switch" />-Anweisung ohne Standardfall darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle <xref:System.Linq.Expressions.SwitchCase> Objekte in einem <xref:System.Linq.Expressions.SwitchExpression> Objekt muss den gleichen Typ aufweisen, es sei denn, die <xref:System.Linq.Expressions.SwitchExpression> hat den Typ `void`.  
  
 Jede <xref:System.Linq.Expressions.SwitchCase> Objekt verfügt über einen impliziten `break` Anweisung, d. h. es ist kein implizites über aus einer Case-Bezeichnung zu einem anderen.  
  
 Wenn `switchValue` stimmt mit keinem der Fälle wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einen Ausdruck erstellt, der eine Switch-Anweisung ohne Standardfall darstellt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
        <param name="defaultBody">Das Ergebnis des Schalters Wenn <c>SwitchValue</c> stimmt mit keinem der Fälle.</param>
        <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine <see langword="switch" />-Anweisung mit einem Standardfall darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle <xref:System.Linq.Expressions.SwitchCase> Objekte in einem <xref:System.Linq.Expressions.SwitchExpression> Objekt muss den gleichen Typ aufweisen, es sei denn, die <xref:System.Linq.Expressions.SwitchExpression> hat den Typ `void`.  
  
 Jede <xref:System.Linq.Expressions.SwitchCase> Objekt verfügt über einen impliziten `break` Anweisung, d. h. es ist kein implizites über aus einer Case-Bezeichnung zu einem anderen.  
  
 Wenn `switchValue` stimmt mit keinem der Fälle der Standardfall dargestellte `defaultBody` ausgeführt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einen Ausdruck erstellt, der eine Switch-Anweisung darstellt, die einem Standardfall.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
        <param name="defaultBody">Das Ergebnis des Schalters Wenn <c>SwitchValue</c> stimmt mit keinem der Fälle.</param>
        <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
        <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine <see langword="switch" />-Anweisung mit einem Standardfall darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
        <param name="defaultBody">Das Ergebnis des Schalters Wenn <c>SwitchValue</c> stimmt mit keinem der Fälle.</param>
        <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
        <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine <see langword="switch" />-Anweisung mit einem Standardfall darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Der Ergebnistyp des Schalters.</param>
        <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
        <param name="defaultBody">Das Ergebnis des Schalters Wenn <c>SwitchValue</c> stimmt mit keinem der Fälle.</param>
        <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
        <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine <see langword="switch" />-Anweisung mit einem Standardfall darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Der Ergebnistyp des Schalters.</param>
        <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
        <param name="defaultBody">Das Ergebnis des Schalters Wenn <c>SwitchValue</c> stimmt mit keinem der Fälle.</param>
        <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
        <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine <see langword="switch" />-Anweisung mit einem Standardfall darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Der Text des Falls.</param>
        <param name="testValues">Die Testwerte des Falls.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Expressions.SwitchCase" />-Objekt, das in einem <see cref="T:System.Linq.Expressions.SwitchExpression" />-Objekt verwendet werden soll.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle <xref:System.Linq.Expressions.SwitchCase> Objekte in einem <xref:System.Linq.Expressions.SwitchExpression> Objekt muss den gleichen Typ aufweisen, es sei denn, die <xref:System.Linq.Expressions.SwitchExpression> hat den Typ `void`.  
  
 Jede <xref:System.Linq.Expressions.SwitchCase> Objekt verfügt über einen impliziten `break` Anweisung, d. h. es ist kein implizites über aus einer Case-Bezeichnung zu einem anderen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einen Ausdruck erstellt, der eine Switch-Anweisung darstellt, die einem Standardfall.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Der Text des Falls.</param>
        <param name="testValues">Die Testwerte des Falls.</param>
        <summary>Erstellt einen <see cref="T:System.Linq.Expressions.SwitchCase" /> zur Verwendung in einem <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
        <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
        <param name="language">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> festgelegt werden soll.</param>
        <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
        <param name="language">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> festgelegt werden soll.</param>
        <param name="languageVendor">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> festgelegt werden soll.</param>
        <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft, die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
        <param name="language">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> festgelegt werden soll.</param>
        <param name="languageVendor">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> festgelegt werden soll.</param>
        <param name="documentType">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> festgelegt werden soll.</param>
        <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft, die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />-Eigenschaft, die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="value">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Auslösen einer Ausnahme darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Ausnahme darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie eine <xref:System.Linq.Expressions.TryExpression> -Objekt, verwendet die <xref:System.Linq.Expressions.Expression.Throw%2A> Methode.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="type">Der neue <see cref="T:System.Type" /> des Ausdrucks.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Auslösen einer Ausnahme eines angegebenen Typs darstellt.</summary>
        <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Ausnahme darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Textdarstellung des <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
        <returns>Eine Textdarstellung der <see cref="T:System.Linq.Expressions.Expression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Der Text des Try-Blocks.</param>
        <param name="handlers">Das Array von 0 oder mehr <see cref="T:System.Linq.Expressions.CatchBlock" />-Ausdrücken, die die dem Try-Block zuzuordnenden Catch-Anweisungen darstellen.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einer beliebigen Anzahl von Catch-Anweisungen ohne Fault- und Finally-Block darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein <xref:System.Linq.Expressions.TryExpression> Objekt, das eine Catch-Anweisung enthält.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Der Text des Try-Blocks.</param>
        <param name="finally">Der Text des Finally-Blocks.</param>
        <param name="handlers">Das Array von 0 oder mehr <see cref="T:System.Linq.Expressions.CatchBlock" />-Ausdrücken, die die dem Try-Block zuzuordnenden Catch-Anweisungen darstellen.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einer beliebigen Anzahl von Catch-Anweisungen und einem Finally-Block darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein <xref:System.Linq.Expressions.TryExpression> Objekt, das eine Catch-Anweisung enthält und einen finally-Anweisung.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">Der Text des Try-Blocks.</param>
        <param name="fault">Der Text des Fault-Blocks.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einem Fault-Block ohne Catch-Anweisungen darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">Der Text des Try-Blocks.</param>
        <param name="finally">Der Text des Finally-Blocks.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einem Finally-Block ohne Catch-Anweisungen darstellt.</summary>
        <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="actionType" Type="System.Type&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">Ein Array von Type-Objekten, die die Typargumente für den System.Action-Delegattyp angeben.</param>
        <param name="actionType">Enthält nach dem Beenden dieser Methode den generischen System.Action-Delegattyp mit bestimmten Typargumenten. Enthält Null, wenn es ist kein generischer System.Action-Delegat, der entspricht der <c>TypeArgs</c>. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Erstellt ein <see cref="P:System.Linq.Expressions.Expression.Type" />-Objekt, das einen generischen System.Action-Delegattyp mit bestimmten Typargumenten darstellt.</summary>
        <returns>true, wenn ein generischer System.Action-Delegattyp für bestimmte <paramref name="typeArgs" /> erstellt wurde, andernfalls false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="funcType" Type="System.Type&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">Ein Array von Type-Objekten, die die Typargumente für den System.Func-Delegattyp angeben.</param>
        <param name="funcType">Enthält nach dem Beenden dieser Methode den generischen System.Func-Delegattyp mit bestimmten Typargumenten. Enthält Null, wenn es ist kein generischer System.Func-Delegat, der entspricht der <c>TypeArgs</c>. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Erstellt ein <see cref="P:System.Linq.Expressions.Expression.Type" />-Objekt, das einen generischen System.Func-Delegattyp mit bestimmten Typargumenten darstellt. Das letzte Typargument gibt den Rückgabetyp des erstellten Delegaten an.</summary>
        <returns>true, wenn ein generischer System.Func-Delegattyp für bestimmte <paramref name="typeArgs" /> erstellt wurde, andernfalls false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den statischen Typ des Ausdrucks ab, den dieser <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
        <value>Der <see cref="T:System.Type" />, der den statischen Typ des Ausdrucks darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.NodeType%2A> ist der Typ des Knotens in der Ausdrucksbaumstruktur, während die <xref:System.Linq.Expressions.Expression.Type%2A> stellt den statischen common Language Runtime (CLR)-Typ des Ausdrucks, der den Knoten darstellt. Angenommen, zwei Knoten mit unterschiedlichen Knotentypen können verfügen über denselben <xref:System.Linq.Expressions.Expression.Type%2A>, wie im folgenden Codebeispiel gezeigt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
        <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine explizite Verweis- oder Boxingkonvertierung darstellt, bei der <see langword="null" /> zurückgegeben wird, wenn bei der Konvertierung ein Fehler auftritt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.UnaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> ist `null`. Die <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `false`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> Methode zum Erstellen einer <xref:System.Linq.Expressions.UnaryExpression> , die die verweiskonvertierung von einer NULL-Ganzzahlausdruck, der NULL-Werte zulässt-Ganzzahltyp darstellt.  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> oder <paramref name="type" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="T:System.Linq.Expressions.Expression" />-Eigenschaft festgelegt werden soll.</param>
        <param name="type">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, auf das die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />, die die Laufzeittypidentität vergleicht.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> ist und die <see cref="T:System.Linq.Expressions.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />-Eigenschaft festgelegt werden soll.</param>
        <param name="type">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, auf das die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> ist und die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression.Type%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> stellt <xref:System.Boolean>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> Methode zum Erstellen einer <xref:System.Linq.Expressions.TypeBinaryExpression> , die einen Typtest für einen Zeichenfolgenwert darstellt der <xref:System.Int32> Typ.  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> oder <paramref name="type" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine unäre Plusoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.UnaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> auf die implementierende Methode festgelegt ist. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie "false".  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `expression`. Typ ist ein vom benutzerdefinierten Typ, die den unären plus -Operator, definiert die <xref:System.Reflection.MethodInfo> , darstellt, der Operator ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `expression`. Ein numerischer Typ ist, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `expression`. Typ ist der Argumenttyp der implementierenden Methode zugeordnet werden kann, die Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `expression`. Typ ist ein Typ NULL-Werte zulassen, und der entsprechende Werttyp der NULL-gleich dem Argumenttyp der implementierenden Methode.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`, ist der Typ des Knotens `expression`. Geben Sie ein. Wenn `expression`. Typ: NULL-Werte zulässt, der Knoten nicht transformiert. Andernfalls ist der Knoten transformiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der unäre plus -Operator ist nicht definiert, für <paramref name="expression" />. Geben Sie ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
        <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine unäre Plusoperation darstellt.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.UnaryExpression.Method%2A> -Eigenschaft des resultierenden <xref:System.Linq.Expressions.UnaryExpression> auf die implementierende Methode festgelegt ist. Die <xref:System.Linq.Expressions.Expression.Type%2A> Eigenschaft auf den Typ des Knotens festgelegt ist. Wenn der Knoten transformiert wird, die <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> und <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Eigenschaften sind beide `true`. Andernfalls sind sie "false".  
  
#### <a name="implementing-method"></a>Implementieren-Methode  
 Die folgenden Regeln bestimmen die implementierende Methode für den Vorgang.  
  
-   Wenn `method` nicht `null` und dar, eine nicht-Void `static` (`Shared` in Visual Basic) Methode, die ein Argument akzeptiert, ist die implementierende Methode für den Knoten.  
  
-   Wenn `expression`. Typ ist ein vom benutzerdefinierten Typ, die den unären plus -Operator, definiert die <xref:System.Reflection.MethodInfo> , darstellt, der Operator ist die implementierende Methode.  
  
-   Andernfalls gilt: Wenn `expression`. Ein numerischer Typ ist, ist die implementierende Methode `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Knotentyp und nicht transformierte aufgehoben  
 Die implementierende Methode ist nicht `null`:  
  
-   Wenn `expression`. Typ ist der Argumenttyp der implementierenden Methode zugeordnet werden kann, die Knoten nicht transformiert. Der Typ des Knotens ist der Rückgabetyp der implementierenden Methode.  
  
-   Die beiden folgenden Bedingungen erfüllt sind, wird der Knoten transformiert und der Typ des Knotens ist die nullable-Typ, der in den Rückgabetyp der implementierenden Methode entspricht:  
  
    -   `expression`. Typ ist ein Typ NULL-Werte zulassen, und der entsprechende Werttyp der NULL-gleich dem Argumenttyp der implementierenden Methode.  
  
    -   Der Rückgabetyp der implementierenden Methode ist ein NULL-Werttyp.  
  
 Wenn die implementierende Methode `null`, ist der Typ des Knotens `expression`. Geben Sie ein. Wenn `expression`. Typ: NULL-Werte zulässt, der Knoten nicht transformiert. Andernfalls ist der Knoten transformiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" />ist kein <see langword="null" /> und die Methode dar, gibt <see langword="void" />, ist nicht <see langword="static" /> (<see langword="Shared" /> in Visual Basic), oder ist nicht genau ein Argument annehmen.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" />ist <see langword="null" /> und den unären plus -Operator ist nicht definiert, für <paramref name="expression" />. Geben Sie ein.  
  
 - oder -   
  
 <paramref name="expression" />. Typ (oder der entsprechende NULL-Typ, wenn es sich um einen Werttyp handelt) ist nicht zugewiesen werden, in den Argumenttyp der dargestellte Methode <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die Unboxing angewendet werden soll.</param>
        <param name="type">Der neue <see cref="T:System.Type" /> des Ausdrucks.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die ein explizites Unboxing darstellt.</summary>
        <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des Parameters oder der Variable.</param>
        <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten mit dem angegebenen Namen und Typ.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des Parameters oder der Variable.</param>
        <param name="name">Der Name des Parameters oder der Variable. Dieser Name wird nur zum Debugging oder Drucken verwendet.</param>
        <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
        <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten mit dem angegebenen Namen und Typ.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">Eine Instanz von <see cref="T:System.Func`2" />.</param>
        <summary>Reduziert den Knoten und ruft dann den Visitor-Delegaten für den reduzierten Ausdruck auf. Die Methode löst eine Ausnahme aus, wenn der Knoten nicht reduziert werden kann.</summary>
        <returns>Der besuchte Ausdruck oder ein Ausdruck, durch den der Ausdruck in der Struktur ersetzt werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreiben Sie diese Methode, um die Logik bereitstellen, um die untergeordneten Knoten zu durchlaufen. Eine typische Implementierung angerufen Besucher. Besuchen Sie auf jede der untergeordneten und ggf. von ihnen geändert wird, sollte eine neue Kopie von sich selbst mit den geänderten untergeordneten Elementen zurückgeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
