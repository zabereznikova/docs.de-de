<Type Name="BufferedGraphics" FullName="System.Drawing.BufferedGraphics">
  <TypeSignature Language="C#" Value="public sealed class BufferedGraphics : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BufferedGraphics extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Drawing.BufferedGraphics" />
  <AssemblyInfo>
    <AssemblyName>System.Drawing</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen Grafikpuffer für doppelte Pufferung bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.BufferedGraphics> -Klasse können Sie benutzerdefinierte doppelte Pufferung für Grafiken zu implementieren. Es stellt einen Wrapper für einen Grafikpuffer, zusammen mit den Methoden, die Sie verwenden können, in den Puffer schreiben und deren Inhalt in ein Ausgabegerät zu rendern.  
  
 Grafiken, die doppelte Pufferung können reduziert oder zunichte Flackern, die durch das Neuzeichnen einer Anzeigeoberfläche verursacht wird. Bei Verwendung von doppelte Pufferung aktualisierte Grafiken werden zuerst gezeichnet, in einen Puffer im Arbeitsspeicher, und der Inhalt dieses Puffers werden dann schnell in einiger oder aller der angezeigten Oberfläche geschrieben. Dieser relativ kurze Überschreiben der angezeigten Grafiken in der Regel verringert oder beseitigt, das Flackern, das in einigen Fällen tritt auf, wenn Grafiken aktualisiert werden.  
  
> [!NOTE]
>  Die einfachste Möglichkeit, doppelte Pufferung verwendet wird, legen Sie die <xref:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer> Steuern der Format-Flag auf ein Steuerelement mithilfe der <xref:System.Windows.Forms.Control.SetStyle%2A> Methode. Festlegen der <xref:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer> flag für ein Steuerelement alle Paint-Ereignisse für das Steuerelement über eine umleitet, ohne dass zusätzlichen Code. Dieses Flag wird festgelegt, um `true` standardmäßig.  
  
 Die <xref:System.Drawing.BufferedGraphics> Klasse verfügt über keinen öffentlichen Konstruktor und muss erstellt werden, indem die <xref:System.Drawing.BufferedGraphicsContext> für eine Anwendungsdomäne unter Verwendung seiner <xref:System.Drawing.BufferedGraphicsContext.Allocate%2A> Methode. Sie können Abrufen der <xref:System.Drawing.BufferedGraphicsContext> für die aktuelle Anwendungsdomäne aus der statischen <xref:System.Drawing.BufferedGraphicsManager.Current%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die <xref:System.Drawing.BufferedGraphics.Graphics%2A> Eigenschaft kann verwendet werden, um den Grafikpuffer zu zeichnen. Diese Eigenschaft ermöglicht den Zugriff auf die <xref:System.Drawing.Graphics> -Objekt, das an den Grafikpuffer für diese zugeordneten zeichnet <xref:System.Drawing.BufferedGraphics> Objekt.  
  
 Die <xref:System.Drawing.BufferedGraphics.Render%2A> Methode keine Argumente zeichnet den Inhalt des Grafikpuffers Puffer auf die Oberfläche angegeben, wenn der Puffer zugewiesen wurde. Andere Überladungen der der <xref:System.Drawing.BufferedGraphics.Render%2A> Methode ermöglicht Ihnen die Angabe ein <xref:System.Drawing.Graphics> Objekt oder ein <xref:System.IntPtr> Objekt, das für einen Gerätekontext, der zum Zeichnen der Inhalt des Grafikpuffers verweist.  
  
 Weitere Informationen zu zeichnen doppelt gepufferte Grafiken, finden Sie unter [doppelt gepufferte Grafiken](~/docs/framework/winforms/advanced/double-buffered-graphics.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung einer <xref:System.Drawing.BufferedGraphics> Objekt Grafiken, die über verschiedene Implementierungen Pufferung gezeichnet werden soll. Auf das Formular klicken Sie alternativ startet und stoppt einen Zeitgeber, Ursachen Updates zeichnen. Die Draw-Updates können Sie die Auswirkungen der doppelten Pufferung zu beobachten. Mit der rechten Maustaste in das Formular durchläuft die folgenden zeichnen Modi:  
  
-   Zeichnen direkt an die <xref:System.Windows.Forms.Control.Handle%2A> für eine <xref:System.Windows.Forms.Form>.  
  
-   Zeichnen durch Überschreiben der <xref:System.Windows.Forms.Form.OnPaint%2A> -Methode der <xref:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer> Stil zu steuern.  
  
-   Zeichnen durch Überschreiben der <xref:System.Windows.Forms.Form.OnPaint%2A> Methode für die Formularmethode ohne Verwendung der <xref:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer> Stil zu steuern.  
  
 Jeder Modus wird Text gezeichnet, die den aktuellen Modus angibt, und beschreibt das Verhalten, das auftritt, wenn jede Maustaste gedrückt wird.  
  
 [!code-cpp[BufferedGraphicsExample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/BufferedGraphicsExample/CPP/bufferingtest.cpp#1)]
 [!code-csharp[BufferedGraphicsExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/BufferedGraphicsExample/CS/bufferingtest.cs#1)]
 [!code-vb[BufferedGraphicsExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/BufferedGraphicsExample/VB/bufferingtest.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Die <see cref="T:System.Drawing.BufferedGraphics" />-Klasse ist nicht threadsicher. Beim Zugriff auf einen Grafikpuffer aus separaten Threads ist es wichtig, einen Thread Zugriffssteuerungsmechanismus zu verwenden, um Konflikte zu vermeiden.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.BufferedGraphics.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle vom <see cref="T:System.Drawing.BufferedGraphics" />-Objekt verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Drawing.BufferedGraphics.Dispose%2A> sobald Sie fertig sind mit den <xref:System.Drawing.BufferedGraphics> Objekt. Die <xref:System.Drawing.BufferedGraphics.Dispose%2A> -Methode bewirkt, dass die <xref:System.Drawing.BufferedGraphics> Objekt in einem nicht verwendbaren Zustand. Nach dem Aufruf <xref:System.Drawing.BufferedGraphics.Dispose%2A>, müssen Sie alle Verweise auf Freigeben der <xref:System.Drawing.BufferedGraphics> Objekt, damit der Garbage Collector den Arbeitsspeicher freigeben kann, die die <xref:System.Drawing.BufferedGraphics> Objekt belegt wurde. Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Rufen Sie immer <xref:System.Drawing.BufferedGraphics.Dispose%2A> , bevor Sie den letzten Verweis auf Freigeben der <xref:System.Drawing.BufferedGraphics> Objekt. Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Drawing.BufferedGraphics>-Methode des `Finalize`-Objekts aufruft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~BufferedGraphics ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.BufferedGraphics.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einem Objekt Gelegenheit zu dem Versuch, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor es von der Garbage Collection freigegeben wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Graphics">
      <MemberSignature Language="C#" Value="public System.Drawing.Graphics Graphics { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Graphics Graphics" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.BufferedGraphics.Graphics" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Drawing.Graphics" />-Objekt ab, das eine Ausgabe an den Grafikpuffer ausführt.</summary>
        <value>Ein <see cref="T:System.Drawing.Graphics" />-Objekt, das eine Ausgabe an den Grafikpuffer ausführt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht eine <xref:System.Drawing.Graphics> -Objekt, das an den Grafikpuffer für diese zugeordneten zeichnet <xref:System.Drawing.BufferedGraphics> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="public void Render ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Render() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.BufferedGraphics.Render" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schreibt den Inhalt des Grafikpuffers an das Standardgerät.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode schreibt den Inhalt des Grafikpuffers an das Gerät angegeben, indem die <xref:System.Drawing.BufferedGraphicsContext.Allocate%2A> Methode der <xref:System.Drawing.BufferedGraphicsContext> verwendet zum Erstellen dieser <xref:System.Drawing.BufferedGraphics> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="public void Render (System.Drawing.Graphics target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Render(class System.Drawing.Graphics target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.BufferedGraphics.Render(System.Drawing.Graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="target">Ein <see cref="T:System.Drawing.Graphics" />-Objekt, in das der Inhalt des Grafikpuffers geschrieben werden soll.</param>
        <summary>Schreibt den Inhalt des Grafikpuffers in das angegebene <see cref="T:System.Drawing.Graphics" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode schreibt den Inhalt des Grafikpuffers auf den angegebenen <xref:System.Drawing.Graphics> Objekt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Rendern den Inhalt des Grafikpuffers in ein angegebenes <xref:System.Drawing.Graphics> Objekt. Dieser Code ist Teil eines umfangreicheren Beispiels für die <xref:System.Drawing.BufferedGraphics> Klasse.  
  
 [!code-cpp[BufferingExamples#5](~/samples/snippets/cpp/VS_Snippets_Winforms/BufferingExamples/CPP/bufferingexamples.cpp#5)]
 [!code-csharp[BufferingExamples#5](~/samples/snippets/csharp/VS_Snippets_Winforms/BufferingExamples/CS/bufferingexamples.cs#5)]
 [!code-vb[BufferingExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/BufferingExamples/VB/bufferingexamples.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="public void Render (IntPtr targetDC);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Render(native int targetDC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.BufferedGraphics.Render(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetDC" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="targetDC">Ein <see cref="T:System.IntPtr" />, der auf den Gerätekontext zeigt, auf den der Inhalt des Grafikpuffers geschrieben werden soll.</param>
        <summary>Schreibt den Inhalt des Grafikpuffers auf den Gerätekontext, der dem angegebenen <see cref="T:System.IntPtr" />-Handle zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode schreibt den Inhalt des Grafikpuffers auf den Gerätekontext, der mit dem angegebenen verknüpften <xref:System.IntPtr> behandeln.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie der Inhalt des Grafikpuffers gerendert `grafx` für einen angegebenen Gerätekontext. Dieser Code ist Teil eines umfangreicheren Beispiels für die <xref:System.Drawing.BufferedGraphics> Klasse.  
  
 [!code-cpp[BufferingExamples#6](~/samples/snippets/cpp/VS_Snippets_Winforms/BufferingExamples/CPP/bufferingexamples.cpp#6)]
 [!code-csharp[BufferingExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/BufferingExamples/CS/bufferingexamples.cs#6)]
 [!code-vb[BufferingExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/BufferingExamples/VB/bufferingexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Im Zusammenhang Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
