<Type Name="Encoding" FullName="System.Text.Encoding">
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Zeichencodierung dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die .NET Framework-Quellcodes für diesen Typ finden Sie unter der [Verweisquelle](http://referencesource.microsoft.com/#mscorlib/system/text/encoding.cs#3b6090c501893c25). Sie können den Quellcode online Durchsuchen, Referenz für die Offlineanzeige herunterladen und schrittweise durchlaufen (inklusive Patches und Updates) während des Debuggens; finden Sie unter [Anweisungen](http://referencesource.microsoft.com/).  
  
 Beim Kodieren werden Unicode-Zeichen in eine Bytefolge transformiert. Im Gegensatz dazu ist die Decodierung transformiert eine codierte Bytefolge in einen Satz von Unicode-Zeichen. Informationen zu Unicode-Transformation Format (UTFs) und andere von unterstützten Codierungen <xref:System.Text.Encoding>, finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Beachten Sie, dass <xref:System.Text.Encoding> für Unicode-Zeichen anstelle von beliebigen Binärdaten, z. B. Bytearrays ausgeführt werden soll. Wenn beliebige Binärdaten in Text codiert werden müssen, verwenden Sie ein Protokoll wie Uuencode, die durch Methoden, wie z. B. implementiert wird <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 .NET Framework bietet die folgenden Implementierungen der <xref:System.Text.Encoding> Klasse, um die aktuellen Unicode-Codierungen und andere Codierungen unterstützen:  
  
-   <xref:System.Text.ASCIIEncoding>Unicode-Zeichen codiert als einzelne 7-Bit-ASCII-Zeichen. Diese Codierung unterstützt nur Zeichenwerte zwischen U + 0000 und U + 007F. Codepage 20127. Auch verfügbar durch die <xref:System.Text.Encoding.ASCII%2A> Eigenschaft.  
  
-   <xref:System.Text.UTF7Encoding>Unicode-Zeichen, die unter Verwendung der UTF-7-Codierung codiert. Diese Codierung unterstützt alle Unicode-Zeichenwerte. Codepage 65000. Auch verfügbar durch die <xref:System.Text.Encoding.UTF7%2A> Eigenschaft.  
  
-   <xref:System.Text.UTF8Encoding>Unicode-Zeichen, die unter Verwendung der UTF-8-Codierung codiert. Diese Codierung unterstützt alle Unicode-Zeichenwerte. Codepage 65001. Auch verfügbar durch die <xref:System.Text.Encoding.UTF8%2A> Eigenschaft.  
  
-   <xref:System.Text.UnicodeEncoding>Unicode-Zeichen, die unter Verwendung der UTF-16-Codierung codiert. Sowohl little endian und big-endian-Byte-Aufträge werden unterstützt. Auch verfügbar durch die <xref:System.Text.Encoding.Unicode%2A> Eigenschaft und die <xref:System.Text.Encoding.BigEndianUnicode%2A> Eigenschaft.  
  
-   <xref:System.Text.UTF32Encoding>Unicode-Zeichen, die unter Verwendung der UTF-32-Codierung codiert. Sowohl little Endian (Codepage 12000) und big-Endian (Codepage 12001) werden Aufträge unterstützt. Auch verfügbar durch die <xref:System.Text.Encoding.UTF32%2A> Eigenschaft.  
  
 Die <xref:System.Text.Encoding> Klasse dient in erster Linie zum Konvertieren zwischen verschiedenen Codierungen und Unicode. Einer der abgeleiteten Klassen von Unicode-ist häufig die richtige Wahl für Ihre app.  
  
 Verwenden der <xref:System.Text.Encoding.GetEncoding%2A> Methode, um andere Codierungen abzurufen, und rufen Sie die <xref:System.Text.Encoding.GetEncodings%2A> Methode, um eine Liste aller Codierungen abzurufen.  
  
 Die folgende Tabelle enthält die von .NET Framework unterstützten Codierungen. Jede Codierung Codepagenummer und die Werte von der Codierung aufgeführt <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> und <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> Eigenschaften. Ein Sternchen in der letzten Spalte gibt an, dass die Codepage von .NET Framework, unabhängig von der zugrunde liegenden Plattform systemintern unterstützt wird. Beachten Sie, dass Code, dessen Seiten <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> Eigenschaft einem internationalen Standard entspricht nicht unbedingt vollständig mit dieses Standards entsprechen.  
  
|Codepage|Name|Angezeigter Name|.NET Framework-Unterstützung|  
|---------------|----------|------------------|----------------------------|  
|37|IBM037|IBM-EBCDIC (USA, Kanada)||  
|437|IBM437|OEM-USA||  
|500|IBM500|IBM-EBCDIC (International)||  
|708|ASMO-708|Arabisch (ASMO 708)||  
|720|DOS-720|Arabisch (DOS)||  
|737|ibm737|Griechisch (DOS)||  
|775|ibm775|Baltisch (DOS)||  
|850|ibm850|Westeuropäisch (DOS)||  
|852|IBM 852|Mitteleuropäisch (DOS)||  
|855|IBM855|OEM-Kyrillisch||  
|857|ibm857|Türkisch (DOS)||  
|858|IBM00858|OEM Multilingual Lateinisch I||  
|860|IBM860|Portugiesisch (DOS)||  
|861|ibm861|Isländisch (DOS)||  
|862|DOS-862|Hebräisch (DOS)||  
|863|IBM863|Französisch (Kanada) (DOS)||  
|864|IBM864|Arabisch (864)||  
|865|IBM865|Nordisch (DOS)||  
|866|cp866|Kyrillisch (DOS)||  
|869|ibm869|Griechisch, Modern (DOS)||  
|870|IBM870|IBM-EBCDIC (Multilingual Lateinisch-2)||  
|874|Windows-874|Thailändisch (Windows)||  
|875|cp875|IBM-EBCDIC (Griechisch, Modern)||  
|932|"Shift_jis"|Japanisch (Shift-JIS)||  
|936|GB2312|Chinesisch vereinfacht (GB2312)|✓|  
|949|KS_C_5601-1987|Koreanisch||  
|950|Big5|Chinesisch traditionell (Big5)||  
|1026|IBM1026|IBM-EBCDIC (Türkisch Latein-5)||  
|1047|IBM01047|IBM-Latin-1||  
|1140|IBM01140|IBM-EBCDIC (US-Kanada Euro)||  
|1141|IBM01141|IBM-EBCDIC (Deutschland-Euro)||  
|1142|IBM01142|IBM-EBCDIC (Dänemark-Norwegen-Euro)||  
|1143|IBM01143|IBM-EBCDIC (Finnland Schweden Euro)||  
|1144|IBM01144|IBM-EBCDIC (Italien-Euro)||  
|1145|IBM01145|IBM-EBCDIC (Spanien-Euro)||  
|1146|IBM01146|IBM-EBCDIC (Großbritannien-Euro)||  
|1147|IBM01147|IBM-EBCDIC (Frankreich-Euro)||  
|1148|IBM01148|IBM-EBCDIC (International Euro)||  
|1149|IBM01149|IBM-EBCDIC (Isländisch-Euro)||  
|1200|UTF-16|Unicode|✓|  
|1201|unicodeFFFE|Unicode (Big Endian)|✓|  
|1250|Windows-1250|Mitteleuropäisch (Windows)||  
|1251|Windows-1251|Kyrillisch (Windows)||  
|1252|Windows-1252|Westeuropäisch (Windows)|✓|  
|1253|Windows-1253|Griechisch (Windows)||  
|1254|Windows-1254|Türkisch (Windows)||  
|1255|Windows-1255|Hebräisch (Windows)||  
|1256|Windows-1256|Arabisch (Windows)||  
|1257|Windows-1257|Baltisch (Windows)||  
|1258|Windows-1258|Vietnamesisch (Windows)||  
|1361|Johab|Niederländisch (Standard)||  
|10000|Macintosh|Westeuropäisch (Mac)||  
|10001|X-Mac-Japanisch|Japanisch (Mac)||  
|10002|X-Mac-Chinesisch (traditionell)|Chinesisch (traditionell) (Mac)||  
|10003|X-Mac-Koreanisch|Koreanisch (Mac)|✓|  
|10004|X-Mac-Arabisch|Arabisch (Mac)||  
|10005|X-Mac-Hebräisch|Hebräisch (Mac)||  
|10006|X-Mac-Griechisch|Griechisch (Mac)||  
|10007|X-Mac-Kyrillisch|Kyrillisch (Mac)||  
|10008|X-Mac-chinesesimp|Chinesisch vereinfacht (Mac)|✓|  
|10010|X-Mac-Rumänisch|Rumänisch (Mac)||  
|10017|X-Mac-Ukrainisch|Ukrainisch (Mac)||  
|10021|X-Mac-thai|Thailändisch (Mac)||  
|10029|X-Mac-ce|Mitteleuropäisch (Mac)||  
|10079|X-Mac-Isländisch|Isländisch (Mac)||  
|10081|X-Mac-Türkisch|Türkisch (Mac)||  
|10082|X-Mac-Kroatisch|Kroatisch (Mac)||  
|12000|UTF-32|Unicode (UTF-32)|✓|  
|12001|UTF-32BE|Unicode (UTF-32 Big-Endian)|✓|  
|20000|X-Chinesisch-CNS|Chinesisch traditionell (CNS)||  
|20001|X-cp20001|TCA Taiwan||  
|20002|X-Chinesisch-Eten|Chinesisch traditionell (Eten)||  
|20003|X-cp20003|IBM5550 Taiwan||  
|20004|X-cp20004|Er durch Drücken Taiwan||  
|20005|X-cp20005|Wang Taiwan||  
|20105|X-IA5|Westeuropäisch (IA5)||  
|20106|X-IA5-Deutsch|Deutsch (IA5)||  
|20107|X-IA5-Schwedisch|Schwedisch (IA5)||  
|20108|X-IA5-Norwegian|Norwegisch (IA5)||  
|20127|us-ascii|US-ASCII|✓|  
|20261|X-cp20261|T.61||  
|20269|X-cp20269|ISO 6937||  
|20273|IBM273|IBM-EBCDIC (Deutschland)||  
|20277|IBM277|IBM-EBCDIC (Dänemark-Norwegen)||  
|20278|IBM278|IBM-EBCDIC (Finnland Schweden)||  
|20280|IBM280|IBM-EBCDIC (Italien)||  
|20284|IBM284|IBM-EBCDIC (Spanien)||  
|20285|IBM285|IBM-EBCDIC (GROSSBRITANNIEN)||  
|20290|IBM290|IBM-EBCDIC (japanische Katakana)||  
|20297|IBM297|IBM-EBCDIC (Frankreich)||  
|20420|IBM420|IBM-EBCDIC (Arabisch)||  
|20423|IBM423|IBM-EBCDIC (Griechisch)||  
|20424|IBM424|IBM-EBCDIC (Hebräisch)||  
|20833|X-EBCDIC-KoreanExtended|IBM-EBCDIC (erweitertes Koreanisch)||  
|20838|IBM-Thai|IBM-EBCDIC (Thai)||  
|20866|KOI8-r|Kyrillisch (KOI8-R)||  
|20871|IBM871|IBM-EBCDIC (Isländisch)||  
|20880|IBM880|IBM-EBCDIC (Kyrillisch, Russisch)||  
|20905|IBM905|IBM-EBCDIC (Türkisch)||  
|20924|IBM00924|IBM-Latin-1||  
|20932|EUC-JP|Japanisch (JIS 0208-1990 und 0212-1990)||  
|20936|X-cp20936|Chinesisch vereinfacht (GB2312-80)|✓|  
|20949|X-cp20949|Koreanisch Wansung|✓|  
|21025|cp1025|IBM-EBCDIC (Kyrillisch, Serbisch-Bulgarisch)||  
|21866|KOI8-u|Kyrillisch (KOI8-U)||  
|28591|ISO-8859-1|Westeuropäisch (ISO)|✓|  
|28592|ISO-8859-2|Mitteleuropäisch (ISO)||  
|28593|ISO-8859-3|Lateinisch 3 (ISO)||  
|28594|ISO-8859-4|Baltisch (ISO)||  
|28595|ISO-8859-5|Kyrillisch (ISO)||  
|28596|ISO-8859-6|Arabisch (ISO)||  
|28597|ISO-8859-7|Griechisch (ISO)||  
|28598|ISO-8859-8|Hebräisch (ISO-Visual)|✓|  
|28599|ISO-8859-9|Türkisch (ISO)||  
|28603|ISO-8859-13|Estnisch (ISO)||  
|28605|ISO-8859-15|Lateinisch 9 (ISO)||  
|29001|X-Europa|Europa||  
|38598|ISO-8859-8-i|Hebräisch (ISO-logisch)|✓|  
|50220|ISO-2022-jp|Japanisch (JIS)|✓|  
|50221|csISO2022JP|Japanisch (JIS-1 Byte Kana erlaubt)|✓|  
|50222|ISO-2022-jp|Japanisch (JIS erlaubt 1 Byte Kana - SO / SI)|✓|  
|50225|ISO-2022-kr|Koreanisch (ISO)|✓|  
|50227|X-cp50227|Chinesisch vereinfacht (ISO-2022)|✓|  
|51932|EUC-jp|Japanisch (EUC)|✓|  
|51936|EUC CN|Chinesisch vereinfacht (EUC)|✓|  
|51949|EUC-kr|Koreanisch (EUC)|✓|  
|52936|Hz-gb-2312|Chinesisch vereinfacht (HZ)|✓|  
|54936|GB18030|Chinesisch vereinfacht (GB18030)|✓|  
|57002|X-Iscii – de|ISCII Devanagari|✓|  
|57003|X Iscii werden|ISCII Bengalisch|✓|  
|57004|X-Iscii-ta|ISCII Tamil|✓|  
|57005|X-Iscii-te|ISCII Telugu|✓|  
|57006|X Iscii als|ISCII Assamisch|✓|  
|57007|oder für die x iscii|ISCII Oriya|✓|  
|57008|X-Iscii-ka|ISCII Kannada|✓|  
|57009|X-Iscii-ma|ISCII Malayalam|✓|  
|57010|X-Iscii-gu|ISCII Gujarati|✓|  
|57011|X-Iscii-pa|ISCII Punjabi|✓|  
|65000|UTF-7|Unicode (UTF-7)|✓|  
|65001|UTF-8|Unicode (UTF-8)|✓|  
  
 Im folgenden Beispiel wird die <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> und <xref:System.Text.Encoding.GetEncoding%28System.String%29> Methoden zum Abrufen der Griechisch (Windows) code Codierung. Vergleicht die <xref:System.Text.Encoding> Ruft die Methode, um anzugeben, dass sie gleich sind, und klicken Sie dann Maps zeigt den Unicode-Codepunkt und den entsprechenden Codepagewert für jedes Zeichen des griechischen Alphabets zurückgegebenen Objekte.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die UTF-16 und UTF-32-Encoder können die big-endian-Bytereihenfolge (höchstwertigen Byte erste) oder die little-endian-Bytereihenfolge (am wenigsten signifikanten Byte zuerst). Beispielsweise folgt dem lateinischen Großbuchstaben (U + 0041) als serialisiert wird (hexadezimal):  
  
-   UTF-16 big endian-Bytereihenfolge: 00 41  
  
-   UTF-16 little-endian-Bytereihenfolge: 41 00  
  
-   UTF-32 big-endian-Bytereihenfolge: 00 00 00 41  
  
-   UTF-32 little-endian-Bytereihenfolge: 41 00 00 00  
  
 Es ist im Allgemeinen effizienter zum Speichern von Unicode-Zeichen, die mit systemeigenen Bytereihenfolge. Beispielsweise ist es besser, die little-endian-Bytereihenfolge auf little-endian Plattformtypen, beispielsweise Intel Computer verwenden.  
  
 Die <xref:System.Text.Encoding.GetPreamble%2A> Methode ruft ein Array von Bytes, die die Bytereihenfolgemarke (BOM) enthält. Wenn dieses Bytearray in einen codierten Stream vorangestellt ist, leichter den Decoder das Codierungsformat zu identifizieren.  
  
 Weitere Informationen zu Bytereihenfolge und Byte Order Mark, finden Sie im Unicode-Standard an die [Unicode-Homepage](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Beachten Sie, dass die Codierungsklassen Fehler zulassen:  
  
-   Ändern Sie im Hintergrund in ein "?" Zeichen.  
  
-   Verwenden Sie ein Zeichen "best fit".  
  
-   Ändern Sie auf ein anwendungsspezifisches Verhalten mithilfe von der <xref:System.Text.EncoderFallback> und <xref:System.Text.DecoderFallback> Klassen mit dem U + FFFD Unicode-Ersatzzeichen.  
  
 Sie sollten eine Ausnahme bei jedem Data Stream-Fehler auslösen. Eine Anwendung wird mit einem "Throwonerror"-Flag bei Bedarf oder verwendet den <xref:System.Text.EncoderExceptionFallback> und <xref:System.Text.DecoderExceptionFallback> Klassen. Beste Übereinstimmung Fallback wird häufig nicht empfohlen, kann dazu führen, dass Daten verloren gehen oder Verwechslungen und befindet sich langsamer als Ersatz für einfache Zeichen. Für ANSI-Codierung ist die am besten geeignete Verhalten die Standardeinstellung.  
  
   
  
## Examples  
 Das folgende Beispiel konvertiert eine Zeichenfolge aus einer Codierung in eine andere.  
  
> [!NOTE]
>  Das Bytearray [] ist der einzige Typ in diesem Beispiel, das die codierten Daten enthält. Die .NET Char und String-Typen sind selbst Unicode, sodass der <xref:System.Text.Encoding.GetChars%2A> Aufruf decodiert die Daten wieder in Unicode.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Encoding" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen überschreiben dieses Konstruktors.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">Der Codepagebezeichner der bevorzugten Codierung.  
  
 - oder -  
  
 0, um die Standardcodierung zu verwenden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Encoding" />-Klasse, die der angegebenen Codepage entspricht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen überschreiben dieses Konstruktors.  
  
 Aufrufe an diesen Konstruktor von einer abgeleiteten Klasse erstellen ein <xref:System.Text.Encoding> -Objekt, das Fallback mit ähnlichen Zeichen für Codierung und Decodierung Vorgänge verwendet. Sowohl die <xref:System.Text.Encoding.DecoderFallback%2A> und <xref:System.Text.Encoding.EncoderFallback%2A> Eigenschaften sind schreibgeschützt und kann nicht geändert werden. Um die Fallbackstrategie zu steuern, für eine Klasse abgeleitet <xref:System.Text.Encoding>, rufen Sie die <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> Konstruktor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">Der Bezeichner der Codierungs-Codepage.</param>
        <param name="encoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn ein Zeichen nicht mit der aktuellen Codierung codiert werden kann.</param>
        <param name="decoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn eine Bytefolge nicht mit der aktuellen Codierung decodiert werden kann.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Encoding" />-Klasse, die der angegebenen Codepage entspricht, mit den angegebenen Fallbackstrategien für Codierer und Decodierer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ist `protected`; abgeleitete Klassen überschreiben.  
  
 Rufen Sie diesen Konstruktor, von einer abgeleiteten Klasse zum Codieren und Decodieren von Strategien beim Fallback zu steuern. Die <xref:System.Text.Encoding> Klassenkonstruktoren nur-Lese Codierung Objekte erstellen, die nicht zulassen, Encoder oder DecoderFallback festgelegt werden, nachdem das Objekt erstellt wurde.  
  
 Wenn entweder `encoderFallback` oder `decoderFallback` ist null, Fallback mit ähnlichen Zeichen als die entsprechenden Fallbackstrategie verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für den ASCII-Zeichensatz (7-Bit) ab.</summary>
        <value>Eine Codierung für den ASCII-Zeichensatz (7 Bits).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASCII-Zeichen sind auf die ersten 128 Unicode-Zeichen von U + 0000 bis U + 007F beschränkt.  
  
 Wenn Sie auswählen, die ASCII-Codierung für Ihre app, beachten Sie Folgendes ein:  
  
-   Der ASCII-Codierung eignet sich in der Regel für die Protokolle, die ASCII erfordern.  
  
-   Wenn Sie die 8-Bit-Codierung (die manchmal fälschlicherweise als "ASCII" bezeichnet) erforderlich ist, die UTF-8-Codierung wird empfohlen gegenüber der ASCII-Codierung. Klicken Sie für die Zeichen 0-7F. die Ergebnisse sind identisch, aber vermeidet Datenverluste Verwendung von UTF-8 ermöglicht die Darstellung der alle Unicode-Zeichen dargestellt werden kann. Beachten Sie, dass die ASCII-Codierung hat einen 8-bit-Mehrdeutigkeit, mit denen böswillige verwenden kann, kann aber UTF-8-Codierung Mehrdeutigkeit in Bezug auf das 8. Bit entfernt.  
  
-   Vor .NET Framework, Version 2.0 darf die .NET Framework spoofing durch ignorieren des 8. Bits. Ab .NET Framework 2.0, ausweichen nicht-ASCII-Codepunkte während der Decodierung.  
  
 Die <xref:System.Text.ASCIIEncoding> von dieser Eigenschaft zurückgegebene Objekt möglicherweise nicht das entsprechende Verhalten für Ihre app. Es verwendet einen Ersatzfallback ersetzt jede Zeichenfolge, die nicht codiert werden kann, und jedes Byte, die nicht decodiert werden können mit einem Fragezeichen ("?") Zeichen. Rufen Sie stattdessen die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> -Methode instanziieren ein <xref:System.Text.ASCIIEncoding> Objekt, dessen Fallback handelt es sich um, eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Wirkung der ASCII-Codierung für Zeichen, die außerhalb des ASCII-Bereichs liegen.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für das UTF-16-Format mit Big-Endian-Bytereihenfolge ab.</summary>
        <value>Ein Codierungsobjekt für das UTF-16-Format, das die Big-Endian-Bytereihenfolge verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.UnicodeEncoding> von dieser Eigenschaft zurückgegebene Objekt möglicherweise nicht das entsprechende Verhalten für Ihre app. Es verwendet einen Ersatzfallback ersetzt jede Zeichenfolge, die nicht codiert werden kann, und jedes Byte, die nicht decodiert werden können mit einem Fragezeichen ("?") Zeichen. Rufen Sie stattdessen die <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor zum Instanziieren einer big-Endian <xref:System.Text.UnicodeEncoding> Objekt, dessen Fallback handelt es sich um, eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 Das zurückgegebene <xref:System.Text.UnicodeEncoding> Objekt hat <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, und <xref:System.Text.Encoding.WebName%2A> Eigenschaften, die den Namen "UnicodeFFFE" ergeben. Obwohl die UTF-16 big-endian-Byte-reihenfolgemarkierung hexadezimale FEFF ist, wurde die UnicodeFFFE"Name" gewählt, weil Byte Order Mark als hexadezimale FFFE auf little-endian-Windows-Computer angezeigt wird.  
  
   
  
## Examples  
 Das folgende Beispiel liest eine Textdatei mit einer UTF-16-Codierung, die unter Verwendung der big-endian-Bytereihenfolge.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Name für die aktuelle Codierung abgerufen, die mit den Body-Tags des E-Mail-Agenten verwendet werden kann.</summary>
        <value>Ein Name der aktuellen <see cref="T:System.Text.Encoding" />-Klasse, die mit den Body-Tags des E-Mail-Agenten verwendet werden kann.  
  
 - oder -  
  
 Eine leere Zeichenfolge (""), wenn das aktuelle <see cref="T:System.Text.Encoding" /> nicht verwendet werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Codierung für den Namen eines Body haben möchten, sollten Sie aufrufen <xref:System.Text.Encoding.GetEncoding%2A> mit der <xref:System.Text.Encoding.BodyName%2A> Eigenschaft. Häufig Ruft die Methode mit einer abweichenden Codierung aus der Test Codierung, die im Aufruf erbracht ab. Im Allgemeinen müssen nur e-Mail-Anwendungen zum Abrufen, diese Codierung; Die meisten anderen Anwendungen, die eine Codierung wird beschrieben, müssen die zu verwendende seine <xref:System.Text.Encoding.WebName%2A>.  
  
 In einigen Fällen den Wert der <xref:System.Text.Encoding.BodyName%2A> Eigenschaft entspricht der internationalen Standard, die Codierung definiert. Dies bedeutet nicht, dass die Implementierung vollständig mit dieses Standards erfüllt.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft die verschiedenen Namen für jede Codierung ab und zeigt die Codierungen mit ein oder mehrere Namen, die von unterscheiden <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Es zeigt <xref:System.Text.Encoding.EncodingName%2A> jedoch nicht dafür verglichen.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt beim Überschreiben in einer abgeleiteten Klasse eine flache Kopie des aktuellen <see cref="T:System.Text.Encoding" />-Objekts.</summary>
        <returns>Eine Kopie des aktuellen <see cref="T:System.Text.Encoding" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Klon beschreibbar ist auch dann, wenn die ursprüngliche <xref:System.Text.Encoding> Objekt ist schreibgeschützt. Aus diesem Grund können die Eigenschaften des Klons geändert werden.  
  
 Eine flache Kopie eines Objekts ist eine Kopie des Objekts nur. Wenn das Objekt Verweise auf andere Objekte enthält, erstellt die flache Kopie keine Kopien der Objekte verwiesen wird. Er bezieht sich stattdessen auf die ursprünglichen Objekte. Im Gegensatz dazu erstellt eine tiefe Kopie eines Objekts eine Kopie des Objekts und eine Kopie aller Elemente auf die dieses Objekt direkt oder indirekt verweist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Codepagebezeichner der aktuellen <see cref="T:System.Text.Encoding" />-Klasse beim Überschreiben in einer abgeleiteten Klasse ab.</summary>
        <value>Der Codepagebezeichner der aktuellen <see cref="T:System.Text.Encoding" />-Klasse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel ruft die verschiedenen Namen für jede Codierung ab und zeigt die Codierungen mit ein oder mehrere Namen, die von unterscheiden <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Es zeigt <xref:System.Text.Encoding.EncodingName%2A> jedoch nicht dafür verglichen.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Das Codierungsformat von <c>Bytes</c>.</param>
        <param name="dstEncoding">Das Zielcodierungsformat.</param>
        <param name="bytes">Die zu konvertierenden Bytes.</param>
        <summary>Konvertiert ein vollständiges Bytearray aus einer Codierung in eine andere.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Byte" />, das die Ergebnisse der Konvertierung in <paramref name="bytes" /> von <paramref name="srcEncoding" /> in <paramref name="dstEncoding" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel konvertiert eine Unicode-codierte Zeichenfolge in eine ASCII-codierte Zeichenfolge. Da das ASCII-Codieren von Objekts zurückgegebene der <xref:System.Text.Encoding.ASCII%2A> Eigenschaft verwendet einen Ersatzfallback und das Zeichen Pi ist nicht Teil des ASCII-Zeichensatz, das Pi-Zeichen wird durch ein Fragezeichen ersetzt, wie die Ausgabe des Beispiels zeigt.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="dstEncoding" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 **SrcEncoding.** Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 **DstEncoding.** Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Die Codierung des Quellarrays, <c>Bytes</c>.</param>
        <param name="dstEncoding">Die Codierung des Ausgabearrays.</param>
        <param name="bytes">Das zu konvertierende Bytearray.</param>
        <param name="index">Der Index des ersten Elements der <c>Bytes</c> konvertieren.</param>
        <param name="count">Die Anzahl der zu konvertierenden Bytes.</param>
        <summary>Konvertiert einen Bereich von Bytes in einem Bytearray aus einer Codierung in eine andere.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Byte" />, das das Ergebnis der Konvertierung eines Bereichs von Bytes in <paramref name="bytes" /> von <paramref name="srcEncoding" /> in <paramref name="dstEncoding" /> enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="dstEncoding" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />und <paramref name="count" /> Geben Sie keinen gültigen Bereich nicht im Bytearray.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 **SrcEncoding.** Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 **DstEncoding.** Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Text.DecoderFallback" />-Objekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt ab.</summary>
        <value>Das Decoderfallbackobjekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.DecoderFallback> -Objekt stellt einen Fehlerhandler, der aufgerufen wird, wenn eine codierte Bytefolge in Zeichen decodiert werden kann. Eines der folgenden Handlertypen wird unterstützt:  
  
-   Einen ähnlichen fallback-Handler, der Bytes, die nicht decodiert werden können, durch ein geeigneter Ersatz-Zeichen ersetzt.  
  
-   Ein Ersatzfallback-Handler, der Bytes, die nicht decodiert werden können nicht mit einem beliebigen Ersatzzeichen ersetzt. .NET Framework enthält eine Ersetzung fallback-Handler <xref:System.Text.DecoderFallback>, ersetzt die standardmäßig Bytes, die nicht decodiert werden können, mit einem Fragezeichen ("?") Zeichen.  
  
-   Eine Ausnahme fallback-Handler, der eine Ausnahme auslöst, wenn Bytes nicht decodiert werden können. .NET Framework enthält eine Ausnahme fallback-Handler <xref:System.Text.DecoderExceptionFallback>, wodurch eine <xref:System.Text.DecoderFallbackException> Wenn Bytes nicht decodiert werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert in einem Set-Vorgang ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Wert kann nicht in einem Set-Vorgang nicht zugewiesen werden, da die aktuelle <see cref="T:System.Text.Encoding" /> Objekt ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, die standardcodierung für diese Implementierung .NET.</summary>
        <value>Der Standardwert für diese Implementierung .NET Codierung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Unterschiedliche Computer können unterschiedliche Codierungen verwenden, als die Standardeinstellung, und die standardcodierung auf einem einzelnen Computer ändern kann. Bei Verwendung der <xref:System.Text.Encoding.Default%2A> Codierung zur Codierung und Decodierung von Daten zwischen Computern Streaming- oder zu unterschiedlichen Zeiten auf dem gleichen Computer abgerufen, es möglicherweise übersetzt diese Daten nicht ordnungsgemäß. Darüber hinaus zurückgegebenes die Codierung der <xref:System.Text.Encoding.Default%2A> Eigenschaft verwendet Fallback mit ähnlichen Zeichen, die von der Codepage unterstützt nicht unterstützte Zeichen zuzuordnen. Aus diesen Gründen wird die Verwendung der standardcodierung nicht empfohlen. Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, verwenden Sie eine Unicode-Codierung, z. B. <xref:System.Text.UTF8Encoding> oder <xref:System.Text.UnicodeEncoding>. Ein Protokoll auf höherer Ebene können Sie sicherstellen, dass das gleiche Format verwendet wird, zum Codieren und decodieren.  

### <a name="the-default-property-in-the-net-framework"></a>Die Standardeigenschaft in .NET Framework

In .NET Framework auf dem Windows-Desktop den <xref:System.Text.Encoding.Default%2A> Eigenschaft immer ruft aktive Codepage des Systems ab und erstellt eine <xref:System.Text.Encoding> Objekt, das es entspricht. Die aktive Codepage möglicherweise eine ANSI-Codepage enthält die ASCII-Zeichensatz zusammen mit zusätzlichen Zeichen, die variieren nach Codepage. Da alle <xref:System.Text.Encoding.Default%2A> Codierungen, die basierend auf ANSI-Codepages Daten verloren gehen, sollten Sie die <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> stattdessen Codierung. UTF-8 häufig U + 00 mit U + 7F. Bereich identisch ist, aber Sie können Zeichen außerhalb des ASCII-ohne Verlust codieren.

## <a name="the-default-property-on-net-core"></a>Die Standardeigenschaft für .NET Core

Auf .NET Core die <xref:System.Text.Encoding.Default%2A> -Eigenschaft gibt immer die <xref:System.Text.UTF8Encoding>. Auf alle Betriebssysteme (Windows, Linux und Max OS X) auf die Anwendungen mit .NET Core ausgeführt wird UTF-8 unterstützt.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Text.EncoderFallback" />-Objekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt ab.</summary>
        <value>Das Encoderfallbackobjekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.EncoderFallback> -Objekt stellt einen Fehlerhandler, der aufgerufen wird, wenn ein Zeichen in eine codierte Bytefolge konvertiert werden kann. Eines der folgenden Handlertypen wird unterstützt:  
  
-   Einen ähnlichen fallback-Handler, der Zeichen, die nicht codiert werden können, durch ein geeigneter Ersatz-Zeichen ersetzt.  
  
-   Ein Ersatzfallback-Handler, der Zeichen, die nicht codiert werden können mit einem beliebigen Ersatzzeichen ersetzt. .NET Framework enthält eine Ersetzung fallback-Handler <xref:System.Text.EncoderFallback>, die standardmäßig ersetzt Zeichen, die nicht codiert werden können, mit einem Fragezeichen ("?") Zeichen.  
  
-   Eine Ausnahme fallback-Handler, der eine Ausnahme auslöst, wenn Zeichen nicht codiert werden können. .NET Framework enthält eine Ausnahme fallback-Handler <xref:System.Text.EncoderExceptionFallback>, wodurch eine <xref:System.Text.EncoderFallbackException> Wenn Zeichen nicht decodiert werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert in einem Set-Vorgang ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Wert kann nicht in einem Set-Vorgang nicht zugewiesen werden, da die aktuelle <see cref="T:System.Text.Encoding" /> Objekt ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird die Klartextbeschreibung der aktuellen Codierung abgerufen.</summary>
        <value>Die Klartextbeschreibung der aktuellen <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.EncodingName%2A> Eigenschaft zur Anzeige vorgesehen ist. Beim Ermitteln eines Namens, der übergeben werden kann die <xref:System.Text.Encoding.GetEncoding%2A> -Methode, mit der <xref:System.Text.Encoding.WebName%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft die verschiedenen Namen für jede Codierung ab und zeigt die Codierungen mit ein oder mehrere Namen, die von unterscheiden <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Es zeigt <xref:System.Text.Encoding.EncodingName%2A> jedoch nicht dafür verglichen.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das <see cref="T:System.Object" />, das mit der aktuellen Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob das angegebene <see cref="T:System.Object" /> und die aktuelle Instanz gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="value" /> eine Instanz von <see cref="T:System.Text.Encoding" /> und gleich der aktuellen Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei Instanzen von <xref:System.Text.Encoding> werden als gleich betrachtet, wenn sie dieselbe Codepage entsprechen und ihre `EncoderFallback` und `DecoderFallback` -Objekte gleich sind. Insbesondere abgeleiteten Codepages, die alle eine Codepage 0 und deren Zugriffe sind normalerweise `null` (`Nothing` in Visual Basic .NET).). Daher werden sie alle anderen gleich angesehen. Ein Vorteil ist, die bei der <xref:System.Text.Encoding.Equals%2A> wird verwendet, um eine Hashtabelle aufzufüllen, alle Codierungen gleich stammen und fallen in der gleichen Tabelle Hash Slot.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft zwei Instanzen der gleichen Codierung (eine nach der Codepage) und ein anderes anhand des Namens ab und überprüft deren Gleichheit.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray mit den zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl an Bytes, die beim Codieren aller Zeichen im angegebenen Zeichenarray erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die durch Codieren aller Zeichen im angegebenen Zeichenarray erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> rufen Sie zum Speichern der resultierenden Bytes der <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird.  
  
-   Wenn Ihre app Zeichenfolgeneingaben behandelt, sollte, verwenden Sie die Zeichenfolge Versionen der <xref:System.Text.Encoding.GetBytes%2A> Methode.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten Sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge mit den zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Bytes, die beim Codieren der Zeichen in der angegebenen Zeichenfolge erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> rufen Sie zum Speichern der resultierenden Bytes der <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird.  
  
-   Wenn Ihre app Zeichenfolgeneingaben, die Version der Zeichenfolge behandelt <xref:System.Text.Encoding.GetBytes%2A> wird empfohlen.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Ein Zeiger auf das erste zu codierende Zeichen.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Bytes, die beim Codieren der Zeichen ab dem Zeichenzeiger erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> erfordert zum Speichern der resultierenden Bytes, rufen Sie die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Überlegungen zur Verwendung dieser Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird.  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, sollten Sie die Version der Zeichenfolge verwenden die <xref:System.Text.Encoding.GetBytes%2A> Methode.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%2A> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray, das die zu codierenden Zeichen enthält.</param>
        <param name="index">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl an Bytes, die beim Codieren der Zeichen aus dem angegebenen Zeichenarray erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> rufen Sie zum Speichern der resultierenden Bytes der <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird.  
  
-   Wenn Ihre app Zeichenfolgeneingaben, die Version der Zeichenfolge behandelt <xref:System.Text.Encoding.GetBytes%2A> wird empfohlen.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um drei Zeichen aus einem Zeichenarray von zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray mit den zu codierenden Zeichen.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden alle Zeichen im angegebenen Zeichenarray in eine Bytefolge codiert.</summary>
        <returns>Ein Bytearray mit den Ergebnissen der Codierung der angegebenen Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Ersatzzeichenpaare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> merkt sich dieses hohe Ersatzzeichen, damit es mit ein niedriges Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding>wird nicht in der Lage, den Status verwalten, damit das Zeichen zu sendende der <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, sollten Sie die Version der Zeichenfolge Aufrufen der <xref:System.Text.Encoding.GetBytes%2A> Methode.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge mit den zu codierenden Zeichen.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden alle Zeichen in der angegebenen Zeichenfolge in eine Bytefolge codiert.</summary>
        <returns>Ein Bytearray mit den Ergebnissen der Codierung der angegebenen Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Ersatzzeichenpaare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> merkt sich dieses hohe Ersatzzeichen, damit es mit ein niedriges Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding>wird nicht in der Lage, den Status verwalten, damit das Zeichen zu sendende der <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray, das die zu codierenden Zeichen enthält.</param>
        <param name="index">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen im angegebenen Zeichenarray in eine Bytefolge codiert.</summary>
        <returns>Ein Bytearray mit den Ergebnissen der Codierung der angegebenen Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Ersatzzeichenpaare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> merkt sich dieses hohe Ersatzzeichen, damit es mit ein niedriges Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding>wird nicht in der Lage, den Status verwalten, damit das Zeichen zu sendende der <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um drei Zeichen aus einem Zeichenarray von zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Ein Zeiger auf das erste zu codierende Zeichen.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <param name="byteCount">Die maximale Anzahl der zu schreibenden Bytes.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen beginnend am angegebenen Zeichenzeiger in eine Bytefolge codiert, die ab Beginn des angegebenen Bytezeigers gespeichert wird.</summary>
        <returns>Die tatsächliche Anzahl an Bytes, die an der durch den <paramref name="bytes" />-Parameter angegebenen Position geschrieben wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> erfordert zum Speichern der resultierenden Bytes, rufen Sie die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> Objekt von der bereitgestellten<c5/> oder <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Ersatzzeichenpaare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> merkt sich dieses hohe Ersatzzeichen, damit es mit ein niedriges Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding>wird nicht in der Lage, den Status verwalten, damit das Zeichen zu sendende der <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> oder <paramref name="byteCount" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" />ist kleiner als die resultierende Anzahl von Bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray, das die zu codierenden Zeichen enthält.</param>
        <param name="charIndex">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</param>
        <param name="byteIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen aus dem angegebenen Zeichenarray in das angegebene Bytearray codiert.</summary>
        <returns>Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes rufen Sie die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Ersatzzeichenpaare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> merkt sich dieses hohe Ersatzzeichen, damit es mit ein niedriges Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding>wird nicht in der Lage, den Status verwalten, damit das Zeichen zu sendende der <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um drei Zeichen aus einem Zeichenarray von zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />oder <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.  
  
 - oder -   
  
 <paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" />verfügt nicht über genügend Kapazität von <paramref name="byteIndex" /> bis zum Ende des Arrays, die sich ergebenden Bytes aufzunehmen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge mit den zu codierenden Zeichen.</param>
        <param name="charIndex">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</param>
        <param name="byteIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen aus der angegebenen Zeichenfolge in das angegebene Bytearray codiert.</summary>
        <returns>Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes rufen Sie die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Ersatzzeichenpaare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> merkt sich dieses hohe Ersatzzeichen, damit es mit ein niedriges Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding>wird nicht in der Lage, den Status verwalten, damit das Zeichen zu sendende der <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />oder <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.  
  
 - oder -   
  
 <paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" />verfügt nicht über genügend Kapazität von <paramref name="byteIndex" /> bis zum Ende des Arrays, die sich ergebenden Bytes aufzunehmen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren aller Bytes in dem angegebenen Bytearray erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> zum Speichern der resultierenden Zeichen verwenden Sie die <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Methode. Um die maximale Arraygröße zu berechnen, verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> Methode. Die <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und die <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> Methode führt die tatsächlichen Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihrer app müssen möglicherweise mehrere Eingabe Bytes aus einer Codepage zu decodieren und die Bytes mit mehreren Aufrufen verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen aufrufen.  
  
-   Wenn Ihre app Zeichenfolgenausgaben verarbeitet, sollten Sie verwenden die <xref:System.Text.Encoding.GetString%2A> Methode. Da diese Methode muss Zeichenfolgenlänge überprüfen und einen Puffer zuzuordnen, ist es etwas langsamer, aber die resultierende <xref:System.String> zu bevorzugen ist.  
  
-   Der Byteversion von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, unterstützt die Ausgabe von Zeichen Puffer ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert und klicken Sie dann die Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf das erste zu decodierende Byte.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren einer Bytefolge ab dem angegebenen Bytezeiger erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetChars%2A> erfordert zum Speichern der resultierenden Zeichen, verwenden Sie die <xref:System.Text.Encoding.GetCharCount%2A> Methode. Zum Berechnen der maximalen Arraygröße verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.Encoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die tatsächlichen Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihrer app müssen möglicherweise mehrere Eingabe Bytes aus einer Codepage zu decodieren und die Bytes mit mehreren Aufrufen verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen aufrufen.  
  
-   Wenn Ihre app Zeichenfolgenausgaben verarbeitet, es wird empfohlen, verwenden Sie die <xref:System.Text.Encoding.GetString%2A> Methode. Da diese Methode muss Zeichenfolgenlänge überprüfen und einen Puffer zuzuordnen, ist es etwas langsamer, aber die resultierende <xref:System.String> zu bevorzugen ist.  
  
-   Der Byteversion von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, unterstützt die Ausgabe von Zeichen Puffer ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren einer Bytefolge aus dem angegebenen Bytearray erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen verwenden Sie die <xref:System.Text.Encoding.GetCharCount%2A> Methode. Zum Berechnen der maximalen Arraygröße verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.Encoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die tatsächlichen Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihrer app müssen möglicherweise mehrere Eingabe Bytes aus einer Codepage zu decodieren und die Bytes mit mehreren Aufrufen verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen aufrufen.  
  
-   Wenn Ihre app Zeichenfolgenausgaben verarbeitet, es wird empfohlen, verwenden Sie die <xref:System.Text.Encoding.GetString%2A> Methode. Da diese Methode muss Zeichenfolgenlänge überprüfen und einen Puffer zuzuordnen, ist es etwas langsamer, aber die resultierende <xref:System.String> zu bevorzugen ist.  
  
-   Der Byteversion von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, unterstützt die Ausgabe von Zeichen Puffer ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Das folgende Beispiel konvertiert eine Zeichenfolge aus einer Codierung in eine andere.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert und anschließend einen Bereich von Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden alle Bytes im angegebenen Bytearray in Zeichen decodiert.</summary>
        <returns>Ein Zeichenarray, das die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>Ruft die Zeichen aus einer Eingabebytefolge ab. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> da <xref:System.Text.Encoding> erwartet diskrete Konvertierungen während <xref:System.Text.Decoder> für mehrere Durchläufe für genau einen Eingabedatenstrom dient.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 **Hinweis** diese Methode dient zum Verarbeiten von Unicode-Zeichen, nicht auf beliebigen Binärdaten, z. B. Bytearrays. Wenn Sie beliebige Binärdaten in Text codiert werden müssen, verwenden Sie ein Protokoll wie Uuencode, die durch Methoden, wie z. B. implementiert wird <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die tatsächlichen Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihrer app müssen möglicherweise mehrere Eingabe Bytes aus einer Codepage zu decodieren und die Bytes mit mehreren Aufrufen verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen aufrufen, da Bytefolgen unterbrochen werden können, wenn in Batches verarbeitet. (Z. B. Teil einer ISO-2022 Umschaltsequenz unter Umständen eine <xref:System.Text.Encoding.GetChars%2A> aufrufen und den Vorgang fortzusetzen, am Anfang der nächsten <xref:System.Text.Encoding.GetChars%2A> aufrufen. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>Ruft den Fallback für diese unvollständigen Sequenzen jedoch <xref:System.Text.Decoder> merkt sich diese Sequenzen für den nächsten Aufruf.)  
  
-   Wenn Ihre app Zeichenfolgenausgaben verarbeitet, es wird empfohlen, verwenden Sie die <xref:System.Text.Encoding.GetString%2A> Methode. Da diese Methode muss Zeichenfolgenlänge überprüfen und einen Puffer zuzuordnen, ist es etwas langsamer, aber die resultierende <xref:System.String> zu bevorzugen ist.  
  
-   Der Byteversion von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, unterstützt die Ausgabe von Zeichen Puffer ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert und klicken Sie dann die Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge aus dem angegebenen Bytearray in Zeichen decodiert.</summary>
        <returns>Ein Zeichenarray, das die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>Ruft die Zeichen aus einer Eingabebytefolge ab. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> da <xref:System.Text.Encoding> erwartet diskrete Konvertierungen während <xref:System.Text.Decoder> für mehrere Durchläufe für genau einen Eingabedatenstrom dient.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 **Hinweis** diese Methode dient zum Verarbeiten von Unicode-Zeichen, nicht auf beliebigen Binärdaten, z. B. Bytearrays. Wenn Sie beliebige Binärdaten in Text codiert werden müssen, verwenden Sie ein Protokoll wie Uuencode, die durch Methoden, wie z. B. implementiert wird <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die tatsächlichen Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihrer app müssen möglicherweise mehrere Eingabe Bytes aus einer Codepage zu decodieren und die Bytes mit mehreren Aufrufen verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen aufrufen, da Bytefolgen unterbrochen werden können, wenn in Batches verarbeitet. (Z. B. Teil einer ISO-2022 Umschaltsequenz unter Umständen eine <xref:System.Text.Encoding.GetChars%2A> aufrufen und den Vorgang fortzusetzen, am Anfang der nächsten <xref:System.Text.Encoding.GetChars%2A> aufrufen. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>Ruft den Fallback für diese unvollständigen Sequenzen jedoch <xref:System.Text.Decoder> merkt sich diese Sequenzen für den nächsten Aufruf.)  
  
-   Wenn Ihre app Zeichenfolgenausgaben verarbeitet, es wird empfohlen, verwenden Sie die <xref:System.Text.Encoding.GetString%2A> Methode. Da diese Methode muss Zeichenfolgenlänge überprüfen und einen Puffer zuzuordnen, ist es etwas langsamer, aber die resultierende <xref:System.String> zu bevorzugen ist.  
  
-   Der Byteversion von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, unterstützt die Ausgabe von Zeichen Puffer ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert und anschließend einen Bereich von Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf das erste zu decodierende Byte.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="chars">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</param>
        <param name="charCount">Die maximale Anzahl der zu schreibenden Zeichen.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge beginnend am angegebenen Bytezeiger in Zeichen decodiert, die ab Beginn des angegebenen Zeichenzeigers gespeichert werden.</summary>
        <returns>Die tatsächliche Anzahl der Zeichen, die an der durch den <paramref name="chars" />-Parameter angegebenen Position geschrieben wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetChars%2A> erfordert zum Speichern der resultierenden Zeichen, verwenden Sie die <xref:System.Text.Encoding.GetCharCount%2A> Methode. Zum Berechnen der maximalen Arraygröße verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.Encoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>Ruft die Zeichen aus einer Eingabebytefolge ab. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> da <xref:System.Text.Encoding> erwartet diskrete Konvertierungen während <xref:System.Text.Decoder> für mehrere Durchläufe für genau einen Eingabedatenstrom dient.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> Objekt von der bereitgestellten<c5/> oder <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 **Hinweis** diese Methode dient zum Verarbeiten von Unicode-Zeichen, nicht auf beliebigen Binärdaten, z. B. Bytearrays. Wenn Sie beliebige Binärdaten in Text codiert werden müssen, verwenden Sie ein Protokoll wie Uuencode, die durch Methoden, wie z. B. implementiert wird <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die tatsächlichen Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihrer app müssen möglicherweise mehrere Eingabe Bytes aus einer Codepage zu decodieren und die Bytes mit mehreren Aufrufen verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen aufrufen, da Bytefolgen unterbrochen werden können, wenn in Batches verarbeitet. (Z. B. Teil einer ISO-2022 Umschaltsequenz unter Umständen eine <xref:System.Text.Encoding.GetChars%2A> aufrufen und den Vorgang fortzusetzen, am Anfang der nächsten <xref:System.Text.Encoding.GetChars%2A> aufrufen. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>Ruft den Fallback für diese unvollständigen Sequenzen jedoch <xref:System.Text.Decoder> merkt sich diese Sequenzen für den nächsten Aufruf.)  
  
-   Wenn Ihre app Zeichenfolgenausgaben, behandelt die <xref:System.Text.Encoding.GetString%2A> Methode wird empfohlen. Da diese Methode muss Zeichenfolgenlänge überprüfen und einen Puffer zuzuordnen, ist es etwas langsamer, aber die resultierende <xref:System.String> zu bevorzugen ist.  
  
-   Der Byteversion von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, unterstützt die Ausgabe von Zeichen Puffer ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> oder <paramref name="charCount" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" />ist kleiner als die daraus resultierende Zeichenanzahl.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="byteIndex">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="chars">Das Zeichenarray, das die sich ergebenden Zeichen enthalten soll.</param>
        <param name="charIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge aus dem angegebenen Bytearray in das angegebene Zeichenarray decodiert.</summary>
        <returns>Die tatsächliche Anzahl der Zeichen, die in <paramref name="chars" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen verwenden Sie die <xref:System.Text.Encoding.GetCharCount%2A> Methode. Zum Berechnen der maximalen Arraygröße verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.Encoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > ruft Zeichen aus einer Eingabebytefolge ab. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> da <xref:System.Text.Encoding> erwartet diskrete Konvertierungen während <xref:System.Text.Decoder> dient für mehrere Durchläufe für genau einen Eingabedatenstrom.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 **Hinweis** diese Methode dient zum Verarbeiten von Unicode-Zeichen, nicht auf beliebigen Binärdaten, z. B. Bytearrays. Wenn Sie beliebige Binärdaten in Text codiert werden müssen, verwenden Sie ein Protokoll wie Uuencode, die durch Methoden, wie z. B. implementiert wird <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die tatsächlichen Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihrer app müssen möglicherweise mehrere Eingabe Bytes aus einer Codepage zu decodieren und die Bytes mit mehreren Aufrufen verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen aufrufen, da Bytefolgen unterbrochen werden können, wenn in Batches verarbeitet. (Z. B. Teil einer ISO-2022 Umschaltsequenz unter Umständen eine [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > aufrufen und den Vorgang fortzusetzen, am Anfang der nächsten [\], Int32, Int32, Char\<Xref : System.Text.Encoding.GetChars%2A > aufrufen. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > Fallback für diese unvollständigen Sequenzen ruft aber <xref:System.Text.Decoder> merkt sich diese Sequenzen für den nächsten Aufruf.)  
  
-   Wenn Ihre app Zeichenfolgenausgaben, behandelt die <xref:System.Text.Encoding.GetString%2A> Methode wird empfohlen. Da diese Methode muss Zeichenfolgenlänge überprüfen und einen Puffer zuzuordnen, ist es etwas langsamer, aber die resultierende <xref:System.String> zu bevorzugen ist.  
  
-   Der Byteversion von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, unterstützt die Ausgabe von Zeichen Puffer ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Das folgende Beispiel konvertiert eine Zeichenfolge aus einer Codierung in eine andere.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert und anschließend einen Bereich von Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />oder <paramref name="byteCount" /> oder <paramref name="charIndex" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="byteindex" /> und <paramref name="byteCount" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.  
  
 - oder -   
  
 <paramref name="charIndex" /> ist kein gültiger Index in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" />verfügt nicht über genügend Kapazität von <paramref name="charIndex" /> bis zum Ende des Arrays, die sich ergebenden Zeichen aufzunehmen.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Decoder abgerufen, der eine codierte Bytefolge in Zeichen konvertiert.</summary>
        <returns>Eine <see cref="T:System.Text.Decoder" />-Klasse, die eine codierte Bytefolge in eine Folge von Zeichen codiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> konvertiert sequenzielle Blöcke von Bytes in sequenzielle Blöcke von Zeichen ähnlich wie die <xref:System.Text.Encoding.GetChars%2A> Methode dieser Klasse. Allerdings eine <xref:System.Text.Decoder> Zustandsinformationen zwischen aufrufen, damit es ordnungsgemäß decodiert Bytefolgen an, die Blöcke umfassen verwaltet. Die <xref:System.Text.Decoder> behält nachfolgende Bytes am Ende der Datenblöcke und die nachfolgenden Bytes im nächste Decodierungsvorgang verwendet. Aus diesem Grund <xref:System.Text.Encoding.GetDecoder%2A> und <xref:System.Text.Encoding.GetEncoder%2A> eignen sich für die netzwerkübertragung und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die Standardimplementierung gibt ein <see cref="T:System.Text.Decoder" /> aufruft, die die <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> und <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> Methoden des aktuellen <see cref="T:System.Text.Encoding" />. Muss, überschreiben Sie diese Methode zum Zurückgeben einer <see cref="T:System.Text.Decoder" /> , verwaltet den Zustand zwischen aufrufen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Encoder abgerufen, der eine Folge von Unicode-Zeichen in eine codierte Bytefolge konvertiert.</summary>
        <returns>Ein <see cref="T:System.Text.Encoder" />, der eine Folge von Unicode-Zeichen in eine codierte Bytefolge konvertiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> konvertiert sequenzielle Blöcke von Zeichen in sequenzielle Blöcke von Bytes auf ähnliche Weise die <xref:System.Text.Encoding.GetBytes%2A> Methode dieser Klasse. Allerdings eine <xref:System.Text.Encoder> Zustandsinformationen zwischen aufrufen, damit korrekt Zeichensequenzen codiert werden, die Blöcke umfassen verwaltet. Die <xref:System.Text.Encoder> auch beibehalten, nachfolgende Zeichen am Ende der Datenblöcke und das nachfolgenden Zeichen in der nächsten Codierungsvorgang verwendet. Z. B. ein Datenblock möglicherweise eine hohe Ersatzzeichen ohne Entsprechung enden, und die übereinstimmende niedrige Ersatzzeichen ist möglicherweise in den nächsten Datenblock. Aus diesem Grund <xref:System.Text.Encoding.GetDecoder%2A> und <xref:System.Text.Encoding.GetEncoder%2A> eignen sich für die netzwerkübertragung und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die Standardimplementierung gibt ein <see cref="T:System.Text.Encoder" /> aufruft, die die <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> und <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> Methoden des aktuellen <see cref="T:System.Text.Encoding" />. Muss, überschreiben Sie diese Methode zum Zurückgeben einer <see cref="T:System.Text.Encoder" /> , verwaltet den Zustand zwischen aufrufen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">Der Codepagebezeichner der bevorzugten Codierung. Mögliche Werte sind in der Codepage-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.  
  
 - oder -  
  
 0 (null), um die Standardcodierung zu verwenden.</param>
        <summary>Gibt die dem angegebenen Codepagebezeichner zugeordnete Codierung zurück.</summary>
        <returns>Die Codierung, die der angegebenen Codepage zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das fallback-Handler hängt von den Codierungstyp des `codepage`. Wenn `codepage` ist ein Code Seiten- oder Doppelbyte-Zeichensatz (DBCS)-Codierung, die ein ähnlichen fallback-Handler wird verwendet. Andernfalls wird ein Ersatz-fallback-Handler verwendet. Diese fallback-Handler können nicht für Ihre app geeignet sein. Das fallback-Handler verwendet, die von der Codierung gemäß Angabe `codepage`, Sie erreichen die <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> überladen.  
  
 Die <xref:System.Text.Encoding.GetEncoding%2A> Methode abhängig von der zugrunde liegenden Plattform unterstützt die meisten Codepages. .NET Framework unterstützt systemintern jedoch einige Codierungen. Eine Liste der Codepages, finden Sie unter der <xref:System.Text.Encoding> klassenthema. Alternativ können Sie rufen die <xref:System.Text.Encoding.GetEncodings%2A> ein Array der abzurufenden Methode <xref:System.Text.EncodingInfo> Objekte, die Informationen über alle Codierungen enthält.  
  
 Zusätzlich zu den Codierungen, die systemintern auf einer bestimmten Plattform-Version von .NET Framework unterstützt werden die <xref:System.Text.Encoding.GetEncoding%2A> Methodenrückgabe alle zusätzlichen Codierungen, bei denen durch die Registrierung zur Verfügung gestellt werden ein <xref:System.Text.EncodingProvider> Objekt. Die gleiche Codierung registriert wurde, indem Sie mehrere <xref:System.Text.EncodingProvider> Objekte, die diese Methode gibt das letzte Lesezeichen registriert.  

Sie können auch angeben, der Wert 0 für die `codepage` Argument. Das genaue Verhalten hängt von, ob alle Codierungen verfügbar durch die Registrierung vorgenommen wurden ein <xref:System.Text.EncodingProvider> Objekt:

- Einen oder mehrere Codierung Anbieter registriert wurden, wird die Codierung des letzten registrierten Anbieters, der sich entschieden hat, wenn Codierung liefern kann die <xref:System.Text.Encoding.GetEncoding%2A> -Methode übergeben ein `codepage` Argument von 0.     

- Auf .NET Framework, wenn keine Codierung Anbieter wurde registriert, wenn die <xref:System.Text.CodePagesEncodingProvider> der registrierten codierungsanbieter ist oder wenn keine Codierung registrierten Anbieter kümmert sich um eine `codepage` Wert 0, gibt es aktiven Codepage des Betriebssystems. Um die aktive Codepage in Windows-Systemen zu bestimmen, rufen Sie die Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Funktion von .NET Framework auf dem Windows-Desktop.

- Auf .NET Core, wenn kein codierungsanbieter wurde registriert, oder wenn keine Codierung registrierten Anbieter kümmert sich um eine `codepage` Wert von 0 (null) gibt die <xref:System.Text.UTF8Encoding>.
  
> [!NOTE]
>  Einige nicht unterstützte Codepages Ursache ein <xref:System.ArgumentException> ausgelöst wird, während andere auslösen, eine <xref:System.NotSupportedException>. Daher Ihren Code muss catch alle Ausnahmen, die im Abschnitt für Ausnahmen angegeben.  
  
> [!NOTE]
>  Die ANSI-Codepages können auf verschiedenen Computern unterschiedlich sein und können auf einem einzelnen Computer, die führende zur Beschädigung von Daten ändern. Aus diesem Grund ist die aktive Codepage ANSI-Codepage, codieren und Decodieren von Daten mithilfe der Standardcodepage zurückgegebenes `Encoding.GetEncoding(0)` wird nicht empfohlen. Die meisten konsistent zu erzielen sollten Sie verwenden, eine Unicode-Codierung, z. B. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage.  
  
 <xref:System.Text.Encoding.GetEncoding%2A>Gibt eine zwischengespeicherte Instanz mit Standardeinstellungen zurück. Sie sollten die Konstruktoren der abgeleiteten Klassen zum Abrufen einer Instanz mit unterschiedlichen Einstellungen verwenden. Z. B. die <xref:System.Text.UTF32Encoding> Klasse bietet einen Konstruktor, der Sie die fehlererkennung aktivieren kann.  

   
  
## Examples  
 Im folgenden Beispiel ruft zwei Instanzen der gleichen Codierung (eine nach Codepage) und ein anderes nach Namen ab und überprüft deren Gleichheit.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" />ist kleiner als 0 (null) oder größer als 65535 sein.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" />wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" />wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Codepagename der bevorzugten Codierung. Jeder von der <see cref="P:System.Text.Encoding.WebName" />-Eigenschaft zurückgegebene Wert ist gültig. Mögliche Werte sind in der Name-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.</param>
        <summary>Gibt die dem angegebenen Codepagenamen zugeordnete Codierung zurück.</summary>
        <returns>Die der angegebenen Codepage zugeordnete Codierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das fallback-Handler hängt von den Codierungstyp des `name`. Wenn `name` ist ein Code Seiten- oder Doppelbyte-Zeichensatz (DBCS)-Codierung, die ein ähnlichen fallback-Handler wird verwendet. Andernfalls wird ein Ersatz-fallback-Handler verwendet. Diese fallback-Handler können nicht für Ihre app geeignet sein. Das fallback-Handler verwendet, die von der Codierung gemäß Angabe `name`, Sie erreichen die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> überladen.  
  
 Die <xref:System.Text.Encoding.GetEncoding%2A> Methode abhängig von der zugrunde liegenden Plattform unterstützt die meisten Codepages. .NET Framework unterstützt systemintern jedoch einige Codierungen. Eine Liste der Codepages, finden Sie unter der <xref:System.Text.Encoding> klassenthema. Alternativ können Sie rufen die <xref:System.Text.Encoding.GetEncodings%2A> ein Array der abzurufenden Methode <xref:System.Text.EncodingInfo> Objekte, die Informationen über alle Codierungen enthält. 
  
 Zusätzlich zu den Codierungen, die systemintern auf einer bestimmten Plattform-Version von .NET Framework unterstützt werden die <xref:System.Text.Encoding.GetEncoding%2A> Methodenrückgabe alle zusätzlichen Codierungen, bei denen durch die Registrierung zur Verfügung gestellt werden ein <xref:System.Text.EncodingProvider> Objekt. Die gleiche Codierung registriert wurde, indem Sie mehrere <xref:System.Text.EncodingProvider> Objekte, die diese Methode gibt das letzte Lesezeichen registriert.  
   
> [!NOTE]
>  Die ANSI-Codepages können auf verschiedenen Computern unterschiedlich sein, oder für einen einzelnen Computer, die führende zur Beschädigung von Daten geändert werden können. Die meisten konsistent zu erzielen sollten Sie Unicode, z. B. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage verwenden.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A>Gibt eine zwischengespeicherte Instanz mit Standardeinstellungen zurück. Sie sollten die Konstruktoren der abgeleiteten Klassen zum Abrufen einer Instanz mit unterschiedlichen Einstellungen verwenden. Z. B. die <xref:System.Text.UTF32Encoding> Klasse bietet einen Konstruktor, der Sie die fehlererkennung aktivieren kann.  
  
## Examples  
 Im folgenden Beispiel ruft zwei Instanzen der gleichen Codierung (eine nach Codepage) und ein anderes nach Namen ab und überprüft deren Gleichheit.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />ist keinem gültigen Codeseitennamen.  
  
 - oder -   
  
 Die Codepage erkennbar <paramref name="name" /> wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">Der Codepagebezeichner der bevorzugten Codierung. Mögliche Werte sind in der Codepage-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.  
  
 - oder -  
  
 0 (null), um die Standardcodierung zu verwenden.</param>
        <param name="encoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn ein Zeichen nicht mit der aktuellen Codierung codiert werden kann.</param>
        <param name="decoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn eine Bytefolge nicht mit der aktuellen Codierung decodiert werden kann.</param>
        <summary>Gibt die dem angegebenen Codepagebezeichner zugeordnete Codierung zurück. Parameter geben einen Fehlerhandler für Zeichen an, die nicht codiert werden können, und für Bytefolgen, die nicht decodiert werden können.</summary>
        <returns>Die Codierung, die der angegebenen Codepage zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Einige nicht unterstützte Codepages dazu führen, dass die Ausnahme <xref:System.ArgumentException> ausgelöst wird, während andere auslösen, <xref:System.NotSupportedException>. Daher Ihren Code muss catch alle Ausnahmen, die im Abschnitt für Ausnahmen angegeben.  
  
 Die <xref:System.Text.Encoding.GetEncoding%2A> Methode abhängig von der zugrunde liegenden Plattform unterstützt die meisten Codepages. .NET Framework unterstützt systemintern jedoch einige Codierungen. Eine Liste der Codepages, finden Sie unter der <xref:System.Text.Encoding> klassenthema. Sie erreichen die <xref:System.Text.Encoding.GetEncodings%2A> Methode im vollständigen .NET Framework auf dem Windows-Desktop um eine Liste aller Codierungen abzurufen.   
  
 Zusätzlich zu den Codierungen, die systemintern auf einer bestimmten Plattform-Version von .NET Framework unterstützt werden die <xref:System.Text.Encoding.GetEncoding%2A> Methodenrückgabe alle zusätzlichen Codierungen, bei denen durch die Registrierung zur Verfügung gestellt werden ein <xref:System.Text.EncodingProvider> Objekt.  Die gleiche Codierung registriert wurde, indem Sie mehrere <xref:System.Text.EncodingProvider> Objekte, die diese Methode gibt das letzte Lesezeichen registriert.  

Sie können auch angeben, der Wert 0 für die `codepage` Argument. Das genaue Verhalten hängt von, ob alle Codierungen verfügbar durch die Registrierung vorgenommen wurden ein <xref:System.Text.EncodingProvider> Objekt:

- Einen oder mehrere Codierung Anbieter registriert wurden, wird die Codierung des letzten registrierten Anbieters, der sich entschieden hat, wenn Codierung liefern kann die <xref:System.Text.Encoding.GetEncoding%2A> -Methode übergeben ein `codepage` Argument von 0.     

- Auf .NET Framework, wenn keine Codierung Anbieter wurde registriert, wenn die <xref:System.Text.CodePagesEncodingProvider> ist der registrierte codierungsanbieter oder wenn keine Codierung registrierten Anbieter kümmert sich um eine `codepage` Wert 0, gibt es zurück, die aktiven Codepage.

- Auf .NET Core, wenn kein codierungsanbieter wurde registriert, oder wenn keine Codierung registrierten Anbieter kümmert sich um eine `codepage` Wert von 0 (null) gibt die <xref:System.Text.UTF8Encoding> Codierung.

> [!NOTE]
>  Die ANSI-Codepages können auf verschiedenen Computern unterschiedlich sein und können auf einem einzelnen Computer, die führende zur Beschädigung von Daten ändern. Aus diesem Grund ist die aktive Codepage ANSI-Codepage, codieren und Decodieren von Daten mithilfe der Standardcodepage zurückgegebenes `Encoding.GetEncoding(0)` wird nicht empfohlen. Die meisten konsistent zu erzielen sollten Sie Unicode, z. B. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage verwenden. 
  
 Zum Abrufen der aktiven Codepage zugeordnete Codierung, können Sie entweder einen Wert 0 für angeben der `codepage` Argument oder, wenn Ihr Code auf das vollständige .NET Framework auf dem Windows-Desktop ausgeführt wird, Abrufen des Werts der <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> Eigenschaft. Um die aktuelle aktive Codepage zu bestimmen, rufen Sie die Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Funktion von .NET Framework auf dem Windows-Desktop.  
  
 <xref:System.Text.Encoding.GetEncoding%2A>Gibt eine zwischengespeicherte Instanz mit Standardeinstellungen zurück. Sie sollten die Konstruktoren der abgeleiteten Klassen zum Abrufen einer Instanz mit unterschiedlichen Einstellungen verwenden. Z. B. die <xref:System.Text.UTF32Encoding> Klasse bietet einen Konstruktor, der Sie die fehlererkennung aktivieren kann.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> Methode.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" />ist kleiner als 0 (null) oder größer als 65535 sein.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" />wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" />wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">Der Codepagename der bevorzugten Codierung. Jeder von der <see cref="P:System.Text.Encoding.WebName" />-Eigenschaft zurückgegebene Wert ist gültig. Mögliche Werte sind in der Name-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.</param>
        <param name="encoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn ein Zeichen nicht mit der aktuellen Codierung codiert werden kann.</param>
        <param name="decoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn eine Bytefolge nicht mit der aktuellen Codierung decodiert werden kann.</param>
        <summary>Gibt die dem angegebenen Codepagenamen zugeordnete Codierung zurück. Parameter geben einen Fehlerhandler für Zeichen an, die nicht codiert werden können, und für Bytefolgen, die nicht decodiert werden können.</summary>
        <returns>Die Codierung, die der angegebenen Codepage zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.GetEncoding%2A> Methode abhängig von der zugrunde liegenden Plattform unterstützt die meisten Codepages. .NET Framework unterstützt systemintern jedoch einige Codierungen.  
  
 Zusätzlich zu den Codierungen, die systemintern auf einer bestimmten Plattform-Version von .NET Framework unterstützt werden die <xref:System.Text.Encoding.GetEncoding%2A> Methodenrückgabe alle zusätzlichen Codierungen, bei denen durch die Registrierung zur Verfügung gestellt werden ein <xref:System.Text.EncodingProvider> Objekt. Die gleiche Codierung registriert wurde, indem Sie mehrere <xref:System.Text.EncodingProvider> Objekte, die diese Methode gibt das letzte Lesezeichen registriert. 
  
> [!NOTE]
>  Die ANSI-Codepages können auf verschiedenen Computern unterschiedlich sein und können auf einem einzelnen Computer, die führende zur Beschädigung von Daten ändern. Die meisten konsistent zu erzielen sollten Sie verwenden, eine Unicode-Codierung, z. B. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage.  
  
 Eine Liste der Codepages, finden Sie unter der <xref:System.Text.Encoding> klassenthema. Sie erreichen die <xref:System.Text.Encoding.GetEncodings%2A> Methode auf das vollständige .NET Framework auf dem Windows-Desktop um eine Liste aller Codierungen abzurufen.  
  
 <xref:System.Text.Encoding.GetEncoding%2A>Gibt eine zwischengespeicherte Instanz mit Standardeinstellungen zurück. Sie sollten die Konstruktoren der abgeleiteten Klassen zum Abrufen einer Instanz mit unterschiedlichen Einstellungen verwenden. Z. B. die <xref:System.Text.UTF32Encoding> Klasse bietet einen Konstruktor, der Sie die fehlererkennung aktivieren kann.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> Methode.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />ist keinem gültigen Codeseitennamen.  
  
 - oder -   
  
 Die Codepage erkennbar <paramref name="name" /> wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array zurück, das alle Codierungen enthält.</summary>
        <returns>Ein Array, das alle Codierungen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt eine Liste der unterstützten Codierungen, die eindeutig durch die Codepage unterschieden. Eine Tabelle mit den unterstützten Codierungen, finden Sie unter der <xref:System.Text.Encoding> klassenthema.  
  
> [!NOTE]
>  Die Liste der unterstützten Codierungen zurückgegebenes der <xref:System.Text.Encoding.GetEncodings%2A> Methode schließt zusätzliche Codierung zur Verfügung gestellt, von einer nicht <xref:System.Text.EncodingProvider> Implementierungen, die durch Aufrufe von registriert wurden die <xref:System.Text.Encoding.RegisterProvider%2A> Methode.  
  
 Codierungen 50220 und 50222 sind beide verknüpft sind, mit dem Namen "Iso-2022-jp", aber nicht identisch sind. Codierung 50220 konvertiert halber Breite Katakana-Zeichen in Katakana-Zeichen mit voller Breite, wohingegen Codierung 50222 verwendet eine Sequenz UMSCHALT-in/UMSCHALT-Out halbbreiten Katakana-Zeichen zu codieren. Der Anzeigename für Codierung 50222 ist "Japanisch (JIS-1 Byte Kana erlaubt - SO / SI)" zur Unterscheidung von Codierung 50220, mit dem Anzeigenamen "Japanisch (JIS)" nennen.  
  
 Wenn Sie die Codierung Name "Iso-2022-jp", die .NET Framework gibt Codierung 50220 anfordern. Allerdings hängt die Codierung, die für Ihre app geeignet ist der bevorzugten Behandlung der Katakana-Zeichen halber Breite.  
  
 Verwenden Sie zum Abrufen einer bestimmten Codierung der <xref:System.Text.Encoding.GetEncoding%2A> Methode.  
  
 <xref:System.Text.Encoding.GetEncodings%2A>wird in einigen Fällen verwendet werden, um Benutzer mit einer Liste von Codierungen in eine Datei vorlegen **speichern als** (Dialogfeld). Viele nicht-Unicode-Codierungen sind jedoch entweder unvollständig und übersetzen: zu viele Zeichen "?", oder weisen Sie etwas andere Verhalten auf verschiedenen Plattformen. Erwägen Sie UTF-8 oder UTF-16 als Standard.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Werte der booleschen Eigenschaften jeder Codierung überprüft.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für die aktuelle Instanz zurück.</summary>
        <returns>Der Hashcode für die aktuelle Instanz.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die maximale Anzahl der Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt werden.</summary>
        <returns>Die maximale Anzahl an Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `charCount` Parameter gibt die Anzahl der tatsächlich an <xref:System.Char> Objekte, die Unicode-Zeichen zu codieren, darstellen, da .NET Framework intern UTF-16-Unicode-Zeichen verwendet. Daher können die meisten Unicode-Zeichen dargestellt werden, von einem <xref:System.Char> -Objekt, aber ein Unicode-Zeichen, die durch ein Ersatzzeichenpaar, z. B. dargestellt wird, müssen Sie zwei <xref:System.Char> Objekte.  
  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes verwenden Sie die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Zum Berechnen der maximalen Arraygröße verwenden Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A>Ruft die Anzahl Worst-Case, einschließlich ungünstigsten Fall für das derzeit ausgewählte ab <xref:System.Text.EncoderFallback>. Wenn ein Fallback mit einer potenziell großen Zeichenfolge ausgewählt wird <xref:System.Text.Encoding.GetMaxByteCount%2A> große Werte, insbesondere in Fällen, in denen die schlimmsten Fall für die Codierung umfasst Moduswechsel für jedes Zeichen, abgerufen. Dies kann z. B. ISO-2022-JP haben. Weitere Informationen finden Sie im Blogeintrag "[mit Encoding.GetMaxByteCount() und Encoding.GetMaxCharCount() Neuigkeiten?](http://go.microsoft.com/fwlink/?LinkId=153702)" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 In den meisten Fällen ruft diese Methode geeignete Werte für kleine Zeichenfolgen ab. Für große Zeichenfolgen müssen Sie möglicherweise entscheiden sehr große Puffer und Erfassen von Fehlern in dem seltenen Fall, wenn ein günstiger Puffer zu klein ist. Sie sollten auch einen anderen Ansatz erwägen <xref:System.Text.Encoding.GetByteCount%2A> oder <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 Bei Verwendung <xref:System.Text.Encoding.GetMaxByteCount%2A>, sollten Sie den Ausgabepuffer basierend auf der maximalen Größe des Eingabepuffers zuweisen. Wenn der Ausgabepuffer Größe eingeschränkt ist, können die <xref:System.Text.Encoding.Convert%2A> Methode.  
  
 Beachten Sie, dass <xref:System.Text.Encoding.GetMaxByteCount%2A> potenzielle übrig gebliebene Surrogate aus einer vorherigen betrachtet. Aufgrund der Decoder Ruft die Übergabe des Werts 1 an die Methode für ein Einzelbyte-Codierung, z. B. ASCII 2 ab. Verwenden Sie die <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> Eigenschaft, wenn diese Informationen erforderlich ist.  
  
> [!NOTE]
>  `GetMaxByteCount(N)`ist nicht unbedingt der gleiche Wert wie `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <block subset="none" type="overrides">
          <para>Alle <see cref="T:System.Text.Encoding" /> Implementierungen müssen sicherstellen, dass keine Ausnahmen durch Pufferüberlauf auftritt, wenn Puffer anhand der Ergebnisse von dieser Methode Berechnungen deren Größe geändert werden.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die maximale Anzahl an Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</summary>
        <returns>Die maximale Anzahl von Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen verwenden Sie die <xref:System.Text.Encoding.GetCharCount%2A> Methode. Zum Berechnen der maximalen Arraygröße verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.Encoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A>Ruft die Anzahl Worst-Case, einschließlich ungünstigsten Fall für das derzeit ausgewählte ab <xref:System.Text.DecoderFallback>. Wenn ein Fallback mit einer potenziell großen Zeichenfolge ausgewählt wird <xref:System.Text.Encoding.GetMaxCharCount%2A> große Werte abgerufen.  
  
 In den meisten Fällen ruft diese Methode geeignete Zahlen für kleine Zeichenfolgen ab. Für große Zeichenfolgen müssen Sie möglicherweise entscheiden sehr große Puffer und Erfassen von Fehlern in dem seltenen Fall, dass ein günstiger Puffer zu klein ist. Sie sollten auch einen anderen Ansatz erwägen <xref:System.Text.Encoding.GetCharCount%2A> oder <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A>hat keinen Bezug zu <xref:System.Text.Encoding.GetBytes%2A>. Wenn Sie eine ähnliche Funktion für die Verwendung mit benötigt <xref:System.Text.Encoding.GetBytes%2A>, verwenden Sie <xref:System.Text.Encoding.GetMaxByteCount%2A>.  
  
 Bei Verwendung <xref:System.Text.Encoding.GetMaxCharCount%2A>, sollten Sie den Ausgabepuffer basierend auf der maximalen Größe des Eingabepuffers zuweisen. Wenn der Ausgabepuffer Größe eingeschränkt ist, können die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode.  
  
 Beachten Sie, dass <xref:System.Text.Encoding.GetMaxCharCount%2A> berücksichtigt den ungünstigsten Fall für übrig gebliebene Bytes aus einem vorherigen Encoder-Vorgang. Die Übergabe des Werts 0 an diese Methode bei den meisten Codepages hingegen Werte größer als oder gleich 1 abgerufen.  
  
> [!NOTE]
>  `GetMaxCharCount(N)`ist nicht unbedingt der gleiche Wert wie `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert und klicken Sie dann die Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <block subset="none" type="overrides">
          <para>Alle <see cref="T:System.Text.Encoding" /> Implementierungen müssen sicherstellen, dass keine Ausnahmen durch Pufferüberlauf auftritt, wenn Puffer anhand der Ergebnisse von dieser Methode Berechnungen deren Größe geändert werden.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge zurückgegeben, die die verwendete Codierung angibt.</summary>
        <returns>Ein Bytearray, das eine Bytefolge enthält, in der die verwendete Codierung angegeben ist.  
  
 - oder -  
  
 Ein Bytearray der Länge 0 (null), wenn keine Präambel erforderlich ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Optional können die <xref:System.Text.Encoding> Objekt stellt keine Präambel, die ein Array von Bytes, die die Abfolge von Bytes, die aufgrund des Codierungsvorgangs vorangestellt werden kann. Die Präambel eine Bytereihenfolge-Marke (in Unicode-Codepunkt U + FEFF) enthält, leichter den Decoder die Bytereihenfolge und die Transformationsformat oder im UTF zu bestimmen.  
  
 Die Unicode-bytereihenfolgemarkierung (BOM) ist (im Hexadezimalformat) wie folgt serialisiert:  
  
-   UTF-8: EF BB BF  
  
-   UTF-16 big endian-Bytereihenfolge: FF FE  
  
-   UTF-16 little-endian-Bytereihenfolge: FF FE  
  
-   UTF-32 big-endian-Bytereihenfolge: 00 00 FE FF  
  
-   UTF-32 little-endian-Bytereihenfolge: FF FE 00 00  
  
 Sollten Sie die BOM verwenden, da es bietet eine nahezu bestimmte Identifikation des eine Codierung für Dateien, die andernfalls verloren Verweis auf die <xref:System.Text.Encoding> Objekts an, z. B. nicht gekennzeichnet oder falsch gekennzeichnet Webdaten oder zufällige Dateien gespeichert, wenn ein Unternehmen hat keine haben Sie internationale Sicherheitsrisiken oder andere Daten. Häufig Benutzerprobleme können vermieden werden, wenn Daten einheitlich und ordnungsgemäß konfiguriert, vorzugsweise in UTF-8 oder UTF-16 gekennzeichnet ist.  
  
 Für die Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant. Es kann jedoch verwendet werden, zu einem Server, den richtigen encoding-Header zu senden. Alternativ können sie als ein Fallback verwendet werden, für den Fall, dass die Codierung verloren gegangen ist.  
  
 Es gibt einige Nachteile mit einer BOM. Zu wissen, wie die Datenbankfelder zu beschränken, die eine BOM verwenden kann z. B. schwierig sein. Die Verkettung von Dateien, problematisch sein kann auch, beispielsweise beim Zusammenführen von Dateien in einem solchen eine Möglichkeit, die ein unnötige Zeichen in der Mitte Daten annehmen kann. Trotz der einige Nachteile wird jedoch dringend die Verwendung einer Stückliste empfohlen.  
  
 Weitere Informationen zu Bytereihenfolge und Byte Order Mark, finden Sie im Unicode-Standard an die [Unicode-Homepage](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie die codierten Bytes mit einer Präambel voranstellen. Die meisten Codierungen bieten jedoch keine Präambel. Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie mit einer Unicode-Codierung, d. h. <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, oder <xref:System.Text.UTF32Encoding>, mit einer Präambel.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Bytereihenfolge der Codierung auf Grundlage der Präambel bestimmt.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden alle Bytes im angegebenen Bytearray in eine Zeichenfolge decodiert.</summary>
        <returns>Eine Zeichenfolge, die die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> zurückgegebenes Objekt die <xref:System.Text.Encoding.GetDecoder%2A> eine Deri-Methode Verschieben von-Klasse.  
  
 Finden Sie im Abschnitt "Hinweise" der <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Verweis Themas beschriebenen Techniken und Überlegungen zu decodieren.  
  
 Beachten Sie, dass das genaue Verhalten der <xref:System.Text.Encoding.GetString%2A> Methode für einen bestimmten <xref:System.Text.Encoding> Implementierung hängt von der Fallbackstrategie definiert für diesen <xref:System.Text.Encoding> Objekt. Weitere Informationen finden Sie im Abschnitt "Auswählen einer Fallbackstrategie" die [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) Thema.  
  
   
  
## Examples  
 Das folgende Beispiel liest eine UTF-8-codierte Zeichenfolge aus einer Binärdatei, dargestellt durch eine <xref:System.IO.FileStream> Objekt. Für Dateien, die kleiner als 2.048 Bytes sind, liest er den Inhalt der gesamten Datei in ein Bytearray und ruft die <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> Methode, um die Decodierung durchzuführen. Es liest für größere Dateien 2.048 Bytes zu einem Zeitpunkt in ein Bytearray, ruft der <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um zu bestimmen, wie viele Zeichen im Array enthalten sind, und ruft dann die <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um die Decodierung durchzuführen.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 Das Beispiel verwendet den folgenden Text, der in eine UTF-8-codierte Datei, die mit dem Namen Utf8Example.txt gespeichert werden soll.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Bytearray enthält ungültige Unicode-Codepunkten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf ein Bytearray.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine angegebene Anzahl von Bytes ab einer angegebenen Adresse in eine Zeichenfolge decodiert.</summary>
        <returns>Eine Zeichenfolge, die die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.GetString%2A> -Methode entwickelt, um die Leistung zu optimieren, wenn Sie einen systemeigenen Zeiger auf ein Bytearray verfügen. Statt verwalteten Bytearrays erstellen und anschließend decodiert können Sie stattdessen diese Methode aufrufen, ohne alle zwischenobjekte erstellen zu müssen.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> zurückgegebenes Objekt die <xref:System.Text.Encoding.GetDecoder%2A> eine Deri-Methode Verschieben von-Klasse.  
  
 Finden Sie im Abschnitt "Hinweise" der <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Verweis Themas beschriebenen Techniken und Überlegungen zu decodieren.  
  
 Beachten Sie, dass das genaue Verhalten der <xref:System.Text.Encoding.GetString%2A> Methode für einen bestimmten <xref:System.Text.Encoding> Implementierung hängt von der Fallbackstrategie definiert für diesen <xref:System.Text.Encoding> Objekt. Weitere Informationen finden Sie im Abschnitt "Auswählen einer Fallbackstrategie" die [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) Thema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist ein NULL-Zeiger</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) eine vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge aus dem angegebenen Bytearray in eine Zeichenfolge decodiert.</summary>
        <returns>Eine Zeichenfolge, die die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Finden Sie im Abschnitt "Hinweise" der <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Verweis Themas beschriebenen Techniken und Überlegungen zu decodieren.  
  
   
  
## Examples  
 Das folgende Beispiel liest eine UTF-8-codierte Zeichenfolge aus einer Binärdatei, die durch dargestellt wird ein <xref:System.IO.FileStream> Objekt. Für Dateien, die kleiner als 2.048 Bytes sind, liest er den Inhalt der gesamten Datei in ein Bytearray und ruft die <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methode, um die Decodierung durchzuführen. Es liest für größere Dateien 2.048 Bytes zu einem Zeitpunkt in ein Bytearray, ruft der <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um zu bestimmen, wie viele Zeichen im Array enthalten sind, und ruft dann die <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um die Decodierung durchzuführen.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 Das Beispiel verwendet den folgenden Text, der in eine UTF-8-codierte Datei, die mit dem Namen Utf8Example.txt gespeichert werden soll.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Bytearray enthält ungültige Unicode-Codepunkten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0 (null).  
  
 - oder -   
  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (siehe [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) vollständige Erläuterung)  
  
 - und -  
  
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Name für die aktuelle Codierung abgerufen, die mit den Header-Tags des E-Mail-Agenten verwendet werden kann.</summary>
        <value>Ein Name für die aktuelle <see cref="T:System.Text.Encoding" />, die für die Header-Tags des E-Mail-Agenten verwendet werden kann.  
  
 - oder -  
  
 Eine leere Zeichenfolge (""), wenn das aktuelle <see cref="T:System.Text.Encoding" /> nicht verwendet werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie benötigen eine Codierung für einen Headernamen an, Sie sollten Aufrufen der <xref:System.Text.Encoding.GetEncoding%2A> Methode mit der <xref:System.Text.Encoding.HeaderName%2A> Eigenschaft. Häufig Ruft die Methode mit einer abweichenden Codierung aus der Test Codierung, die im Aufruf erbracht ab. Im Allgemeinen müssen nur e-Mail-Anwendungen, diese Codierung abgerufen.  
  
 In einigen Fällen den Wert der <xref:System.Text.Encoding.BodyName%2A> Eigenschaft entspricht der internationalen Standard, die Codierung definiert. Dies bedeutet nicht, dass die Implementierung vollständig mit dieses Standards erfüllt.  
  
 Beachten Sie, dass <xref:System.Text.Encoding.WebName%2A> gibt den Namen zu verwenden, um die Beschreibung einer Codierung zurück. Die <xref:System.Text.Encoding.HeaderName%2A> Eigenschaft definiert eine andere Codierung, die besser für eine e-Mail-Anwendung, z. B. möglicherweise. Verwendung der Eigenschaft zum Definieren der Codierung wird jedoch nicht empfohlen.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft die verschiedenen Namen für jede Codierung ab und zeigt die Codierungen mit ein oder mehrere Namen, die von unterscheiden <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Es zeigt <xref:System.Text.Encoding.EncodingName%2A> jedoch nicht dafür verglichen.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle Codierung immer normalisiert ist. Es wird die Standardnormalisierungsform verwendet.</summary>
        <returns>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" />-Klasse immer normalisiert ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardformular für die Normalisierung wird <xref:System.Text.NormalizationForm.FormC>, die vollständigen kanonischen Zerlegung, gefolgt von der Austausch von Sequenzen mit ihren primären aus Komponenten zusammengesetzt, nach Möglichkeit verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">Einer der <see cref="T:System.Text.NormalizationForm" />-Werte.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung immer normalisiert ist. Hierzu wird die angegebene Normalisierungsform verwendet.</summary>
        <returns>
          <see langword="true" />, wenn das aktuelle <see cref="T:System.Text.Encoding" />-Objekt immer mit dem angegebenen <see cref="T:System.Text.NormalizationForm" />-Wert normalisiert wird, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardformular für die Normalisierung wird <xref:System.Text.NormalizationForm.FormC>, die vollständigen kanonischen Zerlegung, gefolgt von der Austausch von Sequenzen mit ihren primären aus Komponenten zusammengesetzt, nach Möglichkeit verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Browserclients zum Anzeigen des Inhalts verwendet werden kann.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> von Browserclients verwendet werden kann, um Inhalt anzuzeigen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel werden die Werte der booleschen Eigenschaften jeder Codierung überprüft.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Browserclients zum Speichern von Inhalt verwendet werden kann.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> von Browserclients verwendet werden kann, um Inhalt zu speichern, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel werden die Werte der booleschen Eigenschaften jeder Codierung überprüft.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Mail- und Newsclients zum Anzeigen von Inhalt verwendet werden kann.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> von Mail- und Newsclients verwendet werden kann, um Inhalt anzuzeigen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel werden die Werte der booleschen Eigenschaften jeder Codierung überprüft.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Mail- und Newsclients zum Speichern von Inhalt verwendet werden kann.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> von Mail- und Newsclients verwendet werden kann, um Inhalt zu speichern, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel werden die Werte der booleschen Eigenschaften jeder Codierung überprüft.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob die aktuelle Codierung schreibgeschützt ist.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> schreibgeschützt ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob die aktuelle Codierung Einzelbyte-Codepunkte verwendet.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> Einzelbyte-Codepunkte verwendet, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für ein Einzelbyte-Codierung, z. B. <xref:System.Text.ASCIIEncoding>, ruft diese Eigenschaft `true`.  
  
> [!CAUTION]
>  Sie sollten darauf achten in Leistungsumfang von Ihrer Anwendung mit dem Wert für <xref:System.Text.Encoding.IsSingleByte%2A>. Eine Annahme, wie eine Codierung fortfährt, möglicherweise trotzdem falsch. Windows-1252 hat beispielsweise den Wert `true` für <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, aber Encoding.GetMaxByteCount (1) gibt 2 zurück. Dies ist, da die Methode potenzielle übrig gebliebene Surrogate aus einer vorherigen betrachtet.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Werte der booleschen Eigenschaften jeder Codierung überprüft.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Eine Unterklasse von <see cref="T:System.Text.EncodingProvider" />, die Zugriff auf zusätzliche Zeichencodierungen bietet.</param>
        <summary>Registriert einen Codierungsanbieter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.RegisterProvider%2A> Methode ermöglicht Ihnen die Registrierung einer Klasse abgeleitet <xref:System.Text.EncodingProvider> , macht auf einer Plattform verfügbaren Codierungen Zeichen, die nicht anderweitig unterstützt werden. Sobald die codierungsanbieter registriert wurde, können die Codierungen, die er unterstützt abgerufen werden, durch das Aufrufen einer <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> überladen. Wenn es mehrere Codierung Anbieter sind, die <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> Methode versucht, zum Abrufen einer angegebenen Codierung aus jeder Anbieter, beginnend mit dem zuletzt registriert.

Registrieren einen codierungsanbieter mithilfe der <xref:System.Text.Encoding.RegisterProvider%2A> Methode ändert auch das Verhalten von der [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) und [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) Methoden, die beim Übergeben eines Arguments der `0`:

- Wenn der registrierte Anbieter ist der <xref:System.Text.CodePagesEncodingProvider>, die Methode gibt die Codierung, die der Codepage des Systems active entspricht, wenn auf dem Windows-Betriebssystem ausgeführt wird.

- Eine benutzerdefinierte codierungsanbieter kann auswählen, welche Codierung beim Zurückgeben einer von beiden <xref:System.Text.Encoding.GetEncoding%2A> Überladungen der Methode wird ein Argument übergeben `0`. Der Anbieter nach Wunsch kann nicht zurückgegeben wird, eine Codierung durch die Verwendung der <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> -Methodenrückgabe `null`. 
  
 [!INCLUDE[net_v46](~/includes/net-v46-md.md)]enthält ein codierungsanbieter, <xref:System.Text.CodePagesEncodingProvider>, stellt die Codierungen, die im vollständigen .NET Framework vorhanden sind, jedoch sind nicht verfügbar in [!INCLUDE[net_v46](~/includes/net-v46-md.md)]. Standardmäßig [!INCLUDE[net_v46](~/includes/net-v46-md.md)] unterstützt nur die Unicode-Codierungen, die ASCII- und die Codepage 28591 entscheiden.  
  
 Wenn die gleiche Anbieter für die Codierung, in mehreren Aufrufen verwendet wird der <xref:System.Text.Encoding.RegisterProvider%2A> -Methode, nur der erste Methodenaufruf registriert den Anbieter. Nachfolgende Aufrufe werden ignoriert.  
  
 Wenn die <xref:System.Text.Encoding.RegisterProvider%2A> Methode wird aufgerufen, um mehrere Anbieter zu registrieren, die gleiche Codierung behandelt, der zuletzt registrierte Anbieter wird für alle Codierungs- und Decodierungsvorgängen verwendet. Zuvor registrierten Anbietern werden ignoriert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für das UTF-16-Format in der Little-Endian-Bytereihenfolge ab.</summary>
        <value>Eine Codierung für das UTF-16-Format mit Little-Endian-Bytereihenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informationen über die Codierungen, die von .NET Framework und eine Erläuterung der Unicode-Zeichen um zu verwendende Codierung unterstützt werden, finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Die <xref:System.Text.UnicodeEncoding> von dieser Eigenschaft zurückgegebene Objekt möglicherweise nicht das entsprechende Verhalten für Ihre app. Es verwendet einen Ersatzfallback ersetzt jede Zeichenfolge, die nicht codiert werden kann, und jedes Byte, die nicht decodiert werden können mit einem Fragezeichen ("?") Zeichen. Rufen Sie stattdessen die <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor zum Instanziieren einer little-Endian <xref:System.Text.UnicodeEncoding> Objekt, dessen Fallback handelt es sich um, eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für das UTF-32-Format in der Little-Endian-Bytereihenfolge ab.</summary>
        <value>Ein Codierungsobjekt für das UTF-32-Format mit Little-Endian-Bytereihenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.UTF32Encoding> von dieser Eigenschaft zurückgegebene Objekt möglicherweise nicht das entsprechende Verhalten für Ihre app. Ersatzfallback verwendet, um das Unicode-ERSATZZEICHEN (U + FFFE) ersetzt jede Zeichenfolge, die nicht codiert werden kann, und jedes Byte, die nicht decodiert werden können. Rufen Sie stattdessen die <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor zum Instanziieren einer <xref:System.Text.UTF32Encoding> Objekt, dessen Fallback handelt es sich um, eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Eine Erläuterung der little-endian-Bytereihenfolge, finden Sie unter der <xref:System.Text.Encoding> klassenthema.  
  
 Informationen über die Codierungen, die von .NET Framework und eine Erläuterung der Unicode-Zeichen um zu verwendende Codierung unterstützt werden, finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für das UTF-7-Format ab.</summary>
        <value>Eine Codierung für das UTF-7-Format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 UTF-7-Codierung wird hauptsächlich in Umgebungen verwendet, die in der Vergangenheit, um 7 Bits, z. B. NNTP und einige e-Mail-Anwendungen eingeschränkt wurden. Aufgrund von Verbindungsproblemen mit Stabilität und Sicherheit sollten Sie nicht verwenden UTF7 Codierung in 8-Bit-Umgebungen, in dem UTF-8-Codierung anstelle kann verwendet werden.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für das UTF-8-Format ab.</summary>
        <value>Eine Codierung für das UTF-8-Format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt ein <xref:System.Text.UTF8Encoding> Objekt, das Unicode (UTF-16-codierte) Zeichen in eine Folge von ein bis vier Bytes pro Zeichen codiert und, die ein UTF-8-codierte Bytearray in Unicode (UTF-16-codierte) Zeichen decodiert. Informationen zu zeichencodierungen, die von .NET Framework und eine Erläuterung der Unicode-Zeichen um zu verwendende Codierung unterstützt werden, finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Die <xref:System.Text.UTF8Encoding> von dieser Eigenschaft zurückgegebene Objekt möglicherweise nicht das entsprechende Verhalten für Ihre app.  
  
-   Es gibt eine <xref:System.Text.UTF8Encoding> Objekt, das eine Unicode-bytereihenfolgemarkierung (BOM) bereitstellt. Rufen Sie eine Überladung der zum Instanziieren einer UTF8-Codierung, die eine BOM nicht bereitstellt, die <xref:System.Text.UTF8Encoding.%23ctor%2A> Konstruktor.  
  
-   Gibt eine <xref:System.Text.UTF8Encoding> -Objekt, das verwendet einen Ersatzfallback ersetzt jede Zeichenfolge, die nicht codiert werden kann, und jedes Byte, die nicht decodiert werden können mit einem Fragezeichen ("?") Zeichen. Rufen Sie stattdessen die <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor zum Instanziieren einer <xref:System.Text.UTF8Encoding> Objekt, dessen Fallback handelt es sich um, eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>, wie das folgende Beispiel veranschaulicht.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 Das folgende Beispiel definiert ein Array, das die folgenden Zeichen besteht aus:  
  
-   KLEINES LATEINISCHES Z (U + 007A)  
  
-   KLEINE LATEINISCHE BUCHSTABEN EIN (U + 0061 IST)  
  
-   KOMBINIEREN VON BREVIS (U + 0306)  
  
-   KLEINES LATEINISCHES AE MIT AKUT (U + 01FD)  
  
-   GRIECHISCH BUCHSTABE BETA (U + 03B2)  
  
-   Ein Ersatzzeichenpaar (U + D800 U + DD54), die griechischen ACROPHONIC ATTIC ein TAUSENDERTRENNZEICHEN STATERS (U + 10154) bildet.  
  
 Es zeigt die UTF-16-Codeeinheiten jedes Zeichens und bestimmt die Anzahl der Bytes, die von einem UTF-8-Encoder zum Codieren der Zeichen erforderlich. Klicken Sie dann codiert die Zeichen, und die resultierenden UTF-8-codierten Bytes angezeigt.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird der Name für die aktuelle Codierung bei der Internet Assigned Numbers Authority (IANA) registriert.</summary>
        <value>Der IANA-Name für die aktuelle <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.WebName%2A> Eigenschaft ist identisch mit der <xref:System.Text.EncodingInfo.Name%2A> Eigenschaft.  
  
 Beachten Sie, dass <xref:System.Text.Encoding.WebName%2A> gibt einen IANA registrierten Namen für die Codierung zurück. Wenn der Wert der Name der Standard ist, kann die Implementierung der Codierung nicht vollständig dieses Standards entsprechen. Die <xref:System.Text.Encoding.HeaderName%2A> Eigenschaft definiert eine andere Codierung, die für e-Mail-Header besser geeignet sein könnte. Allerdings sollten die meisten apps verwenden <xref:System.Text.Encoding.WebName%2A> stattdessen.  
  
 Weitere Informationen zur IANA finden Sie unter [www.iana.org](http://www.iana.org/).  
  
 Die <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> ist identisch mit der <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> zurückgegebenes <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. Manche der Webnamen sind Duplikate; Siehe die Hinweise für <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> für Weitere Informationen.  
  
   
  
## Examples  
 Das folgende Beispiel schließt den <xref:System.Text.Encoding.WebName%2A> in einem HTML-Header.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 Im folgenden Beispiel ruft die verschiedenen Namen für jede Codierung ab und zeigt die Codierungen mit ein oder mehrere Namen, die von unterscheiden <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Es zeigt <xref:System.Text.Encoding.EncodingName%2A> jedoch nicht dafür verglichen.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird die Codepage des Betriebssystems Windows abgerufen, die der aktuellen Codierung am ehesten entspricht.</summary>
        <value>Die Codepage des Betriebssystems Windows, die der aktuellen <see cref="T:System.Text.Encoding" /> am ehesten entspricht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird für die Kompatibilität mit Windows unterstützt mehrere Sprachen (MLang) APIs, z. B. zur Ermittlung von Schriftartfamilien. Für die Globalisierung wird die Verwendung eines Unicode-Codierungen stattdessen empfohlen. Es wird außerdem empfohlen, verwenden Sie <xref:System.Text.Encoding.WebName%2A> anstelle von <xref:System.Text.Encoding.WindowsCodePage%2A> um die Codepage zu identifizieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, die Windows-Codepage, die jeder Codierung am ehesten entspricht.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
