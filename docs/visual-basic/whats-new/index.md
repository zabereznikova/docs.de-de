---
title: Neues
ms.date: 10/24/2018
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
ms.openlocfilehash: ada336ee5fce317315bb5f3974e0366f7bca3985
ms.sourcegitcommit: f99115e12a5eb75638abe45072e023a3ce3351ac
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/12/2020
ms.locfileid: "94557102"
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="35c5b-102">Neues in Visual Basic</span><span class="sxs-lookup"><span data-stu-id="35c5b-102">What's new for Visual Basic</span></span>

<span data-ttu-id="35c5b-103">In diesem Thema sind die Namen der wichtigsten Funktionen für jede Version von Visual Basic mit ausführlichen Beschreibungen der neuen und verbesserten Funktionen in der aktuellen Version der Sprache aufgelistet.</span><span class="sxs-lookup"><span data-stu-id="35c5b-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.</span></span>

## <a name="current-version"></a><span data-ttu-id="35c5b-104">Aktuelle Version</span><span class="sxs-lookup"><span data-stu-id="35c5b-104">Current version</span></span>

<span data-ttu-id="35c5b-105">Visual Basic 16.0/Visual Studio 2019 Version 16.0</span><span class="sxs-lookup"><span data-stu-id="35c5b-105">Visual Basic 16.0 / Visual Studio 2019 version 16.0</span></span>\
<span data-ttu-id="35c5b-106">Weitere Informationen zu neuen Features finden Sie unter [Visual Basic 16.0](#visual-basic-160).</span><span class="sxs-lookup"><span data-stu-id="35c5b-106">For new features, see [Visual Basic 16.0](#visual-basic-160).</span></span>

<span data-ttu-id="35c5b-107">Sie können das neueste .NET SDK über die [.NET-Downloadseite](https://dotnet.microsoft.com/download) herunterladen.</span><span class="sxs-lookup"><span data-stu-id="35c5b-107">You can download the latest .NET SDK from the [.NET downloads page](https://dotnet.microsoft.com/download).</span></span>

## <a name="previous-versions"></a><span data-ttu-id="35c5b-108">Frühere Versionen</span><span class="sxs-lookup"><span data-stu-id="35c5b-108">Previous versions</span></span>

<span data-ttu-id="35c5b-109">Visual Basic 15.8/Visual Studio 2017 Version 15.8</span><span class="sxs-lookup"><span data-stu-id="35c5b-109">Visual Basic 15.8 / Visual Studio 2017 version 15.8</span></span>\
<span data-ttu-id="35c5b-110">Informationen zu neuen Features finden Sie unter [Visual Basic 15.8](#visual-basic-158).</span><span class="sxs-lookup"><span data-stu-id="35c5b-110">For new features, see [Visual Basic 15.8](#visual-basic-158).</span></span>

<span data-ttu-id="35c5b-111">Visual Basic 15.5/Visual Studio 2017 Version 15.5</span><span class="sxs-lookup"><span data-stu-id="35c5b-111">Visual Basic 15.5 / Visual Studio 2017 version 15.5</span></span>\
<span data-ttu-id="35c5b-112">Informationen zu neuen Features finden Sie unter [Visual Basic 15.5](#visual-basic-155).</span><span class="sxs-lookup"><span data-stu-id="35c5b-112">For new features, see [Visual Basic 15.5](#visual-basic-155).</span></span>

<span data-ttu-id="35c5b-113">Visual Basic 15.3/Visual Studio 2017 Version 15.3</span><span class="sxs-lookup"><span data-stu-id="35c5b-113">Visual Basic 15.3 / Visual Studio 2017 version 15.3</span></span>\
<span data-ttu-id="35c5b-114">Informationen zu neuen Features finden Sie unter [Visual Basic 15.3](#visual-basic-153).</span><span class="sxs-lookup"><span data-stu-id="35c5b-114">For new features, see [Visual Basic 15.3](#visual-basic-153).</span></span>

<span data-ttu-id="35c5b-115">Visual Basic 2017/Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="35c5b-115">Visual Basic 2017 / Visual Studio 2017</span></span>\
<span data-ttu-id="35c5b-116">Informationen zu neuen Features finden Sie unter [Visual Basic 2017](#visual-basic-2017).</span><span class="sxs-lookup"><span data-stu-id="35c5b-116">For new features, see [Visual Basic 2017](#visual-basic-2017).</span></span>

<span data-ttu-id="35c5b-117">Visual Basic/Visual Studio 2015</span><span class="sxs-lookup"><span data-stu-id="35c5b-117">Visual Basic / Visual Studio 2015</span></span>\
<span data-ttu-id="35c5b-118">Informationen zu neuen Features finden Sie unter [Visual Basic 14](#visual-basic-14).</span><span class="sxs-lookup"><span data-stu-id="35c5b-118">For new features, see [Visual Basic 14](#visual-basic-14).</span></span>

<span data-ttu-id="35c5b-119">Visual Basic/Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="35c5b-119">Visual Basic / Visual Studio 2013</span></span>\
<span data-ttu-id="35c5b-120">Technologievorschau der .NET Compiler Platform (Roslyn)</span><span class="sxs-lookup"><span data-stu-id="35c5b-120">Technology previews of the .NET Compiler Platform ("Roslyn")</span></span>

<span data-ttu-id="35c5b-121">Visual Basic/Visual Studio 2012</span><span class="sxs-lookup"><span data-stu-id="35c5b-121">Visual Basic / Visual Studio 2012</span></span>\
<span data-ttu-id="35c5b-122">Die Schlüsselwörter `Async` und `await`, Iteratoren, Aufruferinformationsattribute</span><span class="sxs-lookup"><span data-stu-id="35c5b-122">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="35c5b-123">Visual Basic/Visual Studio 2010</span><span class="sxs-lookup"><span data-stu-id="35c5b-123">Visual Basic, Visual Studio 2010</span></span>\
<span data-ttu-id="35c5b-124">Automatisch implementierte Eigenschaften, Auflistungsinitialisierer, implizite Zeilenfortsetzung, dynamische, generische Ko-/Kontravarianz, Zugriff auf globalen Namespace</span><span class="sxs-lookup"><span data-stu-id="35c5b-124">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="35c5b-125">Visual Basic/Visual Studio 2008</span><span class="sxs-lookup"><span data-stu-id="35c5b-125">Visual Basic / Visual Studio 2008</span></span>\
<span data-ttu-id="35c5b-126">Language Integrated Query (LINQ), XML-Literale, lokaler Typrückschluss, Objektinitialisierer, anonyme Typen, Erweiterungsmethoden, lokaler `var`-Typrückschluss, Lambda-Ausdrücke, `if`-Operator, partielle Methoden, auf NULL festlegbare Werttypen</span><span class="sxs-lookup"><span data-stu-id="35c5b-126">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>

<span data-ttu-id="35c5b-127">Visual Basic/Visual Studio 2005</span><span class="sxs-lookup"><span data-stu-id="35c5b-127">Visual Basic / Visual Studio 2005</span></span>\
<span data-ttu-id="35c5b-128">Der `My`-Typ und Hilfstypen (Zugriff auf App, Computer, Dateisystem, Netzwerk)</span><span class="sxs-lookup"><span data-stu-id="35c5b-128">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="35c5b-129">Visual Basic/Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="35c5b-129">Visual Basic / Visual Studio .NET 2003</span></span>\
<span data-ttu-id="35c5b-130">Bitschiebeoperatoren, Deklaration von Schleifenvariablen</span><span class="sxs-lookup"><span data-stu-id="35c5b-130">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="35c5b-131">Visual Basic/Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="35c5b-131">Visual Basic / Visual Studio .NET 2002</span></span>\
<span data-ttu-id="35c5b-132">Die erste Version von Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="35c5b-132">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-160"></a><span data-ttu-id="35c5b-133">Visual Basic 16.0</span><span class="sxs-lookup"><span data-stu-id="35c5b-133">Visual Basic 16.0</span></span>

<span data-ttu-id="35c5b-134">Bei Visual Basic 16.0 liegt der Fokus darauf, weitere Features der Visual Basic-Laufzeit (microsoft.visualbasic.dll) für .NET Core bereitzustellen, und ist die erste Version von Visual Basic, die auf .NET Core ausgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="35c5b-134">Visual Basic 16.0 focuses on supplying more of the features of the Visual Basic Runtime (microsoft.visualbasic.dll) to .NET Core and is the first version of Visual Basic focused on .NET Core.</span></span> <span data-ttu-id="35c5b-135">Viele Teile der Visual Basic-Laufzeit sind von WinForms abhängig und werden in einer späteren Version von Visual Basic hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="35c5b-135">Many portions of the Visual Basic Runtime depend on WinForms and these will be added in a later version of Visual Basic.</span></span>

<span data-ttu-id="35c5b-136">**Kommentare sind an weiteren Stellen innerhalb von Anweisungen zulässig**</span><span class="sxs-lookup"><span data-stu-id="35c5b-136">**Comments allowed in more places within statements**</span></span>

<span data-ttu-id="35c5b-137">In Visual Basic 15.8 und früheren Versionen sind Kommentare nur in leeren Zeilen, am Ende von Anweisungen oder an bestimmten Stellen in einer Anweisung zulässig, an denen implizite Zeilenfortsetzungen erlaubt sind.</span><span class="sxs-lookup"><span data-stu-id="35c5b-137">In Visual Basic 15.8 and earlier versions, comments are only allowed on blank lines, at the end of a statement, or in specific places within a statement where an implicit line continuation is allowed.</span></span> <span data-ttu-id="35c5b-138">Ab Visual Basic 16.0 sind Kommentare auch nach expliziten Zeilenfortsetzungen und innerhalb von Anweisungen in Zeilen zulässig, die mit einem Leerzeichen gefolgt von einem Unterstrich beginnen.</span><span class="sxs-lookup"><span data-stu-id="35c5b-138">Starting with Visual Basic 16.0, comments are also allowed after explicit line continuations and within a statement on a line beginning with a space followed by an underscore.</span></span>

```vb
Public Sub Main()
    cmd.CommandText = ' Comment is allowed here without _
        "SELECT * FROM Titles JOIN Publishers " _ ' This is a comment
        & "ON Publishers.PubId = Titles.PubID " _
 _ ' This is a comment on a line without code
        & "WHERE Publishers.State = 'CA'"
End Sub
```

## <a name="visual-basic-158"></a><span data-ttu-id="35c5b-139">Visual Basic 15.8</span><span class="sxs-lookup"><span data-stu-id="35c5b-139">Visual Basic 15.8</span></span>

<span data-ttu-id="35c5b-140">**Optimierte Konvertierung von Gleitkommazahlen in ganze Zahlen**</span><span class="sxs-lookup"><span data-stu-id="35c5b-140">**Optimized floating-point to integer conversion**</span></span>

<span data-ttu-id="35c5b-141">Frühere Visual Basic-Versionen erzielten beim Konvertieren von [doppelten](../language-reference/data-types/double-data-type.md) und [einzelnen](../language-reference/data-types/single-data-type.md) Werten in ganze Zahlen eine relativ schlechte Leistung.</span><span class="sxs-lookup"><span data-stu-id="35c5b-141">In previous versions of Visual Basic, conversion of [Double](../language-reference/data-types/double-data-type.md) and [Single](../language-reference/data-types/single-data-type.md) values to integers offered relatively poor performance.</span></span> <span data-ttu-id="35c5b-142">Visual Basic 15.8 weist eine deutlich verbesserte Leistung beim Konvertieren von Gleitkomma- in ganze Zahlen auf, wenn Sie den Wert, der durch eine der folgenden Methoden zurückgegeben wird, an eine [intrinsische Visual Basic-Konvertierungsfunktion für ganze Zahlen](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng) übergeben, oder wenn der durch eine der folgenden Methoden zurückgegebene Wert implizit in einen integralen Typ umgewandelt wird, wenn [Option Strict](../language-reference/statements/option-strict-statement.md) auf `Off` festgelegt ist:</span><span class="sxs-lookup"><span data-stu-id="35c5b-142">Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the [intrinsic Visual Basic integer conversion functions](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when [Option Strict](../language-reference/statements/option-strict-statement.md) is set to `Off`:</span></span>

- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Single)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Single)?displayProperty=nameWithType>
- <xref:System.Math.Ceiling(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Floor(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Round(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Truncate(System.Double)?displayProperty=nameWithType>

<span data-ttu-id="35c5b-143">Dank dieser Optimierung kann Code schneller ausgeführt werden. Code, der viele Ganzzahltypen konvertiert, wird bis zu doppelt so schnell ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="35c5b-143">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="35c5b-144">Das folgende Beispiel veranschaulicht einige einfache Methodenaufrufe, die von dieser Optimierung betroffen sind:</span><span class="sxs-lookup"><span data-stu-id="35c5b-144">The following example illustrates some simple method calls that are affected by this optimization:</span></span>

```vb
Dim s As Single = 173.7619
Dim d As Double = s

Dim i1 As Integer = CInt(Fix(s))               ' Result: 173
Dim b1 As Byte = CByte(Int(d))                 ' Result: 173
Dim s1 AS Short = CShort(Math.Truncate(s))     ' Result: 173
Dim i2 As Integer = CInt(Math.Ceiling(d))      ' Result: 174
Dim i3 As Integer = CInt(Math.Round(s))        ' Result: 174
```

<span data-ttu-id="35c5b-145">Beachten Sie, dass diese Option die Gleitkommawerte kürzt und nicht rundet.</span><span class="sxs-lookup"><span data-stu-id="35c5b-145">Note that this truncates rather than rounds floating-point values.</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="35c5b-146">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="35c5b-146">Visual Basic 15.5</span></span>

[<span data-ttu-id="35c5b-147">Nicht schließende benannte Argumente</span><span class="sxs-lookup"><span data-stu-id="35c5b-147">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="35c5b-148">In Visual Basic 15.3 und früheren Versionen mussten positionelle vor benannten Argumenten stehen, wenn ein Methodenaufruf sowohl Argumente nach Position als auch nach Namen beinhaltete.</span><span class="sxs-lookup"><span data-stu-id="35c5b-148">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="35c5b-149">Ab Visual Basic 15.5 können positionelle und benannte Argumente in beliebiger Reihenfolge angeordnet werden, solange sich alle Argumente bis zum letzten positionellen Argument an der korrekten Position befinden.</span><span class="sxs-lookup"><span data-stu-id="35c5b-149">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="35c5b-150">Dies ist besonders dann nützlich, wenn benannte Argumente verwendet werden, um Code lesbarer zu machen.</span><span class="sxs-lookup"><span data-stu-id="35c5b-150">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="35c5b-151">Der folgende Methodenaufruf hat beispielsweise zwei positionelle Argumente zwischen einem benannten Argument.</span><span class="sxs-lookup"><span data-stu-id="35c5b-151">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="35c5b-152">Das benannte Argument gibt an, dass der Wert 19 für ein Alter steht.</span><span class="sxs-lookup"><span data-stu-id="35c5b-152">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

[<span data-ttu-id="35c5b-153">Zugriffsmodifizierer `Private Protected` für Member</span><span class="sxs-lookup"><span data-stu-id="35c5b-153">`Private Protected` member access modifier</span></span>](../language-reference/modifiers/private-protected.md)

<span data-ttu-id="35c5b-154">Diese neue Schlüsselwortkombination definiert einen Member, auf den alle Member seiner enthaltenden Klasse sowie Typen, die von der enthaltenden Klasse abgeleitet sind, zugreifen können, wenn sie sich auch in der enthaltenden Assembly befinden.</span><span class="sxs-lookup"><span data-stu-id="35c5b-154">This new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly.</span></span> <span data-ttu-id="35c5b-155">Da Strukturen nicht geerbt werden können, kann `Private Protected` nur auf die Member einer Klasse angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="35c5b-155">Because structures cannot be inherited, `Private Protected` can only be applied to the members of a class.</span></span>

<span data-ttu-id="35c5b-156">**Führendes Hexadezimal-/Binär-/Oktaltrennzeichen**</span><span class="sxs-lookup"><span data-stu-id="35c5b-156">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="35c5b-157">Mit Visual Basic 2017 wurde Unterstützung für das Unterstrichzeichen (`_`) als Zifferntrennzeichen hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="35c5b-157">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="35c5b-158">Sie können ab Visual Basic 15.5 den Unterstrich als vorangestelltes Trennzeichen zwischen dem Präfix und Hexadezimal-, Binär- oder Oktalziffern verwenden.</span><span class="sxs-lookup"><span data-stu-id="35c5b-158">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="35c5b-159">Im folgenden Beispiel wird ein Trennzeichen für vorangestellte Ziffern verwendet, um 3.271.948.384 als hexadezimale Zahl zu definieren:</span><span class="sxs-lookup"><span data-stu-id="35c5b-159">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
```

<span data-ttu-id="35c5b-160">Um den Unterstrich als vorangestelltes Trennzeichen verwenden zu können, müssen Sie Ihrer Visual Basic-Projektdatei (\*.vbproj) das folgende Element hinzufügen:</span><span class="sxs-lookup"><span data-stu-id="35c5b-160">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="35c5b-161">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="35c5b-161">Visual Basic 15.3</span></span>

[<span data-ttu-id="35c5b-162">**Rückschluss auf benannte Tupel**</span><span class="sxs-lookup"><span data-stu-id="35c5b-162">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="35c5b-163">Wenn Sie den Wert von Tupelelementen von Variablen zuweisen, leitet Visual Basic den Namen der Typelelemente von den entsprechenden Variablennamen ab. Sie müssen ein Tupelelement nicht explizit benennen.</span><span class="sxs-lookup"><span data-stu-id="35c5b-163">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="35c5b-164">In folgendem Beispiel werden Rückschlüsse verwendet, um ein Tupel mit drei benannten Elementen, `state`, `stateName` und `capital`, zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="35c5b-164">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="35c5b-165">**Zusätzliche Compileroptionen**</span><span class="sxs-lookup"><span data-stu-id="35c5b-165">**Additional compiler switches**</span></span>

<span data-ttu-id="35c5b-166">Der Visual Basic-Befehlszeilencompiler unterstützt nun die zusätzlichen Compileroptionen [ **-refout**](../reference/command-line-compiler/refout-compiler-option.md) und [ **-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) zur Steuerung der Ausgabe von Verweisassemblys.</span><span class="sxs-lookup"><span data-stu-id="35c5b-166">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="35c5b-167">**-refout** definiert das Ausgabeverzeichnis der Referenzassembly, und **-refonly** legt fest, dass nur eine Referenzassembly bei der Kompilierung ausgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="35c5b-167">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="35c5b-168">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="35c5b-168">Visual Basic 2017</span></span>

[<span data-ttu-id="35c5b-169">**Tupel**</span><span class="sxs-lookup"><span data-stu-id="35c5b-169">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="35c5b-170">Tupel sind einfache Datenstrukturen, die am häufigsten für die Rückgabe von mehreren Werten aus einem einzelnen Methodenaufruf verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="35c5b-170">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="35c5b-171">Für gewöhnlich müssen Sie eine der folgenden Aktionen durchführen, um mehrere Werte aus einer Methode zurückzugeben:</span><span class="sxs-lookup"><span data-stu-id="35c5b-171">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="35c5b-172">die Definition eines benutzerdefinierten Typs (eine `Class` oder eine `Structure`).</span><span class="sxs-lookup"><span data-stu-id="35c5b-172">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="35c5b-173">Dabei handelt es sich um eine schwierige Lösung.</span><span class="sxs-lookup"><span data-stu-id="35c5b-173">This is a heavyweight solution.</span></span>

- <span data-ttu-id="35c5b-174">die Definition von mindestens einem `ByRef`-Parameter zusätzlich zur Rückgabe eines Werts aus der Methode</span><span class="sxs-lookup"><span data-stu-id="35c5b-174">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>

<span data-ttu-id="35c5b-175">Die Unterstützung für Tupel von Visual Basic erlaubt Ihnen die schnelle Definition von Tupeln, die optionale Zuweisung von semantischen Namen an deren Werte und das schnelle Abrufen dieser Werte.</span><span class="sxs-lookup"><span data-stu-id="35c5b-175">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="35c5b-176">In folgendem Beispiel wird ein Aufruf der <xref:System.Int32.TryParse%2A>-Methode umschlossen und ein Tupel zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="35c5b-176">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="35c5b-177">Anschließend können Sie die Methode aufrufen und das zurückgegebene Tupel mit Code wie dem folgenden behandeln.</span><span class="sxs-lookup"><span data-stu-id="35c5b-177">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

<span data-ttu-id="35c5b-178">**Binäre Literale und Zahlentrennzeichen**</span><span class="sxs-lookup"><span data-stu-id="35c5b-178">**Binary literals and digit separators**</span></span>

<span data-ttu-id="35c5b-179">Sie können ein binäres Literal definieren, indem Sie die Präfixe `&B` oder `&b` verwenden.</span><span class="sxs-lookup"><span data-stu-id="35c5b-179">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="35c5b-180">Zusätzlich können Sie einen Unterstrich (`_`) als Zahlentrennzeichen verwenden, um die Lesbarkeit zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="35c5b-180">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="35c5b-181">In folgendem Beispiel werden Funktionen sowohl verwendet, um einen `Byte`-Wert zuzuweisen, als auch um ihn als Dezimal-, Hexadezimal- und binäre Zahl anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="35c5b-181">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="35c5b-182">Weitere Informationen finden Sie im Abschnitt „Zuweisung von Literalen“ der Datentypen [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments) und [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments).</span><span class="sxs-lookup"><span data-stu-id="35c5b-182">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

[<span data-ttu-id="35c5b-183">**Support for C# reference return values (Unterstützung für Verweisrückgabewerte von C#)**</span><span class="sxs-lookup"><span data-stu-id="35c5b-183">**Support for C# reference return values**</span></span>](../programming-guide/language-features/procedures/ref-return-values.md)

<span data-ttu-id="35c5b-184">Ab C# 7.0 unterstützt C# Verweisrückgabewerte.</span><span class="sxs-lookup"><span data-stu-id="35c5b-184">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="35c5b-185">Das heißt, wenn die aufrufende Methode einen von einem Verweis zurückgegebenen Wert erhält, kann sie den Wert des Verweises ändern.</span><span class="sxs-lookup"><span data-stu-id="35c5b-185">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="35c5b-186">In Visual Basic können Sie keine Methoden mit Verweisrückgabewerten erstellen. Allerdings können Sie Verweisrückgabewerte verarbeiten und modifizieren.</span><span class="sxs-lookup"><span data-stu-id="35c5b-186">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="35c5b-187">Die folgende in C# geschriebene `Sentence`-Klasse enthält z.B eine `FindNext`-Methode, die nach dem nächsten Wort in einer Sequenz sucht, die mit einer angegebenen Teilzeichenfolge beginnt.</span><span class="sxs-lookup"><span data-stu-id="35c5b-187">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="35c5b-188">Die Zeichenfolge wird als Verweisrückgabewert zurückgegeben, und eine vom Verweis an die Methode übergebene `Boolean`-Variable gibt an, ob die Suche Erfolg hatte.</span><span class="sxs-lookup"><span data-stu-id="35c5b-188">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="35c5b-189">Das bedeutet, dass der Rückgabewert nicht nur vom Aufrufer gelesen sondern auch geändert werden kann. Diese Änderung wird in der `Sentence`-Klasse widergespiegelt.</span><span class="sxs-lookup"><span data-stu-id="35c5b-189">This means that in addition to reading the returned value, the caller can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="35c5b-190">Sie können das in der Sequenz gefundene Wort in seiner einfachsten Form mit Code wie dem folgenden modifizieren.</span><span class="sxs-lookup"><span data-stu-id="35c5b-190">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="35c5b-191">Beachten Sie, dass Sie nicht der Methode sondern dem Ausdruck, den die Methode zurückgibt, einen Wert zuweisen. Dabei handelt es sich um den Verweisrückgabewert.</span><span class="sxs-lookup"><span data-stu-id="35c5b-191">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="35c5b-192">Bei diesem Code besteht jedoch das Problem, dass die Methode das erste Wort zurückgibt, wenn keine Übereinstimmung gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="35c5b-192">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="35c5b-193">Da in dem Beispiel nicht der Wert des `Boolean`-Arguments untersucht wird, um festzustellen, ob eine Übereinstimmung gefunden wurde, wird das erste Wort modifiziert, wenn es keine Übereinstimmung gibt.</span><span class="sxs-lookup"><span data-stu-id="35c5b-193">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="35c5b-194">In folgendem Beispiel wird dies korrigiert, indem das erste Wort durch sich selbst ersetzt wird, wenn es keine Übereinstimmung gibt.</span><span class="sxs-lookup"><span data-stu-id="35c5b-194">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="35c5b-195">Eine sinnvollere Lösung ist das Verwenden einer Hilfsmethode, an die der Verweisrückgabewert vom Verweis übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="35c5b-195">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="35c5b-196">Die Hilfsmethode kann dann das an sie vom Verweis übergebene Argument modifizieren.</span><span class="sxs-lookup"><span data-stu-id="35c5b-196">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="35c5b-197">In folgendem Beispiel wird dies getan.</span><span class="sxs-lookup"><span data-stu-id="35c5b-197">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="35c5b-198">Weitere Informationen finden Sie unter [Verweisrückgabewerte](../programming-guide/language-features/procedures/ref-return-values.md).</span><span class="sxs-lookup"><span data-stu-id="35c5b-198">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="35c5b-199">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="35c5b-199">Visual Basic 14</span></span>

[<span data-ttu-id="35c5b-200">NameOf</span><span class="sxs-lookup"><span data-stu-id="35c5b-200">NameOf</span></span>](../language-reference/operators/nameof.md)

<span data-ttu-id="35c5b-201">Sie können den nicht qualifizierten Zeichenfolgennamen eines Typs oder Members zur Verwendung in einer Fehlermeldung ohne Hartcodierung einer Zeichenfolge abrufen.</span><span class="sxs-lookup"><span data-stu-id="35c5b-201">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="35c5b-202">Dadurch bleibt der Code bei der Umgestaltung korrekt.</span><span class="sxs-lookup"><span data-stu-id="35c5b-202">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="35c5b-203">Diese Funktion eignet sich auch zum Einbinden von MVC-Links (Model-View-Controller) und das Auslösen von Ereignissen durch geänderte Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="35c5b-203">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>

[<span data-ttu-id="35c5b-204">Zeichenfolgeninterpolation</span><span class="sxs-lookup"><span data-stu-id="35c5b-204">String interpolation</span></span>](../programming-guide/language-features/strings/interpolated-strings.md)

<span data-ttu-id="35c5b-205">Sie können Ausdrücke für die Zeichenfolgeninterpolierung zum Erstellen von Zeichenfolgen verwenden.</span><span class="sxs-lookup"><span data-stu-id="35c5b-205">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="35c5b-206">Ein Ausdruck für eine interpolierte Zeichenfolge sieht wie eine Vorlagenzeichenfolge aus, die Ausdrücke enthält.</span><span class="sxs-lookup"><span data-stu-id="35c5b-206">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="35c5b-207">Eine interpolierte Zeichenfolge ist in Bezug auf die Argumente leichter zu verstehen als eine [Zusammengesetzte Formatierung](../../standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="35c5b-207">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-formatting.md).</span></span>

[<span data-ttu-id="35c5b-208">Memberzugriff und Indizierung mit NULL-Bedingung</span><span class="sxs-lookup"><span data-stu-id="35c5b-208">Null-conditional member access and indexing</span></span>](../language-reference/operators/null-conditional-operators.md)

<span data-ttu-id="35c5b-209">Sie können eine Prüfung auf null auf sehr einfache syntaktische Weise vornehmen, bevor Sie eine Operation für den Memberzugriff (`?.`) oder die Indizierung (`?[]`) ausführen.</span><span class="sxs-lookup"><span data-stu-id="35c5b-209">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="35c5b-210">Mithilfe dieser Operatoren müssen Sie für die Prüfung auf null weniger Code schreiben, insbesondere beim tieferen Eindringen in Datenstrukturen.</span><span class="sxs-lookup"><span data-stu-id="35c5b-210">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="35c5b-211">Wenn der linke Operand oder Objektverweis NULL ist, geben die Operationen NULL zurück.</span><span class="sxs-lookup"><span data-stu-id="35c5b-211">If the left operand or object reference is null, the operations returns null.</span></span>

[<span data-ttu-id="35c5b-212">Multi-line string literals (Mehrzeilige Zeichenfolgenliterale)</span><span class="sxs-lookup"><span data-stu-id="35c5b-212">Multi-line string literals</span></span>](../programming-guide/language-features/strings/string-basics.md)

<span data-ttu-id="35c5b-213">Zeichenfolgenliterale können Zeilenumbruchsequenzen enthalten.</span><span class="sxs-lookup"><span data-stu-id="35c5b-213">String literals can contain newline sequences.</span></span>  <span data-ttu-id="35c5b-214">Sie müssen nicht mehr die alte Problemumgehung mit `<xml><![CDATA[...text with newlines...]]></xml>.Value` verwenden.</span><span class="sxs-lookup"><span data-stu-id="35c5b-214">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>

<span data-ttu-id="35c5b-215">**Kommentare**</span><span class="sxs-lookup"><span data-stu-id="35c5b-215">**Comments**</span></span>

<span data-ttu-id="35c5b-216">Sie können Kommentare nach impliziten Zeilenfortsetzungen, innerhalb von Initialisierungsausdrücken und zwischen LINQ-Ausdrücken einfügen.</span><span class="sxs-lookup"><span data-stu-id="35c5b-216">You can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.</span></span>

<span data-ttu-id="35c5b-217">**Intelligentere Auflösung vollqualifizierter Namen**</span><span class="sxs-lookup"><span data-stu-id="35c5b-217">**Smarter fully-qualified name resolution**</span></span>

<span data-ttu-id="35c5b-218">Bei Code wie `Threading.Thread.Sleep(1000)` suchte Visual Basic bisher den Namespace "Threading", stellte fest, dass dieser mit "System.Threading" und "System.Windows.Threading" mehrdeutig war und meldete dann einen Fehler.</span><span class="sxs-lookup"><span data-stu-id="35c5b-218">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="35c5b-219">Nun berücksichtigt Visual Basic die beiden möglichen Namespaces gemeinsam.</span><span class="sxs-lookup"><span data-stu-id="35c5b-219">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="35c5b-220">Wenn Sie die Vervollständigungsliste anzeigen, listet der Visual Studio-Editor Member beider Typen in der Vervollständigungsliste auf.</span><span class="sxs-lookup"><span data-stu-id="35c5b-220">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>

<span data-ttu-id="35c5b-221">**Datumsliterale mit Jahresangabe am Anfang**</span><span class="sxs-lookup"><span data-stu-id="35c5b-221">**Year-first date literals**</span></span>

<span data-ttu-id="35c5b-222">Datumsliterale im Format jjjj-mm-tt sind möglich, z. B. `#2015-03-17 16:10 PM#`.</span><span class="sxs-lookup"><span data-stu-id="35c5b-222">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>

<span data-ttu-id="35c5b-223">**Schreibgeschützte Schnittstelleneigenschaften**</span><span class="sxs-lookup"><span data-stu-id="35c5b-223">**Readonly interface properties**</span></span>

<span data-ttu-id="35c5b-224">Sie können mithilfe einer Readwrite-Eigenschaft schreibgeschützte Schnittstelleneigenschaften implementieren.</span><span class="sxs-lookup"><span data-stu-id="35c5b-224">You can implement readonly interface properties using a readwrite property.</span></span> <span data-ttu-id="35c5b-225">Die Schnittstelle garantiert Mindestfunktionalität und hindert eine Implementierungsklasse nicht daran, die Festlegung der Eigenschaft zuzulassen.</span><span class="sxs-lookup"><span data-stu-id="35c5b-225">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>

[<span data-ttu-id="35c5b-226">TypeOf \<expr> IsNot \<type></span><span class="sxs-lookup"><span data-stu-id="35c5b-226">TypeOf \<expr> IsNot \<type></span></span>](../language-reference/operators/typeof-operator.md)

<span data-ttu-id="35c5b-227">Zur besseren Lesbarkeit des Codes können Sie nun `TypeOf` mit `IsNot` verwenden.</span><span class="sxs-lookup"><span data-stu-id="35c5b-227">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>

[<span data-ttu-id="35c5b-228">#Disable Warning\<ID> und #Enable Warning \<ID></span><span class="sxs-lookup"><span data-stu-id="35c5b-228">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../language-reference/directives/index.md)

<span data-ttu-id="35c5b-229">Sie können bestimmte Warnungen für Bereiche innerhalb einer Quelldatei deaktivieren und aktivieren.</span><span class="sxs-lookup"><span data-stu-id="35c5b-229">You can disable and enable specific warnings for regions within a source file.</span></span>

<span data-ttu-id="35c5b-230">**Verbesserungen bei XML-Dokumentationskommentaren**</span><span class="sxs-lookup"><span data-stu-id="35c5b-230">**XML doc comment improvements**</span></span>

<span data-ttu-id="35c5b-231">Beim Schreiben von Dokumentationskommentaren steht intelligente Editor- und Buildunterstützung zum Überprüfen von Parameternamen, ordnungsgemäßer Handhabung von `crefs` (Generics, Operatoren usw.), Farben und Umgestaltung bereit.</span><span class="sxs-lookup"><span data-stu-id="35c5b-231">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>

[<span data-ttu-id="35c5b-232">Partial Module and Interface Definitions (Partielle Modul- und Schnittstellendefinitionen)</span><span class="sxs-lookup"><span data-stu-id="35c5b-232">Partial module and interface definitions</span></span>](../language-reference/modifiers/partial.md)

<span data-ttu-id="35c5b-233">Zusätzlich zu Klassen und Strukturen können Sie partielle Module und Schnittstellen deklarieren.</span><span class="sxs-lookup"><span data-stu-id="35c5b-233">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>

[<span data-ttu-id="35c5b-234">#Region directives inside method bodies (#Region-Anweisungen in Methodentexten)</span><span class="sxs-lookup"><span data-stu-id="35c5b-234">#Region directives inside method bodies</span></span>](../language-reference/directives/region-directive.md)

<span data-ttu-id="35c5b-235">Sie können die Begrenzer #Region...#End Region an einer beliebigen Stelle in einer Datei, innerhalb von Funktionen und sogar Funktionsrümpfe übergreifend einfügen.</span><span class="sxs-lookup"><span data-stu-id="35c5b-235">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>

[<span data-ttu-id="35c5b-236">Overrides definitions are implicitly overloads (Überschreibungsdefinitionen sind implizite Überladungen)</span><span class="sxs-lookup"><span data-stu-id="35c5b-236">Overrides definitions are implicitly overloads</span></span>](../language-reference/modifiers/overrides.md)

<span data-ttu-id="35c5b-237">Wenn Sie den `Overrides`-Modifizierer zu einer Definition hinzufügen, fügt der Compiler implizit `Overloads` hinzu, sodass Sie in allgemeinen Fällen weniger Code eingeben können.</span><span class="sxs-lookup"><span data-stu-id="35c5b-237">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>

<span data-ttu-id="35c5b-238">**CObj in Attributargumenten zulässig**</span><span class="sxs-lookup"><span data-stu-id="35c5b-238">**CObj allowed in attributes arguments**</span></span>

<span data-ttu-id="35c5b-239">Der Compiler gab gewöhnlich eine Fehlermeldung aus, dass CObj(...) bei Verwendung in Attributkonstruktionen keine Konstante war.</span><span class="sxs-lookup"><span data-stu-id="35c5b-239">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>

<span data-ttu-id="35c5b-240">**Deklarieren und Verwenden mehrdeutiger Methoden von unterschiedlichen Schnittstellen**</span><span class="sxs-lookup"><span data-stu-id="35c5b-240">**Declaring and consuming ambiguous methods from different interfaces**</span></span>

<span data-ttu-id="35c5b-241">Zuvor führte der folgende Code zu Fehlern, die Sie daran hinderten, `IMock` zu deklarieren oder `GetDetails` aufzurufen (wenn diese in C# deklariert waren):</span><span class="sxs-lookup"><span data-stu-id="35c5b-241">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>

```vb
Interface ICustomer
  Sub GetDetails(x As Integer)
End Interface

Interface ITime
  Sub GetDetails(x As String)
End Interface

Interface IMock : Inherits ICustomer, ITime
  Overloads Sub GetDetails(x As Char)
End Interface

Interface IMock2 : Inherits ICustomer, ITime
End Interface
```

<span data-ttu-id="35c5b-242">Nun verwendet der Compiler normale Regeln zur Überladungsauflösung, um die am besten geeignete `GetDetails`-Methode zum Aufrufen auszuwählen, und Sie können Schnittstellenbeziehungen in Visual Basic deklarieren, wie sie im Beispiel gezeigt sind.</span><span class="sxs-lookup"><span data-stu-id="35c5b-242">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>

## <a name="see-also"></a><span data-ttu-id="35c5b-243">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="35c5b-243">See also</span></span>

- [<span data-ttu-id="35c5b-244">Neues in Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="35c5b-244">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-visual-studio-2017)
- [<span data-ttu-id="35c5b-245">Neues in Visual Studio 2019</span><span class="sxs-lookup"><span data-stu-id="35c5b-245">What's New in Visual Studio 2019</span></span>](/visualstudio/ide/whats-new-visual-studio-2019)
