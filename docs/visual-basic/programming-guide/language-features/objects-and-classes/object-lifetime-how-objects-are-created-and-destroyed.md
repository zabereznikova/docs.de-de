---
title: 'Objektlebensdauer: Erstellen und Zerstören von Objekten'
ms.date: 07/20/2015
f1_keywords:
- vb.Constructor
helpviewer_keywords:
- destructors, object lifetime
- Sub Finalize destructor
- objects [Visual Basic], destroying
- lifetime [Visual Basic], objects
- Sub New constructor, object lifetime
- Finalize method [Visual Basic], object lifetime
- objects [Visual Basic], creating
- Class_Terminate
- Dispose method [Visual Basic], object lifetime
- Class_Initialize
- object creation [Visual Basic], object lifetime
- parameterized constructors
- objects [Visual Basic], lifetime
- objects [Visual Basic], garbage collection
- constructors [Visual Basic], object lifetime
- Sub Dispose destructor
- garbage collection [Visual Basic], Visual Basic
ms.assetid: f1ee8458-b156-44e0-9a8a-5dd171648cd8
ms.openlocfilehash: 8d9647fa490077f9f6ef82f30eccc4d5ee271985
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/22/2019
ms.locfileid: "74346108"
---
# <a name="object-lifetime-how-objects-are-created-and-destroyed-visual-basic"></a><span data-ttu-id="3de1b-102">Objektlebensdauer: Erstellen und Zerstören von Objekten (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="3de1b-102">Object Lifetime: How Objects Are Created and Destroyed (Visual Basic)</span></span>

<span data-ttu-id="3de1b-103">Erstellt mit dem `New`-Schlüsselwort eine Instanz einer Klasse, ein Objekt.</span><span class="sxs-lookup"><span data-stu-id="3de1b-103">An instance of a class, an object, is created by using the `New` keyword.</span></span> <span data-ttu-id="3de1b-104">Initialisierungsaufgaben müssen häufig für neue Objekte ausgeführt werden, bevor sie verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3de1b-104">Initialization tasks often must be performed on new objects before they are used.</span></span> <span data-ttu-id="3de1b-105">Gebräuchliche Initialisierungsaufgaben umfassen das Öffnen von Dateien, Verbinden mit Datenbanken und das Lesen von Werten von Registrierungsschlüsseln.</span><span class="sxs-lookup"><span data-stu-id="3de1b-105">Common initialization tasks include opening files, connecting to databases, and reading values of registry keys.</span></span> <span data-ttu-id="3de1b-106">Visual Basic controls the initialization of new objects using procedures called *constructors* (special methods that allow control over initialization).</span><span class="sxs-lookup"><span data-stu-id="3de1b-106">Visual Basic controls the initialization of new objects using procedures called *constructors* (special methods that allow control over initialization).</span></span>

<span data-ttu-id="3de1b-107">Nachdem ein Objekt den Gültigkeitsbereich verlässt, wird es von der common Language Runtime (CLR) freigegeben.</span><span class="sxs-lookup"><span data-stu-id="3de1b-107">After an object leaves scope, it is released by the common language runtime (CLR).</span></span> <span data-ttu-id="3de1b-108">Visual Basic controls the release of system resources using procedures called *destructors*.</span><span class="sxs-lookup"><span data-stu-id="3de1b-108">Visual Basic controls the release of system resources using procedures called *destructors*.</span></span> <span data-ttu-id="3de1b-109">Konstruktoren und Destruktoren unterstützen gemeinsam die Erstellung stabiler und vorhersehbarer Klassenbibliotheken.</span><span class="sxs-lookup"><span data-stu-id="3de1b-109">Together, constructors and destructors support the creation of robust and predictable class libraries.</span></span>

## <a name="using-constructors-and-destructors"></a><span data-ttu-id="3de1b-110">Verwenden von Konstruktoren und Destruktoren</span><span class="sxs-lookup"><span data-stu-id="3de1b-110">Using Constructors and Destructors</span></span>

<span data-ttu-id="3de1b-111">Konstruktoren und Destruktoren steuern die Erstellung und Zerstörung von Objekten.</span><span class="sxs-lookup"><span data-stu-id="3de1b-111">Constructors and destructors control the creation and destruction of objects.</span></span> <span data-ttu-id="3de1b-112">The `Sub New` and `Sub Finalize` procedures in Visual Basic initialize and destroy objects; they replace the `Class_Initialize` and `Class_Terminate` methods used in Visual Basic 6.0 and earlier versions.</span><span class="sxs-lookup"><span data-stu-id="3de1b-112">The `Sub New` and `Sub Finalize` procedures in Visual Basic initialize and destroy objects; they replace the `Class_Initialize` and `Class_Terminate` methods used in Visual Basic 6.0 and earlier versions.</span></span>

### <a name="sub-new"></a><span data-ttu-id="3de1b-113">Sub New</span><span class="sxs-lookup"><span data-stu-id="3de1b-113">Sub New</span></span>

<span data-ttu-id="3de1b-114">Der `Sub New`-Konstruktor kann nur einmal während der Erstellung der Klasse ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3de1b-114">The `Sub New` constructor can run only once when a class is created.</span></span> <span data-ttu-id="3de1b-115">Es kann nicht als explizit an einer beliebigen Stelle aufgerufen werden, außer in der ersten Codezeile eines anderen Konstruktors von derselben Klasse oder von einer abgeleiteten Klasse.</span><span class="sxs-lookup"><span data-stu-id="3de1b-115">It cannot be called explicitly anywhere other than in the first line of code of another constructor from either the same class or from a derived class.</span></span> <span data-ttu-id="3de1b-116">Weiterhin wird der Code in der `Sub New`-Methode immer vor jedem anderen Code in einer Klasse ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3de1b-116">Furthermore, the code in the `Sub New` method always runs before any other code in a class.</span></span> <span data-ttu-id="3de1b-117">Visual Basic implicitly creates a `Sub New` constructor at run time if you do not explicitly define a `Sub New` procedure for a class.</span><span class="sxs-lookup"><span data-stu-id="3de1b-117">Visual Basic implicitly creates a `Sub New` constructor at run time if you do not explicitly define a `Sub New` procedure for a class.</span></span>

<span data-ttu-id="3de1b-118">Um einen Konstruktor für eine Klasse zu erstellen, erstellen Sie eine Prozedur mit dem Namen `Sub New` an einer beliebigen Stelle in der Klassendefinition.</span><span class="sxs-lookup"><span data-stu-id="3de1b-118">To create a constructor for a class, create a procedure named `Sub New` anywhere in the class definition.</span></span> <span data-ttu-id="3de1b-119">Zum Erstellen eines parametrisierten Konstruktors legen Sie die Namen und Datentypen der Argumente von `Sub New` so fest, wie Sie die Argumente für eine beliebige andere Prozedur angeben würden, wie im folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="3de1b-119">To create a parameterized constructor, specify the names and data types of arguments to `Sub New` just as you would specify arguments for any other procedure, as in the following code:</span></span>

[!code-vb[VbVbalrOOP#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/WhidbeyStuff.vb#42)]

<span data-ttu-id="3de1b-120">Konstruktoren sind häufig überladen, wie im folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="3de1b-120">Constructors are frequently overloaded, as in the following code:</span></span>

[!code-vb[VbVbalrOOP#116](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/WhidbeyStuff.vb#116)]

<span data-ttu-id="3de1b-121">Wenn Sie eine von einer anderen Klasse abgeleitete Klasse definieren, muss die erste Zeile eines Konstruktors ein Aufruf an den Konstruktor der Basisklasse sein, es sei denn die Basisklasse verfügt über einen zugreifbaren Konstruktor, der keine Parameter annimmt.</span><span class="sxs-lookup"><span data-stu-id="3de1b-121">When you define a class derived from another class, the first line of a constructor must be a call to the constructor of the base class, unless the base class has an accessible constructor that takes no parameters.</span></span> <span data-ttu-id="3de1b-122">Ein Aufruf der Basisklasse mit dem oben stehenden Konstruktor wäre zum Beispiel `MyBase.New(s)`.</span><span class="sxs-lookup"><span data-stu-id="3de1b-122">A call to the base class that contains the above constructor, for example, would be `MyBase.New(s)`.</span></span> <span data-ttu-id="3de1b-123">Otherwise, `MyBase.New` is optional, and the Visual Basic runtime calls it implicitly.</span><span class="sxs-lookup"><span data-stu-id="3de1b-123">Otherwise, `MyBase.New` is optional, and the Visual Basic runtime calls it implicitly.</span></span>

<span data-ttu-id="3de1b-124">Nachdem Sie den Code zum Aufrufen des Konstruktors des übergeordneten Objekts geschrieben haben, können Sie einen beliebigen zusätzlichen Initialisierungscode dem `Sub New`-Verfahren hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="3de1b-124">After you write the code to call the parent object's constructor, you can add any additional initialization code to the `Sub New` procedure.</span></span> <span data-ttu-id="3de1b-125">`Sub New` can accept arguments when called as a parameterized constructor.</span><span class="sxs-lookup"><span data-stu-id="3de1b-125">`Sub New` can accept arguments when called as a parameterized constructor.</span></span> <span data-ttu-id="3de1b-126">Diese Parameter werden von der den Konstruktor aufrufenden Prozedur übergeben, zum Beispiel `Dim AnObject As New ThisClass(X)`.</span><span class="sxs-lookup"><span data-stu-id="3de1b-126">These parameters are passed from the procedure calling the constructor, for example, `Dim AnObject As New ThisClass(X)`.</span></span>

### <a name="sub-finalize"></a><span data-ttu-id="3de1b-127">Sub Finalize</span><span class="sxs-lookup"><span data-stu-id="3de1b-127">Sub Finalize</span></span>

<span data-ttu-id="3de1b-128">Vor der Freigabe von Objekten ruft die CLR automatisch die `Finalize`-Methode für das Objekt auf, das ein `Sub Finalize`-Verfahren definiert</span><span class="sxs-lookup"><span data-stu-id="3de1b-128">Before releasing objects, the CLR automatically calls the `Finalize` method for objects that define a `Sub Finalize` procedure.</span></span> <span data-ttu-id="3de1b-129">Die `Finalize`-Methode kann Code enthalten, der direkt vor der Zerstörung eines Objekts ausgeführt werden muss, z. B. Code zum Schließen von Dateien und Speichern von Zustandsinformationen.</span><span class="sxs-lookup"><span data-stu-id="3de1b-129">The `Finalize` method can contain code that needs to execute just before an object is destroyed, such as code for closing files and saving state information.</span></span> <span data-ttu-id="3de1b-130">Es gibt leichte Leistungseinbußen für die Ausführung von `Sub Finalize`, sodass Sie eine `Sub Finalize`-Methode nur definieren sollten, wenn Sie Objekte explizit freigeben müssen.</span><span class="sxs-lookup"><span data-stu-id="3de1b-130">There is a slight performance penalty for executing `Sub Finalize`, so you should define a `Sub Finalize` method only when you need to release objects explicitly.</span></span>

> [!NOTE]
> <span data-ttu-id="3de1b-131">The garbage collector in the CLR does not (and cannot) dispose of *unmanaged objects*, objects that the operating system executes directly, outside the CLR environment.</span><span class="sxs-lookup"><span data-stu-id="3de1b-131">The garbage collector in the CLR does not (and cannot) dispose of *unmanaged objects*, objects that the operating system executes directly, outside the CLR environment.</span></span> <span data-ttu-id="3de1b-132">Dies liegt daran, dass unterschiedliche nicht verwaltete Objekte auf verschiedene Arten freigegeben werden müssen.</span><span class="sxs-lookup"><span data-stu-id="3de1b-132">This is because different unmanaged objects must be disposed of in different ways.</span></span> <span data-ttu-id="3de1b-133">Diese Informationen ist nicht direkt dem nicht verwalteten Objekt zugeordnet; Sie muss in der Dokumentation für das Objekt vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="3de1b-133">That information is not directly associated with the unmanaged object; it must be found in the documentation for the object.</span></span> <span data-ttu-id="3de1b-134">Eine Klasse, die nicht verwaltete Objekte verwendet, muss diese in ihrer `Finalize`-Methode freigeben.</span><span class="sxs-lookup"><span data-stu-id="3de1b-134">A class that uses unmanaged objects must dispose of them in its `Finalize` method.</span></span>

<span data-ttu-id="3de1b-135">Der `Finalize`-Destruktor ist eine geschützte Methode, die nur über die zugehörige Klasse oder über abgeleitete Klassen aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="3de1b-135">The `Finalize` destructor is a protected method that can be called only from the class it belongs to, or from derived classes.</span></span> <span data-ttu-id="3de1b-136">Das System ruft `Finalize` automatisch auf, wenn ein Objekt zerstört wird, daher sollten Sie `Finalize` nicht explizit von außerhalb einer `Finalize`-Implementierung einer abgeleiteten Klasse aufrufen müssen.</span><span class="sxs-lookup"><span data-stu-id="3de1b-136">The system calls `Finalize` automatically when an object is destroyed, so you should not explicitly call `Finalize` from outside of a derived class's `Finalize` implementation.</span></span>

<span data-ttu-id="3de1b-137">Im Gegensatz zu `Class_Terminate`, das ausgeführt wird, sobald ein Objekt auf nichts festgelegt wurde, gibt es in der Regel eine Verzögerung zwischen dem Zeitpunkt, an dem ein Objekt seinen Gültigkeitsbereich verliert und wenn Visual Basic den `Finalize`-Destruktor aufruft.</span><span class="sxs-lookup"><span data-stu-id="3de1b-137">Unlike `Class_Terminate`, which executes as soon as an object is set to nothing, there is usually a delay between when an object loses scope and when Visual Basic calls the `Finalize` destructor.</span></span> <span data-ttu-id="3de1b-138">Visual Basic .NET allows for a second kind of destructor, <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>, which can be explicitly called at any time to immediately release resources.</span><span class="sxs-lookup"><span data-stu-id="3de1b-138">Visual Basic .NET allows for a second kind of destructor, <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>, which can be explicitly called at any time to immediately release resources.</span></span>

> [!NOTE]
> <span data-ttu-id="3de1b-139">Eine `Finalize`-Destruktor sollte keine Ausnahmen auslösen, da die Anwendung sie nicht behandeln kann und sie das Beenden der Anwendung verursachen können.</span><span class="sxs-lookup"><span data-stu-id="3de1b-139">A `Finalize` destructor should not throw exceptions, because they cannot be handled by the application and can cause the application to terminate.</span></span>

### <a name="how-new-and-finalize-methods-work-in-a-class-hierarchy"></a><span data-ttu-id="3de1b-140">Wie Neue und Finalize-Methoden in einer Klassenhierarchie arbeiten</span><span class="sxs-lookup"><span data-stu-id="3de1b-140">How New and Finalize Methods Work in a Class Hierarchy</span></span>

<span data-ttu-id="3de1b-141">Wenn eine Instanz einer Klasse erstellt wird, versucht die common Language Runtime (CLR), eine Prozedur mit dem Namen `New` auszuführen, wenn es in diesem Objekt vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="3de1b-141">Whenever an instance of a class is created, the common language runtime (CLR) attempts to execute a procedure named `New`, if it exists in that object.</span></span> <span data-ttu-id="3de1b-142">`New` is a type of procedure called a `constructor` that is used to initialize new objects before any other code in an object executes.</span><span class="sxs-lookup"><span data-stu-id="3de1b-142">`New` is a type of procedure called a `constructor` that is used to initialize new objects before any other code in an object executes.</span></span> <span data-ttu-id="3de1b-143">Ein `New`-Konstruktor kann verwendet werden, um Dateien zu öffnen, Verbindungen mit Datenbanken herzustellen, Variablen zu initialisieren und sich um andere Aufgaben zu kümmern, die ausgeführt werden, bevor ein Objekt verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="3de1b-143">A `New` constructor can be used to open files, connect to databases, initialize variables, and take care of any other tasks that need to be done before an object can be used.</span></span>

<span data-ttu-id="3de1b-144">Wenn eine Instanz einer abgeleiteten Klasse erstellt wird, wird der `Sub New`-Konstruktor der Basisklasse zuerst ausgeführt, gefolgt von Konstruktoren in abgeleiteten Klassen.</span><span class="sxs-lookup"><span data-stu-id="3de1b-144">When an instance of a derived class is created, the `Sub New` constructor of the base class executes first, followed by constructors in derived classes.</span></span> <span data-ttu-id="3de1b-145">Dies geschieht, da die erste Codezeile in einem `Sub New`-Konstruktor die Syntax `MyBase.New()` verwendet, um den Konstruktor der Klasse direkt über sich selbst in der Klassenhierarchie aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="3de1b-145">This happens because the first line of code in a `Sub New` constructor uses the syntax `MyBase.New()`to call the constructor of the class immediately above itself in the class hierarchy.</span></span> <span data-ttu-id="3de1b-146">Der `Sub New`-Konstruktor wird dann für jede Klasse in der Klassenhierarchie aufgerufen, bis der Konstruktor für die Basisklasse erreicht wird.</span><span class="sxs-lookup"><span data-stu-id="3de1b-146">The `Sub New` constructor is then called for each class in the class hierarchy until the constructor for the base class is reached.</span></span> <span data-ttu-id="3de1b-147">An dieser Stelle wird der Code im Konstruktor für die Basisklasse ausgeführt, gefolgt vom Code in jedem Konstruktor in allen abgeleiteten Klassen und der Code in den meisten abgeleiteten Klassen wird als letztes ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3de1b-147">At that point, the code in the constructor for the base class executes, followed by the code in each constructor in all derived classes and the code in the most derived classes is executed last.</span></span>

![Screenshot showing class hierarchy constructors and inheritance.](./media/object-lifetime-how-objects-are-created-and-destroyed/subnew-constructor-inheritance.gif)

<span data-ttu-id="3de1b-149">Wenn ein Objekt nicht mehr benötigt wird, ruft die CLR die <xref:System.Object.Finalize%2A>-Methode für dieses Objekt auf, bevor der Speicher freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="3de1b-149">When an object is no longer needed, the CLR calls the <xref:System.Object.Finalize%2A> method for that object before freeing its memory.</span></span> <span data-ttu-id="3de1b-150">Die <xref:System.Object.Finalize%2A> -Methode wird `destructor` genannt, weil es Bereinigungsaufgaben führt, z. B. Speichern von Zustandsinformationen, Schließen von Dateien und Verbindungen mit Datenbanken sowie andere Aufgaben, die vor der Freigabe eines Objekts ausgeführt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="3de1b-150">The <xref:System.Object.Finalize%2A> method is called a `destructor` because it performs cleanup tasks, such as saving state information, closing files and connections to databases, and other tasks that must be done before releasing the object.</span></span>

![Screenshot showing the Finalize method destructor.](./media/object-lifetime-how-objects-are-created-and-destroyed/finalize-method-destructor.gif)

## <a name="idisposable-interface"></a><span data-ttu-id="3de1b-152">IDisposable-Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="3de1b-152">IDisposable Interface</span></span>

<span data-ttu-id="3de1b-153">Klasseninstanzen steuern oft nicht von der CLR verwaltete Ressourcen, z. B. Windows-Handles und Datenbankverbindungen.</span><span class="sxs-lookup"><span data-stu-id="3de1b-153">Class instances often control resources not managed by the CLR, such as Windows handles and database connections.</span></span> <span data-ttu-id="3de1b-154">Diese Ressourcen müssen in der `Finalize`-Methode der Klasse beseitigt werden, sodass sie freigegeben werden, wenn das Objekt vom Garbage Collector zerstört wird.</span><span class="sxs-lookup"><span data-stu-id="3de1b-154">These resources must be disposed of in the `Finalize` method of the class, so that they will be released when the object is destroyed by the garbage collector.</span></span> <span data-ttu-id="3de1b-155">Der Garbage Collector zerstört Objekte jedoch nur, wenn die CLR mehr freien Arbeitsspeicher erfordert.</span><span class="sxs-lookup"><span data-stu-id="3de1b-155">However, the garbage collector destroys objects only when the CLR requires more free memory.</span></span> <span data-ttu-id="3de1b-156">Dies bedeutet, dass die Ressourcen erst freigegeben werdn, nachdem das Objekt längst den Gültigkeitsbereich verlassen hat.</span><span class="sxs-lookup"><span data-stu-id="3de1b-156">This means that the resources may not be released until long after the object goes out of scope.</span></span>

<span data-ttu-id="3de1b-157">Zur Ergänzung der Garbagecollection können die Klassen einen Mechanismus für die aktive Verwaltung von Systemressourcen bereitstellen, wenn sie die <xref:System.IDisposable>-Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="3de1b-157">To supplement garbage collection, your classes can provide a mechanism to actively manage system resources if they implement the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="3de1b-158"><xref:System.IDisposable> has one method, <xref:System.IDisposable.Dispose%2A>, which clients should call when they finish using an object.</span><span class="sxs-lookup"><span data-stu-id="3de1b-158"><xref:System.IDisposable> has one method, <xref:System.IDisposable.Dispose%2A>, which clients should call when they finish using an object.</span></span> <span data-ttu-id="3de1b-159">Sie können die <xref:System.IDisposable.Dispose%2A>-Methode verwenden, um Ressourcen sofort freizugeben und Aufgaben wie das Schließen von Dateien und Datenbankverbindungen durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="3de1b-159">You can use the <xref:System.IDisposable.Dispose%2A> method to immediately release resources and perform tasks such as closing files and database connections.</span></span> <span data-ttu-id="3de1b-160">Im Gegensatz zum `Finalize`-Destruktor, wird die <xref:System.IDisposable.Dispose%2A>-Methode nicht automatisch aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="3de1b-160">Unlike the `Finalize` destructor, the <xref:System.IDisposable.Dispose%2A> method is not called automatically.</span></span> <span data-ttu-id="3de1b-161">Clients einer Klasse müssen explizit <xref:System.IDisposable.Dispose%2A> aufrufen, wenn Ressourcen sofort freigegeben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="3de1b-161">Clients of a class must explicitly call <xref:System.IDisposable.Dispose%2A> when you want to immediately release resources.</span></span>

### <a name="implementing-idisposable"></a><span data-ttu-id="3de1b-162">Implementieren von IDisposable</span><span class="sxs-lookup"><span data-stu-id="3de1b-162">Implementing IDisposable</span></span>

<span data-ttu-id="3de1b-163">Eine Klasse, die die <xref:System.IDisposable>-Schnittstelle implementiert, sollte diese Codeabschnitte enthalten:</span><span class="sxs-lookup"><span data-stu-id="3de1b-163">A class that implements the <xref:System.IDisposable> interface should include these sections of code:</span></span>

- <span data-ttu-id="3de1b-164">Ein Feld, um den Überblick zu behalten, ob das Objekt entsorgt wurde:</span><span class="sxs-lookup"><span data-stu-id="3de1b-164">A field for keeping track of whether the object has been disposed:</span></span>

  ```vb
  Protected disposed As Boolean = False
  ```

- <span data-ttu-id="3de1b-165">Eine Überladung von der <xref:System.IDisposable.Dispose%2A>, die die Ressourcen der Klasse freigibt.</span><span class="sxs-lookup"><span data-stu-id="3de1b-165">An overload of the <xref:System.IDisposable.Dispose%2A> that frees the class's resources.</span></span> <span data-ttu-id="3de1b-166">Diese Methode sollte durch die <xref:System.IDisposable.Dispose%2A> und `Finalize`-Methoden der Basisklasse aufgerufen werden:</span><span class="sxs-lookup"><span data-stu-id="3de1b-166">This method should be called by the <xref:System.IDisposable.Dispose%2A> and `Finalize` methods of the base class:</span></span>

  ```vb
  Protected Overridable Sub Dispose(ByVal disposing As Boolean)
      If Not Me.disposed Then
          If disposing Then
              ' Insert code to free managed resources.
          End If
          ' Insert code to free unmanaged resources.
      End If
      Me.disposed = True
  End Sub
  ```

- <span data-ttu-id="3de1b-167">Eine Implementierung von <xref:System.IDisposable.Dispose%2A>, die nur den folgenden Code enthält:</span><span class="sxs-lookup"><span data-stu-id="3de1b-167">An implementation of <xref:System.IDisposable.Dispose%2A> that contains only the following code:</span></span>

  ```vb
  Public Sub Dispose() Implements IDisposable.Dispose
      Dispose(True)
      GC.SuppressFinalize(Me)
  End Sub
  ```

- <span data-ttu-id="3de1b-168">Eine Überschreibung der `Finalize`-Methode, die nur folgenden Code enthält:</span><span class="sxs-lookup"><span data-stu-id="3de1b-168">An override of the `Finalize` method that contains only the following code:</span></span>

  ```vb
  Protected Overrides Sub Finalize()
      Dispose(False)
      MyBase.Finalize()
  End Sub
  ```

### <a name="deriving-from-a-class-that-implements-idisposable"></a><span data-ttu-id="3de1b-169">Ableiten von einer Klasse, die IDisposable implementiert</span><span class="sxs-lookup"><span data-stu-id="3de1b-169">Deriving from a Class that Implements IDisposable</span></span>

<span data-ttu-id="3de1b-170">Eine Klasse, die von einer Basisklasse abgeleitet wird, die die <xref:System.IDisposable>-Schnittstelle implementiert, muss keine Basismethoden überschreiben, es sei denn, sie verwendet zusätzliche Ressourcen, die freigegeben werden müssen.</span><span class="sxs-lookup"><span data-stu-id="3de1b-170">A class that derives from a base class that implements the <xref:System.IDisposable> interface does not need to override any of the base methods unless it uses additional resources that need to be disposed.</span></span> <span data-ttu-id="3de1b-171">In diesem Fall sollte die abgeleitete Klasse die `Dispose(disposing)`-Methode der Basisklasse überschreiben, um die Ressourcen der abgeleiteten Klasse freizugeben.</span><span class="sxs-lookup"><span data-stu-id="3de1b-171">In that situation, the derived class should override the base class's `Dispose(disposing)` method to dispose of the derived class's resources.</span></span> <span data-ttu-id="3de1b-172">Diese Überschreibung muss die `Dispose(disposing)`-Methode der Basisklasse aufrufen.</span><span class="sxs-lookup"><span data-stu-id="3de1b-172">This override must call the base class's `Dispose(disposing)` method.</span></span>

```vb
Protected Overrides Sub Dispose(ByVal disposing As Boolean)
    If Not Me.disposed Then
        If disposing Then
            ' Insert code to free managed resources.
        End If
        ' Insert code to free unmanaged resources.
    End If
    MyBase.Dispose(disposing)
End Sub
```

<span data-ttu-id="3de1b-173">Eine abgeleitete Klasse darf nicht die <xref:System.IDisposable.Dispose%2A>- und `Finalize`-Methode der Basisklasse überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3de1b-173">A derived class should not override the base class's <xref:System.IDisposable.Dispose%2A> and `Finalize` methods.</span></span> <span data-ttu-id="3de1b-174">Wenn diese Methoden aus einer Instanz der abgeleiteten Klasse aufgerufen werden, ruft die Basisklassenimplementierung dieser Methoden die Überschreibung der `Dispose(disposing)`-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="3de1b-174">When those methods are called from an instance of the derived class, the base class's implementation of those methods call the derived class's override of the `Dispose(disposing)` method.</span></span>

## <a name="garbage-collection-and-the-finalize-destructor"></a><span data-ttu-id="3de1b-175">Garbagecollection und der Finalize-Destruktor</span><span class="sxs-lookup"><span data-stu-id="3de1b-175">Garbage Collection and the Finalize Destructor</span></span>

<span data-ttu-id="3de1b-176">The .NET Framework uses the *reference-tracing garbage collection* system to periodically release unused resources.</span><span class="sxs-lookup"><span data-stu-id="3de1b-176">The .NET Framework uses the *reference-tracing garbage collection* system to periodically release unused resources.</span></span> <span data-ttu-id="3de1b-177">Visual Basic 6.0 and earlier versions used a different system called *reference counting* to manage resources.</span><span class="sxs-lookup"><span data-stu-id="3de1b-177">Visual Basic 6.0 and earlier versions used a different system called *reference counting* to manage resources.</span></span> <span data-ttu-id="3de1b-178">Obwohl beide Systeme dieselbe Funktion automatisch ausführen, gibt es einige wichtige Unterschiede.</span><span class="sxs-lookup"><span data-stu-id="3de1b-178">Although both systems perform the same function automatically, there are a few important differences.</span></span>

<span data-ttu-id="3de1b-179">Die CLR zerstört Objekte in regelmäßigen Abständen, wenn das System feststellt, dass diese Objekte nicht mehr benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="3de1b-179">The CLR periodically destroys objects when the system determines that such objects are no longer needed.</span></span> <span data-ttu-id="3de1b-180">Objekte werden schneller freigegeben, wenn die Systemressourcen knapp und ansonsten seltener sind.</span><span class="sxs-lookup"><span data-stu-id="3de1b-180">Objects are released more quickly when system resources are in short supply, and less frequently otherwise.</span></span> <span data-ttu-id="3de1b-181">Die Verzögerung zwischen dem Zeitpunkt, an dem ein Objekt seinen Gültigkeitsbereich verliert, und der Freigabe durch der CLR bedeutet, dass im Unterschied zu Objekten in Visual Basic 6.0 und früheren Versionen, Sie genau bestimmen können, wann das Objekt zerstört wird.</span><span class="sxs-lookup"><span data-stu-id="3de1b-181">The delay between when an object loses scope and when the CLR releases it means that, unlike with objects in Visual Basic 6.0 and earlier versions, you cannot determine exactly when the object will be destroyed.</span></span> <span data-ttu-id="3de1b-182">In such a situation, objects are said to have *non-deterministic lifetime*.</span><span class="sxs-lookup"><span data-stu-id="3de1b-182">In such a situation, objects are said to have *non-deterministic lifetime*.</span></span> <span data-ttu-id="3de1b-183">In den meisten Fällen ändert die nicht deterministische Lebensdauer nicht das Schreiben von Anwendungen, solange beachtet wird, dass der `Finalize`-Destruktor möglicherweise nicht sofort nach Verlust des Gültigkeitsbereichs eines Objekts ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="3de1b-183">In most cases, non-deterministic lifetime does not change how you write applications, as long as you remember that the `Finalize` destructor may not immediately execute when an object loses scope.</span></span>

<span data-ttu-id="3de1b-184">Ein weiterer Unterschied zu Garbage Collection-Systemen betrifft die Verwendung von `Nothing`.</span><span class="sxs-lookup"><span data-stu-id="3de1b-184">Another difference between the garbage-collection systems involves the use of `Nothing`.</span></span> <span data-ttu-id="3de1b-185">Zur Nutzung der Verweiszählung in Visual Basic 6.0 und früheren Versionen, wiesen Programmierer Objektvariablen zuweilen `Nothing` zu, um die Verweise, die diese Variablen gehalten haben, freizugeben.</span><span class="sxs-lookup"><span data-stu-id="3de1b-185">To take advantage of reference counting in Visual Basic 6.0 and earlier versions, programmers sometimes assigned `Nothing` to object variables to release the references those variables held.</span></span> <span data-ttu-id="3de1b-186">Wenn die Variable den letzten Verweis auf das Objekt gehalten hat, wurden die Ressourcen des Objekts sofort freigegeben.</span><span class="sxs-lookup"><span data-stu-id="3de1b-186">If the variable held the last reference to the object, the object's resources were released immediately.</span></span> <span data-ttu-id="3de1b-187">In späteren Versionen von Visual Basic und in einigen Fällen, in denen dieses Verfahren noch von Bedeutung ist, führt die Ausführung nie dazu, dass das referenzierte Objekt seine Ressourcen sofort freigibt.</span><span class="sxs-lookup"><span data-stu-id="3de1b-187">In later versions of Visual Basic, while there may be cases in which this procedure is still valuable, performing it never causes the referenced object to release its resources immediately.</span></span> <span data-ttu-id="3de1b-188">Um Ressourcen sofort freizugeben, verwenden Sie die <xref:System.IDisposable.Dispose%2A> -Methode des Objekts, falls verfügbar.</span><span class="sxs-lookup"><span data-stu-id="3de1b-188">To release resources immediately, use the object's <xref:System.IDisposable.Dispose%2A> method, if available.</span></span> <span data-ttu-id="3de1b-189">Legen Sie für die Variable `Nothing` nur fest, wenn ihre Lebensdauer im Bezug zur Dauer, die der Garbage Collector zum Auffinden verwaister Objekte benötigt, lang ist.</span><span class="sxs-lookup"><span data-stu-id="3de1b-189">The only time you should set a variable to `Nothing` is when its lifetime is long relative to the time the garbage collector takes to detect orphaned objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="3de1b-190">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="3de1b-190">See also</span></span>

- <xref:System.IDisposable.Dispose%2A>
- <span data-ttu-id="3de1b-191">[Initialization and Termination of Components](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2013/ws9dc6t6(v=vs.120))</span><span class="sxs-lookup"><span data-stu-id="3de1b-191">[Initialization and Termination of Components](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2013/ws9dc6t6(v=vs.120))</span></span>
- [<span data-ttu-id="3de1b-192">New-Operator</span><span class="sxs-lookup"><span data-stu-id="3de1b-192">New Operator</span></span>](../../../../visual-basic/language-reference/operators/new-operator.md)
- [<span data-ttu-id="3de1b-193">Bereinigen von nicht verwalteten Ressourcen</span><span class="sxs-lookup"><span data-stu-id="3de1b-193">Cleaning Up Unmanaged Resources</span></span>](../../../../standard/garbage-collection/unmanaged.md)
- [<span data-ttu-id="3de1b-194">Nothing</span><span class="sxs-lookup"><span data-stu-id="3de1b-194">Nothing</span></span>](../../../../visual-basic/language-reference/nothing.md)
