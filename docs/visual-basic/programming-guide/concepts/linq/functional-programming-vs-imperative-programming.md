---
title: Funktionale Programmierung kontra imperativer Programmierung
ms.date: 07/20/2015
ms.assetid: 6a1f3b57-00e6-447d-9906-74c7c4d5d85c
ms.openlocfilehash: 704beadc29af0de606b8f246360dc6fffca8cfcc
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/22/2019
ms.locfileid: "74353442"
---
# <a name="functional-programming-vs-imperative-programming-visual-basic"></a><span data-ttu-id="24d87-102">Funktionale Programmierung im Vergleich zu imperativer Programmierung (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="24d87-102">Functional Programming vs. Imperative Programming (Visual Basic)</span></span>
<span data-ttu-id="24d87-103">In diesem Thema werden die Gemeinsamkeiten und die Unterschiede der funktionalen Programmierung und der herkömmlichen imperativen (prozeduralen) Programmierung erläutert.</span><span class="sxs-lookup"><span data-stu-id="24d87-103">This topic compares and contrasts functional programming with more traditional imperative (procedural) programming.</span></span>  
  
## <a name="functional-programming-vs-imperative-programming"></a><span data-ttu-id="24d87-104">Funktionale Programmierung kontra imperativer Programmierung</span><span class="sxs-lookup"><span data-stu-id="24d87-104">Functional Programming vs. Imperative Programming</span></span>  
 <span data-ttu-id="24d87-105">Explizite Aufgabe der *funktionalen Programmierung* ist die Unterstützung eines reinen funktionalen Ansatzes bei der Problemlösung.</span><span class="sxs-lookup"><span data-stu-id="24d87-105">The *functional programming* paradigm was explicitly created to support a pure functional approach to problem solving.</span></span> <span data-ttu-id="24d87-106">Die funktionale Programmierung ist eine Form der *deklarativen Programmierung*.</span><span class="sxs-lookup"><span data-stu-id="24d87-106">Functional programming is a form of *declarative programming*.</span></span> <span data-ttu-id="24d87-107">Im Unterschied dazu unterstützen die meisten normalen Programmiersprachen, darunter auch OOP-Sprachen wie C#, Visual Basic, C++ und Java, in erster Linie die *imperative* (prozedurale) Programmierung.</span><span class="sxs-lookup"><span data-stu-id="24d87-107">In contrast, most mainstream languages, including object-oriented programming (OOP) languages such as C#, Visual Basic, C++, and Java, were designed to primarily support *imperative* (procedural) programming.</span></span>  
  
 <span data-ttu-id="24d87-108">Beim imperativen Ansatz schreibt ein Entwickler Code, der detailliert die Schritte beschreibt, die der Computer zur Erfüllung der Aufgabe ausführen muss.</span><span class="sxs-lookup"><span data-stu-id="24d87-108">With an imperative approach, a developer writes code that describes in exacting detail the steps that the computer must take to accomplish the goal.</span></span> <span data-ttu-id="24d87-109">Diese Form der Programmierung wird mitunter auch als *algorithmische* Programmierung bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="24d87-109">This is sometimes referred to as *algorithmic* programming.</span></span> <span data-ttu-id="24d87-110">Beim funktionalen Ansatz hingegen wird das Problem als Satz von auszuführenden Funktionen formuliert.</span><span class="sxs-lookup"><span data-stu-id="24d87-110">In contrast, a functional approach involves composing the problem as a set of functions to be executed.</span></span> <span data-ttu-id="24d87-111">Sie definieren sorgfältig, was für jede Funktion eingegeben wird und was die jeweilige Funktion zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="24d87-111">You define carefully the input to each function, and what each function returns.</span></span> <span data-ttu-id="24d87-112">In der folgenden Tabelle werden einige der allgemeinen Unterschiede zwischen diesen beiden Ansätzen beschrieben:</span><span class="sxs-lookup"><span data-stu-id="24d87-112">The following table describes some of the general differences between these two approaches.</span></span>  
  
|<span data-ttu-id="24d87-113">Merkmal</span><span class="sxs-lookup"><span data-stu-id="24d87-113">Characteristic</span></span>|<span data-ttu-id="24d87-114">Imperativer Ansatz</span><span class="sxs-lookup"><span data-stu-id="24d87-114">Imperative approach</span></span>|<span data-ttu-id="24d87-115">Funktionaler Ansatz</span><span class="sxs-lookup"><span data-stu-id="24d87-115">Functional approach</span></span>|  
|--------------------|-------------------------|-------------------------|  
|<span data-ttu-id="24d87-116">Schwerpunkt bei der Programmierung</span><span class="sxs-lookup"><span data-stu-id="24d87-116">Programmer focus</span></span>|<span data-ttu-id="24d87-117">Art und Weise der Ausführung von Aufgaben (Algorithmen) und der Überwachung von Statusänderungen</span><span class="sxs-lookup"><span data-stu-id="24d87-117">How to perform tasks (algorithms) and how to track changes in state.</span></span>|<span data-ttu-id="24d87-118">Art der gewünschten Informationen und der erforderlichen Transformationen</span><span class="sxs-lookup"><span data-stu-id="24d87-118">What information is desired and what transformations are required.</span></span>|  
|<span data-ttu-id="24d87-119">Zustandsänderungen</span><span class="sxs-lookup"><span data-stu-id="24d87-119">State changes</span></span>|<span data-ttu-id="24d87-120">Wichtig.</span><span class="sxs-lookup"><span data-stu-id="24d87-120">Important.</span></span>|<span data-ttu-id="24d87-121">nicht existent</span><span class="sxs-lookup"><span data-stu-id="24d87-121">Non-existent.</span></span>|  
|<span data-ttu-id="24d87-122">Reihenfolge der Ausführung</span><span class="sxs-lookup"><span data-stu-id="24d87-122">Order of execution</span></span>|<span data-ttu-id="24d87-123">Wichtig.</span><span class="sxs-lookup"><span data-stu-id="24d87-123">Important.</span></span>|<span data-ttu-id="24d87-124">weniger wichtig</span><span class="sxs-lookup"><span data-stu-id="24d87-124">Low importance.</span></span>|  
|<span data-ttu-id="24d87-125">Primäre Datenflusskontrolle</span><span class="sxs-lookup"><span data-stu-id="24d87-125">Primary flow control</span></span>|<span data-ttu-id="24d87-126">Schleifen, Bedingungen und Funktions- (Methoden-)Aufrufe</span><span class="sxs-lookup"><span data-stu-id="24d87-126">Loops, conditionals, and function (method) calls.</span></span>|<span data-ttu-id="24d87-127">Funktionsaufrufe, einschließlich Rekursion</span><span class="sxs-lookup"><span data-stu-id="24d87-127">Function calls, including recursion.</span></span>|  
|<span data-ttu-id="24d87-128">Primäre Manipulationseinheit</span><span class="sxs-lookup"><span data-stu-id="24d87-128">Primary manipulation unit</span></span>|<span data-ttu-id="24d87-129">Instanzen von Strukturen oder Klassen</span><span class="sxs-lookup"><span data-stu-id="24d87-129">Instances of structures or classes.</span></span>|<span data-ttu-id="24d87-130">Funktionen als erstklassige Objekte und Datensammlungen</span><span class="sxs-lookup"><span data-stu-id="24d87-130">Functions as first-class objects and data collections.</span></span>|  
  
 <span data-ttu-id="24d87-131">Die meisten Sprachen unterstützen zwar ein bestimmtes Programmierparadigma, viele allgemeine Sprachen sind aber ausreichend flexibel, um mehrere Paradigmen zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="24d87-131">Although most languages were designed to support a specific programming paradigm, many general languages are flexible enough to support multiple paradigms.</span></span> <span data-ttu-id="24d87-132">So können z. B. die meisten Sprachen, die Funktionszeiger enthalten, zur glaubwürdigen Unterstützung der funktionalen Programmierung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="24d87-132">For example, most languages that contain function pointers can be used to credibly support functional programming.</span></span> <span data-ttu-id="24d87-133">Darüber hinaus enthält Visual Basic explizite Spracherweiterungen zur Unterstützung der funktionalen Programmierung, einschließlich Lambda-Ausdrücken und Typrückschluss.</span><span class="sxs-lookup"><span data-stu-id="24d87-133">Furthermore, Visual Basic includes explicit language extensions to support functional programming, including lambda expressions and type inference.</span></span> <span data-ttu-id="24d87-134">Eine Form der deklarativen, funktionalen Programmierung ist die LINQ-Technologie.</span><span class="sxs-lookup"><span data-stu-id="24d87-134">LINQ technology is a form of declarative, functional programming.</span></span>  
  
## <a name="functional-programming-using-xslt"></a><span data-ttu-id="24d87-135">Funktionale Programmierung mit XSLT</span><span class="sxs-lookup"><span data-stu-id="24d87-135">Functional Programming Using XSLT</span></span>  
 <span data-ttu-id="24d87-136">Viele XSLT-Entwickler sind mit dem reinen funktionalen Ansatz vertraut.</span><span class="sxs-lookup"><span data-stu-id="24d87-136">Many XSLT developers are familiar with the pure functional approach.</span></span> <span data-ttu-id="24d87-137">Der effektivste Weg bei der Entwicklung eines XSLT-Stylesheets besteht darin, jede Vorlage als isolierte, zusammensetzbare Transformation zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="24d87-137">The most effective way to develop an XSLT style sheet is to treat each template as an isolated, composable transformation.</span></span> <span data-ttu-id="24d87-138">Die Reihenfolge der Ausführung ist dabei ohne jede Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="24d87-138">The order of execution is completely de-emphasized.</span></span> <span data-ttu-id="24d87-139">XSLT lässt keine Nebenwirkungen zu (lediglich die Escapemechanismen für die Ausführung von prozeduralem Code können Nebenwirkungen mit sich bringen, die zu funktionaler Unreinheit führen).</span><span class="sxs-lookup"><span data-stu-id="24d87-139">XSLT does not allow side effects (with the exception that escaping mechanisms for executing procedural code can introduce side effects that result in functional impurity).</span></span> <span data-ttu-id="24d87-140">XSLT ist zwar ein wirksames Tool, dennoch sind einige seiner Eigenschaften nicht optimal.</span><span class="sxs-lookup"><span data-stu-id="24d87-140">However, although XSLT is an effective tool, some of its characteristics are not optimal.</span></span> <span data-ttu-id="24d87-141">So führt z. B. das Ausdrücken von Programmierkonstrukten in XML dazu, dass Code relativ weitschweifig und damit schwierig zu unterhalten ist.</span><span class="sxs-lookup"><span data-stu-id="24d87-141">For example, expressing programming constructs in XML makes code relatively verbose, and therefore difficult to maintain.</span></span> <span data-ttu-id="24d87-142">Auch die schwere Abhängigkeit von der Rekursion zur Flusssteuerung kann dazu führen, dass Code schwer lesbar ist.</span><span class="sxs-lookup"><span data-stu-id="24d87-142">Also, the heavy reliance on recursion for flow control can result in code that is hard to read.</span></span> <span data-ttu-id="24d87-143">Weitere Informationen zu XSLT finden Sie unter [XSLT-Transformationen](../../../../standard/data/xml/xslt-transformations.md).</span><span class="sxs-lookup"><span data-stu-id="24d87-143">For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).</span></span>  
  
 <span data-ttu-id="24d87-144">Dennoch hat XSLT bewiesen, dass die Verwendung eines reinen funktionalen Ansatzes bei der Transformierung von XML von einer Form in eine andere sinnvoll ist.</span><span class="sxs-lookup"><span data-stu-id="24d87-144">However, XSLT has proved the value of using a pure functional approach for transforming XML from one shape to another.</span></span> <span data-ttu-id="24d87-145">Die reine funktionale Programmierung mit LINQ to XML ähnelt in vielerlei Hinsicht XSLT.</span><span class="sxs-lookup"><span data-stu-id="24d87-145">Pure functional programming with LINQ to XML is similar in many ways to XSLT.</span></span> <span data-ttu-id="24d87-146">Mit den Programmierkonstrukten, die mit LINQ to XML und Visual Basic eingeführt wurden, können Sie jedoch reine funktionale Transformationen schreiben, die besser lesbar und verwalterbar sind als XSLT.</span><span class="sxs-lookup"><span data-stu-id="24d87-146">However, the programming constructs introduced by LINQ to XML and Visual Basic allow you to write pure functional transformations that are more readable and maintainable than XSLT.</span></span>  
  
## <a name="advantages-of-pure-functions"></a><span data-ttu-id="24d87-147">Vorteile von reinen Funktionen</span><span class="sxs-lookup"><span data-stu-id="24d87-147">Advantages of Pure Functions</span></span>  
 <span data-ttu-id="24d87-148">Der Hauptgrund für die Implementierung von funktionalen Transformationen als reinen Funktionen (Pure-Funktionen) besteht darin, dass reine Funktionen zusammenstellbar sind, d. h., sie sind in sich abgeschlossen und zustandslos.</span><span class="sxs-lookup"><span data-stu-id="24d87-148">The primary reason to implement functional transformations as pure functions is that pure functions are composable: that is, self-contained and stateless.</span></span> <span data-ttu-id="24d87-149">Diese Eigenschaften bieten u. a. die folgenden Vorteile:</span><span class="sxs-lookup"><span data-stu-id="24d87-149">These characteristics bring a number of benefits, including the following:</span></span>  
  
- <span data-ttu-id="24d87-150">Bessere Lesbarkeit und Verwaltbarkeit:</span><span class="sxs-lookup"><span data-stu-id="24d87-150">Increased readability and maintainability.</span></span> <span data-ttu-id="24d87-151">Jede Funktion ist für die Erledigung einer bestimmten Aufgabe anhand ihrer Argumente vorgesehen,</span><span class="sxs-lookup"><span data-stu-id="24d87-151">This is because each function is designed to accomplish a specific task given its arguments.</span></span> <span data-ttu-id="24d87-152">ohne sich dabei auf einen externen Zustand zu verlassen.</span><span class="sxs-lookup"><span data-stu-id="24d87-152">The function does not rely on any external state.</span></span>  
  
- <span data-ttu-id="24d87-153">Einfachere reiterative Entwicklung:</span><span class="sxs-lookup"><span data-stu-id="24d87-153">Easier reiterative development.</span></span> <span data-ttu-id="24d87-154">Da der Code einfacher umgestaltet werden kann, können Änderungen am Entwurf oft leichter implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="24d87-154">Because the code is easier to refactor, changes to design are often easier to implement.</span></span> <span data-ttu-id="24d87-155">Nehmen wir z. B. an, Sie schreiben eine komplizierte Transformation und stellen dann fest, dass sich ein Teil des Codes in der Transformation mehrmals wiederholt.</span><span class="sxs-lookup"><span data-stu-id="24d87-155">For example, suppose you write a complicated transformation, and then realize that some code is repeated several times in the transformation.</span></span> <span data-ttu-id="24d87-156">Bei der Umgestaltung mit einer reinen Methode können Sie Ihre reine Methode ganz nach Belieben aufrufen, ohne auf irgendwelche Nebenwirkungen Rücksicht nehmen zu müssen.</span><span class="sxs-lookup"><span data-stu-id="24d87-156">If you refactor through a pure method, you can call your pure method at will without worrying about side effects.</span></span>  
  
- <span data-ttu-id="24d87-157">Einfacheres Testen und Debuggen:</span><span class="sxs-lookup"><span data-stu-id="24d87-157">Easier testing and debugging.</span></span> <span data-ttu-id="24d87-158">Da reine Funktionen einfacher in Isolation getestet werden können, können Sie Testcode schreiben, der die reine Funktion mit typischen Werten, gültigen Randfällen und ungültigen Randfällen aufruft.</span><span class="sxs-lookup"><span data-stu-id="24d87-158">Because pure functions can more easily be tested in isolation, you can write test code that calls the pure function with typical values, valid edge cases, and invalid edge cases.</span></span>  
  
## <a name="transitioning-for-oop-developers"></a><span data-ttu-id="24d87-159">Was müssen OOP-Entwickler beachten?</span><span class="sxs-lookup"><span data-stu-id="24d87-159">Transitioning for OOP Developers</span></span>  
 <span data-ttu-id="24d87-160">Bei der traditionellen objektorientierten Programmierung (OOP) verwenden die meisten Entwickler beim Programmieren den imperativen/prozeduralen Stil.</span><span class="sxs-lookup"><span data-stu-id="24d87-160">In traditional object-oriented programming (OOP), most developers are accustomed to programming in the imperative/procedural style.</span></span> <span data-ttu-id="24d87-161">Für den Umstieg auf die Entwicklung in einem reinen funktionalen Stil müssen die Entwickler umdenken und ihre Herangehensweise an die Entwicklung ändern.</span><span class="sxs-lookup"><span data-stu-id="24d87-161">To switch to developing in a pure functional style, they have to make a transition in their thinking and their approach to development.</span></span>  
  
 <span data-ttu-id="24d87-162">Zur Lösung von Problemen entwerfen OOP-Entwickler Klassenhierarchien, konzentrieren sich auf die richtige Kapselung und denken in Klassenvertragskategorien.</span><span class="sxs-lookup"><span data-stu-id="24d87-162">To solve problems, OOP developers design class hierarchies, focus on proper encapsulation, and think in terms of class contracts.</span></span> <span data-ttu-id="24d87-163">Im Vordergrund stehen das Verhalten und der Status von Objekttypen, und zu diesem Zweck werden Sprachfunktionen wie Klassen, Schnittstellen, Vererbung und Polymorphie bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="24d87-163">The behavior and state of object types are paramount, and language features, such as classes, interfaces, inheritance, and polymorphism, are provided to address these concerns.</span></span>  
  
 <span data-ttu-id="24d87-164">Dagegen werden die Berechnungsprobleme bei der funktionalen Programmierung als Übung für die Auswertung reiner funktionaler Transformationen von Datensammlungen angesehen.</span><span class="sxs-lookup"><span data-stu-id="24d87-164">In contrast, functional programming approaches computational problems as an exercise in the evaluation of pure functional transformations of data collections.</span></span> <span data-ttu-id="24d87-165">Bei der funktionalen Programmierung werden Zustands- und änderbare Daten vermieden, stattdessen steht die Anwendung von Funktionen im Mittelpunkt.</span><span class="sxs-lookup"><span data-stu-id="24d87-165">Functional programming avoids state and mutable data, and instead emphasizes the application of functions.</span></span>  
  
 <span data-ttu-id="24d87-166">Glücklicherweise erfordert Visual Basic nicht den vollständigen Sprung zur funktionalen Programmierung, da Sie sowohl imperative als auch funktionale Programmier Ansätze unterstützt.</span><span class="sxs-lookup"><span data-stu-id="24d87-166">Fortunately, Visual Basic doesn't require the full leap to functional programming, because it supports both imperative and functional programming approaches.</span></span> <span data-ttu-id="24d87-167">Der Entwickler kann daher selbst entscheiden, welcher Ansatz für ein bestimmtes Szenario am geeignetsten ist.</span><span class="sxs-lookup"><span data-stu-id="24d87-167">A developer can choose which approach is most appropriate for a particular scenario.</span></span> <span data-ttu-id="24d87-168">Bei vielen Programme werden beide Ansätze häufig miteinander kombiniert.</span><span class="sxs-lookup"><span data-stu-id="24d87-168">In fact, programs often combine both approaches.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="24d87-169">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="24d87-169">See also</span></span>

- [<span data-ttu-id="24d87-170">Einführung in reine funktionale Transformationen (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="24d87-170">Introduction to Pure Functional Transformations (Visual Basic)</span></span>](../../../../visual-basic/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md)
- [<span data-ttu-id="24d87-171">XSLT Transformations (XSLT-Transformationen)</span><span class="sxs-lookup"><span data-stu-id="24d87-171">XSLT Transformations</span></span>](../../../../standard/data/xml/xslt-transformations.md)
- [<span data-ttu-id="24d87-172">Refactoring in reine Funktionen (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="24d87-172">Refactoring Into Pure Functions (Visual Basic)</span></span>](../../../../visual-basic/programming-guide/concepts/linq/refactoring-into-pure-functions.md)
