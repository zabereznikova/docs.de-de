---
title: Quantifizierer in regulären Ausdrücken
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, quantifiers
- metacharacters, quantifiers
- minimal matching quantifiers
- quantifiers in regular expressions
- .NET Framework regular expressions, quantifiers
- quantifiers
- lazy quantifiers
ms.assetid: 36b81212-6511-49ed-a8f1-ff080415312f
ms.openlocfilehash: f1627248cbed0f03c6fb76ce660f9b2bf7764781
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/15/2020
ms.locfileid: "78160013"
---
# <a name="quantifiers-in-regular-expressions"></a><span data-ttu-id="d4fc7-102">Quantifizierer in regulären Ausdrücken</span><span class="sxs-lookup"><span data-stu-id="d4fc7-102">Quantifiers in Regular Expressions</span></span>
<span data-ttu-id="d4fc7-103">Quantifizierer geben an, wie viele Instanzen eines Zeichens, einer Gruppe oder einer Zeichenklasse in der Eingabe vorhanden sein müssen, damit eine Übereinstimmung gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-103">Quantifiers specify how many instances of a character, group, or character class must be present in the input for a match to be found.</span></span>  <span data-ttu-id="d4fc7-104">In der folgenden Tabelle werden die von .NET unterstützten Quantifizierer aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-104">The following table lists the quantifiers supported by .NET.</span></span>  
  
|<span data-ttu-id="d4fc7-105">Gieriger Quantifizierer</span><span class="sxs-lookup"><span data-stu-id="d4fc7-105">Greedy quantifier</span></span>|<span data-ttu-id="d4fc7-106">Träger Quantifizierer</span><span class="sxs-lookup"><span data-stu-id="d4fc7-106">Lazy quantifier</span></span>|<span data-ttu-id="d4fc7-107">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="d4fc7-107">Description</span></span>|  
|-----------------------|---------------------|-----------------|  
|`*`|`*?`|<span data-ttu-id="d4fc7-108">Übereinstimmung mit null oder mehr Vorkommen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-108">Match zero or more times.</span></span>|  
|`+`|`+?`|<span data-ttu-id="d4fc7-109">Übereinstimmung mit einem oder mehr Vorkommen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-109">Match one or more times.</span></span>|  
|`?`|`??`|<span data-ttu-id="d4fc7-110">Übereinstimmung mit null oder einem Vorkommen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-110">Match zero or one time.</span></span>|  
|<span data-ttu-id="d4fc7-111">`{` *n* `}`</span><span class="sxs-lookup"><span data-stu-id="d4fc7-111">`{` *n* `}`</span></span>|<span data-ttu-id="d4fc7-112">`{` *n* `}?`</span><span class="sxs-lookup"><span data-stu-id="d4fc7-112">`{` *n* `}?`</span></span>|<span data-ttu-id="d4fc7-113">Übereinstimmung mit genau *n* Vorkommen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-113">Match exactly *n* times.</span></span>|  
|<span data-ttu-id="d4fc7-114">`{` *n* `,}`</span><span class="sxs-lookup"><span data-stu-id="d4fc7-114">`{` *n* `,}`</span></span>|<span data-ttu-id="d4fc7-115">`{` *n* `,}?`</span><span class="sxs-lookup"><span data-stu-id="d4fc7-115">`{` *n* `,}?`</span></span>|<span data-ttu-id="d4fc7-116">Übereinstimmung mit mindestens *n* Vorkommen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-116">Match at least *n* times.</span></span>|  
|<span data-ttu-id="d4fc7-117">`{` *n* `,` *m* `}`</span><span class="sxs-lookup"><span data-stu-id="d4fc7-117">`{` *n* `,` *m* `}`</span></span>|<span data-ttu-id="d4fc7-118">`{` *n* `,` *m* `}?`</span><span class="sxs-lookup"><span data-stu-id="d4fc7-118">`{` *n* `,` *m* `}?`</span></span>|<span data-ttu-id="d4fc7-119">Übereinstimmung mit *n* bis *m* Vorkommen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-119">Match from *n* to *m* times.</span></span>|  
  
 <span data-ttu-id="d4fc7-120">Die Mengen `n` und `m` sind ganzzahlige Konstanten.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-120">The quantities `n` and `m` are integer constants.</span></span> <span data-ttu-id="d4fc7-121">Gewöhnlich sind Quantifizierer gierig; durch sie gleicht die Engine für reguläre Ausdrücke so viele Vorkommen bestimmter Muster wie möglich ab.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-121">Ordinarily, quantifiers are greedy; they cause the regular expression engine to match as many occurrences of particular patterns as possible.</span></span> <span data-ttu-id="d4fc7-122">Das Anhängen des `?`-Zeichens an einen Quantifizierer macht es träge; es bewirkt, dass die Engine für reguläre Ausdrücke so wenige Vorkommen wie möglich abgleicht.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-122">Appending the `?` character to a quantifier makes it lazy; it causes the regular expression engine to match as few occurrences as possible.</span></span> <span data-ttu-id="d4fc7-123">Eine vollständige Beschreibung des Unterschieds zwischen „gierigen“ und „trägen“ Quantifizierern finden Sie weiter unten in diesem Thema im Abschnitt [Gierige und träge Quantifizierer](#Greedy).</span><span class="sxs-lookup"><span data-stu-id="d4fc7-123">For a complete description of the difference between greedy and lazy quantifiers, see the section [Greedy and Lazy Quantifiers](#Greedy) later in this topic.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="d4fc7-124">Das Schachteln von Quantifizierern (z.B. wie durch das Muster für reguläre Ausdrücke `(a*)*`) kann die Anzahl von Vergleichen, die die Engine für reguläre Ausdrücke ausführen muss, als Exponentialfunktion der Anzahl von Zeichen in der Eingabezeichenfolge erhöhen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-124">Nesting quantifiers (for example, as the regular expression pattern `(a*)*` does) can increase the number of comparisons that the regular expression engine must perform, as an exponential function of the number of characters in the input string.</span></span> <span data-ttu-id="d4fc7-125">Weitere Informationen zu diesem Verhalten und zu Problemumgehungen finden Sie unter [Rückverfolgung](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="d4fc7-125">For more information about this behavior and its workarounds, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="regular-expression-quantifiers"></a><span data-ttu-id="d4fc7-126">Quantifizierer in regulären Ausdrücken</span><span class="sxs-lookup"><span data-stu-id="d4fc7-126">Regular Expression Quantifiers</span></span>  
 <span data-ttu-id="d4fc7-127">In den folgenden Abschnitten werden die Quantifizierer aufgeführt, die in regulären .NET-Ausdrücken unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-127">The following sections list the quantifiers supported by .NET regular expressions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d4fc7-128">Wenn die Zeichen \*, +, ?, { und } im Muster für reguläre Ausdrücke enthalten sind, interpretiert die Engine für reguläre Ausdrücke sie als Quantifizierer oder als Teil von Quantifiziererkonstrukten, sofern sie nicht in einer [Zeichenklasse](../../../docs/standard/base-types/character-classes-in-regular-expressions.md) enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-128">If the \*, +, ?, {, and } characters are encountered in a regular expression pattern, the regular expression engine interprets them as quantifiers or part of quantifier constructs unless they are included in a [character class](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).</span></span> <span data-ttu-id="d4fc7-129">Um sie als Literalzeichen außerhalb einer Zeichenklasse zu interpretieren, müssen Sie sie mit Escapezeichen versehen, indem Sie ihnen einen umgekehrten Schrägstrich voranstellen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-129">To interpret these as literal characters outside a character class, you must escape them by preceding them with a backslash.</span></span> <span data-ttu-id="d4fc7-130">Die Zeichenfolge `\*` in einem Muster für reguläre Ausdrücke wird z.B. als literales Sternchen („\*“) interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-130">For example, the string `\*` in a regular expression pattern is interpreted as a literal asterisk ("\*") character.</span></span>  
  
### <a name="match-zero-or-more-times-"></a><span data-ttu-id="d4fc7-131">Übereinstimmung mit null oder mehr Vorkommen: \*</span><span class="sxs-lookup"><span data-stu-id="d4fc7-131">Match Zero or More Times: \*</span></span>  
 <span data-ttu-id="d4fc7-132">Der `*`-Quantifizierer gleicht das vorangehende Element nullmal oder häufiger ab.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-132">The `*` quantifier matches the preceding element zero or more times.</span></span> <span data-ttu-id="d4fc7-133">Dies entspricht dem `{0,}`-Quantifizierer.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-133">It is equivalent to the `{0,}` quantifier.</span></span> <span data-ttu-id="d4fc7-134">`*` ist ein gieriger Quantifizierer, dessen träges Äquivalent `*?` lautet.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-134">`*` is a greedy quantifier whose lazy equivalent is `*?`.</span></span>  
  
 <span data-ttu-id="d4fc7-135">Im folgenden Beispiel wird dieser reguläre Ausdruck veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-135">The following example illustrates this regular expression.</span></span> <span data-ttu-id="d4fc7-136">Von den neun Ziffern in der Eingabezeichenfolge entsprechen fünf dem Muster, bei vier Ziffern (`95`, `929`, `9219` und `9919`) ist das nicht der Fall.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-136">Of the nine digits in the input string, five match the pattern and four (`95`, `929`, `9219`, and `9919`) do not.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#1)]  
  
 <span data-ttu-id="d4fc7-137">Das Muster für reguläre Ausdrücke ist wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-137">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d4fc7-138">Muster</span><span class="sxs-lookup"><span data-stu-id="d4fc7-138">Pattern</span></span>|<span data-ttu-id="d4fc7-139">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="d4fc7-139">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d4fc7-140">An einer Wortgrenze beginnen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-140">Start at a word boundary.</span></span>|  
|`91*`|<span data-ttu-id="d4fc7-141">Übereinstimmung mit „9“, gefolgt von null oder mehr Zeichen „1“.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-141">Match a "9" followed by zero or more "1" characters.</span></span>|  
|`9*`|<span data-ttu-id="d4fc7-142">Übereinstimmung mit null oder mehr Zeichen „9“.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-142">Match zero or more "9" characters.</span></span>|  
|`\b`|<span data-ttu-id="d4fc7-143">An einer Wortgrenze beenden.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-143">End at a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-"></a><span data-ttu-id="d4fc7-144">Übereinstimmung mit einem oder mehr Vorkommen: +</span><span class="sxs-lookup"><span data-stu-id="d4fc7-144">Match One or More Times: +</span></span>  
 <span data-ttu-id="d4fc7-145">Der `+`-Quantifizierer gleicht das vorangehende Element einmal oder häufiger ab.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-145">The `+` quantifier matches the preceding element one or more times.</span></span> <span data-ttu-id="d4fc7-146">Er entspricht `{1,}`.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-146">It is equivalent to `{1,}`.</span></span> <span data-ttu-id="d4fc7-147">`+` ist ein gieriger Quantifizierer, dessen träges Äquivalent `+?` lautet.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-147">`+` is a greedy quantifier whose lazy equivalent is `+?`.</span></span>  
  
 <span data-ttu-id="d4fc7-148">Beispielsweise versucht der reguläre Ausdruck `\ban+\w*?\b` ganze Wörter abzugleichen, die mit dem Buchstaben `a` beginnen, gefolgt von mindestens einer Instanz des Buchstabens `n`.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-148">For example, the regular expression `\ban+\w*?\b` tries to match entire words that begin with the letter `a` followed by one or more instances of the letter `n`.</span></span> <span data-ttu-id="d4fc7-149">Im folgenden Beispiel wird dieser reguläre Ausdruck veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-149">The following example illustrates this regular expression.</span></span> <span data-ttu-id="d4fc7-150">Der reguläre Ausdruck gleicht die Wörter `an`, `annual`, `announcement` und `antique` ab und findet richtigerweise keine Übereinstimmung mit `autumn` und `all`.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-150">The regular expression matches the words `an`, `annual`, `announcement`, and `antique`, and correctly fails to match `autumn` and `all`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#2)]  
  
 <span data-ttu-id="d4fc7-151">Das Muster für reguläre Ausdrücke ist wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-151">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d4fc7-152">Muster</span><span class="sxs-lookup"><span data-stu-id="d4fc7-152">Pattern</span></span>|<span data-ttu-id="d4fc7-153">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="d4fc7-153">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d4fc7-154">An einer Wortgrenze beginnen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-154">Start at a word boundary.</span></span>|  
|`an+`|<span data-ttu-id="d4fc7-155">Übereinstimmung mit „a“, gefolgt von einem oder mehr Zeichen „n“.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-155">Match an "a" followed by one or more "n" characters.</span></span>|  
|`\w*?`|<span data-ttu-id="d4fc7-156">Gleicht ein Wortzeichen nullmal oder häufiger ab, jedoch so wenige Male wie möglich.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-156">Match a word character zero or more times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="d4fc7-157">An einer Wortgrenze beenden.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-157">End at a word boundary.</span></span>|  
  
### <a name="match-zero-or-one-time-"></a><span data-ttu-id="d4fc7-158">Übereinstimmung mit null oder einem Vorkommen: ?</span><span class="sxs-lookup"><span data-stu-id="d4fc7-158">Match Zero or One Time: ?</span></span>  
 <span data-ttu-id="d4fc7-159">Der Quantifizierer `?` gleicht das vorangehende Element null- oder einmal ab.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-159">The `?` quantifier matches the preceding element zero or one time.</span></span> <span data-ttu-id="d4fc7-160">Er entspricht `{0,1}`.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-160">It is equivalent to `{0,1}`.</span></span> <span data-ttu-id="d4fc7-161">`?` ist ein gieriger Quantifizierer, dessen träges Äquivalent `??` lautet.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-161">`?` is a greedy quantifier whose lazy equivalent is `??`.</span></span>  
  
 <span data-ttu-id="d4fc7-162">Beispielsweise versucht der reguläre Ausdruck `\ban?\b` ganze Wörter abzugleichen, die mit dem Buchstaben `a` beginnen, gefolgt von null oder einer Instanz des Buchstabens `n`.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-162">For example, the regular expression `\ban?\b` tries to match entire words that begin with the letter `a` followed by zero or one instances of the letter `n`.</span></span> <span data-ttu-id="d4fc7-163">Das heißt, er versucht, die Wörter `a` und `an` abzugleichen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-163">In other words, it tries to match the words `a` and `an`.</span></span> <span data-ttu-id="d4fc7-164">Im folgenden Beispiel wird dieser reguläre Ausdruck veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-164">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#3](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#3)]
 [!code-vb[RegularExpressions.Quantifiers#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#3)]  
  
 <span data-ttu-id="d4fc7-165">Das Muster für reguläre Ausdrücke ist wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-165">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d4fc7-166">Muster</span><span class="sxs-lookup"><span data-stu-id="d4fc7-166">Pattern</span></span>|<span data-ttu-id="d4fc7-167">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="d4fc7-167">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d4fc7-168">An einer Wortgrenze beginnen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-168">Start at a word boundary.</span></span>|  
|`an?`|<span data-ttu-id="d4fc7-169">Übereinstimmung mit „a“, gefolgt von null oder einem Zeichen „n“.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-169">Match an "a" followed by zero or one "n" character.</span></span>|  
|`\b`|<span data-ttu-id="d4fc7-170">An einer Wortgrenze beenden.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-170">End at a word boundary.</span></span>|  
  
### <a name="match-exactly-n-times-n"></a><span data-ttu-id="d4fc7-171">Übereinstimmung mit genau n Vorkommen: {n}</span><span class="sxs-lookup"><span data-stu-id="d4fc7-171">Match Exactly n Times: {n}</span></span>  
 <span data-ttu-id="d4fc7-172">Der `{`*n*`}`-Quantifizierer gleicht das vorangehende Element genau *n* Mal ab, wobei *n* für einen beliebigen Integer steht.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-172">The `{`*n*`}` quantifier matches the preceding element exactly *n* times, where *n* is any integer.</span></span> <span data-ttu-id="d4fc7-173">`{`*n*`}` ist ein gieriger Quantifizierer, dessen träges Äquivalent `{`*n*`}?` lautet.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-173">`{`*n*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`}?`.</span></span>  
  
 <span data-ttu-id="d4fc7-174">Beispielsweise versucht der reguläre Ausdruck `\b\d+\,\d{3}\b`, eine Wortgrenze, gefolgt von einer oder mehreren Dezimalziffern, gefolgt von drei Dezimalziffern, gefolgt von einer Wortgrenze abzugleichen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-174">For example, the regular expression `\b\d+\,\d{3}\b` tries to match a word boundary followed by one or more decimal digits followed by three decimal digits followed by a word boundary.</span></span> <span data-ttu-id="d4fc7-175">Im folgenden Beispiel wird dieser reguläre Ausdruck veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-175">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#4](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#4)]
 [!code-vb[RegularExpressions.Quantifiers#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#4)]  
  
 <span data-ttu-id="d4fc7-176">Das Muster für reguläre Ausdrücke ist wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-176">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d4fc7-177">Muster</span><span class="sxs-lookup"><span data-stu-id="d4fc7-177">Pattern</span></span>|<span data-ttu-id="d4fc7-178">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="d4fc7-178">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d4fc7-179">An einer Wortgrenze beginnen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-179">Start at a word boundary.</span></span>|  
|`\d+`|<span data-ttu-id="d4fc7-180">Entsprechung für mindestens eine Dezimalstelle finden.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-180">Match one or more decimal digits.</span></span>|  
|`\,`|<span data-ttu-id="d4fc7-181">Übereinstimmung mit einem Kommazeichen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-181">Match a comma character.</span></span>|  
|`\d{3}`|<span data-ttu-id="d4fc7-182">Entsprechung für drei Dezimalstellen finden.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-182">Match three decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="d4fc7-183">An einer Wortgrenze beenden.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-183">End at a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-n"></a><span data-ttu-id="d4fc7-184">Übereinstimmung mit mindestens n Vorkommen: {n,}</span><span class="sxs-lookup"><span data-stu-id="d4fc7-184">Match at Least n Times: {n,}</span></span>  
 <span data-ttu-id="d4fc7-185">Der `{`*n*`,}`-Quantifizierer gleicht das vorangehende Element mindestens *n*-mal ab, wobei *n* für einen beliebigen Integer steht.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-185">The `{`*n*`,}` quantifier matches the preceding element at least *n* times, where *n* is any integer.</span></span> <span data-ttu-id="d4fc7-186">`{`*n*`,}` ist ein gieriger Quantifizierer, dessen träges Äquivalent `{`*n*`,}?` lautet.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-186">`{`*n*`,}` is a greedy quantifier whose lazy equivalent is `{`*n*`,}?`.</span></span>  
  
 <span data-ttu-id="d4fc7-187">Beispielsweise versucht der reguläre Ausdruck `\b\d{2,}\b\D+`, eine Wortgrenze, gefolgt von mindestens zwei Ziffern, gefolgt von einer Wortgrenze und einer Nicht-Dezimalziffer abzugleichen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-187">For example, the regular expression `\b\d{2,}\b\D+` tries to match a word boundary followed by at least two digits followed by a word boundary and a non-digit character.</span></span> <span data-ttu-id="d4fc7-188">Im folgenden Beispiel wird dieser reguläre Ausdruck veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-188">The following example illustrates this regular expression.</span></span> <span data-ttu-id="d4fc7-189">Der reguläre Ausdruck kann den Ausdruck `"7 days"` nicht abgleichen, da er nur eine Dezimalziffer enthält, findet aber erfolgreich Übereinstimmungen mit den Phrasen `"10 weeks and 300 years"`.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-189">The regular expression fails to match the phrase `"7 days"` because it contains just one decimal digit, but it successfully matches the phrases `"10 weeks and 300 years"`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#5](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#5)]
 [!code-vb[RegularExpressions.Quantifiers#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#5)]  
  
 <span data-ttu-id="d4fc7-190">Das Muster für reguläre Ausdrücke ist wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-190">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d4fc7-191">Muster</span><span class="sxs-lookup"><span data-stu-id="d4fc7-191">Pattern</span></span>|<span data-ttu-id="d4fc7-192">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="d4fc7-192">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d4fc7-193">An einer Wortgrenze beginnen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-193">Start at a word boundary.</span></span>|  
|`\d{2,}`|<span data-ttu-id="d4fc7-194">Übereinstimmung mit mindestens zwei Dezimalziffern.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-194">Match at least two decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="d4fc7-195">Übereinstimmung mit einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-195">Match a word boundary.</span></span>|  
|`\D+`|<span data-ttu-id="d4fc7-196">Übereinstimmung mit mindestens einer Nicht-Dezimalziffer.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-196">Match at least one non-decimal digit.</span></span>|  
  
### <a name="match-between-n-and-m-times-nm"></a><span data-ttu-id="d4fc7-197">Übereinstimmung mit n bis m Vorkommen: {n,m}</span><span class="sxs-lookup"><span data-stu-id="d4fc7-197">Match Between n and m Times: {n,m}</span></span>  
 <span data-ttu-id="d4fc7-198">Der `{`*n*`,`*m*`}`-Quantifizierer gleicht das vorangehende Element mindestens *n* Mal, aber nicht mehr als *m* Mal ab, wobei *n* und *m* Integerwerte sind.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-198">The `{`*n*`,`*m*`}` quantifier matches the preceding element at least *n* times, but no more than *m* times, where *n* and *m* are integers.</span></span> <span data-ttu-id="d4fc7-199">`{`*n*`,`*m*`}` ist ein gieriger Quantifizierer, dessen träges Äquivalent `{`*n*`,`*m*`}?` lautet.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-199">`{`*n*`,`*m*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`,`*m*`}?`.</span></span>  
  
 <span data-ttu-id="d4fc7-200">Im folgenden Beispiel versucht der reguläre Ausdruck `(00\s){2,4}`, zwei bis vier Vorkommen zweier 0-Ziffern, gefolgt von einem Leerzeichen, abzugleichen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-200">In the following example, the regular expression `(00\s){2,4}` tries to match between two and four occurrences of two zero digits followed by a space.</span></span> <span data-ttu-id="d4fc7-201">Beachten Sie, dass der letzte Teil der Eingabezeichenfolge dieses Muster fünfmal enthält und damit das Maximum von vier überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-201">Note that the final portion of the input string includes this pattern five times rather than the maximum of four.</span></span> <span data-ttu-id="d4fc7-202">Allerdings stimmt nur der erste Teil dieser Teilzeichenfolge (bis zum Leerzeichen und fünften Nullpaar) mit dem Muster für reguläre Ausdrücke überein.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-202">However, only the initial portion of this substring (up to the space and the fifth pair of zeros) matches the regular expression pattern.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#6](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#6)]
 [!code-vb[RegularExpressions.Quantifiers#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#6)]  
  
### <a name="match-zero-or-more-times-lazy-match-"></a><span data-ttu-id="d4fc7-203">Übereinstimmung mit null oder mehr Vorkommen (träger Abgleich): \*?</span><span class="sxs-lookup"><span data-stu-id="d4fc7-203">Match Zero or More Times (Lazy Match): \*?</span></span>  
 <span data-ttu-id="d4fc7-204">Der `*?`-Quantifizierer gleicht das vorangehende Element nullmal oder häufiger ab, jedoch so wenige Male wie möglich.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-204">The `*?` quantifier matches the preceding element zero or more times, but as few times as possible.</span></span> <span data-ttu-id="d4fc7-205">Dies ist das träge Gegenstück zum gierigen Quantifizierer `*`.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-205">It is the lazy counterpart of the greedy quantifier `*`.</span></span>  
  
 <span data-ttu-id="d4fc7-206">Im folgenden Beispiel gleicht der reguläre Ausdruck `\b\w*?oo\w*?\b` alle Wörter ab, die die Zeichenfolge `oo` enthalten.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-206">In the following example, the regular expression `\b\w*?oo\w*?\b` matches all words that contain the string `oo`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#7](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#7)]
 [!code-vb[RegularExpressions.Quantifiers#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#7)]  
  
 <span data-ttu-id="d4fc7-207">Das Muster für reguläre Ausdrücke ist wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-207">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d4fc7-208">Muster</span><span class="sxs-lookup"><span data-stu-id="d4fc7-208">Pattern</span></span>|<span data-ttu-id="d4fc7-209">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="d4fc7-209">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d4fc7-210">An einer Wortgrenze beginnen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-210">Start at a word boundary.</span></span>|  
|`\w*?`|<span data-ttu-id="d4fc7-211">Übereinstimmung mit null oder mehr Wortzeichen, aber so wenigen Zeichen wie möglich.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-211">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`oo`|<span data-ttu-id="d4fc7-212">Übereinstimmung mit der Zeichenfolge „Oo“.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-212">Match the string "oo".</span></span>|  
|`\w*?`|<span data-ttu-id="d4fc7-213">Übereinstimmung mit null oder mehr Wortzeichen, aber so wenigen Zeichen wie möglich.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-213">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`\b`|<span data-ttu-id="d4fc7-214">An einer Wortgrenze beenden.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-214">End on a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-lazy-match-"></a><span data-ttu-id="d4fc7-215">Übereinstimmung mit einem oder mehr Vorkommen (träger Abgleich): +?</span><span class="sxs-lookup"><span data-stu-id="d4fc7-215">Match One or More Times (Lazy Match): +?</span></span>  
 <span data-ttu-id="d4fc7-216">Der `+?`-Quantifizierer gleicht das vorangehende Element einmal oder häufiger ab, jedoch so wenige Male wie möglich.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-216">The `+?` quantifier matches the preceding element one or more times, but as few times as possible.</span></span> <span data-ttu-id="d4fc7-217">Dies ist das träge Gegenstück zum gierigen Quantifizierer `+`.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-217">It is the lazy counterpart of the greedy quantifier `+`.</span></span>  
  
 <span data-ttu-id="d4fc7-218">Beispielsweise gleicht der reguläre Ausdruck `\b\w+?\b` ein oder mehr Zeichen ab, die durch Wortgrenzen getrennt sind.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-218">For example, the regular expression `\b\w+?\b` matches one or more characters separated by word boundaries.</span></span> <span data-ttu-id="d4fc7-219">Im folgenden Beispiel wird dieser reguläre Ausdruck veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-219">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#8](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#8)]
 [!code-vb[RegularExpressions.Quantifiers#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#8)]  
  
### <a name="match-zero-or-one-time-lazy-match-"></a><span data-ttu-id="d4fc7-220">Übereinstimmung mit null oder einem Vorkommen (träger Abgleich): ??</span><span class="sxs-lookup"><span data-stu-id="d4fc7-220">Match Zero or One Time (Lazy Match): ??</span></span>  
 <span data-ttu-id="d4fc7-221">Der `??`-Quantifizierer gleicht das vorangehende Element null- oder einmal ab, jedoch so wenige Male wie möglich.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-221">The `??` quantifier matches the preceding element zero or one time, but as few times as possible.</span></span> <span data-ttu-id="d4fc7-222">Dies ist das träge Gegenstück zum gierigen Quantifizierer `?`.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-222">It is the lazy counterpart of the greedy quantifier `?`.</span></span>  
  
 <span data-ttu-id="d4fc7-223">Beispielsweise versucht der reguläre Ausdruck `^\s*(System.)??Console.Write(Line)??\(??`, die Zeichenfolgen „Console.Write“ oder „Console.WriteLine“ abzugleichen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-223">For example, the regular expression `^\s*(System.)??Console.Write(Line)??\(??` attempts to match the strings "Console.Write" or "Console.WriteLine".</span></span> <span data-ttu-id="d4fc7-224">Die Zeichenfolge kann auch „System.“</span><span class="sxs-lookup"><span data-stu-id="d4fc7-224">The string can also include "System."</span></span> <span data-ttu-id="d4fc7-225">vor „Console“ enthalten und von einer öffnenden Klammer gefolgt sein.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-225">before "Console", and it can be followed by an opening parenthesis.</span></span> <span data-ttu-id="d4fc7-226">Die Zeichenfolge muss sich am Anfang einer Zeile befinden, ihr kann jedoch ein Leerzeichen vorangestellt sein.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-226">The string must be at the beginning of a line, although it can be preceded by white space.</span></span> <span data-ttu-id="d4fc7-227">Im folgenden Beispiel wird dieser reguläre Ausdruck veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-227">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#9](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#9)]
 [!code-vb[RegularExpressions.Quantifiers#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#9)]  
  
 <span data-ttu-id="d4fc7-228">Das Muster für reguläre Ausdrücke ist wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-228">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d4fc7-229">Muster</span><span class="sxs-lookup"><span data-stu-id="d4fc7-229">Pattern</span></span>|<span data-ttu-id="d4fc7-230">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="d4fc7-230">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="d4fc7-231">Übereinstimmung mit dem Beginn des Eingabestreams.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-231">Match the start of the input stream.</span></span>|  
|`\s*`|<span data-ttu-id="d4fc7-232">Sucht nach 0 (null) oder mehr Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-232">Match zero or more white-space characters.</span></span>|  
|`(System.)??`|<span data-ttu-id="d4fc7-233">Übereinstimmung mit null oder einem Vorkommen der Zeichenfolge „System.“.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-233">Match zero or one occurrence of the string "System.".</span></span>|  
|`Console.Write`|<span data-ttu-id="d4fc7-234">Übereinstimmung mit der Zeichenfolge „Console.Write“.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-234">Match the string "Console.Write".</span></span>|  
|`(Line)??`|<span data-ttu-id="d4fc7-235">Übereinstimmung mit null oder einem Vorkommen der Zeichenfolge „Line“.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-235">Match zero or one occurrence of the string "Line".</span></span>|  
|`\(??`|<span data-ttu-id="d4fc7-236">Übereinstimmung mit null oder einem Vorkommen der öffnenden Klammer.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-236">Match zero or one occurrence of the opening parenthesis.</span></span>|  
  
### <a name="match-exactly-n-times-lazy-match-n"></a><span data-ttu-id="d4fc7-237">Übereinstimmung mit genau n Vorkommen (träger Abgleich): {n}?</span><span class="sxs-lookup"><span data-stu-id="d4fc7-237">Match Exactly n Times (Lazy Match): {n}?</span></span>  
 <span data-ttu-id="d4fc7-238">Der `{`*n*`}?`-Quantifizierer gleicht das vorangehende Element genau `n` Mal ab, wobei *n* für eine beliebige ganze Zahl steht.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-238">The `{`*n*`}?` quantifier matches the preceding element exactly `n` times, where *n* is any integer.</span></span> <span data-ttu-id="d4fc7-239">Dies ist das träge Gegenstück zum gierigen Quantifizierer `{`*n*`}`.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-239">It is the lazy counterpart of the greedy quantifier `{`*n*`}`.</span></span>  
  
 <span data-ttu-id="d4fc7-240">Im folgenden Beispiel wird der reguläre Ausdruck `\b(\w{3,}?\.){2}?\w{3,}?\b` verwendet, um die Adresse einer Website zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-240">In the following example, the regular expression `\b(\w{3,}?\.){2}?\w{3,}?\b` is used to identify a Web site address.</span></span> <span data-ttu-id="d4fc7-241">Beachten Sie, dass „www.microsoft.com“ und „msdn.microsoft.com“ abgeglichen werden, aber nicht „mywebsite“ oder „mycompany.com“.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-241">Note that it matches "www.microsoft.com" and "msdn.microsoft.com", but does not match "mywebsite" or "mycompany.com".</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#10](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#10)]
 [!code-vb[RegularExpressions.Quantifiers#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#10)]  
  
 <span data-ttu-id="d4fc7-242">Das Muster für reguläre Ausdrücke ist wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-242">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d4fc7-243">Muster</span><span class="sxs-lookup"><span data-stu-id="d4fc7-243">Pattern</span></span>|<span data-ttu-id="d4fc7-244">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="d4fc7-244">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d4fc7-245">An einer Wortgrenze beginnen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-245">Start at a word boundary.</span></span>|  
|`(\w{3,}?\.)`|<span data-ttu-id="d4fc7-246">Übereinstimmung mit mindestens 3 Wortzeichen, aber so wenigen Zeichen wie möglich, gefolgt von einem Punktzeichen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-246">Match at least 3 word characters, but as few characters as possible, followed by a dot or period character.</span></span> <span data-ttu-id="d4fc7-247">Dies ist die erste Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-247">This is the first capturing group.</span></span>|  
|`(\w{3,}?\.){2}?`|<span data-ttu-id="d4fc7-248">Übereinstimmung mit zwei Vorkommen im Muster in der ersten Gruppe, jedoch so wenige Male wie möglich.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-248">Match the pattern in the first group two times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="d4fc7-249">Beendet den Vergleich an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-249">End the match on a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-lazy-match-n"></a><span data-ttu-id="d4fc7-250">Übereinstimmung mit mindestens n Vorkommen (träger Abgleich): {n,}?</span><span class="sxs-lookup"><span data-stu-id="d4fc7-250">Match at Least n Times (Lazy Match): {n,}?</span></span>  
 <span data-ttu-id="d4fc7-251">Der `{`*n*`,}?`-Qualifizierer gleicht das vorangehende Element mindestens `n` Mal ab, jedoch so wenige Male wie möglich, wobei *n* für einen beliebigen Integer steht.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-251">The `{`*n*`,}?` quantifier matches the preceding element at least `n` times, where *n* is any integer, but as few times as possible.</span></span> <span data-ttu-id="d4fc7-252">Dies ist das träge Gegenstück zum gierigen Quantifizierer `{`*n*`,}`.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-252">It is the lazy counterpart of the greedy quantifier `{`*n*`,}`.</span></span>  
  
 <span data-ttu-id="d4fc7-253">Eine Veranschaulichung finden Sie im vorherigen Abschnitt im Beispiel für den `{`*n*`}?`-Quantifizierer.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-253">See the example for the `{`*n*`}?` quantifier in the previous section for an illustration.</span></span> <span data-ttu-id="d4fc7-254">Der reguläre Ausdruck in diesem Beispiel verwendet den `{`*n*`,}`-Quantifizierer, um eine Zeichenfolge abzugleichen, die mindestens drei Zeichen umfasst, gefolgt von einem Punkt.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-254">The regular expression in that example uses the `{`*n*`,}` quantifier to match a string that has at least three characters followed by a period.</span></span>  
  
### <a name="match-between-n-and-m-times-lazy-match-nm"></a><span data-ttu-id="d4fc7-255">Übereinstimmung mit n bis m Vorkommen (träger Abgleich): {n,m}?</span><span class="sxs-lookup"><span data-stu-id="d4fc7-255">Match Between n and m Times (Lazy Match): {n,m}?</span></span>  
 <span data-ttu-id="d4fc7-256">Der `{`*n*`,`*m*`}?`-Quantifizierer gleicht das vorangehende Element `n` bis `m` Mal ab, jedoch so wenige Male wie möglich, wobei *n* und *m* Integerwerte sind.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-256">The `{`*n*`,`*m*`}?` quantifier matches the preceding element between `n` and `m` times, where *n* and *m* are integers, but as few times as possible.</span></span> <span data-ttu-id="d4fc7-257">Dies ist das träge Gegenstück zum gierigen Quantifizierer `{`*n*`,`*m*`}`.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-257">It is the lazy counterpart of the greedy quantifier `{`*n*`,`*m*`}`.</span></span>  
  
 <span data-ttu-id="d4fc7-258">Im folgenden Beispiel gleicht der reguläre Ausdruck `\b[A-Z](\w*?\s*?){1,10}[.!?]` Sätze ab, die zwischen ein und zehn Wörter enthalten.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-258">In the following example, the regular expression `\b[A-Z](\w*?\s*?){1,10}[.!?]` matches sentences that contain between one and ten words.</span></span> <span data-ttu-id="d4fc7-259">Er gleicht alle Sätze in der Eingabezeichenfolge ab mit Ausnahme eines Satzes, der 18 Wörter enthält.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-259">It matches all the sentences in the input string except for one sentence that contains 18 words.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#12](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#12)]
 [!code-vb[RegularExpressions.Quantifiers#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#12)]  
  
 <span data-ttu-id="d4fc7-260">Das Muster für reguläre Ausdrücke ist wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-260">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d4fc7-261">Muster</span><span class="sxs-lookup"><span data-stu-id="d4fc7-261">Pattern</span></span>|<span data-ttu-id="d4fc7-262">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="d4fc7-262">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="d4fc7-263">An einer Wortgrenze beginnen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-263">Start at a word boundary.</span></span>|  
|`[A-Z]`|<span data-ttu-id="d4fc7-264">Übereinstimmung mit einem Großbuchstaben von A bis Z.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-264">Match an uppercase character from A to Z.</span></span>|  
|`(\w*?\s*?)`|<span data-ttu-id="d4fc7-265">Übereinstimmung mit 0 (null) oder mehr Wortzeichen, gefolgt von einem oder mehreren Leerzeichen, jedoch so wenige wie möglich.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-265">Match zero or more word characters, followed by one or more white-space characters, but as few times as possible.</span></span> <span data-ttu-id="d4fc7-266">Dies ist die erste Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-266">This is the first capture group.</span></span>|  
|`{1,10}`|<span data-ttu-id="d4fc7-267">Übereinstimmung mit dem vorhergehenden Muster zwischen 1- und 10-mal.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-267">Match the previous pattern between 1 and 10 times.</span></span>|  
|`[.!?]`|<span data-ttu-id="d4fc7-268">Übereinstimmung mit einem der Interpunktionszeichen „.“, „!“ oder „?“.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-268">Match any one of the punctuation characters ".", "!", or "?".</span></span>|  
  
<a name="Greedy"></a>
## <a name="greedy-and-lazy-quantifiers"></a><span data-ttu-id="d4fc7-269">Gierige und träge Quantifizierer</span><span class="sxs-lookup"><span data-stu-id="d4fc7-269">Greedy and Lazy Quantifiers</span></span>  
 <span data-ttu-id="d4fc7-270">Eine Reihe von Quantifizierern gibt es in zwei Versionen:</span><span class="sxs-lookup"><span data-stu-id="d4fc7-270">A number of the quantifiers have two versions:</span></span>  
  
- <span data-ttu-id="d4fc7-271">Eine gierige Version.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-271">A greedy version.</span></span>  
  
     <span data-ttu-id="d4fc7-272">Ein gieriger Quantifizierer versucht, ein Element so oft wie möglich abzugleichen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-272">A greedy quantifier tries to match an element as many times as possible.</span></span>  
  
- <span data-ttu-id="d4fc7-273">Eine nicht gierige (oder träge) Version.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-273">A non-greedy (or lazy) version.</span></span>  
  
     <span data-ttu-id="d4fc7-274">Ein nicht gieriger Quantifizierer versucht, ein Element so selten wie möglich abzugleichen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-274">A non-greedy quantifier tries to match an element as few times as possible.</span></span> <span data-ttu-id="d4fc7-275">Sie können einen gierigen Quantifizierer in einen trägen Quantifizierer umwandeln, indem Sie einfach ein `?` hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-275">You can turn a greedy quantifier into a lazy quantifier by simply adding a `?`.</span></span>  
  
 <span data-ttu-id="d4fc7-276">Nehmen Sie einen einfachen regulären Ausdruck, der die letzten vier Ziffern aus einer Zeichenfolge mit Zahlen extrahieren soll, beispielsweise aus einer Kreditkartennummer.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-276">Consider a simple regular expression that is intended to extract the last four digits from a string of numbers such as a credit card number.</span></span> <span data-ttu-id="d4fc7-277">Die Version des regulären Ausdrucks, die den gierigen `*`-Quantifizierer verwendet, lautet `\b.*([0-9]{4})\b`.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-277">The version of the regular expression that uses the `*` greedy quantifier is `\b.*([0-9]{4})\b`.</span></span> <span data-ttu-id="d4fc7-278">Wenn eine Zeichenfolge zwei Zahlen enthält, gleicht dieser reguläre Ausdruck jedoch nur die letzten vier Ziffern der zweiten Zahl ab, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-278">However, if a string contains two numbers, this regular expression matches the last four digits of the second number only, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#1)]  
  
 <span data-ttu-id="d4fc7-279">Der reguläre Ausdruck kann die erste Zahl nicht abgleichen, da der `*`-Quantifizierer versucht, das vorherige Element so oft wie möglich in der gesamten Zeichenfolge abzugleichen. Daher wird die Übereinstimmung am Ende der Zeichenfolge gefunden.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-279">The regular expression fails to match the first number because the `*` quantifier tries to match the previous element as many times as possible in the entire string, and so it finds its match at the end of the string.</span></span>  
  
 <span data-ttu-id="d4fc7-280">Dies entspricht nicht dem gewünschten Verhalten.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-280">This is not the desired behavior.</span></span> <span data-ttu-id="d4fc7-281">Stattdessen können Sie den `*?`trägen Quantifizierer verwenden, um Ziffern aus beiden Zahlen zu extrahieren, wie im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-281">Instead, you can use the `*?`lazy quantifier to extract digits from both numbers, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#2)]  
  
 <span data-ttu-id="d4fc7-282">In den meisten Fällen werden von regulären Ausdrücken mit gierigen und trägen Quantifizierern die gleichen Übereinstimmungen zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-282">In most cases, regular expressions with greedy and lazy quantifiers return the same matches.</span></span> <span data-ttu-id="d4fc7-283">Im Allgemeinen geben sie unterschiedliche Ergebnisse zurück, wenn sie mit dem Platzhaltermetazeichen (`.`) verwendet werden, das jedes beliebige Zeichen abgleicht.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-283">They most commonly return different results when they are used with the wildcard (`.`) metacharacter, which matches any character.</span></span>  
  
## <a name="quantifiers-and-empty-matches"></a><span data-ttu-id="d4fc7-284">Quantifizierer und leere Übereinstimmungen</span><span class="sxs-lookup"><span data-stu-id="d4fc7-284">Quantifiers and Empty Matches</span></span>  
 <span data-ttu-id="d4fc7-285">Die Quantifizierer `*`, `+` und `{`*n*`,`*m*`}` sowie ihre trägen Gegenstücke werden nach einer leeren Übereinstimmung nie wiederholt, wenn die Mindestanzahl von Erfassungen gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-285">The quantifiers `*`, `+`, and `{`*n*`,`*m*`}` and their lazy counterparts never repeat after an empty match when the minimum number of captures has been found.</span></span> <span data-ttu-id="d4fc7-286">Diese Regel verhindert, dass Quantifizierer bei leeren Teilausdruckübereinstimmungen in Endlosschleifen geraten, wenn die maximale Anzahl möglicher Gruppenerfassungen unendlich oder nahezu unendlich ist.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-286">This rule prevents quantifiers from entering infinite loops on empty subexpression matches when the maximum number of possible group captures is infinite or near infinite.</span></span>  
  
 <span data-ttu-id="d4fc7-287">Der folgende Code zeigt z.B. das Ergebnis eines Aufrufs der <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType>-Methode mit dem Muster für reguläre Ausdrücke `(a?)*`, bei dem null oder ein Zeichen „a“ nullmal oder häufiger abgeglichen wird.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-287">For example, the following code shows the result of a call to the <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> method with the regular expression pattern `(a?)*`, which matches zero or one "a" character zero or more times.</span></span> <span data-ttu-id="d4fc7-288">Beachten Sie, dass die einzelne Erfassungsgruppe jedes „a“ sowie <xref:System.String.Empty?displayProperty=nameWithType> abgleicht, dass es aber keine zweite leere Übereinstimmung gibt, weil der Quantifizierer nach der ersten leeren Übereinstimmung nicht mehr wiederholt wird.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-288">Note that the single capturing group captures each "a" as well as <xref:System.String.Empty?displayProperty=nameWithType>, but that there is no second empty match, because the first empty match causes the quantifier to stop repeating.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch1.vb#1)]  
  
 <span data-ttu-id="d4fc7-289">Um den praktischen Unterschied zwischen einer Erfassungsgruppe, die eine Mindest- und eine Höchstzahl von Erfassungen definiert, und einer Erfassungsgruppe zu sehen, die eine feste Anzahl von Erfassungen definiert, betrachten Sie die Muster für reguläre Ausdrücke `(a\1|(?(1)\1)){0,2}` und `(a\1|(?(1)\1)){2}`.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-289">To see the practical difference between a capturing group that defines a minimum and a maximum number of captures and one that defines a fixed number of captures, consider the regular expression patterns `(a\1|(?(1)\1)){0,2}` and `(a\1|(?(1)\1)){2}`.</span></span> <span data-ttu-id="d4fc7-290">Beide reguläre Ausdrücke bestehen aus einer einzelnen Erfassungsgruppe, die wie in der folgenden Tabelle gezeigt definiert ist.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-290">Both regular expressions consist of a single capturing group, which is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="d4fc7-291">Muster</span><span class="sxs-lookup"><span data-stu-id="d4fc7-291">Pattern</span></span>|<span data-ttu-id="d4fc7-292">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="d4fc7-292">Description</span></span>|  
|-------------|-----------------|  
|`(a\1`|<span data-ttu-id="d4fc7-293">Entweder „a“ zusammen mit dem Wert der ersten Erfassungsgruppe abgleichen...</span><span class="sxs-lookup"><span data-stu-id="d4fc7-293">Either match "a" along with the value of the first captured group …</span></span>|  
|<code>&#124;(?(1)</code>|<span data-ttu-id="d4fc7-294">…</span><span class="sxs-lookup"><span data-stu-id="d4fc7-294">…</span></span> <span data-ttu-id="d4fc7-295">oder testen, ob die erste Erfassungsgruppe definiert wurde.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-295">or test whether the first captured group has been defined.</span></span> <span data-ttu-id="d4fc7-296">(Beachten Sie, dass das `(?(1)`-Konstrukt keine Erfassungsgruppe definiert.)</span><span class="sxs-lookup"><span data-stu-id="d4fc7-296">(Note that the `(?(1)` construct does not define a capturing group.)</span></span>|  
|`\1))`|<span data-ttu-id="d4fc7-297">Wenn die erste Erfassungsgruppe vorhanden ist, deren Wert abgleichen.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-297">If the first captured group exists, match its value.</span></span> <span data-ttu-id="d4fc7-298">Wenn die Gruppe nicht vorhanden ist, gleicht die Gruppe <xref:System.String.Empty?displayProperty=nameWithType> ab.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-298">If the group does not exist, the group will match <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="d4fc7-299">Der erste reguläre Ausdruck versucht, dieses Muster zwischen null- und zweimal abzugleichen; der zweite Ausdruck genau zweimal.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-299">The first regular expression tries to match this pattern between zero and two times; the second, exactly two times.</span></span> <span data-ttu-id="d4fc7-300">Da das erste Muster die minimale Anzahl von Erfassungen mit der ersten Erfassung von <xref:System.String.Empty?displayProperty=nameWithType> erreicht, wird es nie wiederholt, um `a\1` abzugleichen. Der `{0,2}`-Quantifizierer erlaubt nur leere Übereinstimmungen in der letzten Iteration.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-300">Because the first pattern reaches its minimum number of captures with its first capture of <xref:System.String.Empty?displayProperty=nameWithType>, it never repeats to try to match `a\1`; the `{0,2}` quantifier allows only empty matches in the last iteration.</span></span> <span data-ttu-id="d4fc7-301">Im Gegensatz dazu gleicht der zweite reguläre Ausdruck „a“ ab, weil `a\1` ein zweites Mal ausgewertet wird; die Mindestanzahl von Iterationen (2) zwingt die Engine nach einer leeren Übereinstimmung zur Wiederholung.</span><span class="sxs-lookup"><span data-stu-id="d4fc7-301">In contrast, the second regular expression does match "a" because it evaluates `a\1` a second time; the minimum number of iterations, 2, forces the engine to repeat after an empty match.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch4.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch4.vb#2)]  
  
## <a name="see-also"></a><span data-ttu-id="d4fc7-302">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="d4fc7-302">See also</span></span>

- [<span data-ttu-id="d4fc7-303">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</span><span class="sxs-lookup"><span data-stu-id="d4fc7-303">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [<span data-ttu-id="d4fc7-304">Backtracking</span><span class="sxs-lookup"><span data-stu-id="d4fc7-304">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
