---
title: Gruppierungskonstrukte in regulären Ausdrücken
description: Erfahren Sie, wie Sie Gruppierungskonstrukte in .NET verwenden. Gruppierungskonstrukte grenzen Teilausdrücke eines regulären Ausdrucks ab und erfassen Teilzeichenfolgen einer Eingabezeichenfolge.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lookbehinds
- regular expressions, grouping constructs
- lookaheads
- .NET regular expressions, grouping constructs
- constructs, grouping
- grouping constructs
ms.assetid: 0fc18634-f590-4062-8d5c-f0b71abe405b
ms.openlocfilehash: 62de6dc3b6276aab4667c719033ee3b66928ea2c
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/24/2020
ms.locfileid: "95734373"
---
# <a name="grouping-constructs-in-regular-expressions"></a><span data-ttu-id="49cac-104">Gruppierungskonstrukte in regulären Ausdrücken</span><span class="sxs-lookup"><span data-stu-id="49cac-104">Grouping Constructs in Regular Expressions</span></span>

<span data-ttu-id="49cac-105">Gruppierungskonstrukte grenzen die Teilausdrücke eines regulären Ausdrucks ab und zeichnen die Teilzeichenfolgen einer Eingabezeichenfolge auf.</span><span class="sxs-lookup"><span data-stu-id="49cac-105">Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</span></span> <span data-ttu-id="49cac-106">Mit Gruppierungskonstrukten können Sie folgende Schritte ausführen:</span><span class="sxs-lookup"><span data-stu-id="49cac-106">You can use grouping constructs to do the following:</span></span>  
  
- <span data-ttu-id="49cac-107">Finden Sie eine Entsprechung für einen Teilausdruck, der in der Eingabezeichenfolge wiederholt wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-107">Match a subexpression that is repeated in the input string.</span></span>  
  
- <span data-ttu-id="49cac-108">Wenden Sie einen Quantifizierer auf einen Teilausdruck an, der über mehrere reguläre Ausdruckssprachelemente verfügt.</span><span class="sxs-lookup"><span data-stu-id="49cac-108">Apply a quantifier to a subexpression that has multiple regular expression language elements.</span></span> <span data-ttu-id="49cac-109">Weitere Informationen zu Quantifizierern finden Sie unter [Quantifiers](quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="49cac-109">For more information about quantifiers, see [Quantifiers](quantifiers-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="49cac-110">Schließen Sie einen Teilausdruck in die Zeichenfolge ein, die von den <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> - und <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> -Methoden zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-110">Include a subexpression in the string that is returned by the <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> methods.</span></span>  
  
- <span data-ttu-id="49cac-111">Rufen Sie einzelne Teilausdrücke aus der <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> -Eigenschaft ab, und verarbeiten Sie sie getrennt vom entsprechenden Text als Ganzes.</span><span class="sxs-lookup"><span data-stu-id="49cac-111">Retrieve individual subexpressions from the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property and process them separately from the matched text as a whole.</span></span>  
  
 <span data-ttu-id="49cac-112">Die folgende Tabelle führt die Gruppierungskonstrukte auf, die von der .NET-Engine für reguläre Ausdrücke unterstützt werden, und gibt an, ob sie erfassend oder nicht erfassend sind.</span><span class="sxs-lookup"><span data-stu-id="49cac-112">The following table lists the grouping constructs supported by the .NET regular expression engine and indicates whether they are capturing or non-capturing.</span></span>  
  
|<span data-ttu-id="49cac-113">Gruppierungskonstrukt</span><span class="sxs-lookup"><span data-stu-id="49cac-113">Grouping construct</span></span>|<span data-ttu-id="49cac-114">Erfassend oder nicht erfassend</span><span class="sxs-lookup"><span data-stu-id="49cac-114">Capturing or noncapturing</span></span>|  
|------------------------|-------------------------------|  
|[<span data-ttu-id="49cac-115">Übereinstimmende Teilausdrücke</span><span class="sxs-lookup"><span data-stu-id="49cac-115">Matched subexpressions</span></span>](#matched_subexpression)|<span data-ttu-id="49cac-116">Wird erfasst</span><span class="sxs-lookup"><span data-stu-id="49cac-116">Capturing</span></span>|  
|[<span data-ttu-id="49cac-117">Benannte übereinstimmende Teilausdrücke</span><span class="sxs-lookup"><span data-stu-id="49cac-117">Named matched subexpressions</span></span>](#named_matched_subexpression)|<span data-ttu-id="49cac-118">Wird erfasst</span><span class="sxs-lookup"><span data-stu-id="49cac-118">Capturing</span></span>|  
|[<span data-ttu-id="49cac-119">Ausgleichen von Gruppendefinitionen</span><span class="sxs-lookup"><span data-stu-id="49cac-119">Balancing group definitions</span></span>](#balancing_group_definition)|<span data-ttu-id="49cac-120">Wird erfasst</span><span class="sxs-lookup"><span data-stu-id="49cac-120">Capturing</span></span>|  
|[<span data-ttu-id="49cac-121">Nicht erfassende Gruppen</span><span class="sxs-lookup"><span data-stu-id="49cac-121">Noncapturing groups</span></span>](#noncapturing_group)|<span data-ttu-id="49cac-122">Nicht erfassend</span><span class="sxs-lookup"><span data-stu-id="49cac-122">Noncapturing</span></span>|  
|[<span data-ttu-id="49cac-123">Gruppenoptionen</span><span class="sxs-lookup"><span data-stu-id="49cac-123">Group options</span></span>](#group_options)|<span data-ttu-id="49cac-124">Nicht erfassend</span><span class="sxs-lookup"><span data-stu-id="49cac-124">Noncapturing</span></span>|  
|[<span data-ttu-id="49cac-125">Positive Lookaheadassertionen mit einer Breite von Null</span><span class="sxs-lookup"><span data-stu-id="49cac-125">Zero-width positive lookahead assertions</span></span>](#zerowidth_positive_lookahead_assertion)|<span data-ttu-id="49cac-126">Nicht erfassend</span><span class="sxs-lookup"><span data-stu-id="49cac-126">Noncapturing</span></span>|  
|[<span data-ttu-id="49cac-127">Negative Lookaheadassertionen mit einer Breite von Null</span><span class="sxs-lookup"><span data-stu-id="49cac-127">Zero-width negative lookahead assertions</span></span>](#zerowidth_negative_lookahead_assertion)|<span data-ttu-id="49cac-128">Nicht erfassend</span><span class="sxs-lookup"><span data-stu-id="49cac-128">Noncapturing</span></span>|  
|[<span data-ttu-id="49cac-129">Positive Lookbehindassertionen mit einer Breite von Null</span><span class="sxs-lookup"><span data-stu-id="49cac-129">Zero-width positive lookbehind assertions</span></span>](#zerowidth_positive_lookbehind_assertion)|<span data-ttu-id="49cac-130">Nicht erfassend</span><span class="sxs-lookup"><span data-stu-id="49cac-130">Noncapturing</span></span>|  
|[<span data-ttu-id="49cac-131">Negative Lookbehindassertionen mit einer Breite von Null</span><span class="sxs-lookup"><span data-stu-id="49cac-131">Zero-width negative lookbehind assertions</span></span>](#zerowidth_negative_lookbehind_assertion)|<span data-ttu-id="49cac-132">Nicht erfassend</span><span class="sxs-lookup"><span data-stu-id="49cac-132">Noncapturing</span></span>|  
|[<span data-ttu-id="49cac-133">Atomische Gruppen</span><span class="sxs-lookup"><span data-stu-id="49cac-133">Atomic groups</span></span>](#atomic_groups)|<span data-ttu-id="49cac-134">Nicht erfassend</span><span class="sxs-lookup"><span data-stu-id="49cac-134">Noncapturing</span></span>|  
  
 <span data-ttu-id="49cac-135">Weitere Informationen zu Gruppen und dem Objektmodell für reguläre Ausdrücke finden Sie unter [Gruppieren von Konstrukten und Objekten für reguläre Ausdrücke](#Objects).</span><span class="sxs-lookup"><span data-stu-id="49cac-135">For information on groups and the regular expression object model, see [Grouping constructs and regular expression objects](#Objects).</span></span>  
  
<a name="matched_subexpression"></a>

## <a name="matched-subexpressions"></a><span data-ttu-id="49cac-136">Übereinstimmende Teilausdrücke</span><span class="sxs-lookup"><span data-stu-id="49cac-136">Matched Subexpressions</span></span>  

 <span data-ttu-id="49cac-137">Das folgende Gruppierungskonstrukt erfasst einen übereinstimmenden Teilausdruck:</span><span class="sxs-lookup"><span data-stu-id="49cac-137">The following grouping construct captures a matched subexpression:</span></span>  
  
 <span data-ttu-id="49cac-138">`(` *Teilausdruck* `)`</span><span class="sxs-lookup"><span data-stu-id="49cac-138">`(` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="49cac-139">wobei *Teilausdruck* ein beliebiges gültiges Muster eines regulären Ausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-139">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="49cac-140">Erfassungen, die Klammern verwenden, werden automatisch von links nach rechts und mit eins beginnend auf Grundlage der Reihenfolge der öffnenden runden Klammern im regulären Ausdruck aufgezählt.</span><span class="sxs-lookup"><span data-stu-id="49cac-140">Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</span></span> <span data-ttu-id="49cac-141">Die Erfassung, die mit 0 gekennzeichnet wird, ist der Text, dem das gesamte Muster für den regulären Ausdruck entspricht.</span><span class="sxs-lookup"><span data-stu-id="49cac-141">The capture that is numbered zero is the text matched by the entire regular expression pattern.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="49cac-142">Standardmäßig erfasst das Sprachelement `(`*Teilausdruck*`)` den übereinstimmenden Teilausdruck.</span><span class="sxs-lookup"><span data-stu-id="49cac-142">By default, the `(`*subexpression*`)` language element captures the matched subexpression.</span></span> <span data-ttu-id="49cac-143">Wenn der <xref:System.Text.RegularExpressions.RegexOptions> -Parameter einer übereinstimmenden Methode für ein Muster eines regulären Ausdrucks das <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> -Flag enthält oder wenn die `n` -Option auf diesen Teilausdruck angewendet wird (siehe weiter unten in diesem Thema [Gruppenoptionen](#group_options) ), wird der übereinstimmende Teilausdruck jedoch nicht erfasst.</span><span class="sxs-lookup"><span data-stu-id="49cac-143">But if the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the matched subexpression is not captured.</span></span>  
  
 <span data-ttu-id="49cac-144">Für den Zugriff auf erfasste Gruppen gibt es vier Möglichkeiten:</span><span class="sxs-lookup"><span data-stu-id="49cac-144">You can access captured groups in four ways:</span></span>  
  
- <span data-ttu-id="49cac-145">Indem das Rückverweiskonstrukt im regulären Ausdruck verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-145">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="49cac-146">Auf den übereinstimmenden Teilausdruck wird im gleichen regulären Ausdruck mit der Syntax `\`*number* verwiesen, wobei *number* die Ordinalzahl des erfassten Teilausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-146">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="49cac-147">Indem das benannte Rückverweiskonstrukt im regulären Ausdruck verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-147">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="49cac-148">Auf den übereinstimmenden Teilausdruck wird im gleichen regulären Ausdruck mit der Syntax `\k<`*name*`>`verwiesen, wobei *name* der Name einer Erfassungsgruppe ist, oder mit `\k<`*number*`>`verwiesen, wobei *number* die Ordinalzahl einer Erfassungsgruppe ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-148">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of a capturing group, or `\k<`*number*`>`, where *number* is the ordinal number of a capturing group.</span></span> <span data-ttu-id="49cac-149">Eine Erfassungsgruppe weist einen Standardnamen auf, der mit der zugehörigen Ordinalzahl identisch ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-149">A capturing group has a default name that is identical to its ordinal number.</span></span> <span data-ttu-id="49cac-150">Weitere Informationen finden Sie unter [Benannte übereinstimmende Teilausdrücke](#named_matched_subexpression) weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="49cac-150">For more information, see [Named matched subexpressions](#named_matched_subexpression) later in this topic.</span></span>  
  
- <span data-ttu-id="49cac-151">Mit der Ersatzsequenz `$`*number* in einem <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> - oder <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> -Methodenaufruf, wobei *number* die Ordinalzahl des erfassten Teilausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-151">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="49cac-152">Programmgesteuert durch die Verwendung des <xref:System.Text.RegularExpressions.GroupCollection> -Objekts, das von der <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> -Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-152">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="49cac-153">Der Member auf der Nullposition in der Auflistung stellt die gesamte Übereinstimmung für einen regulären Ausdruck dar.</span><span class="sxs-lookup"><span data-stu-id="49cac-153">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="49cac-154">Jeder nachfolgende Member stellt einen übereinstimmenden Teilausdruck dar.</span><span class="sxs-lookup"><span data-stu-id="49cac-154">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="49cac-155">Weitere Informationen finden Sie im Abschnitt [Grouping Constructs and Regular Expression Objects](#Objects) .</span><span class="sxs-lookup"><span data-stu-id="49cac-155">For more information, see the [Grouping Constructs and Regular Expression Objects](#Objects) section.</span></span>  
  
 <span data-ttu-id="49cac-156">Im folgenden Beispiel wird ein regulärer Ausdruck veranschaulicht, der doppelte Wörter im Text identifiziert.</span><span class="sxs-lookup"><span data-stu-id="49cac-156">The following example illustrates a regular expression that identifies duplicated words in text.</span></span> <span data-ttu-id="49cac-157">Die zwei Erfassungsgruppen des Musters eines regulären Ausdrucks stellen die zwei Instanzen des doppelten Worts dar.</span><span class="sxs-lookup"><span data-stu-id="49cac-157">The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</span></span> <span data-ttu-id="49cac-158">Die zweite Instanz wird erfasst, um die Anfangsposition in der Eingabezeichenfolge zu melden.</span><span class="sxs-lookup"><span data-stu-id="49cac-158">The second instance is captured to report its starting position in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping1.cs#1)]
 [!code-vb[RegularExpressions.Language.Grouping#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping1.vb#1)]  
  
 <span data-ttu-id="49cac-159">Das Muster für den reguläre Ausdruck lautet folgendermaßen:</span><span class="sxs-lookup"><span data-stu-id="49cac-159">The regular expression pattern is the following:</span></span>  
  
`(\w+)\s(\1)\W`  
  
 <span data-ttu-id="49cac-160">Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-160">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="49cac-161">Muster</span><span class="sxs-lookup"><span data-stu-id="49cac-161">Pattern</span></span>|<span data-ttu-id="49cac-162">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="49cac-162">Description</span></span>|  
|-------------|-----------------|  
|`(\w+)`|<span data-ttu-id="49cac-163">Übereinstimmung mit mindestens einem Wortzeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-163">Match one or more word characters.</span></span> <span data-ttu-id="49cac-164">Dies ist die erste Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-164">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="49cac-165">Entsprechung für ein Leerraumzeichen finden.</span><span class="sxs-lookup"><span data-stu-id="49cac-165">Match a white-space character.</span></span>|  
|`(\1)`|<span data-ttu-id="49cac-166">Suchen Sie nach einer Entsprechung für die Zeichenfolge in der ersten erfassten Gruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-166">Match the string in the first captured group.</span></span> <span data-ttu-id="49cac-167">Dies ist die zweite Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-167">This is the second capturing group.</span></span> <span data-ttu-id="49cac-168">Im Beispiel wird sie einer erfassten Gruppe zugewiesen, damit die Anfangsposition des doppelten Worts von der `Match.Index` -Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-168">The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the `Match.Index` property.</span></span>|  
|`\W`|<span data-ttu-id="49cac-169">Finden Sie eine Entsprechung für ein Nichtwortzeichen, einschließlich Leerzeichen und Interpunktion.</span><span class="sxs-lookup"><span data-stu-id="49cac-169">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="49cac-170">Dies verhindert, dass für das Muster eines regulären Ausdrucks eine Entsprechung für ein Wort gefunden wird, das mit dem Wort von der zuerst erfassten Gruppe beginnt.</span><span class="sxs-lookup"><span data-stu-id="49cac-170">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
  
<a name="named_matched_subexpression"></a>

## <a name="named-matched-subexpressions"></a><span data-ttu-id="49cac-171">Benannte übereinstimmende Teilausdrücke</span><span class="sxs-lookup"><span data-stu-id="49cac-171">Named Matched Subexpressions</span></span>  

 <span data-ttu-id="49cac-172">Das folgende Gruppierungskonstrukt erfasst einen übereinstimmenden Teilausdruck und ermöglicht den Zugriff nach Name oder Zahl:</span><span class="sxs-lookup"><span data-stu-id="49cac-172">The following grouping construct captures a matched subexpression and lets you access it by name or by number:</span></span>  
  
`(?<name>subexpression)`  
  
 <span data-ttu-id="49cac-173">oder:</span><span class="sxs-lookup"><span data-stu-id="49cac-173">or:</span></span>  
  
`(?'name'subexpression)`  
  
 <span data-ttu-id="49cac-174">wobei *name* ein gültiger Gruppenname und *subexpression* ein beliebiges gültiges Muster eines regulären Ausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-174">where *name* is a valid group name, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="49cac-175">*name* darf keine Interpunktion enthalten und nicht mit einer Zahl beginnen.</span><span class="sxs-lookup"><span data-stu-id="49cac-175">*name* must not contain any punctuation characters and cannot begin with a number.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="49cac-176">Wenn der <xref:System.Text.RegularExpressions.RegexOptions> -Parameter einer übereinstimmenden Methode für ein Muster eines regulären Ausdrucks das <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> -Flag enthält oder wenn die `n` -Option auf diesen Teilausdruck angewendet wird (siehe weiter unten in diesem Thema [Gruppenoptionen](#group_options) ), besteht die einzige Möglichkeit zur Erfassung eines Teilausdrucks in der expliziten Benennung von Erfassungsgruppen.</span><span class="sxs-lookup"><span data-stu-id="49cac-176">If the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</span></span>  
  
 <span data-ttu-id="49cac-177">Sie können wie folgt auf benannte erfasste Gruppen zugreifen:</span><span class="sxs-lookup"><span data-stu-id="49cac-177">You can access named captured groups in the following ways:</span></span>  
  
- <span data-ttu-id="49cac-178">Indem das benannte Rückverweiskonstrukt im regulären Ausdruck verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-178">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="49cac-179">Auf den übereinstimmenden Teilausdruck wird im gleichen regulären Ausdruck mit der Syntax `\k<`*name*`>`verwiesen, wobei *name* der Name des erfassten Teilausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-179">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="49cac-180">Indem das Rückverweiskonstrukt im regulären Ausdruck verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-180">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="49cac-181">Auf den übereinstimmenden Teilausdruck wird im gleichen regulären Ausdruck mit der Syntax `\`*number* verwiesen, wobei *number* die Ordinalzahl des erfassten Teilausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-181">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span> <span data-ttu-id="49cac-182">Benannte übereinstimmende Teilausdrücke werden hintereinander von links nach rechts nach übereinstimmenden Teilausdrücken nummeriert.</span><span class="sxs-lookup"><span data-stu-id="49cac-182">Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</span></span>  
  
- <span data-ttu-id="49cac-183">Mit der Ersatzsequenz `${`*name*`}` in einem <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> - oder <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> -Methodenaufruf, wobei *name* der Name des erfassten Teilausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-183">By using the `${`*name*`}` replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="49cac-184">Mit der Ersatzsequenz `$`*number* in einem <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType>- oder <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>-Methodenaufruf, wobei *number* die Ordinalzahl des erfassten Teilausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-184">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="49cac-185">Programmgesteuert durch die Verwendung des <xref:System.Text.RegularExpressions.GroupCollection> -Objekts, das von der <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> -Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-185">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="49cac-186">Der Member auf der Nullposition in der Auflistung stellt die gesamte Übereinstimmung für einen regulären Ausdruck dar.</span><span class="sxs-lookup"><span data-stu-id="49cac-186">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="49cac-187">Jeder nachfolgende Member stellt einen übereinstimmenden Teilausdruck dar.</span><span class="sxs-lookup"><span data-stu-id="49cac-187">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="49cac-188">Benannte erfasste Gruppen werden in der Auflistung nach nummerierten erfassten Gruppen gespeichert.</span><span class="sxs-lookup"><span data-stu-id="49cac-188">Named captured groups are stored in the collection after numbered captured groups.</span></span>  
  
- <span data-ttu-id="49cac-189">Programmgesteuert, durch das Bereitstellen des Teilausdrucknamens für den Indexer (in C#) des <xref:System.Text.RegularExpressions.GroupCollection> -Objekts oder seine <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> -Eigenschaft (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="49cac-189">Programmatically, by providing the subexpression name to the <xref:System.Text.RegularExpressions.GroupCollection> object's indexer (in C#) or to its <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> property (in Visual Basic).</span></span>  
  
 <span data-ttu-id="49cac-190">Ein einfaches Muster eines regulären Ausdrucks veranschaulicht, wie auf nummerierte (unbenannte) und benannte Gruppen entweder programmgesteuert oder mit der Sprachsyntax für reguläre Ausdrücke verwiesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="49cac-190">A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</span></span> <span data-ttu-id="49cac-191">Der reguläre Ausdruck `((?<One>abc)\d+)?(?<Two>xyz)(.*)` generiert die folgenden Erfassungsgruppen nach Nummer und Name.</span><span class="sxs-lookup"><span data-stu-id="49cac-191">The regular expression `((?<One>abc)\d+)?(?<Two>xyz)(.*)` produces the following capturing groups by number and by name.</span></span> <span data-ttu-id="49cac-192">Die erste Erfassungsgruppe (Nummer 0) bezieht sich stets auf das gesamte Muster.</span><span class="sxs-lookup"><span data-stu-id="49cac-192">The first capturing group (number 0) always refers to the entire pattern.</span></span>  
  
|<span data-ttu-id="49cac-193">number</span><span class="sxs-lookup"><span data-stu-id="49cac-193">Number</span></span>|<span data-ttu-id="49cac-194">name</span><span class="sxs-lookup"><span data-stu-id="49cac-194">Name</span></span>|<span data-ttu-id="49cac-195">Muster</span><span class="sxs-lookup"><span data-stu-id="49cac-195">Pattern</span></span>|  
|------------|----------|-------------|  
|<span data-ttu-id="49cac-196">0</span><span class="sxs-lookup"><span data-stu-id="49cac-196">0</span></span>|<span data-ttu-id="49cac-197">0 (Standardname)</span><span class="sxs-lookup"><span data-stu-id="49cac-197">0 (default name)</span></span>|`((?<One>abc)\d+)?(?<Two>xyz)(.*)`|  
|<span data-ttu-id="49cac-198">1</span><span class="sxs-lookup"><span data-stu-id="49cac-198">1</span></span>|<span data-ttu-id="49cac-199">1 (Standardname)</span><span class="sxs-lookup"><span data-stu-id="49cac-199">1 (default name)</span></span>|`((?<One>abc)\d+)`|  
|<span data-ttu-id="49cac-200">2</span><span class="sxs-lookup"><span data-stu-id="49cac-200">2</span></span>|<span data-ttu-id="49cac-201">2 (Standardname)</span><span class="sxs-lookup"><span data-stu-id="49cac-201">2 (default name)</span></span>|`(.*)`|  
|<span data-ttu-id="49cac-202">3</span><span class="sxs-lookup"><span data-stu-id="49cac-202">3</span></span>|<span data-ttu-id="49cac-203">One</span><span class="sxs-lookup"><span data-stu-id="49cac-203">One</span></span>|`(?<One>abc)`|  
|<span data-ttu-id="49cac-204">4</span><span class="sxs-lookup"><span data-stu-id="49cac-204">4</span></span>|<span data-ttu-id="49cac-205">Two</span><span class="sxs-lookup"><span data-stu-id="49cac-205">Two</span></span>|`(?<Two>xyz)`|  
  
 <span data-ttu-id="49cac-206">Im folgenden Beispiel wird ein regulärer Ausdruck veranschaulicht, der duplizierte Wörter sowie das Wort, das jedem duplizierten Wort direkt folgt, identifiziert.</span><span class="sxs-lookup"><span data-stu-id="49cac-206">The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</span></span> <span data-ttu-id="49cac-207">Das Muster eines regulären Ausdrucks definiert zwei benannte Teilausdrücke: `duplicateWord`, der das doppelte Wort darstellt; und `nextWord`, der das Wort darstellt, das auf das doppelte Wort folgt.</span><span class="sxs-lookup"><span data-stu-id="49cac-207">The regular expression pattern defines two named subexpressions: `duplicateWord`, which represents the duplicated word; and `nextWord`, which represents the word that follows the duplicated word.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping2.cs#2)]
 [!code-vb[RegularExpressions.Language.Grouping#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping2.vb#2)]  
  
 <span data-ttu-id="49cac-208">Das Muster für den reguläre Ausdruck lautet folgendermaßen:</span><span class="sxs-lookup"><span data-stu-id="49cac-208">The regular expression pattern is as follows:</span></span>  
  
`(?<duplicateWord>\w+)\s\k<duplicateWord>\W(?<nextWord>\w+)`  
  
 <span data-ttu-id="49cac-209">In der folgenden Tabelle wird gezeigt, wie der reguläre Ausdruck interpretiert wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-209">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="49cac-210">Muster</span><span class="sxs-lookup"><span data-stu-id="49cac-210">Pattern</span></span>|<span data-ttu-id="49cac-211">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="49cac-211">Description</span></span>|  
|-------------|-----------------|  
|`(?<duplicateWord>\w+)`|<span data-ttu-id="49cac-212">Übereinstimmung mit mindestens einem Wortzeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-212">Match one or more word characters.</span></span> <span data-ttu-id="49cac-213">Geben Sie für die Erfassungsgruppe `duplicateWord`als Namen an.</span><span class="sxs-lookup"><span data-stu-id="49cac-213">Name this capturing group `duplicateWord`.</span></span>|  
|`\s`|<span data-ttu-id="49cac-214">Entsprechung für ein Leerraumzeichen finden.</span><span class="sxs-lookup"><span data-stu-id="49cac-214">Match a white-space character.</span></span>|  
|`\k<duplicateWord>`|<span data-ttu-id="49cac-215">Suchen Sie nach einer Entsprechung der Zeichenfolge der erfassten Gruppe mit der Bezeichnung `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="49cac-215">Match the string from the captured group that is named `duplicateWord`.</span></span>|  
|`\W`|<span data-ttu-id="49cac-216">Finden Sie eine Entsprechung für ein Nichtwortzeichen, einschließlich Leerzeichen und Interpunktion.</span><span class="sxs-lookup"><span data-stu-id="49cac-216">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="49cac-217">Dies verhindert, dass für das Muster eines regulären Ausdrucks eine Entsprechung für ein Wort gefunden wird, das mit dem Wort von der zuerst erfassten Gruppe beginnt.</span><span class="sxs-lookup"><span data-stu-id="49cac-217">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
|`(?<nextWord>\w+)`|<span data-ttu-id="49cac-218">Übereinstimmung mit mindestens einem Wortzeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-218">Match one or more word characters.</span></span> <span data-ttu-id="49cac-219">Geben Sie für die Erfassungsgruppe `nextWord`als Namen an.</span><span class="sxs-lookup"><span data-stu-id="49cac-219">Name this capturing group `nextWord`.</span></span>|  
  
 <span data-ttu-id="49cac-220">Beachten Sie, dass der Name einer Gruppe in einem regulären Ausdruck wiederholt werden kann.</span><span class="sxs-lookup"><span data-stu-id="49cac-220">Note that a group name can be repeated in a regular expression.</span></span> <span data-ttu-id="49cac-221">Beispielsweise ist es möglich, dass mehr als eine Gruppe den Namen `digit`trägt, wie im folgenden Beispiel veranschaulicht wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-221">For example, it is possible for more than one group to be named `digit`, as the following example illustrates.</span></span> <span data-ttu-id="49cac-222">Im Fall von doppelten Namen wird der Wert des <xref:System.Text.RegularExpressions.Group> -Objekts durch die letzte erfolgreiche Erfassung in der Eingabezeichenfolge bestimmt.</span><span class="sxs-lookup"><span data-stu-id="49cac-222">In the case of duplicate names, the value of the <xref:System.Text.RegularExpressions.Group> object is determined by the last successful capture in the input string.</span></span> <span data-ttu-id="49cac-223">Darüber hinaus wird <xref:System.Text.RegularExpressions.CaptureCollection> mit Informationen über jede Erfassung aufgefüllt, wie es der Fall wäre, wenn der Gruppenname nicht dupliziert wäre.</span><span class="sxs-lookup"><span data-stu-id="49cac-223">In addition, the <xref:System.Text.RegularExpressions.CaptureCollection> is populated with information about each capture just as it would be if the group name was not duplicated.</span></span>  
  
 <span data-ttu-id="49cac-224">Im folgenden Beispiel umfasst der reguläre Ausdruck `\D+(?<digit>\d+)\D+(?<digit>\d+)?` zwei Vorkommen einer Gruppe namens `digit`.</span><span class="sxs-lookup"><span data-stu-id="49cac-224">In the following example, the regular expression `\D+(?<digit>\d+)\D+(?<digit>\d+)?` includes two occurrences of a group named `digit`.</span></span> <span data-ttu-id="49cac-225">Die erste mit `digit` benannte Gruppe erfasst ein oder mehrere Ziffernzeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-225">The first `digit` named group captures one or more digit characters.</span></span> <span data-ttu-id="49cac-226">Die zweite mit `digit` benannte Gruppe erfasst entweder null oder ein Vorkommen von einem oder mehreren Ziffernzeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-226">The second `digit` named group captures either zero or one occurrence of one or more digit characters.</span></span> <span data-ttu-id="49cac-227">Wie die Ausgabe des Beispiels zeigt, definiert der Wert dieses Texts, wenn die zweite Erfassungsgruppe erfolgreich mit Text übereinstimmt, den Wert des <xref:System.Text.RegularExpressions.Group> -Objekts.</span><span class="sxs-lookup"><span data-stu-id="49cac-227">As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span> <span data-ttu-id="49cac-228">Wenn die zweite Erfassungsgruppe nicht der Eingabezeichenfolge entspricht, definiert der Wert der letzten erfolgreichen Übereinstimmung den Wert des <xref:System.Text.RegularExpressions.Group> -Objekts.</span><span class="sxs-lookup"><span data-stu-id="49cac-228">If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#12](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/duplicate1.cs#12)]
 [!code-vb[RegularExpressions.Language.Grouping#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/duplicate1.vb#12)]  
  
 <span data-ttu-id="49cac-229">In der folgenden Tabelle wird gezeigt, wie der reguläre Ausdruck interpretiert wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-229">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="49cac-230">Muster</span><span class="sxs-lookup"><span data-stu-id="49cac-230">Pattern</span></span>|<span data-ttu-id="49cac-231">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="49cac-231">Description</span></span>|  
|-------------|-----------------|  
|`\D+`|<span data-ttu-id="49cac-232">Übereinstimmung mit einem oder mehreren Nichtdezimal-Ziffernzeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-232">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)`|<span data-ttu-id="49cac-233">Übereinstimmung mit einem oder mehreren Dezimalziffernzeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-233">Match one or more decimal digit characters.</span></span> <span data-ttu-id="49cac-234">Weisen Sie die Übereinstimmung der Gruppe namens `digit` zu.</span><span class="sxs-lookup"><span data-stu-id="49cac-234">Assign the match to the `digit` named group.</span></span>|  
|`\D+`|<span data-ttu-id="49cac-235">Übereinstimmung mit einem oder mehreren Nichtdezimal-Ziffernzeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-235">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)?`|<span data-ttu-id="49cac-236">Übereinstimmung mit keinem oder einem Vorkommen mindestens eines Dezimalziffernzeichens.</span><span class="sxs-lookup"><span data-stu-id="49cac-236">Match zero or one occurrence of one or more decimal digit characters.</span></span> <span data-ttu-id="49cac-237">Weisen Sie die Übereinstimmung der Gruppe namens `digit` zu.</span><span class="sxs-lookup"><span data-stu-id="49cac-237">Assign the match to the `digit` named group.</span></span>|  
  
<a name="balancing_group_definition"></a>

## <a name="balancing-group-definitions"></a><span data-ttu-id="49cac-238">Ausgleichen von Gruppendefinitionen</span><span class="sxs-lookup"><span data-stu-id="49cac-238">Balancing Group Definitions</span></span>  

 <span data-ttu-id="49cac-239">Eine Ausgleichsgruppendefinition löscht die Definition einer zuvor definierten Gruppe und speichert in der aktuellen Gruppe das Intervall zwischen der zuvor definierten Gruppe und der aktuellen Gruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-239">A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</span></span> <span data-ttu-id="49cac-240">Dieses Gruppierungskonstrukt besitzt das folgende Format:</span><span class="sxs-lookup"><span data-stu-id="49cac-240">This grouping construct has the following format:</span></span>  
  
`(?<name1-name2>subexpression)`  
  
 <span data-ttu-id="49cac-241">oder:</span><span class="sxs-lookup"><span data-stu-id="49cac-241">or:</span></span>  
  
`(?'name1-name2' subexpression)`
  
 <span data-ttu-id="49cac-242">wobei *name1* die aktuelle Gruppe (optional), *name2* eine zuvor definierte Gruppe und *subexpression* ein beliebiges gültiges Muster eines regulären Ausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-242">where *name1* is the current group (optional), *name2* is a previously defined group, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="49cac-243">Die Ausgleichsgruppendefinition löscht die Definition von *name2* und speichert das Intervall zwischen *name2* und *name1* in *name1*.</span><span class="sxs-lookup"><span data-stu-id="49cac-243">The balancing group definition deletes the definition of *name2* and stores the interval between *name2* and *name1* in *name1*.</span></span> <span data-ttu-id="49cac-244">Wenn keine *name2* -Gruppe definiert ist, wird die Übereinstimmung rückwärts verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="49cac-244">If no *name2* group is defined, the match backtracks.</span></span> <span data-ttu-id="49cac-245">Da durch Löschen der letzten Definition von *name2* die vorherige Definition von *name2* angezeigt wird, kann mithilfe dieses Konstrukts der Erfassungsstapel für die *name2* -Gruppe als Zähler für die Erfassung von geschachtelten Konstrukten, z. B. Anführungszeichen oder öffnende bzw. schließende Klammern, verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="49cac-245">Because deleting the last definition of *name2* reveals the previous definition of *name2*, this construct lets you use the stack of captures for group *name2* as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</span></span>  
  
 <span data-ttu-id="49cac-246">Die Ausgleichsgruppendefinition verwendet *name2* als Stapel.</span><span class="sxs-lookup"><span data-stu-id="49cac-246">The balancing group definition uses *name2* as a stack.</span></span> <span data-ttu-id="49cac-247">Das Anfangszeichen jedes geschachtelten Konstrukts wird in die Gruppe sowie in die zugehörige <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> -Auflistung eingefügt.</span><span class="sxs-lookup"><span data-stu-id="49cac-247">The beginning character of each nested construct is placed in the group and in its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection.</span></span> <span data-ttu-id="49cac-248">Wenn das schließende Zeichen abgeglichen wird, wird das entsprechende öffnende Zeichen aus der Gruppe entfernt, und die <xref:System.Text.RegularExpressions.Group.Captures%2A> -Auflistung wird um eins verringert.</span><span class="sxs-lookup"><span data-stu-id="49cac-248">When the closing character is matched, its corresponding opening character is removed from the group, and the <xref:System.Text.RegularExpressions.Group.Captures%2A> collection is decreased by one.</span></span> <span data-ttu-id="49cac-249">Nachdem die öffnenden und schließenden Zeichen aller geschachtelten Konstrukte abgeglichen wurden, ist *name2* leer.</span><span class="sxs-lookup"><span data-stu-id="49cac-249">After the opening and closing characters of all nested constructs have been matched, *name2* is empty.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="49cac-250">Nachdem Sie den regulären Ausdruck im folgenden Beispiel geändert haben, sodass er die entsprechenden öffnenden und schließenden Zeichen eines geschachtelten Konstrukts enthält, können Sie diesen zur Behandlung der meisten geschachtelten Konstrukte verwenden, z. B. für mathematische Ausdrücke oder Programmcodezeilen, die mehrere geschachtelte Methodenaufrufe enthalten.</span><span class="sxs-lookup"><span data-stu-id="49cac-250">After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</span></span>  
  
 <span data-ttu-id="49cac-251">Das folgende Codebeispiel verwendet eine Ausgleichsgruppendefinition, um in einer Eingabezeichenfolge nach öffnenden und schließenden spitzen Klammern (<>) zu suchen.</span><span class="sxs-lookup"><span data-stu-id="49cac-251">The following example uses a balancing group definition to match left and right angle brackets (<>) in an input string.</span></span> <span data-ttu-id="49cac-252">Im Beispiel werden zwei benannte Gruppen, `Open` und `Close`, definiert, die wie ein Stapel verwendet werden, um übereinstimmende Paare von spitzen Klammern nachzuverfolgen.</span><span class="sxs-lookup"><span data-stu-id="49cac-252">The example defines two named groups, `Open` and `Close`, that are used like a stack to track matching pairs of angle brackets.</span></span> <span data-ttu-id="49cac-253">Jede erfasste öffnende spitze Klammer wird in die Erfassungsauflistung der `Open` -Gruppe eingefügt, und jede erfasste schließende spitze Klammer wird in die Erfassungsauflistung der `Close` -Gruppe eingefügt.</span><span class="sxs-lookup"><span data-stu-id="49cac-253">Each captured left angle bracket is pushed into the capture collection of the `Open` group, and each captured right angle bracket is pushed into the capture collection of the `Close` group.</span></span> <span data-ttu-id="49cac-254">Die Ausgleichsgruppendefinition stellt sicher, dass es eine entsprechende schließende spitze Klammer für jede öffnende spitze Klammer gibt.</span><span class="sxs-lookup"><span data-stu-id="49cac-254">The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</span></span> <span data-ttu-id="49cac-255">Trifft dies nicht zu, wird das abschließende Teilmuster, `(?(Open)(?!))`, nur ausgewertet, wenn die `Open` -Gruppe nicht leer ist (und wenn alle geschachtelten Konstrukte nicht geschlossen wurden).</span><span class="sxs-lookup"><span data-stu-id="49cac-255">If there is not, the final subpattern, `(?(Open)(?!))`, is evaluated only if the `Open` group is not empty (and, therefore, if all nested constructs have not been closed).</span></span> <span data-ttu-id="49cac-256">Wenn das endgültige Teilmuster ausgewertet wird, schlägt die Übereinstimmung fehl, da das `(?!)` Teilmuster eine negative Lookaheadassertion mit einer Breite von 0 (null) ist, die immer fehlschlägt.</span><span class="sxs-lookup"><span data-stu-id="49cac-256">If the final subpattern is evaluated, the match fails, because the `(?!)` subpattern is a zero-width negative lookahead assertion that always fails.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping3.cs#3)]
 [!code-vb[RegularExpressions.Language.Grouping#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping3.vb#3)]  
  
 <span data-ttu-id="49cac-257">Das Muster des regulären Ausdrucks lautet:</span><span class="sxs-lookup"><span data-stu-id="49cac-257">The regular expression pattern is:</span></span>  
  
`^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$`  
  
 <span data-ttu-id="49cac-258">Der reguläre Ausdruck wird wie folgt interpretiert:</span><span class="sxs-lookup"><span data-stu-id="49cac-258">The regular expression is interpreted as follows:</span></span>  
  
|<span data-ttu-id="49cac-259">Muster</span><span class="sxs-lookup"><span data-stu-id="49cac-259">Pattern</span></span>|<span data-ttu-id="49cac-260">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="49cac-260">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="49cac-261">Starten Sie am Beginn der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="49cac-261">Begin at the start of the string.</span></span>|  
|`[^<>]*`|<span data-ttu-id="49cac-262">Finden Sie eine Entsprechung für null oder mehr Zeichen, die keine linken oder rechten spitzen Klammern sind.</span><span class="sxs-lookup"><span data-stu-id="49cac-262">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`(?'Open'<)`|<span data-ttu-id="49cac-263">Suchen Sie eine Übereinstimmung für ein kleiner als-Zeichen, und weisen Sie es einer Gruppe mit dem Namen `Open`zu.</span><span class="sxs-lookup"><span data-stu-id="49cac-263">Match a left angle bracket and assign it to a group named `Open`.</span></span>|  
|`[^<>]*`|<span data-ttu-id="49cac-264">Finden Sie eine Entsprechung für null oder mehr Zeichen, die keine linken oder rechten spitzen Klammern sind.</span><span class="sxs-lookup"><span data-stu-id="49cac-264">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`((?'Open'<)[^<>]*)+`|<span data-ttu-id="49cac-265">Finden Sie eine Entsprechung für ein oder mehr Vorkommen einer linken spitzen Klammer, gefolgt von null oder mehr Zeichen, die keine linken oder rechten spitzen Klammern sind.</span><span class="sxs-lookup"><span data-stu-id="49cac-265">Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</span></span> <span data-ttu-id="49cac-266">Dies ist die zweite Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-266">This is the second capturing group.</span></span>|  
|`(?'Close-Open'>)`|<span data-ttu-id="49cac-267">Finden Sie eine Entsprechung für eine öffnende spitze Klammer, weisen Sie die Teilzeichenfolge zwischen der `Open` -Gruppe und der aktuellen Gruppe der `Close` -Gruppe zu, und löschen Sie die Definition der `Open` -Gruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-267">Match a right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span>|  
|`[^<>]*`|<span data-ttu-id="49cac-268">Finden Sie eine Entsprechung für null oder mehr Vorkommen eines die oft ausgegebene Befehlszeilen  Zeichens, das weder eine linke noch eine rechte spitze Klammern ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-268">Match zero or more occurrences of any character that is neither a left  nor a right angle bracket.</span></span>|  
|`((?'Close-Open'>)[^<>]*)+`|<span data-ttu-id="49cac-269">Finden Sie eine Entsprechung für ein oder mehr Vorkommen einer rechten spitzen Klammer, gefolgt von einem die oft ausgegebene Befehlszeilen  Zeichen, das weder eine linke noch eine rechte spitze Klammern ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-269">Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</span></span> <span data-ttu-id="49cac-270">Wenn Sie die öffnende spitze Klammer zuordnen, weisen Sie die Teilzeichenfolge zwischen der `Open` -Gruppe und der aktuellen Gruppe der `Close` -Gruppe zu, und löschen Sie die Definition der `Open` -Gruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-270">When matching the right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span> <span data-ttu-id="49cac-271">Dies ist die dritte Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-271">This is the third capturing group.</span></span>|  
|`(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*`|<span data-ttu-id="49cac-272">Finden Sie eine Entsprechung für null oder mehr Vorkommen des folgenden Musters: ein oder mehr Vorkommen einer linken spitzen Klammer, gefolgt von null oder mehr Zeichen, die keine spitzen Klammern sind, gefolgt von einem oder mehr Vorkommen einer rechten spitzen Klammer, gefolgt von null oder mehr Vorkommen von nicht spitzen Klammern.</span><span class="sxs-lookup"><span data-stu-id="49cac-272">Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</span></span> <span data-ttu-id="49cac-273">Löschen Sie beim Abgleichen der schließenden spitzen Klammer die Definition der `Open` -Gruppe, und weisen Sie der `Open` -Gruppe die Teilzeichenfolge zwischen der `Close` -Gruppe und der aktuellen Gruppe zu.</span><span class="sxs-lookup"><span data-stu-id="49cac-273">When matching the right angle bracket, delete the definition of the `Open` group, and assign the substring between the `Open` group and the current group to the `Close` group.</span></span> <span data-ttu-id="49cac-274">Dies ist die erste Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-274">This is the first capturing group.</span></span>|  
|`(?(Open)(?!))`|<span data-ttu-id="49cac-275">Wenn die `Open`-Gruppe vorhanden ist und eine leere Zeichenfolge abgeglichen werden kann, geben Sie die Übereinstimmung auf, erhöhen Sie dabei jedoch nicht die Position der Engine für den regulären Ausdruck in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="49cac-275">If the `Open` group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</span></span> <span data-ttu-id="49cac-276">Dies ist eine negative Lookaheadassertion mit einer Breite von Null.</span><span class="sxs-lookup"><span data-stu-id="49cac-276">This is a zero-width negative lookahead assertion.</span></span> <span data-ttu-id="49cac-277">Da eine leere Zeichenfolge in einer Eingabezeichenfolge immer implizit vorhanden ist, schlägt diese Übereinstimmung immer fehl.</span><span class="sxs-lookup"><span data-stu-id="49cac-277">Because an empty string is always implicitly present in an input string, this match always fails.</span></span> <span data-ttu-id="49cac-278">Das Fehlschlagen dieser Übereinstimmung weist darauf hin, dass die spitzen Klammern nicht ausgeglichen sind.</span><span class="sxs-lookup"><span data-stu-id="49cac-278">Failure of this match indicates that the angle brackets are not balanced.</span></span>|  
|`$`|<span data-ttu-id="49cac-279">Entsprechung für das Ende der Eingabezeichenfolge finden.</span><span class="sxs-lookup"><span data-stu-id="49cac-279">Match the end of the input string.</span></span>|  
  
 <span data-ttu-id="49cac-280">Der abschließende Teilausdruck, `(?(Open)(?!))`, gibt an, ob die Schachtelungskonstrukte in der Eingabezeichenfolge ausgeglichen sind (z. B. ob jeder öffnenden spitzen Klammer eine entsprechende schließende spitze Klammer zugeordnet ist).</span><span class="sxs-lookup"><span data-stu-id="49cac-280">The final subexpression, `(?(Open)(?!))`, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</span></span> <span data-ttu-id="49cac-281">Dabei wird eine bedingte Übereinstimmung auf Grundlage einer gültigen erfassten Gruppe verwendet. Weitere Informationen finden Sie unter [Alternierungskonstrukte in regulären Ausdrücken](alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="49cac-281">It uses conditional matching based on a valid captured group; for more information, see [Alternation Constructs](alternation-constructs-in-regular-expressions.md).</span></span> <span data-ttu-id="49cac-282">Wenn die `Open`-Gruppe definiert ist, versucht die Engine für reguläre Ausdrücke, eine Entsprechung für den `(?!)`-Teilausdruck in der Eingabezeichenfolge zu finden.</span><span class="sxs-lookup"><span data-stu-id="49cac-282">If the `Open` group is defined, the regular expression engine attempts to match the subexpression `(?!)` in the input string.</span></span> <span data-ttu-id="49cac-283">Die `Open` -Gruppe sollte nur definiert werden, wenn Schachtelungskonstrukte nicht ausgeglichen sind.</span><span class="sxs-lookup"><span data-stu-id="49cac-283">The `Open` group should be defined only if nesting constructs are unbalanced.</span></span> <span data-ttu-id="49cac-284">Daher sollte das in der Eingabezeichenfolge zu findende Muster immer dazu führen, dass die Übereinstimmung fehlschlägt.</span><span class="sxs-lookup"><span data-stu-id="49cac-284">Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</span></span> <span data-ttu-id="49cac-285">In diesem Fall ist `(?!)` eine negative Lookaheadassertion mit einer Breite von Null, die immer fehlschlägt, da eine leere Zeichenfolge immer an der nächsten Position in der Eingabezeichenfolge implizit vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-285">In this case, `(?!)` is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</span></span>  
  
 <span data-ttu-id="49cac-286">Im Beispiel wertet die Engine für reguläre Ausdrücke die Eingabezeichenfolge „\<abc>&lt;mno\<xyz>&gt;“ wie in der folgenden Tabelle gezeigt aus.</span><span class="sxs-lookup"><span data-stu-id="49cac-286">In the example, the regular expression engine evaluates the input string "\<abc><mno\<xyz>>" as shown in the following table.</span></span>  
  
|<span data-ttu-id="49cac-287">Schritt</span><span class="sxs-lookup"><span data-stu-id="49cac-287">Step</span></span>|<span data-ttu-id="49cac-288">Muster</span><span class="sxs-lookup"><span data-stu-id="49cac-288">Pattern</span></span>|<span data-ttu-id="49cac-289">Ergebnis</span><span class="sxs-lookup"><span data-stu-id="49cac-289">Result</span></span>|  
|----------|-------------|------------|  
|<span data-ttu-id="49cac-290">1</span><span class="sxs-lookup"><span data-stu-id="49cac-290">1</span></span>|`^`|<span data-ttu-id="49cac-291">Beginnt den Abgleich am Anfang der Eingabezeichenfolge</span><span class="sxs-lookup"><span data-stu-id="49cac-291">Starts the match at the beginning of the input string</span></span>|  
|<span data-ttu-id="49cac-292">2</span><span class="sxs-lookup"><span data-stu-id="49cac-292">2</span></span>|`[^<>]*`|<span data-ttu-id="49cac-293">Sucht vor der öffnenden spitzen Klammer nach Zeichen, die keine spitzen Klammern sind; findet keine Übereinstimmungen.</span><span class="sxs-lookup"><span data-stu-id="49cac-293">Looks for non-angle bracket characters before the left angle bracket;finds no matches.</span></span>|  
|<span data-ttu-id="49cac-294">3</span><span class="sxs-lookup"><span data-stu-id="49cac-294">3</span></span>|`(((?'Open'<)`|<span data-ttu-id="49cac-295">Findet eine Übereinstimmung mit der linken spitzen Klammer in „\<abc>“ und weist sie der `Open`-Gruppe zu.</span><span class="sxs-lookup"><span data-stu-id="49cac-295">Matches the left angle bracket in "\<abc>" and assigns it to the `Open` group.</span></span>|  
|<span data-ttu-id="49cac-296">4</span><span class="sxs-lookup"><span data-stu-id="49cac-296">4</span></span>|`[^<>]*`|<span data-ttu-id="49cac-297">Entspricht "abc".</span><span class="sxs-lookup"><span data-stu-id="49cac-297">Matches "abc".</span></span>|  
|<span data-ttu-id="49cac-298">5</span><span class="sxs-lookup"><span data-stu-id="49cac-298">5</span></span>|`)+`|<span data-ttu-id="49cac-299">"<abc" ist der Wert der zweiten erfassten Gruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-299">"<abc" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="49cac-300">Das nächste Zeichen in der Eingabezeichenfolge ist keine öffnende spitze Klammer. Deshalb führt die Engine für reguläre Ausdrücke keine Schleife zurück zum `(?'Open'<)[^<>]*)`-Teilmuster aus.</span><span class="sxs-lookup"><span data-stu-id="49cac-300">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="49cac-301">6</span><span class="sxs-lookup"><span data-stu-id="49cac-301">6</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="49cac-302">Findet eine Übereinstimmung mit der rechten spitzen Klammer in „\<abc>“, weist „abc“ (die Teilzeichenfolge zwischen der `Open`-Gruppe und der rechten spitzen Klammer) der `Close`-Gruppe zu und löscht den aktuellen Wert („<“) der `Open`-Gruppe, der dann leer bleibt.</span><span class="sxs-lookup"><span data-stu-id="49cac-302">Matches the right angle bracket in "\<abc>", assigns "abc", which is the substring between the `Open` group and the right angle bracket, to the `Close` group, and deletes the current value ("<") of the `Open` group, leaving it empty.</span></span>|  
|<span data-ttu-id="49cac-303">7</span><span class="sxs-lookup"><span data-stu-id="49cac-303">7</span></span>|`[^<>]*`|<span data-ttu-id="49cac-304">Sucht nach der schließenden spitzen Klammer nach Zeichen, die keine spitzen Klammern sind; findet keine Übereinstimmungen.</span><span class="sxs-lookup"><span data-stu-id="49cac-304">Looks for non-angle bracket characters after the right angle bracket; finds no matches.</span></span>|  
|<span data-ttu-id="49cac-305">8</span><span class="sxs-lookup"><span data-stu-id="49cac-305">8</span></span>|`)+`|<span data-ttu-id="49cac-306">Der Wert der dritten erfassten Gruppe ist ">".</span><span class="sxs-lookup"><span data-stu-id="49cac-306">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="49cac-307">Das nächste Zeichen in der Eingabezeichenfolge ist keine schließende spitze Klammer. Deshalb führt die Engine für reguläre Ausdrücke keine Schleife zurück zum `((?'Close-Open'>)[^<>]*)`-Teilmuster aus.</span><span class="sxs-lookup"><span data-stu-id="49cac-307">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="49cac-308">9</span><span class="sxs-lookup"><span data-stu-id="49cac-308">9</span></span>|`)*`|<span data-ttu-id="49cac-309">Der Wert der ersten erfassten Gruppe ist „\<abc>“.</span><span class="sxs-lookup"><span data-stu-id="49cac-309">The value of the first captured group is "\<abc>".</span></span><br /><br /> <span data-ttu-id="49cac-310">Das nächste Zeichen in der Eingabezeichenfolge ist eine öffnende spitze Klammer, weshalb die Engine für reguläre Ausdrücke eine Schleife zurück zum `(((?'Open'<)` -Teilmuster ausführt.</span><span class="sxs-lookup"><span data-stu-id="49cac-310">The next character in the input string is a left  angle bracket, so the regular expression engine loops back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="49cac-311">10</span><span class="sxs-lookup"><span data-stu-id="49cac-311">10</span></span>|`(((?'Open'<)`|<span data-ttu-id="49cac-312">Entspricht der öffnenden spitzen Klammer in „\<mno" and assigns it to the `Open` group. Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>-Sammlung hat jetzt einen einzelnen Wert, ‚<‘“.</span><span class="sxs-lookup"><span data-stu-id="49cac-312">Matches the left angle bracket in "\<mno" and assigns it to the `Open` group. Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection now has a single value, "<".</span></span>|  
|<span data-ttu-id="49cac-313">11</span><span class="sxs-lookup"><span data-stu-id="49cac-313">11</span></span>|`[^<>]*`|<span data-ttu-id="49cac-314">Entspricht "mno".</span><span class="sxs-lookup"><span data-stu-id="49cac-314">Matches "mno".</span></span>|  
|<span data-ttu-id="49cac-315">12</span><span class="sxs-lookup"><span data-stu-id="49cac-315">12</span></span>|`)+`|<span data-ttu-id="49cac-316">"<mno" ist der Wert der zweiten erfassten Gruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-316">"<mno" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="49cac-317">Das nächste Zeichen in der Eingabezeichenfolge ist eine öffnende spitze Klammer, weshalb die Engine für reguläre Ausdrücke eine Schleife zurück zum `(?'Open'<)[^<>]*)`-Teilmuster ausführt.</span><span class="sxs-lookup"><span data-stu-id="49cac-317">The next character in the input string is an left angle bracket, so the regular expression engine loops back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="49cac-318">13</span><span class="sxs-lookup"><span data-stu-id="49cac-318">13</span></span>|`(((?'Open'<)`|<span data-ttu-id="49cac-319">Findet eine Übereinstimmung mit der linken spitzen Klammer in „\<xyz>“ und weist sie der `Open`-Gruppe zu.</span><span class="sxs-lookup"><span data-stu-id="49cac-319">Matches the left angle bracket in "\<xyz>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="49cac-320">Die <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>-Sammlung der `Open`-Gruppe schließt jetzt zwei Erfassungen ein: die linke spitze Klammer von „\<mno", and the left angle bracket from "\<xyz>“.</span><span class="sxs-lookup"><span data-stu-id="49cac-320">The <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection of the `Open` group now includes two captures: the left angle bracket from "\<mno", and the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="49cac-321">14</span><span class="sxs-lookup"><span data-stu-id="49cac-321">14</span></span>|`[^<>]*`|<span data-ttu-id="49cac-322">Entspricht "xyz".</span><span class="sxs-lookup"><span data-stu-id="49cac-322">Matches "xyz".</span></span>|  
|<span data-ttu-id="49cac-323">15</span><span class="sxs-lookup"><span data-stu-id="49cac-323">15</span></span>|`)+`|<span data-ttu-id="49cac-324">"<xyz" ist der Wert der zweiten erfassten Gruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-324">"<xyz" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="49cac-325">Das nächste Zeichen in der Eingabezeichenfolge ist keine öffnende spitze Klammer. Deshalb führt die Engine für reguläre Ausdrücke keine Schleife zurück zum `(?'Open'<)[^<>]*)`-Teilmuster aus.</span><span class="sxs-lookup"><span data-stu-id="49cac-325">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="49cac-326">16</span><span class="sxs-lookup"><span data-stu-id="49cac-326">16</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="49cac-327">Findet eine Übereinstimmung für die rechte spitze Klammer in „\<xyz>“.</span><span class="sxs-lookup"><span data-stu-id="49cac-327">Matches the right angle bracket in "\<xyz>".</span></span> <span data-ttu-id="49cac-328">„xyz“ weist die Teilzeichenfolge zwischen der `Open` -Gruppe und der schließenden spitzen Klammer der `Close` -Gruppe zu und löscht den aktuellen Wert der `Open` -Gruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-328">"xyz", assigns the substring between the `Open` group and the right angle bracket to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="49cac-329">Der Wert der vorherigen Erfassung (die öffnende spitze Klammer in „\<mno") becomes the current value of the `Open` group. The <xref:System.Text.RegularExpressions.Group.Captures%2A>-Sammlung der `Open`-Gruppe schließt jetzt eine einzelne Erfassung ein, die öffnende spitze Klammer von ‚\<xyz>‘“.</span><span class="sxs-lookup"><span data-stu-id="49cac-329">The value of the previous capture (the left angle bracket in "\<mno") becomes the current value of the `Open` group. The <xref:System.Text.RegularExpressions.Group.Captures%2A> collection of the `Open` group now includes a single capture, the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="49cac-330">17</span><span class="sxs-lookup"><span data-stu-id="49cac-330">17</span></span>|`[^<>]*`|<span data-ttu-id="49cac-331">Sucht nach Zeichen, die keine spitzen Klammern sind; findet keine Übereinstimmungen.</span><span class="sxs-lookup"><span data-stu-id="49cac-331">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="49cac-332">18</span><span class="sxs-lookup"><span data-stu-id="49cac-332">18</span></span>|`)+`|<span data-ttu-id="49cac-333">Der Wert der dritten erfassten Gruppe ist ">".</span><span class="sxs-lookup"><span data-stu-id="49cac-333">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="49cac-334">Das nächste Zeichen in der Eingabezeichenfolge ist eine schließende spitze Klammer, weshalb die Engine für reguläre Ausdrücke eine Schleife zurück zum `((?'Close-Open'>)[^<>]*)`-Teilmuster ausführt.</span><span class="sxs-lookup"><span data-stu-id="49cac-334">The next character in the input string is a right angle bracket, so the regular expression engine loops back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="49cac-335">19</span><span class="sxs-lookup"><span data-stu-id="49cac-335">19</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="49cac-336">Findet eine Entsprechung für die abschließende rechte spitze Klammer in „xyz>>“, weist „mno\<xyz>“ (die Teilzeichenfolge zwischen der `Open`-Gruppe und der rechten spitzen Klammer) der `Close`-Gruppe zu und löscht den aktuellen Wert der `Open`-Gruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-336">Matches the final right angle bracket in "xyz>>", assigns "mno\<xyz>" (the substring between the `Open` group and the right angle bracket) to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="49cac-337">Die `Open`-Gruppe ist jetzt leer.</span><span class="sxs-lookup"><span data-stu-id="49cac-337">The `Open` group is now empty.</span></span>|  
|<span data-ttu-id="49cac-338">20</span><span class="sxs-lookup"><span data-stu-id="49cac-338">20</span></span>|`[^<>]*`|<span data-ttu-id="49cac-339">Sucht nach Zeichen, die keine spitzen Klammern sind; findet keine Übereinstimmungen.</span><span class="sxs-lookup"><span data-stu-id="49cac-339">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="49cac-340">21</span><span class="sxs-lookup"><span data-stu-id="49cac-340">21</span></span>|`)+`|<span data-ttu-id="49cac-341">Der Wert der dritten erfassten Gruppe ist ">".</span><span class="sxs-lookup"><span data-stu-id="49cac-341">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="49cac-342">Das nächste Zeichen in der Eingabezeichenfolge ist keine schließende spitze Klammer. Deshalb führt die Engine für reguläre Ausdrücke keine Schleife zurück zum `((?'Close-Open'>)[^<>]*)`-Teilmuster aus.</span><span class="sxs-lookup"><span data-stu-id="49cac-342">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="49cac-343">22</span><span class="sxs-lookup"><span data-stu-id="49cac-343">22</span></span>|`)*`|<span data-ttu-id="49cac-344">Der Wert der ersten erfassten Gruppe ist „<mno\<xyz>>“.</span><span class="sxs-lookup"><span data-stu-id="49cac-344">The value of the first captured group is "<mno\<xyz>>".</span></span><br /><br /> <span data-ttu-id="49cac-345">Das nächste Zeichen in der Eingabezeichenfolge ist keine öffnende spitze Klammer. Deshalb führt die Engine für reguläre Ausdrücke keine Schleife zurück zum `(((?'Open'<)`-Teilmuster aus.</span><span class="sxs-lookup"><span data-stu-id="49cac-345">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="49cac-346">23</span><span class="sxs-lookup"><span data-stu-id="49cac-346">23</span></span>|`(?(Open)(?!))`|<span data-ttu-id="49cac-347">Die `Open` -Gruppe ist nicht definiert, sodass keine Übereinstimmung gesucht wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-347">The `Open` group is not defined, so no match is attempted.</span></span>|  
|<span data-ttu-id="49cac-348">24</span><span class="sxs-lookup"><span data-stu-id="49cac-348">24</span></span>|`$`|<span data-ttu-id="49cac-349">Gleicht das Ende der Eingabezeichenfolge ab.</span><span class="sxs-lookup"><span data-stu-id="49cac-349">Matches the end of the input string.</span></span>|  
  
<a name="noncapturing_group"></a>

## <a name="noncapturing-groups"></a><span data-ttu-id="49cac-350">Nicht erfassende Gruppen</span><span class="sxs-lookup"><span data-stu-id="49cac-350">Noncapturing Groups</span></span>  

 <span data-ttu-id="49cac-351">Das folgende Gruppierungskonstrukt erfasst nicht die Teilzeichenfolge, die zu einem Teilausdruck passt:</span><span class="sxs-lookup"><span data-stu-id="49cac-351">The following grouping construct does not capture the substring that is matched by a subexpression:</span></span>  
  
`(?:subexpression)`
  
 <span data-ttu-id="49cac-352">wobei *Teilausdruck* ein beliebiges gültiges Muster eines regulären Ausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-352">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="49cac-353">Das nicht erfassende Gruppenkonstrukt wird in der Regel verwendet, wenn ein Quantifizierer auf eine Gruppe angewendet wird, die von der Gruppe erfassten Teilzeichenfolgen jedoch nicht von Interesse sind.</span><span class="sxs-lookup"><span data-stu-id="49cac-353">The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="49cac-354">Wenn ein regulärer Ausdruck geschachtelte Gruppierungskonstrukte einschließt, gilt ein äußeres nicht erfassendes Gruppenkonstrukt nicht für die inneren geschachtelten Gruppenkonstrukte.</span><span class="sxs-lookup"><span data-stu-id="49cac-354">If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</span></span>  
  
 <span data-ttu-id="49cac-355">Im folgenden Beispiel wird ein regulärer Ausdruck veranschaulicht, der nicht erfassende Gruppen einschließt.</span><span class="sxs-lookup"><span data-stu-id="49cac-355">The following example illustrates a regular expression that includes noncapturing groups.</span></span> <span data-ttu-id="49cac-356">Beachten Sie, dass die Ausgabe keine erfassten Gruppen einschließt.</span><span class="sxs-lookup"><span data-stu-id="49cac-356">Note that the output does not include any captured groups.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/noncapture1.cs#5)]
 [!code-vb[RegularExpressions.Language.Grouping#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/noncapture1.vb#5)]  
  
 <span data-ttu-id="49cac-357">Der reguläre Ausdruck `(?:\b(?:\w+)\W*)+\.` stimmt mit einem Satz überein, der durch einen Punkt beendet wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-357">The regular expression `(?:\b(?:\w+)\W*)+\.` matches a sentence that is terminated by a period.</span></span> <span data-ttu-id="49cac-358">Da sich der reguläre Ausdruck auf Sätze konzentriert und nicht auf einzelne Wörter, werden Gruppierungskonstrukte ausschließlich als Quantifizierer verwendet.</span><span class="sxs-lookup"><span data-stu-id="49cac-358">Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</span></span> <span data-ttu-id="49cac-359">Das Muster für reguläre Ausdrücke wird entsprechend der folgenden Tabelle interpretiert.</span><span class="sxs-lookup"><span data-stu-id="49cac-359">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="49cac-360">Muster</span><span class="sxs-lookup"><span data-stu-id="49cac-360">Pattern</span></span>|<span data-ttu-id="49cac-361">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="49cac-361">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="49cac-362">Der Vergleich beginnt an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="49cac-362">Begin the match at a word boundary.</span></span>|  
|`(?:\w+)`|<span data-ttu-id="49cac-363">Übereinstimmung mit mindestens einem Wortzeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-363">Match one or more word characters.</span></span> <span data-ttu-id="49cac-364">Weisen Sie einer erfassten Gruppe den entsprechenden Text nicht zu.</span><span class="sxs-lookup"><span data-stu-id="49cac-364">Do not assign the matched text to a captured group.</span></span>|  
|`\W*`|<span data-ttu-id="49cac-365">Suchen Sie nach einer Übereinstimmung mit null oder mehr Nicht-Wortzeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-365">Match zero or more non-word characters.</span></span>|  
|`(?:\b(?:\w+)\W*)+`|<span data-ttu-id="49cac-366">Suchen Sie nach einer Übereinstimmung für das Muster aus einem oder mehreren Wortzeichen, beginnend bei einer Wortgrenze und gefolgt von null oder mehr Nicht-Wortzeichen (ein oder zwei Mal).</span><span class="sxs-lookup"><span data-stu-id="49cac-366">Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</span></span> <span data-ttu-id="49cac-367">Weisen Sie einer erfassten Gruppe den entsprechenden Text nicht zu.</span><span class="sxs-lookup"><span data-stu-id="49cac-367">Do not assign the matched text to a captured group.</span></span>|  
|`\.`|<span data-ttu-id="49cac-368">Entsprechung für einen Punkt finden.</span><span class="sxs-lookup"><span data-stu-id="49cac-368">Match a period.</span></span>|  
  
<a name="group_options"></a>

## <a name="group-options"></a><span data-ttu-id="49cac-369">Gruppenoptionen</span><span class="sxs-lookup"><span data-stu-id="49cac-369">Group Options</span></span>  

 <span data-ttu-id="49cac-370">Das folgende Gruppierungskonstrukt wendet die angegebenen Optionen in einem Teilausdruck an oder deaktiviert sie:</span><span class="sxs-lookup"><span data-stu-id="49cac-370">The following grouping construct applies or disables the specified options within a subexpression:</span></span>  
  
 <span data-ttu-id="49cac-371">`(?imnsx-imnsx:` *Teilausdruck* `)`</span><span class="sxs-lookup"><span data-stu-id="49cac-371">`(?imnsx-imnsx:` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="49cac-372">wobei *Teilausdruck* ein beliebiges gültiges Muster eines regulären Ausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-372">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="49cac-373">Beispielsweise aktiviert `(?i-s:)` die Einstellung, dass Groß-/Kleinschreibung nicht beachtet wird, und deaktiviert den Einzeilenmodus.</span><span class="sxs-lookup"><span data-stu-id="49cac-373">For example, `(?i-s:)` turns on case insensitivity and disables single-line mode.</span></span> <span data-ttu-id="49cac-374">Weitere Informationen zu den möglichen Inlineoptionen finden Sie unter [Optionen für reguläre Ausdrücke](regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="49cac-374">For more information about the inline options you can specify, see [Regular Expression Options](regular-expression-options.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="49cac-375">Sie können Optionen angeben, die für einen vollständigen regulären Ausdruck und nicht für einen Teilausdruck gültig sind. Verwenden Sie dazu einen <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> -Klassenkonstruktor oder eine statische Methode.</span><span class="sxs-lookup"><span data-stu-id="49cac-375">You can specify options that apply to an entire regular expression rather than a subexpression by using a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or a static method.</span></span> <span data-ttu-id="49cac-376">Sie können auch Inlineoptionen angeben, die nach einem bestimmten Punkt in einem regulären Ausdruck gelten. Verwenden Sie dazu das `(?imnsx-imnsx)` -Sprachkonstrukt.</span><span class="sxs-lookup"><span data-stu-id="49cac-376">You can also specify inline options that apply after a specific point in a regular expression by using the `(?imnsx-imnsx)` language construct.</span></span>  
  
 <span data-ttu-id="49cac-377">Das Konstrukt für die Gruppenoptionen ist keine Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-377">The group options construct is not a capturing group.</span></span> <span data-ttu-id="49cac-378">Obwohl ein beliebiger Teil einer Zeichenfolge, die von *subexpression* erfasst wird, in der Übereinstimmung enthalten ist, ist sie weder in einer erfassten Gruppe enthalten, noch wird sie dazu verwendet, das <xref:System.Text.RegularExpressions.GroupCollection> -Objekt aufzufüllen.</span><span class="sxs-lookup"><span data-stu-id="49cac-378">That is, although any portion of a string that is captured by *subexpression* is included in the match, it is not included in a captured group nor used to populate the <xref:System.Text.RegularExpressions.GroupCollection> object.</span></span>  
  
 <span data-ttu-id="49cac-379">Beispiel: Der reguläre Ausdruck `\b(?ix: d \w+)\s` verwendet Inlineoptionen in einem Gruppierungskonstrukt, um die Groß-/Kleinschreibung nicht beachtende Übereinstimmung zu aktivieren und Musterleerstellen beim Identifizieren aller Wörter zu ignorieren, die mit dem Buchstaben „d“ beginnen.</span><span class="sxs-lookup"><span data-stu-id="49cac-379">For example, the regular expression `\b(?ix: d \w+)\s` in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern white space in identifying all words that begin with the letter "d".</span></span> <span data-ttu-id="49cac-380">Der reguläre Ausdruck wird entsprechend der Darstellung in der folgenden Tabelle definiert:</span><span class="sxs-lookup"><span data-stu-id="49cac-380">The regular expression is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="49cac-381">Muster</span><span class="sxs-lookup"><span data-stu-id="49cac-381">Pattern</span></span>|<span data-ttu-id="49cac-382">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="49cac-382">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="49cac-383">Der Vergleich beginnt an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="49cac-383">Begin the match at a word boundary.</span></span>|  
|`(?ix: d \w+)`|<span data-ttu-id="49cac-384">In diesem Muster wird Übereinstimmung ohne Berücksichtigung von Groß- und Kleinschreibung verwendet, und Leerzeichen werden ignoriert (entspricht dem Buchstaben "d" gefolgt von mindestens einem Wortzeichen).</span><span class="sxs-lookup"><span data-stu-id="49cac-384">Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</span></span>|  
|`\s`|<span data-ttu-id="49cac-385">Entsprechung für ein Leerraumzeichen finden.</span><span class="sxs-lookup"><span data-stu-id="49cac-385">Match a white-space character.</span></span>|  
  
 [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
 [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
<a name="zerowidth_positive_lookahead_assertion"></a>

## <a name="zero-width-positive-lookahead-assertions"></a><span data-ttu-id="49cac-386">Positive Lookaheadassertionen mit einer Breite von Null</span><span class="sxs-lookup"><span data-stu-id="49cac-386">Zero-Width Positive Lookahead Assertions</span></span>  

 <span data-ttu-id="49cac-387">Das folgende Gruppierungskonstrukt definiert eine positive Lookaheadassertion mit einer Breite von Null:</span><span class="sxs-lookup"><span data-stu-id="49cac-387">The following grouping construct defines a zero-width positive lookahead assertion:</span></span>  
  
 <span data-ttu-id="49cac-388">`(?=` *Teilausdruck* `)`</span><span class="sxs-lookup"><span data-stu-id="49cac-388">`(?=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="49cac-389">wobei *Teilausdruck* ein beliebiges Muster eines regulären Ausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-389">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="49cac-390">Damit eine Übereinstimmung erfolgreich ist, muss die Eingabezeichenfolge mit dem regulären Ausdrucksmuster in *subexpression* übereinstimmen, obwohl der übereinstimmende Teilausdruck nicht im Übereinstimmungsergebnis enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-390">For a match to be successful, the input string must match the regular expression pattern in *subexpression*, although the matched substring is not included in the match result.</span></span> <span data-ttu-id="49cac-391">Eine positive Lookaheadassertion mit einer Breite von Null wird nicht zurückverfolgt.</span><span class="sxs-lookup"><span data-stu-id="49cac-391">A zero-width positive lookahead assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="49cac-392">In der Regel befindet sich eine positive Lookaheadassertion mit einer Breite von Null am Ende eines Musters eines regulären Ausdrucks.</span><span class="sxs-lookup"><span data-stu-id="49cac-392">Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</span></span> <span data-ttu-id="49cac-393">Damit wird eine Teilzeichenfolge definiert, die am Ende einer Zeichenfolge gefunden werden muss, damit eine Übereinstimmung vorliegt, jedoch nicht in der Übereinstimmung enthalten sein soll.</span><span class="sxs-lookup"><span data-stu-id="49cac-393">It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</span></span> <span data-ttu-id="49cac-394">Dies ist auch zum Verhindern einer übermäßigen Rückverfolgung nützlich.</span><span class="sxs-lookup"><span data-stu-id="49cac-394">It is also useful for preventing excessive backtracking.</span></span> <span data-ttu-id="49cac-395">Sie können eine Lookaheadassertion mit einer Breite von Null verwenden, um sicherzustellen, dass eine bestimmte Erfassungsgruppe mit Text beginnt, der einer Teilmenge des Musters entspricht, das für diese Erfassungsgruppe definiert ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-395">You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</span></span> <span data-ttu-id="49cac-396">Wenn z. B. eine Erfassungsgruppe aufeinander folgenden Wortzeichen entspricht, können Sie mit einer positiven Lookaheadassertion mit einer Breite von Null anfordern, dass das erste Zeichen ein alphabetischer Großbuchstabe ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-396">For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</span></span>  
  
 <span data-ttu-id="49cac-397">Im folgenden Beispiel wird mithilfe einer positiven Lookaheadassertion mit einer Breite von Null eine Entsprechung für das Wort gesucht, das dem Verb "is" in der Eingabezeichenfolge vorausgeht.</span><span class="sxs-lookup"><span data-stu-id="49cac-397">The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#6](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookahead1.cs#6)]
 [!code-vb[RegularExpressions.Language.Grouping#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookahead1.vb#6)]  
  
 <span data-ttu-id="49cac-398">Der reguläre Ausdruck `\b\w+(?=\sis\b)` wird entsprechend der Darstellung in der folgenden Tabelle interpretiert.</span><span class="sxs-lookup"><span data-stu-id="49cac-398">The regular expression `\b\w+(?=\sis\b)` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="49cac-399">Muster</span><span class="sxs-lookup"><span data-stu-id="49cac-399">Pattern</span></span>|<span data-ttu-id="49cac-400">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="49cac-400">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="49cac-401">Der Vergleich beginnt an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="49cac-401">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="49cac-402">Übereinstimmung mit mindestens einem Wortzeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-402">Match one or more word characters.</span></span>|  
|`(?=\sis\b)`|<span data-ttu-id="49cac-403">Bestimmen Sie, ob den Wortzeichen ein Leerstellenzeichen und die Zeichenfolge "is" folgt, die bei einer Wortgrenze endet.</span><span class="sxs-lookup"><span data-stu-id="49cac-403">Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</span></span> <span data-ttu-id="49cac-404">Trifft dies zu, ist die Übereinstimmung erfolgreich.</span><span class="sxs-lookup"><span data-stu-id="49cac-404">If so, the match is successful.</span></span>|  
  
<a name="zerowidth_negative_lookahead_assertion"></a>

## <a name="zero-width-negative-lookahead-assertions"></a><span data-ttu-id="49cac-405">Negative Lookaheadassertionen mit einer Breite von Null</span><span class="sxs-lookup"><span data-stu-id="49cac-405">Zero-Width Negative Lookahead Assertions</span></span>  

 <span data-ttu-id="49cac-406">Das folgende Gruppierungskonstrukt definiert eine negative Lookaheadassertion mit einer Breite von Null:</span><span class="sxs-lookup"><span data-stu-id="49cac-406">The following grouping construct defines a zero-width negative lookahead assertion:</span></span>  
  
 <span data-ttu-id="49cac-407">`(?!` *Teilausdruck* `)`</span><span class="sxs-lookup"><span data-stu-id="49cac-407">`(?!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="49cac-408">wobei *Teilausdruck* ein beliebiges Muster eines regulären Ausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-408">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="49cac-409">Damit die Übereinstimmung erfolgreich ist, darf die Eingabezeichenfolge mit dem regulären Ausdrucksmuster in *subexpression* nicht übereinstimmen, obwohl die übereinstimmende Zeichenfolge nicht im Übereinstimmungsergebnis enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-409">For the match to be successful, the input string must not match the regular expression pattern in *subexpression*, although the matched string is not included in the match result.</span></span>  
  
 <span data-ttu-id="49cac-410">Eine negative Lookaheadassertion mit einer Breite von Null wird in der Regel entweder am Anfang oder dem Ende eines regulären Ausdrucks verwendet.</span><span class="sxs-lookup"><span data-stu-id="49cac-410">A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</span></span> <span data-ttu-id="49cac-411">Am Anfang eines regulären Ausdrucks kann ein bestimmtes Muster definiert werden, das nicht zugewiesen werden soll, wenn der Anfang des regulären Ausdrucks ein ähnliches aber allgemeineres Muster zur Übereinstimmung definiert.</span><span class="sxs-lookup"><span data-stu-id="49cac-411">At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</span></span> <span data-ttu-id="49cac-412">In diesem Fall wird dies häufig verwendet, um das Zurückverfolgen einzuschränken.</span><span class="sxs-lookup"><span data-stu-id="49cac-412">In this case, it is often used to limit backtracking.</span></span> <span data-ttu-id="49cac-413">Am Ende eines regulären Ausdrucks kann ein Teilausdruck definiert werden, der am Ende einer Übereinstimmung nicht auftreten darf.</span><span class="sxs-lookup"><span data-stu-id="49cac-413">At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</span></span>  
  
 <span data-ttu-id="49cac-414">Im folgenden Beispiel wird ein regulärer Ausdruck definiert, der am Anfang des regulären Ausdrucks eine Lookaheadassertion mit einer Breite von Null verwendet, um eine Entsprechung für Wörter zu finden, die nicht mit "un" beginnen.</span><span class="sxs-lookup"><span data-stu-id="49cac-414">The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#7](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead1.cs#7)]
 [!code-vb[RegularExpressions.Language.Grouping#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead1.vb#7)]  
  
 <span data-ttu-id="49cac-415">Der reguläre Ausdruck `\b(?!un)\w+\b` wird entsprechend der Darstellung in der folgenden Tabelle interpretiert.</span><span class="sxs-lookup"><span data-stu-id="49cac-415">The regular expression `\b(?!un)\w+\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="49cac-416">Muster</span><span class="sxs-lookup"><span data-stu-id="49cac-416">Pattern</span></span>|<span data-ttu-id="49cac-417">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="49cac-417">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="49cac-418">Der Vergleich beginnt an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="49cac-418">Begin the match at a word boundary.</span></span>|  
|`(?!un)`|<span data-ttu-id="49cac-419">Es wird bestimmt, ob die nächsten zwei Zeichen "un" sind.</span><span class="sxs-lookup"><span data-stu-id="49cac-419">Determine whether the next two characters are "un".</span></span> <span data-ttu-id="49cac-420">Trifft dies nicht zu, ist eine Übereinstimmung möglich.</span><span class="sxs-lookup"><span data-stu-id="49cac-420">If they are not, a match is possible.</span></span>|  
|`\w+`|<span data-ttu-id="49cac-421">Übereinstimmung mit mindestens einem Wortzeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-421">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="49cac-422">Der Vergleich endet an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="49cac-422">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="49cac-423">Im folgenden Beispiel wird ein regulärer Ausdruck definiert, der am Ende eine Lookaheadassertion mit einer Breite von Null verwendet, um eine Entsprechung für Wörter zu finden, die nicht mit einem Interpunktionszeichen enden.</span><span class="sxs-lookup"><span data-stu-id="49cac-423">The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#8](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead2.cs#8)]
 [!code-vb[RegularExpressions.Language.Grouping#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead2.vb#8)]  
  
 <span data-ttu-id="49cac-424">Der reguläre Ausdruck `\b\w+\b(?!\p{P})` wird entsprechend der Darstellung in der folgenden Tabelle interpretiert.</span><span class="sxs-lookup"><span data-stu-id="49cac-424">The regular expression `\b\w+\b(?!\p{P})` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="49cac-425">Muster</span><span class="sxs-lookup"><span data-stu-id="49cac-425">Pattern</span></span>|<span data-ttu-id="49cac-426">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="49cac-426">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="49cac-427">Der Vergleich beginnt an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="49cac-427">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="49cac-428">Übereinstimmung mit mindestens einem Wortzeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-428">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="49cac-429">Der Vergleich endet an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="49cac-429">End the match at a word boundary.</span></span>|  
|`\p{P})`|<span data-ttu-id="49cac-430">Wenn das nächste Zeichen kein Interpunktionszeichen (z. B. ein Punkt oder ein Komma) ist, ist die Übereinstimmung erfolgreich.</span><span class="sxs-lookup"><span data-stu-id="49cac-430">If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</span></span>|  
  
<a name="zerowidth_positive_lookbehind_assertion"></a>

## <a name="zero-width-positive-lookbehind-assertions"></a><span data-ttu-id="49cac-431">Positive Lookbehindassertionen mit einer Breite von Null</span><span class="sxs-lookup"><span data-stu-id="49cac-431">Zero-Width Positive Lookbehind Assertions</span></span>  

 <span data-ttu-id="49cac-432">Das folgende Gruppierungskonstrukt definiert eine positive Lookbehindassertion mit einer Breite von Null:</span><span class="sxs-lookup"><span data-stu-id="49cac-432">The following grouping construct defines a zero-width positive lookbehind assertion:</span></span>  
  
 <span data-ttu-id="49cac-433">`(?<=` *Teilausdruck* `)`</span><span class="sxs-lookup"><span data-stu-id="49cac-433">`(?<=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="49cac-434">wobei *Teilausdruck* ein beliebiges Muster eines regulären Ausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-434">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="49cac-435">Damit eine Übereinstimmung erfolgreich ist, muss der *subexpression* in der Eingabezeichenfolge links von der aktuellen Position auftreten, obwohl `subexpression` nicht im Übereinstimmungsergebnis enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-435">For a match to be successful, *subexpression* must occur at the input string to the left of the current position, although `subexpression` is not included in the match result.</span></span> <span data-ttu-id="49cac-436">Eine positive Lookbehindassertion mit einer Breite von Null wird nicht zurückverfolgt.</span><span class="sxs-lookup"><span data-stu-id="49cac-436">A zero-width positive lookbehind assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="49cac-437">Positive Lookbehindassertionen mit einer Breite von Null werden in der Regel entweder am Anfang oder am Ende von regulären Ausdrücken verwendet.</span><span class="sxs-lookup"><span data-stu-id="49cac-437">Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="49cac-438">Das Muster, das sie definieren, ist eine Vorbedingung für eine Übereinstimmung, obwohl es kein Teil des Übereinstimmungsergebnisses ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-438">The pattern that they define is a precondition for a match, although it is not a part of the match result.</span></span>  
  
 <span data-ttu-id="49cac-439">Im folgenden Beispiel wird eine Entsprechung für die letzten zwei Ziffern des Jahres für das 21. Jahrhundert (das heißt, es ist erforderlich, dass die Ziffern "20" der entsprechenden Zeichenfolge vorausgehen) gefunden.</span><span class="sxs-lookup"><span data-stu-id="49cac-439">For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#9](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookbehind1.cs#9)]
 [!code-vb[RegularExpressions.Language.Grouping#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookbehind1.vb#9)]  
  
 <span data-ttu-id="49cac-440">Das Muster für reguläre Ausdrücke `(?<=\b20)\d{2}\b` wird entsprechend der folgenden Tabelle interpretiert:</span><span class="sxs-lookup"><span data-stu-id="49cac-440">The regular expression pattern `(?<=\b20)\d{2}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="49cac-441">Muster</span><span class="sxs-lookup"><span data-stu-id="49cac-441">Pattern</span></span>|<span data-ttu-id="49cac-442">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="49cac-442">Description</span></span>|  
|-------------|-----------------|  
|`\d{2}`|<span data-ttu-id="49cac-443">Entsprechung für zwei Dezimalstellen finden.</span><span class="sxs-lookup"><span data-stu-id="49cac-443">Match two decimal digits.</span></span>|  
|`(?<=\b20)`|<span data-ttu-id="49cac-444">Die Übereinstimmung wird fortgesetzt, wenn den zwei Dezimalstellen die Dezimalstellen "20" bei einer Wortgrenze vorangestellt sind.</span><span class="sxs-lookup"><span data-stu-id="49cac-444">Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</span></span>|  
|`\b`|<span data-ttu-id="49cac-445">Der Vergleich endet an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="49cac-445">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="49cac-446">Positive Lookbehindassertions mit einer Breite von Null werden auch verwendet, um das Zurückverfolgen einzuschränken, wenn die letzten Zeichen in einer Erfassungsgruppe eine Teilmenge der Zeichen sein müssen, die dem Muster eines regulären Ausdrucks dieser Gruppe entsprechen.</span><span class="sxs-lookup"><span data-stu-id="49cac-446">Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="49cac-447">Wenn beispielsweise eine Gruppe alle aufeinander folgenden Wortzeichen erfasst, können Sie mit einer positiven Lookaheadassertion mit einer Breite von Null anfordern, dass das letzte Zeichen alphabetisch ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-447">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</span></span>  
  
<a name="zerowidth_negative_lookbehind_assertion"></a>

## <a name="zero-width-negative-lookbehind-assertions"></a><span data-ttu-id="49cac-448">Negative Lookbehindassertionen mit einer Breite von Null</span><span class="sxs-lookup"><span data-stu-id="49cac-448">Zero-Width Negative Lookbehind Assertions</span></span>  

 <span data-ttu-id="49cac-449">Das folgende Gruppierungskonstrukt definiert eine negative Lookbehindassertion mit einer Breite von Null:</span><span class="sxs-lookup"><span data-stu-id="49cac-449">The following grouping construct defines a zero-width negative lookbehind assertion:</span></span>  
  
 <span data-ttu-id="49cac-450">`(?<!` *Teilausdruck* `)`</span><span class="sxs-lookup"><span data-stu-id="49cac-450">`(?<!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="49cac-451">wobei *Teilausdruck* ein beliebiges Muster eines regulären Ausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-451">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="49cac-452">Damit eine Übereinstimmung erfolgreich ist, darf der *subexpression* nicht in der Eingabezeichenfolge links von der aktuellen Position auftreten.</span><span class="sxs-lookup"><span data-stu-id="49cac-452">For a match to be successful, *subexpression* must not occur at the input string to the left of the current position.</span></span> <span data-ttu-id="49cac-453">Jede Teilzeichenfolge, die nicht mit `subexpression` übereinstimmt, ist nicht im Übereinstimmungsergebnis enthalten.</span><span class="sxs-lookup"><span data-stu-id="49cac-453">However, any substring that does not match `subexpression` is not included in the match result.</span></span>  
  
 <span data-ttu-id="49cac-454">Negative Lookbehindassertionen mit einer Breite von Null werden in der Regel entweder am Anfang oder am Ende von regulären Ausdrücken verwendet.</span><span class="sxs-lookup"><span data-stu-id="49cac-454">Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="49cac-455">Das Muster, das sie definieren, schließt eine Übereinstimmung in der darauf folgenden Zeichenfolge aus.</span><span class="sxs-lookup"><span data-stu-id="49cac-455">The pattern that they define precludes a match in the string that follows.</span></span> <span data-ttu-id="49cac-456">Sie werden auch verwendet, um die Rückverfolgung einzuschränken, wenn die letzten Zeichen in einer erfassten Gruppe keine Zeichen sein dürfen, die dem Muster eines regulären Ausdrucks dieser Gruppe entsprechen.</span><span class="sxs-lookup"><span data-stu-id="49cac-456">They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="49cac-457">Wenn beispielsweise eine Gruppe alle aufeinander folgenden Wortzeichen erfasst, können Sie mit einer positiven Lookbehindassertion mit einer Breite von 0 (null) anfordern, dass das letzte Zeichen kein Unterstrich (\_) ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-457">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (\_).</span></span>  
  
 <span data-ttu-id="49cac-458">Im folgenden Beispiel wird eine Entsprechung für das Datum eines die oft ausgegebene Befehlszeilen  Wochentags gesucht, der nicht auf das Wochenende (das heißt weder Samstag noch Sonntag) fällt.</span><span class="sxs-lookup"><span data-stu-id="49cac-458">The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#10](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookbehind1.cs#10)]
 [!code-vb[RegularExpressions.Language.Grouping#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookbehind1.vb#10)]  
  
 <span data-ttu-id="49cac-459">Das Muster für reguläre Ausdrücke `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` wird entsprechend der folgenden Tabelle interpretiert:</span><span class="sxs-lookup"><span data-stu-id="49cac-459">The regular expression pattern `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="49cac-460">Muster</span><span class="sxs-lookup"><span data-stu-id="49cac-460">Pattern</span></span>|<span data-ttu-id="49cac-461">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="49cac-461">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="49cac-462">Der Vergleich beginnt an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="49cac-462">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="49cac-463">Suchen Sie nach einer Übereinstimmung mit einem oder mehreren Wortzeichen gefolgt von einem Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-463">Match one or more word characters followed by a white-space character.</span></span>|  
|`\d{1,2},`|<span data-ttu-id="49cac-464">Finden Sie eine Entsprechung für entweder eine oder zwei Dezimalstellen, gefolgt von einem Leerstellenzeichen und einem Komma.</span><span class="sxs-lookup"><span data-stu-id="49cac-464">Match either one or two decimal digits followed by a white-space character and a comma.</span></span>|  
|`\d{4}\b`|<span data-ttu-id="49cac-465">Finden Sie eine Entsprechung für vier Dezimalstellen, und beenden Sie die Übereinstimmung an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="49cac-465">Match four decimal digits, and end the match at a word boundary.</span></span>|  
|<code>(?<!(Saturday&#124;Sunday) )</code>|<span data-ttu-id="49cac-466">Wenn der Übereinstimmung etwas anderes als die Zeichenfolgen "Samstag" oder "Sonntag" (gefolgt von einem Leerzeichen) vorangestellt wird, ist die Übereinstimmung erfolgreich.</span><span class="sxs-lookup"><span data-stu-id="49cac-466">If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</span></span>|  
  
<a name="atomic_groups"></a>

## <a name="atomic-groups"></a><span data-ttu-id="49cac-467">Atomische Gruppen</span><span class="sxs-lookup"><span data-stu-id="49cac-467">Atomic groups</span></span>  

 <span data-ttu-id="49cac-468">Die folgenden Gruppierungskonstrukte stellen eine atomische Gruppe dar (in anderen Engines für reguläre Ausdrücke als Teilausdruck ohne Rückverfolgung, als atomischer Teilausdruck oder einmaliger Teilausdruck bekannt):</span><span class="sxs-lookup"><span data-stu-id="49cac-468">The following grouping construct represents an atomic group (known in some other regular expression engines as a nonbacktracking subexpression, an atomic subexpression, or a once-only subexpression):</span></span>
  
 <span data-ttu-id="49cac-469">`(?>` *Teilausdruck* `)`</span><span class="sxs-lookup"><span data-stu-id="49cac-469">`(?>` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="49cac-470">wobei *Teilausdruck* ein beliebiges Muster eines regulären Ausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-470">where *subexpression* is any regular expression pattern.</span></span>  
  
 <span data-ttu-id="49cac-471">Wenn ein regulärer Ausdruck ein optionales oder alternatives übereinstimmendes Muster einschließt und eine Übereinstimmung nicht erfolgreich ist, kann sich die Engine für reguläre Ausdrücke in mehrere Richtungen verzweigen, um eine Entsprechung zwischen einer Eingabezeichenfolge und einem Muster zu finden.</span><span class="sxs-lookup"><span data-stu-id="49cac-471">Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</span></span> <span data-ttu-id="49cac-472">Wenn eine Übereinstimmung nach der ersten Verzweigung nicht gefunden wird, kann die Engine für reguläre Ausdrücke den Punkt der ersten Übereinstimmung sichern bzw. den Punkt zurückverfolgen und die Übereinstimmung mithilfe der zweiten Verzweigung durchführen.</span><span class="sxs-lookup"><span data-stu-id="49cac-472">If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</span></span> <span data-ttu-id="49cac-473">Dieser Prozess kann fortgesetzt werden, bis alle Verzweigungen versucht wurden.</span><span class="sxs-lookup"><span data-stu-id="49cac-473">This process can continue until all branches have been tried.</span></span>  
  
 <span data-ttu-id="49cac-474">Die `(?>`*Teilausdruck*`)` deaktiviert die Rückverfolgung.</span><span class="sxs-lookup"><span data-stu-id="49cac-474">The `(?>`*subexpression*`)` language construct disables backtracking.</span></span> <span data-ttu-id="49cac-475">Die Engine für reguläre Ausdrücke stimmt mit so vielen Zeichen in der Eingabezeichenfolge überein wie möglich.</span><span class="sxs-lookup"><span data-stu-id="49cac-475">The regular expression engine will match as many characters in the input string as it can.</span></span> <span data-ttu-id="49cac-476">Wenn keine weitere Übereinstimmung möglich ist, findet keine Rückverfolgung statt, um alternative Musterübereinstimmungen zu versuchen.</span><span class="sxs-lookup"><span data-stu-id="49cac-476">When no further match is possible, it will not backtrack to attempt alternate pattern matches.</span></span> <span data-ttu-id="49cac-477">(Das heißt, der Teilausdruck sucht nur Entsprechungen für Zeichenfolgen, zu denen der Teilausdruck allein passen würde. Er versucht nicht, eine Entsprechung für eine Zeichenfolge auf Grundlage des Teilausdrucks und beliebige folgende Teilausdrücke zu finden.)</span><span class="sxs-lookup"><span data-stu-id="49cac-477">(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</span></span>  
  
 <span data-ttu-id="49cac-478">Diese Option wird empfohlen, wenn Sie wissen, dass eine Rückverfolgung nicht erfolgreich ist.</span><span class="sxs-lookup"><span data-stu-id="49cac-478">This option is recommended if you know that backtracking will not succeed.</span></span> <span data-ttu-id="49cac-479">Indem verhindert wird, dass von der Engine für reguläre Ausdrücke unnötige Suchläufe durchgeführt werden, wird die Leistung verbessert.</span><span class="sxs-lookup"><span data-stu-id="49cac-479">Preventing the regular expression engine from performing unnecessary searching improves performance.</span></span>  
  
 <span data-ttu-id="49cac-480">Im folgenden Beispiel wird veranschaulicht, wie eine atomische Gruppe die Ergebnisse einer Musterübereinstimmung ändert.</span><span class="sxs-lookup"><span data-stu-id="49cac-480">The following example illustrates how an atomic group modifies the results of a pattern match.</span></span> <span data-ttu-id="49cac-481">Der rückverfolgende reguläre Ausdruck findet erfolgreich eine Entsprechung für eine Reihe von Zeichen, die von einem weiteren Vorkommen des gleichen Zeichens bei einer Wortgrenze gefolgt wird. Beim regulären Ausdruck ohne Rückverfolgung ist dies nicht der Fall.</span><span class="sxs-lookup"><span data-stu-id="49cac-481">The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#11](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/nonbacktracking1.cs#11)]
 [!code-vb[RegularExpressions.Language.Grouping#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/nonbacktracking1.vb#11)]  
  
 <span data-ttu-id="49cac-482">Der nicht zurückverfolgende reguläre Ausdruck `(?>(\w)\1+).\b` wird entsprechend der folgenden Tabelle definiert.</span><span class="sxs-lookup"><span data-stu-id="49cac-482">The nonbacktracking regular expression `(?>(\w)\1+).\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="49cac-483">Muster</span><span class="sxs-lookup"><span data-stu-id="49cac-483">Pattern</span></span>|<span data-ttu-id="49cac-484">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="49cac-484">Description</span></span>|  
|-------------|-----------------|  
|`(\w)`|<span data-ttu-id="49cac-485">Finden Sie eine Entsprechung für ein einzelnes Wortzeichen, und weisen Sie es der ersten Erfassungsgruppe zu.</span><span class="sxs-lookup"><span data-stu-id="49cac-485">Match a single word character and assign it to the first capturing group.</span></span>|  
|`\1+`|<span data-ttu-id="49cac-486">Finden Sie mindestens eine Entsprechung für die erste erfasste Teilzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="49cac-486">Match the value of the first captured substring one or more times.</span></span>|  
|`.`|<span data-ttu-id="49cac-487">Finden Sie eine Entsprechung für ein beliebiges Zeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-487">Match any character.</span></span>|  
|`\b`|<span data-ttu-id="49cac-488">Beendet den Vergleich an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="49cac-488">End the match on a word boundary.</span></span>|  
|`(?>(\w)\1+)`|<span data-ttu-id="49cac-489">Finden Sie eine Entsprechung für ein oder mehrere Vorkommen eines duplizierten Wortzeichens, führen Sie jedoch keine Rückverfolgung aus, um für das letzte Zeichen bei einer Wortgrenze eine Entsprechung zu finden.</span><span class="sxs-lookup"><span data-stu-id="49cac-489">Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</span></span>|  
  
<a name="Objects"></a>

## <a name="grouping-constructs-and-regular-expression-objects"></a><span data-ttu-id="49cac-490">Gruppieren von Konstrukten und Objekten für reguläre Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="49cac-490">Grouping Constructs and Regular Expression Objects</span></span>  

 <span data-ttu-id="49cac-491">Teilzeichenfolgen, die von einer Erfassungsgruppe für reguläre Ausdrücke abgeglichen werden, werden durch <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> -Objekte dargestellt, die aus dem <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> -Objekt abgerufen werden können, das von der <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> -Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-491">Substrings that are matched by a regular expression capturing group are represented by <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objects, which can be retrieved from the <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> object that is returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="49cac-492">Das <xref:System.Text.RegularExpressions.GroupCollection> -Objekt wird folgendermaßen aufgefüllt:</span><span class="sxs-lookup"><span data-stu-id="49cac-492">The <xref:System.Text.RegularExpressions.GroupCollection> object is populated as follows:</span></span>  
  
- <span data-ttu-id="49cac-493">Das erste <xref:System.Text.RegularExpressions.Group> -Objekt in der Auflistung (das Objekt bei Index 0) stellt die gesamte Übereinstimmung dar.</span><span class="sxs-lookup"><span data-stu-id="49cac-493">The first <xref:System.Text.RegularExpressions.Group> object in the collection (the object at index zero) represents the entire match.</span></span>  
  
- <span data-ttu-id="49cac-494">Der nächste Satz von <xref:System.Text.RegularExpressions.Group> -Objekten stellt unbenannte (nummerierte) Erfassungsgruppen dar.</span><span class="sxs-lookup"><span data-stu-id="49cac-494">The next set of <xref:System.Text.RegularExpressions.Group> objects represent unnamed (numbered) capturing groups.</span></span> <span data-ttu-id="49cac-495">Sie werden in der Reihenfolge angezeigt, in der sie im regulären Ausdruck definiert sind (von links nach rechts).</span><span class="sxs-lookup"><span data-stu-id="49cac-495">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="49cac-496">Die Indexwerte dieser Gruppen reichen von 1 bis zur Anzahl unbenannter Erfassungsgruppen in der Auflistung.</span><span class="sxs-lookup"><span data-stu-id="49cac-496">The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</span></span> <span data-ttu-id="49cac-497">(Der Index einer bestimmten Gruppe entspricht seinem nummerierten Rückverweis.</span><span class="sxs-lookup"><span data-stu-id="49cac-497">(The index of a particular group is equivalent to its numbered backreference.</span></span> <span data-ttu-id="49cac-498">Weitere Informationen zu Rückverweisen finden Sie unter [Rückverweiskonstrukte in regulären Ausdrücken](backreference-constructs-in-regular-expressions.md).)</span><span class="sxs-lookup"><span data-stu-id="49cac-498">For more information about backreferences, see [Backreference Constructs](backreference-constructs-in-regular-expressions.md).)</span></span>  
  
- <span data-ttu-id="49cac-499">Der endgültige Satz von <xref:System.Text.RegularExpressions.Group> -Objekten stellt benannte Erfassungsgruppen dar.</span><span class="sxs-lookup"><span data-stu-id="49cac-499">The final set of <xref:System.Text.RegularExpressions.Group> objects represent named capturing groups.</span></span> <span data-ttu-id="49cac-500">Sie werden in der Reihenfolge angezeigt, in der sie im regulären Ausdruck definiert sind (von links nach rechts).</span><span class="sxs-lookup"><span data-stu-id="49cac-500">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="49cac-501">Der Indexwert der zuerst benannten Erfassungsgruppe ist um eins größer als der Index der letzten unbenannten Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-501">The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</span></span> <span data-ttu-id="49cac-502">Wenn es keine unbenannten Erfassungsgruppen im regulären Ausdruck gibt, ist der Indexwert der zuerst benannten Erfassungsgruppe gleich eins.</span><span class="sxs-lookup"><span data-stu-id="49cac-502">If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</span></span>  
  
 <span data-ttu-id="49cac-503">Wenn Sie einen Quantifizierer auf eine Erfassungsgruppe anwenden, reflektieren die entsprechenden <xref:System.Text.RegularExpressions.Group> -, <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>- und <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>-Eigenschaften des <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> -Objekts die letzte Teilzeichenfolge, die von einer Erfassungsgruppe erfasst wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-503">If you apply a quantifier to a capturing group, the corresponding <xref:System.Text.RegularExpressions.Group> object's <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, and <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> properties reflect the last substring that is captured by a capturing group.</span></span> <span data-ttu-id="49cac-504">Sie können einen vollständigen Satz von Teilzeichenfolgen abrufen, die von Gruppen erfasst werden, die Quantifizierer vom <xref:System.Text.RegularExpressions.CaptureCollection> -Objekt besitzen, das von der <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> -Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="49cac-504">You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <xref:System.Text.RegularExpressions.CaptureCollection> object that is returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="49cac-505">Im folgenden Beispiel wird die Beziehung zwischen den <xref:System.Text.RegularExpressions.Group> - und <xref:System.Text.RegularExpressions.Capture> -Objekten veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="49cac-505">The following example clarifies the relationship between the <xref:System.Text.RegularExpressions.Group> and <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/objectmodel1.cs#4)]
 [!code-vb[RegularExpressions.Language.Grouping#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/objectmodel1.vb#4)]  
  
 <span data-ttu-id="49cac-506">Das Muster eines regulären Ausdrucks `(\b(\w+)\W+)+` extrahiert einzelne Wörter aus einer Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="49cac-506">The regular expression pattern `(\b(\w+)\W+)+` extracts individual words from a string.</span></span> <span data-ttu-id="49cac-507">Das Muster wird wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="49cac-507">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="49cac-508">Muster</span><span class="sxs-lookup"><span data-stu-id="49cac-508">Pattern</span></span>|<span data-ttu-id="49cac-509">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="49cac-509">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="49cac-510">Der Vergleich beginnt an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="49cac-510">Begin the match at a word boundary.</span></span>|  
|`(\w+)`|<span data-ttu-id="49cac-511">Übereinstimmung mit mindestens einem Wortzeichen.</span><span class="sxs-lookup"><span data-stu-id="49cac-511">Match one or more word characters.</span></span> <span data-ttu-id="49cac-512">Zusammen bilden diese Zeichen ein Wort.</span><span class="sxs-lookup"><span data-stu-id="49cac-512">Together, these characters form a word.</span></span> <span data-ttu-id="49cac-513">Dies ist die zweite Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-513">This is the second capturing group.</span></span>|  
|`\W+`|<span data-ttu-id="49cac-514">Entsprechung für mindestens ein Nicht-Wortzeichen finden.</span><span class="sxs-lookup"><span data-stu-id="49cac-514">Match one or more non-word characters.</span></span>|  
|`(\b(\w+)\W+)`|<span data-ttu-id="49cac-515">Suchen Sie nach einer Übereinstimmung für das Muster aus einem oder mehreren Wortzeichen, gefolgt von einem oder mehreren Nicht-Wortzeichen (ein oder zwei Mal).</span><span class="sxs-lookup"><span data-stu-id="49cac-515">Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</span></span> <span data-ttu-id="49cac-516">Dies ist die erste Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="49cac-516">This is the first capturing group.</span></span>|  
  
 <span data-ttu-id="49cac-517">Die zweite Erfassungsgruppe stimmt mit jedem Wort des Satzes überein.</span><span class="sxs-lookup"><span data-stu-id="49cac-517">The second capturing group matches each word of the sentence.</span></span> <span data-ttu-id="49cac-518">Die erste Erfassungsgruppe stimmt mit jedem Wort sowie der Interpunktion und dem Leerraum überein, der auf die Worte folgt.</span><span class="sxs-lookup"><span data-stu-id="49cac-518">The first capturing group matches each word along with the punctuation and white space that follow the word.</span></span> <span data-ttu-id="49cac-519">Das <xref:System.Text.RegularExpressions.Group> -Objekt, dessen Index 2 ist, stellt Informationen zu dem Text bereit, der mit der zweiten Erfassungsgruppe übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="49cac-519">The <xref:System.Text.RegularExpressions.Group> object whose index is 2 provides information about the text matched by the second capturing group.</span></span> <span data-ttu-id="49cac-520">Der vollständige Satz von Wörtern, die von der Erfassungsgruppe erfasst wurden, ist vom <xref:System.Text.RegularExpressions.CaptureCollection> -Objekt verfügbar, das von der <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> -Eigenschaft zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="49cac-520">The complete set of words captured by the capturing group are available from the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="49cac-521">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="49cac-521">See also</span></span>

- [<span data-ttu-id="49cac-522">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</span><span class="sxs-lookup"><span data-stu-id="49cac-522">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
- [<span data-ttu-id="49cac-523">Backtracking</span><span class="sxs-lookup"><span data-stu-id="49cac-523">Backtracking</span></span>](backtracking-in-regular-expressions.md)
