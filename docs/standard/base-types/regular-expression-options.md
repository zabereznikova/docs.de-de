---
title: Optionen für reguläre Ausdrücke
description: Informationen zur Verwendung von Optionen für reguläre Ausdrücke in .NET, z. B. Übereinstimmungen ohne Berücksichtigung der Groß-/Kleinschreibung, der Mehrzeilenmodus und der Modus „Von rechts nach links“
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, options
- constructs, options
- .NET regular expressions, options
- inline option constructs
- options parameter
ms.assetid: c82dc689-7e82-4767-a18d-cd24ce5f05e9
ms.openlocfilehash: a77409476c8b2c1b32429118edbe6ad6542a7b09
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/18/2020
ms.locfileid: "94828945"
---
# <a name="regular-expression-options"></a><span data-ttu-id="5b98b-103">Optionen für reguläre Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="5b98b-103">Regular Expression Options</span></span>

<span data-ttu-id="5b98b-104">Standardmäßig wird beim Vergleich einer Eingabezeichenfolge mit Literalzeichen in einem Muster eines regulären Ausdrucks die Groß-/Kleinschreibung beachtet, Leerstellen in einem Muster eines regulären Ausdrucks werden als literale Leerstellenzeichen interpretiert, und Erfassungsgruppen in einem regulären Ausdruck werden implizit sowie explizit benannt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-104">By default, the comparison of an input string with any literal characters in a regular expression pattern is case sensitive, white space in a regular expression pattern is interpreted as literal white-space characters, and capturing groups in a regular expression are named implicitly as well as explicitly.</span></span> <span data-ttu-id="5b98b-105">Sie können diese und andere Aspekte des Standardverhaltens regulärer Ausdrücke ändern, indem Sie Optionen für reguläre Ausdrücke angeben.</span><span class="sxs-lookup"><span data-stu-id="5b98b-105">You can modify these and several other aspects of default regular expression behavior by specifying regular expression options.</span></span> <span data-ttu-id="5b98b-106">Diese Optionen, die in der folgenden Tabelle aufgeführt sind, können inline als Teil des Musters eines regulären Ausdrucks enthalten sein, oder sie können für einen <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType>-Klassenkonstruktor oder eine statische Musterabgleichsmethode als <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType>-Enumerationswert angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-106">These options, which are listed in the following table, can be included inline as part of the regular expression pattern, or they can be supplied to a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or static pattern matching method as a <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> enumeration value.</span></span>

|<span data-ttu-id="5b98b-107">RegexOptions-Member</span><span class="sxs-lookup"><span data-stu-id="5b98b-107">RegexOptions member</span></span>|<span data-ttu-id="5b98b-108">Inlinezeichen</span><span class="sxs-lookup"><span data-stu-id="5b98b-108">Inline character</span></span>|<span data-ttu-id="5b98b-109">Effekt</span><span class="sxs-lookup"><span data-stu-id="5b98b-109">Effect</span></span>|
|-------------------------|----------------------|------------|
|<xref:System.Text.RegularExpressions.RegexOptions.None>|<span data-ttu-id="5b98b-110">Nicht verfügbar</span><span class="sxs-lookup"><span data-stu-id="5b98b-110">Not available</span></span>|<span data-ttu-id="5b98b-111">Standardverfahren verwenden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-111">Use default behavior.</span></span> <span data-ttu-id="5b98b-112">Weitere Informationen finden Sie unter [Standardoptionen](#default-options).</span><span class="sxs-lookup"><span data-stu-id="5b98b-112">For more information, see [Default Options](#default-options).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>|`i`|<span data-ttu-id="5b98b-113">Groß-/Kleinschreibung bei der Suche ignorieren</span><span class="sxs-lookup"><span data-stu-id="5b98b-113">Use case-insensitive matching.</span></span> <span data-ttu-id="5b98b-114">Weitere Informationen finden Sie unter [Übereinstimmung ohne Berücksichtigung der Groß-/Kleinschreibung](#case-insensitive-matching).</span><span class="sxs-lookup"><span data-stu-id="5b98b-114">For more information, see [Case-Insensitive Matching](#case-insensitive-matching).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.Multiline>|`m`|<span data-ttu-id="5b98b-115">Verwenden Sie den Mehrzeilenmodus, in dem `^` und `$` dem Anfang und dem Ende jeder Zeile (und nicht dem Anfang und dem Ende der Eingabezeichenfolge) entsprechen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-115">Use multiline mode, where `^` and `$` match the beginning and end of each line (instead of the beginning and end of the input string).</span></span> <span data-ttu-id="5b98b-116">Weitere Informationen finden Sie unter [Mehrzeilenmodus](#multiline-mode).</span><span class="sxs-lookup"><span data-stu-id="5b98b-116">For more information, see [Multiline Mode](#multiline-mode).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.Singleline>|`s`|<span data-ttu-id="5b98b-117">Verwenden Sie Einzeilenmodus, in dem der Punkt (.) den einzelnen Zeichen entspricht (anstatt allen Zeichen mit Ausnahme von `\n`).</span><span class="sxs-lookup"><span data-stu-id="5b98b-117">Use single-line mode, where the period (.) matches every character (instead of every character except `\n`).</span></span> <span data-ttu-id="5b98b-118">Weitere Informationen finden Sie unter [Einzeilenmodus](#single-line-mode).</span><span class="sxs-lookup"><span data-stu-id="5b98b-118">For more information, see [Single-line Mode](#single-line-mode).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture>|`n`|<span data-ttu-id="5b98b-119">Unbenannte Gruppen nicht erfassen</span><span class="sxs-lookup"><span data-stu-id="5b98b-119">Do not capture unnamed groups.</span></span> <span data-ttu-id="5b98b-120">Die einzigen gültigen Erfassungen sind explizit benannte oder nummerierte Gruppen mit dem Format `(?<`*Name*`>` *Teilausdruck*`)`.</span><span class="sxs-lookup"><span data-stu-id="5b98b-120">The only valid captures are explicitly named or numbered groups of the form `(?<`*name*`>` *subexpression*`)`.</span></span> <span data-ttu-id="5b98b-121">Weitere Informationen finden Sie unter [Nur explizite Erfassungen](#explicit-captures-only).</span><span class="sxs-lookup"><span data-stu-id="5b98b-121">For more information, see [Explicit Captures Only](#explicit-captures-only).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.Compiled>|<span data-ttu-id="5b98b-122">Nicht verfügbar</span><span class="sxs-lookup"><span data-stu-id="5b98b-122">Not available</span></span>|<span data-ttu-id="5b98b-123">Kompiliert den regulären Ausdruck in eine Assembly.</span><span class="sxs-lookup"><span data-stu-id="5b98b-123">Compile the regular expression to an assembly.</span></span> <span data-ttu-id="5b98b-124">Weitere Informationen hierzu finden Sie unter [Kompilierte reguläre Ausdrücke](#compiled-regular-expressions).</span><span class="sxs-lookup"><span data-stu-id="5b98b-124">For more information, see [Compiled Regular Expressions](#compiled-regular-expressions).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace>|`x`|<span data-ttu-id="5b98b-125">Schließt Leerstellen ohne Escapezeichen vom Muster aus und aktiviert Kommentare nach einem Nummernzeichen (`#`).</span><span class="sxs-lookup"><span data-stu-id="5b98b-125">Exclude unescaped white space from the pattern, and enable comments after a number sign (`#`).</span></span> <span data-ttu-id="5b98b-126">Weitere Informationen finden Sie im Abschnitt [Ignorieren von Leerzeichen](#ignore-white-space).</span><span class="sxs-lookup"><span data-stu-id="5b98b-126">For more information, see [Ignore White Space](#ignore-white-space).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>|<span data-ttu-id="5b98b-127">Nicht verfügbar</span><span class="sxs-lookup"><span data-stu-id="5b98b-127">Not available</span></span>|<span data-ttu-id="5b98b-128">Ändert die Suchrichtung.</span><span class="sxs-lookup"><span data-stu-id="5b98b-128">Change the search direction.</span></span> <span data-ttu-id="5b98b-129">Die Suche wird von rechts nach links und nicht von links nach rechts durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-129">Search moves from right to left instead of from left to right.</span></span> <span data-ttu-id="5b98b-130">Weitere Informationen finden Sie unter [Rechts-nach-Links-Modus](#right-to-left-mode).</span><span class="sxs-lookup"><span data-stu-id="5b98b-130">For more information, see [Right-to-Left Mode](#right-to-left-mode).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.ECMAScript>|<span data-ttu-id="5b98b-131">Nicht verfügbar</span><span class="sxs-lookup"><span data-stu-id="5b98b-131">Not available</span></span>|<span data-ttu-id="5b98b-132">ECMAScript-kompatibles Verhalten für den Ausdruck aktivieren.</span><span class="sxs-lookup"><span data-stu-id="5b98b-132">Enable ECMAScript-compliant behavior for the expression.</span></span> <span data-ttu-id="5b98b-133">Weitere Informationen finden Sie unter [ECMAScript-Vergleichsverhalten](#ecmascript-matching-behavior).</span><span class="sxs-lookup"><span data-stu-id="5b98b-133">For more information, see [ECMAScript Matching Behavior](#ecmascript-matching-behavior).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant>|<span data-ttu-id="5b98b-134">Nicht verfügbar</span><span class="sxs-lookup"><span data-stu-id="5b98b-134">Not available</span></span>|<span data-ttu-id="5b98b-135">Ignoriert kulturelle Unterschiede in der Sprache.</span><span class="sxs-lookup"><span data-stu-id="5b98b-135">Ignore cultural differences in language.</span></span> <span data-ttu-id="5b98b-136">Weitere Informationen finden Sie unter [Vergleiche mit der invarianten Kultur](#comparison-using-the-invariant-culture).</span><span class="sxs-lookup"><span data-stu-id="5b98b-136">For more information, see [Comparison Using the Invariant Culture](#comparison-using-the-invariant-culture).</span></span>|

## <a name="specifying-the-options"></a><span data-ttu-id="5b98b-137">Angeben der Optionen</span><span class="sxs-lookup"><span data-stu-id="5b98b-137">Specifying the Options</span></span>

<span data-ttu-id="5b98b-138">Sie können Optionen für reguläre Ausdrücke mit einer von drei Methoden angeben:</span><span class="sxs-lookup"><span data-stu-id="5b98b-138">You can specify options for regular expressions in one of three ways:</span></span>

- <span data-ttu-id="5b98b-139">Im `options`-Parameter eines <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType>-Klassenkonstruktors oder einer statischen (`Shared` in Visual Basic) Mustervergleichsmethode, z. B. <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> oder <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5b98b-139">In the `options` parameter of a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or static (`Shared` in Visual Basic) pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> or <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5b98b-140">Der `options`-Parameter ist eine bitweise OR-Kombination von aufgezählten <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType>-Werten.</span><span class="sxs-lookup"><span data-stu-id="5b98b-140">The `options` parameter is a bitwise OR combination of <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> enumerated values.</span></span>

  <span data-ttu-id="5b98b-141">Wenn Optionen mit dem `options`-Parameter eines Klassenkonstruktors an eine <xref:System.Text.RegularExpressions.Regex>-Instanz übergeben werden, werden die Optionen der <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType>-Eigenschaft zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-141">When options are supplied to a <xref:System.Text.RegularExpressions.Regex> instance by using the `options` parameter of a class constructor, the options are assigned to the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="5b98b-142">Die <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType>-Eigenschaft gibt jedoch nicht die Inlineoptionen des eigentlichen Musters des regulären Ausdrucks wieder.</span><span class="sxs-lookup"><span data-stu-id="5b98b-142">However, the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property does not reflect inline options in the regular expression pattern itself.</span></span>

  <span data-ttu-id="5b98b-143">Dies wird im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="5b98b-143">The following example provides an illustration.</span></span> <span data-ttu-id="5b98b-144">Es verwendet den `options`-Parameter der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>-Methode, um Vergleiche ohne Berücksichtigung der Groß-/Kleinschreibung zu ermöglichen und das Ignorieren von Leerzeichenmustern zu aktivieren, wenn Wörter identifiziert werden, die mit dem Buchstaben "d" beginnen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-144">It uses the `options` parameter of the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#6)]
  [!code-vb[Conceptual.Regex.Language.Options#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#6)]

- <span data-ttu-id="5b98b-145">Durch das Übernehmen von Inlineoptionen in einem Muster eines regulären Ausdrucks mit der Syntax `(?imnsx-imnsx)`.</span><span class="sxs-lookup"><span data-stu-id="5b98b-145">By applying inline options in a regular expression pattern with the syntax `(?imnsx-imnsx)`.</span></span> <span data-ttu-id="5b98b-146">Die Option gilt für das Muster ab dem Punkt, an dem die Option definiert wird, bis zum Ende des Musters oder zu dem Punkt, an dem die Definition der Option von einer anderen Inlineoption aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="5b98b-146">The option applies to the pattern from the point that the option is defined to either the end of the pattern or to the point at which the option is undefined by another inline option.</span></span> <span data-ttu-id="5b98b-147">Beachten Sie, dass die <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType>-Eigenschaft einer <xref:System.Text.RegularExpressions.Regex>-Instanz diese Inlineoptionen nicht wiedergibt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-147">Note that the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property of a <xref:System.Text.RegularExpressions.Regex> instance does not reflect these inline options.</span></span> <span data-ttu-id="5b98b-148">Weitere Informationen finden Sie im Thema [Verschiedene Konstrukte](miscellaneous-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="5b98b-148">For more information, see the [Miscellaneous Constructs](miscellaneous-constructs-in-regular-expressions.md) topic.</span></span>

  <span data-ttu-id="5b98b-149">Dies wird im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="5b98b-149">The following example provides an illustration.</span></span> <span data-ttu-id="5b98b-150">Dabei werden Inlineoptionen verwendet, um Vergleiche ohne Berücksichtigung der Groß-/Kleinschreibung zu ermöglichen und das Ignorieren von Leerzeichenmustern zu aktivieren, wenn Wörter identifiziert werden, die mit dem Buchstaben "d" beginnen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-150">It uses inline options to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#7)]
  [!code-vb[Conceptual.Regex.Language.Options#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#7)]

- <span data-ttu-id="5b98b-151">Durch das Übernehmen von Inlineoptionen in einem bestimmten Gruppierungskonstrukt in einem Muster eines regulären Ausdrucks mit der Syntax `(?imnsx-imnsx:`*Teilausdruck*`)`.</span><span class="sxs-lookup"><span data-stu-id="5b98b-151">By applying inline options in a particular grouping construct in a regular expression pattern with the syntax `(?imnsx-imnsx:`*subexpression*`)`.</span></span> <span data-ttu-id="5b98b-152">Kein Vorzeichen vor einer Gruppe von Optionen aktiviert diese Optionen. Ein Minuszeichen deaktiviert sie.</span><span class="sxs-lookup"><span data-stu-id="5b98b-152">No sign before a set of options turns the set on; a minus sign before a set of options turns the set off.</span></span> <span data-ttu-id="5b98b-153">(`?` ist ein fester Bestandteil der Syntax des Sprachkonstrukts, der immer erforderlich ist, unabhängig davon, ob Optionen aktiviert oder deaktiviert sind.) Die Option wird nur auf diese Gruppe angewendet.</span><span class="sxs-lookup"><span data-stu-id="5b98b-153">(`?` is a fixed part of the language construct's syntax that is required whether options are enabled or disabled.) The option applies only to that group.</span></span> <span data-ttu-id="5b98b-154">Weitere Informationen finden Sie unter [Gruppierungskonstrukte](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="5b98b-154">For more information, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

  <span data-ttu-id="5b98b-155">Dies wird im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="5b98b-155">The following example provides an illustration.</span></span> <span data-ttu-id="5b98b-156">Dabei werden Inlineoptionen in einem Gruppierungskonstrukt verwendet, um Vergleiche ohne Berücksichtigung der Groß-/Kleinschreibung zu ermöglichen und das Ignorieren von Leerzeichenmustern zu aktivieren, wenn Wörter identifiziert werden, die mit dem Buchstaben "d" beginnen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-156">It uses inline options in a grouping construct to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
  [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]

<span data-ttu-id="5b98b-157">Wenn Optionen inline angegeben sind, deaktiviert ein Minuszeichen (`-`) vor einer Option oder einer Gruppe von Optionen diese Optionen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-157">If options are specified inline, a minus sign (`-`) before an option or set of options turns off those options.</span></span> <span data-ttu-id="5b98b-158">Das Inlinekonstrukt `(?ix-ms)` aktiviert z. B. die <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>-Option und die <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>-Option und deaktiviert die <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>-Option und die <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>-Option.</span><span class="sxs-lookup"><span data-stu-id="5b98b-158">For example, the inline construct `(?ix-ms)` turns on the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> options and turns off the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> options.</span></span> <span data-ttu-id="5b98b-159">Alle Optionen für reguläre Ausdrücke sind standardmäßig deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="5b98b-159">All regular expression options are turned off by default.</span></span>

> [!NOTE]
> <span data-ttu-id="5b98b-160">Wenn die Optionen für reguläre Ausdrücke im `options`-Parameter eines Konstruktors oder Methodenaufrufs im Konflikt mit den Optionen stehen, die inline in einem Muster eines regulären Ausdrucks angegeben wurden, werden die Inlineoptionen verwendet.</span><span class="sxs-lookup"><span data-stu-id="5b98b-160">If the regular expression options specified in the `options` parameter of a constructor or method call conflict with the options specified inline in a regular expression pattern, the inline options are used.</span></span>

<span data-ttu-id="5b98b-161">Die folgenden fünf Optionen für reguläre Ausdrücke können sowohl mit dem options-Parameter als auch inline festgelegt werden:</span><span class="sxs-lookup"><span data-stu-id="5b98b-161">The following five regular expression options can be set both with the options parameter and inline:</span></span>

- <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>

<span data-ttu-id="5b98b-162">Die folgenden fünf Optionen für reguläre Ausdrücke können mit dem `options`-Parameter, jedoch nicht inline festgelegt werden:</span><span class="sxs-lookup"><span data-stu-id="5b98b-162">The following five regular expression options can be set using the `options` parameter but cannot be set inline:</span></span>

- <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType>

## <a name="determining-the-options"></a><span data-ttu-id="5b98b-163">Ermitteln der Optionen</span><span class="sxs-lookup"><span data-stu-id="5b98b-163">Determining the Options</span></span>

<span data-ttu-id="5b98b-164">Sie können ermitteln, welche Optionen für ein <xref:System.Text.RegularExpressions.Regex>-Objekt bereitgestellt wurden, als es instanziiert wurde, indem der Wert der schreibgeschützten <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType>-Eigenschaft abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="5b98b-164">You can determine which options were provided to a <xref:System.Text.RegularExpressions.Regex> object when it was instantiated by retrieving the value of the read-only <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="5b98b-165">Diese Eigenschaft ist besonders nützlich zum Ermitteln der Optionen, die für einen von der <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>-Methode erstellten kompilierten regulären Ausdruck definiert sind.</span><span class="sxs-lookup"><span data-stu-id="5b98b-165">This property is particularly useful for determining the options that are defined for a compiled regular expression created by the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="5b98b-166">Um auf Vorhandensein einer anderen Option als <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> zu testen, führen Sie eine AND-Operation mit dem Wert der <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType>-Eigenschaft und dem <xref:System.Text.RegularExpressions.RegexOptions>-Wert aus, für den Sie sich interessieren.</span><span class="sxs-lookup"><span data-stu-id="5b98b-166">To test for the presence of any option except <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, perform an AND operation with the value of the <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property and the <xref:System.Text.RegularExpressions.RegexOptions> value in which you are interested.</span></span> <span data-ttu-id="5b98b-167">Anschließend testen Sie, ob das Ergebnis diesem <xref:System.Text.RegularExpressions.RegexOptions>-Wert entspricht.</span><span class="sxs-lookup"><span data-stu-id="5b98b-167">Then test whether the result equals that <xref:System.Text.RegularExpressions.RegexOptions> value.</span></span> <span data-ttu-id="5b98b-168">Im folgenden Beispiel wird getestet, ob die <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>-Option festgelegt wurde.</span><span class="sxs-lookup"><span data-stu-id="5b98b-168">The following example tests whether the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option has been set.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#19](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#19)]
[!code-vb[Conceptual.Regex.Language.Options#19](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#19)]

<span data-ttu-id="5b98b-169">Zum Testen auf <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> bestimmen Sie, ob der Wert der <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType>-Eigenschaft gleich <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> ist, wie im folgenden Beispiel dargestellt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-169">To test for <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, determine whether the value of the <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property is equal to <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, as the following example illustrates.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#20](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#20)]
[!code-vb[Conceptual.Regex.Language.Options#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#20)]

<span data-ttu-id="5b98b-170">In den folgenden Abschnitten werden die Optionen aufgeführt, die von regulären .NET-Ausdrücken unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-170">The following sections list the options supported by regular expression in .NET.</span></span>

## <a name="default-options"></a><span data-ttu-id="5b98b-171">Standardoptionen</span><span class="sxs-lookup"><span data-stu-id="5b98b-171">Default Options</span></span>

<span data-ttu-id="5b98b-172">Die <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>-Option gibt an, dass keine Optionen angegeben wurden, und die Engine für reguläre Ausdrücke verwendet sein Standardverhalten.</span><span class="sxs-lookup"><span data-stu-id="5b98b-172">The <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option indicates that no options have been specified, and the regular expression engine uses its default behavior.</span></span> <span data-ttu-id="5b98b-173">Hierzu gehören folgende Elemente:</span><span class="sxs-lookup"><span data-stu-id="5b98b-173">This includes the following:</span></span>

- <span data-ttu-id="5b98b-174">Das Muster wird kanonisch und nicht als regulärer ECMAScript-Ausdruck interpretiert.</span><span class="sxs-lookup"><span data-stu-id="5b98b-174">The pattern is interpreted as a canonical rather than an ECMAScript regular expression.</span></span>

- <span data-ttu-id="5b98b-175">Das Muster eines regulären Ausdrucks wird von links nach rechts mit der Eingabezeichenfolge verglichen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-175">The regular expression pattern is matched in the input string from left to right.</span></span>

- <span data-ttu-id="5b98b-176">Bei Vergleichen wird die Groß-/Kleinschreibung berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-176">Comparisons are case-sensitive.</span></span>

- <span data-ttu-id="5b98b-177">Die Sprachelemente `^` und `$` finden eine Entsprechung für den Anfang und das Ende der Eingabezeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="5b98b-177">The `^` and `$` language elements match the beginning and end of the input string.</span></span>

- <span data-ttu-id="5b98b-178">Das `.`-Sprachelement findet eine Entsprechung für jedes Zeichen außer `\n`.</span><span class="sxs-lookup"><span data-stu-id="5b98b-178">The `.` language element matches every character except `\n`.</span></span>

- <span data-ttu-id="5b98b-179">Alle Leerstellen in einem Muster eines regulären Ausdrucks werden als literale Leerzeichen interpretiert.</span><span class="sxs-lookup"><span data-stu-id="5b98b-179">Any white space in a regular expression pattern is interpreted as a literal space character.</span></span>

- <span data-ttu-id="5b98b-180">Die Konventionen der aktuellen Kultur werden zum Vergleichen des Musters mit der Eingabezeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="5b98b-180">The conventions of the current culture are used when comparing the pattern to the input string.</span></span>

- <span data-ttu-id="5b98b-181">Erfassungsgruppen im Muster eines regulären Ausdrucks sind implizit und explizit.</span><span class="sxs-lookup"><span data-stu-id="5b98b-181">Capturing groups in the regular expression pattern are implicit as well as explicit.</span></span>

> [!NOTE]
> <span data-ttu-id="5b98b-182">Die <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>-Option besitzt keine Inlineentsprechung.</span><span class="sxs-lookup"><span data-stu-id="5b98b-182">The <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option has no inline equivalent.</span></span> <span data-ttu-id="5b98b-183">Wenn reguläre Ausdrucksoptionen inline übernommen werden, wird das Standardverhalten auf optionsweiser Basis durch Deaktivieren einer bestimmten Option wiederhergestellt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-183">When regular expression options are applied inline, the default behavior is restored on an option-by-option basis, by turning a particular option off.</span></span> <span data-ttu-id="5b98b-184">`(?i)` aktiviert z. B. Vergleiche, bei denen nicht zwischen Groß- und Kleinschreibung unterschieden wird, und `(?-i)` stellt das Standardverhalten mit Beachtung der Groß-/Kleinschreibung wieder her.</span><span class="sxs-lookup"><span data-stu-id="5b98b-184">For example, `(?i)` turns on case-insensitive comparison, and `(?-i)` restores the default case-sensitive comparison.</span></span>

<span data-ttu-id="5b98b-185">Da die <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>-Option das Standardverhalten der Engine für reguläre Ausdrücke darstellt, wird sie selten explizit in einem Methodenaufruf angegeben.</span><span class="sxs-lookup"><span data-stu-id="5b98b-185">Because the <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option represents the default behavior of the regular expression engine, it is rarely explicitly specified in a method call.</span></span> <span data-ttu-id="5b98b-186">Stattdessen wird ein Konstruktor oder eine statische Mustervergleichsmethode ohne `options`-Parameter aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-186">A constructor or static pattern-matching method without an `options` parameter is called instead.</span></span>

## <a name="case-insensitive-matching"></a><span data-ttu-id="5b98b-187">Übereinstimmung ohne Berücksichtigung der Groß-/Kleinschreibung</span><span class="sxs-lookup"><span data-stu-id="5b98b-187">Case-Insensitive Matching</span></span>

<span data-ttu-id="5b98b-188">Die <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>-Option oder die `i`-Inlineoption stellt die Suche nach Übereinstimmungen ohne Berücksichtigung von Groß-/Kleinschreibung bereit.</span><span class="sxs-lookup"><span data-stu-id="5b98b-188">The <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> option, or the `i` inline option, provides case-insensitive matching.</span></span> <span data-ttu-id="5b98b-189">Standardmäßig werden die Groß-/Kleinschreibungskonventionen der aktuellen Kultur verwendet.</span><span class="sxs-lookup"><span data-stu-id="5b98b-189">By default, the casing conventions of the current culture are used.</span></span>

<span data-ttu-id="5b98b-190">Im folgenden Beispiel wird das Muster eines regulären Ausdrucks `\bthe\w*\b` definiert, das eine Entsprechung für alle Wörter findet, die mit "the" beginnen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-190">The following example defines a regular expression pattern, `\bthe\w*\b`, that matches all words starting with "the".</span></span> <span data-ttu-id="5b98b-191">Da der erste Aufruf der <xref:System.Text.RegularExpressions.Regex.Match%2A>-Methode beim Vergleich standardmäßig die Groß-/Kleinschreibung beachtet, gibt die Ausgabe an, dass zur Zeichenfolge "The" am Anfang des Satzes keine Übereinstimmung gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="5b98b-191">Because the first call to the <xref:System.Text.RegularExpressions.Regex.Match%2A> method uses the default case-sensitive comparison, the output indicates that the string "The" that begins the sentence is not matched.</span></span> <span data-ttu-id="5b98b-192">Eine Entsprechung wird gefunden, wenn die <xref:System.Text.RegularExpressions.Regex.Match%2A>-Methode mit der Einstellung <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> für die Optionen aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="5b98b-192">It is matched when the <xref:System.Text.RegularExpressions.Regex.Match%2A> method is called with options set to <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case1.cs#1)]
[!code-vb[Conceptual.Regex.Language.Options#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case1.vb#1)]

<span data-ttu-id="5b98b-193">Im folgenden Beispiel wird das Muster eines regulären Ausdrucks aus dem vorherigen Beispiel so geändert, dass Inlineoptionen anstelle des `options`-Parameters verwendet werden, um einen Vergleich ohne Berücksichtigung von Groß- und Kleinschreibung bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-193">The following example modifies the regular expression pattern from the previous example to use inline options instead of the `options` parameter to provide case-insensitive comparison.</span></span> <span data-ttu-id="5b98b-194">Das erste Muster definiert die Option zum Ignorieren der Groß-/Kleinschreibung in einem Gruppierungskonstrukt, das in der Zeichenfolge "the" nur für den Buchstaben "t" gilt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-194">The first pattern defines the case-insensitive option in a grouping construct that applies only to the letter "t" in the string "the".</span></span> <span data-ttu-id="5b98b-195">Da das Optionskonstrukt am Anfang des Musters auftritt, wendet das zweite Muster die Option zur Missachtung der Groß-/Kleinschreibung auf den gesamten regulären Ausdruck an.</span><span class="sxs-lookup"><span data-stu-id="5b98b-195">Because the option construct occurs at the beginning of the pattern, the second pattern applies the case-insensitive option to the entire regular expression.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case2.cs#2)]
[!code-vb[Conceptual.Regex.Language.Options#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case2.vb#2)]

## <a name="multiline-mode"></a><span data-ttu-id="5b98b-196">Mehrzeilenmodus</span><span class="sxs-lookup"><span data-stu-id="5b98b-196">Multiline Mode</span></span>

<span data-ttu-id="5b98b-197">Die <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>-Option oder die `m` Inlineoption aktiviert die Engine für reguläre Ausdrücke für die Behandlung einer Eingabezeichenfolge, die aus mehreren Zeilen besteht.</span><span class="sxs-lookup"><span data-stu-id="5b98b-197">The <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, or the `m` inline option, enables the regular expression engine to handle an input string that consists of multiple lines.</span></span> <span data-ttu-id="5b98b-198">Ändert die Bedeutung der Sprachelemente `^` und `$`, sodass sie jeweils dem Anfang und dem Ende einer Zeile und nicht nur dem Anfang und dem Ende der Eingabezeichenfolge entsprechen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-198">It changes the interpretation of the `^` and `$` language elements so that they match the beginning and end of a line, instead of the beginning and end of the input string.</span></span>

<span data-ttu-id="5b98b-199">Standardmäßig findet `$` nur eine Entsprechung für das Ende der Eingabezeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="5b98b-199">By default, `$` matches only the end of the input string.</span></span> <span data-ttu-id="5b98b-200">Wenn Sie die <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>-Option angeben, entspricht diese entweder dem Zeilenumbruchzeichen (`\n`) oder dem Ende der Eingabezeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="5b98b-200">If you specify the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, it matches either the newline character (`\n`) or the end of the input string.</span></span> <span data-ttu-id="5b98b-201">Sie entspricht jedoch nicht der Kombination aus Wagenrücklauf- und Zeilenvorschubzeichen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-201">It does not, however, match the carriage return/line feed character combination.</span></span> <span data-ttu-id="5b98b-202">Um erfolgreich eine Entsprechung für sie zu finden, verwenden Sie den Teilausdruck `\r?$` statt nur `$`.</span><span class="sxs-lookup"><span data-stu-id="5b98b-202">To successfully match them, use the subexpression `\r?$` instead of just `$`.</span></span>

<span data-ttu-id="5b98b-203">Im folgenden Beispiel werden die Namen und Ergebnisse von Bowlern extrahiert und in absteigender Reihenfolge sortiert einer <xref:System.Collections.Generic.SortedList%602>-Auflistung hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-203">The following example extracts bowlers' names and scores and adds them to a <xref:System.Collections.Generic.SortedList%602> collection that sorts them in descending order.</span></span> <span data-ttu-id="5b98b-204">Die <xref:System.Text.RegularExpressions.Regex.Matches%2A>-Methode wird zweimal aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-204">The <xref:System.Text.RegularExpressions.Regex.Matches%2A> method is called twice.</span></span> <span data-ttu-id="5b98b-205">Im ersten Methodenaufruf ist der reguläre Ausdruck `^(\w+)\s(\d+)$`. Es werden keine Optionen festgelegt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-205">In the first method call, the regular expression is `^(\w+)\s(\d+)$` and no options are set.</span></span> <span data-ttu-id="5b98b-206">Wie die Ausgabe zeigt, werden keine Übereinstimmungen gefunden, da die Engine für reguläre Ausdrücke das Eingabemuster nicht mit dem Anfang und dem Ende der Eingabezeichenfolge vergleichen kann.</span><span class="sxs-lookup"><span data-stu-id="5b98b-206">As the output shows, because the regular expression engine cannot match the input pattern along with the beginning and end of the input string, no matches are found.</span></span> <span data-ttu-id="5b98b-207">Im zweiten Methodenaufruf wurde der reguläre Ausdruck in `^(\w+)\s(\d+)\r?$` geändert und die Optionen wurden auf <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-207">In the second method call, the regular expression is changed to `^(\w+)\s(\d+)\r?$` and the options are set to <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5b98b-208">Wie die Ausgabe zeigt, werden die Namen und Ergebnisse erfolgreich abgeglichen, und die Ergebnisse werden in absteigender Reihenfolge angezeigt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-208">As the output shows, the names and scores are successfully matched, and the scores are displayed in descending order.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline1.cs#3)]
[!code-vb[Conceptual.Regex.Language.Options#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline1.vb#3)]

<span data-ttu-id="5b98b-209">Das Muster für reguläre Ausdrücke `^(\w+)\s(\d+)\r*$` wird entsprechend der folgenden Tabelle definiert:</span><span class="sxs-lookup"><span data-stu-id="5b98b-209">The regular expression pattern `^(\w+)\s(\d+)\r*$` is defined as shown in the following table.</span></span>

|<span data-ttu-id="5b98b-210">Muster</span><span class="sxs-lookup"><span data-stu-id="5b98b-210">Pattern</span></span>|<span data-ttu-id="5b98b-211">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="5b98b-211">Description</span></span>|
|-------------|-----------------|
|`^`|<span data-ttu-id="5b98b-212">Am Anfang der Zeile beginnen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-212">Begin at the start of the line.</span></span>|
|`(\w+)`|<span data-ttu-id="5b98b-213">Übereinstimmung mit mindestens einem Wortzeichen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-213">Match one or more word characters.</span></span> <span data-ttu-id="5b98b-214">Dies ist die erste Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="5b98b-214">This is the first capturing group.</span></span>|
|`\s`|<span data-ttu-id="5b98b-215">Entsprechung für ein Leerraumzeichen finden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-215">Match a white-space character.</span></span>|
|`(\d+)`|<span data-ttu-id="5b98b-216">Entsprechung für mindestens eine Dezimalstelle finden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-216">Match one or more decimal digits.</span></span> <span data-ttu-id="5b98b-217">Dies ist die zweite Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="5b98b-217">This is the second capturing group.</span></span>|
|`\r?`|<span data-ttu-id="5b98b-218">Entspricht null oder mehr Wagenrücklaufzeichen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-218">Match zero or one carriage return character.</span></span>|
|`$`|<span data-ttu-id="5b98b-219">Ende am Ende der Zeile.</span><span class="sxs-lookup"><span data-stu-id="5b98b-219">End at the end of the line.</span></span>|

<span data-ttu-id="5b98b-220">Das folgende Beispiel entspricht dem vorherigen, abgesehen davon, dass zum Festlegen der Mehrzeilenoption die Inlineoption `(?m)` verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="5b98b-220">The following example is equivalent to the previous one, except that it uses the inline option `(?m)` to set the multiline option.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline2.cs#4)]
[!code-vb[Conceptual.Regex.Language.Options#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline2.vb#4)]

## <a name="single-line-mode"></a><span data-ttu-id="5b98b-221">Einzeilenmodus</span><span class="sxs-lookup"><span data-stu-id="5b98b-221">Single-line Mode</span></span>

<span data-ttu-id="5b98b-222">Die <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>-Option oder die `s` Inlineoption sorgt dafür, dass die Engine für reguläre Ausdrücke die Eingabezeichenfolge so behandelt, als ob sie aus einer einzigen Zeile besteht.</span><span class="sxs-lookup"><span data-stu-id="5b98b-222">The <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option, or the `s` inline option, causes the regular expression engine to treat the input string as if it consists of a single line.</span></span> <span data-ttu-id="5b98b-223">Es wird das Verhalten des Sprachelements Punkt (`.`) geändert, sodass dieser jedem Zeichen entspricht, anstatt jedem Zeichen außer dem Zeilenumbruchzeichen `\n` oder \u000A.</span><span class="sxs-lookup"><span data-stu-id="5b98b-223">It does this by changing the behavior of the period (`.`) language element so that it matches every character, instead of matching every character except for the newline character `\n` or \u000A.</span></span>

<span data-ttu-id="5b98b-224">Im folgenden Beispiel wird veranschaulicht, wie sich das Verhalten des `.`-Sprachelements ändert, wenn Sie die <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>-Option verwenden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-224">The following example illustrates how the behavior of the `.` language element changes when you use the <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="5b98b-225">Der reguläre `^.+`-Ausdruck beginnt am Anfang der Zeichenfolge und stimmt mit jedem Zeichen überein.</span><span class="sxs-lookup"><span data-stu-id="5b98b-225">The regular expression `^.+` starts at the beginning of the string and matches every character.</span></span> <span data-ttu-id="5b98b-226">Standardmäßig endet die Übereinstimmung am Ende der ersten Zeile. Das Muster für den regulären Ausdruck stimmt mit dem Wagenrücklaufzeichen (`\r` oder "\u000D"), jedoch nicht mit `\n` überein.</span><span class="sxs-lookup"><span data-stu-id="5b98b-226">By default, the match ends at the end of the first line; the regular expression pattern matches the carriage return character, `\r` or \u000D, but it does not match `\n`.</span></span> <span data-ttu-id="5b98b-227">Da die gesamte Eingabezeichenfolge von der <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>-Option als einzelne Zeile interpretiert wird, liegt für jedes enthaltene Zeichen eine Übereinstimmung vor, einschließlich `\n`.</span><span class="sxs-lookup"><span data-stu-id="5b98b-227">Because the <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option interprets the entire input string as a single line, it matches every character in the input string, including `\n`.</span></span>

[!code-csharp[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/any2.cs#5)]
[!code-vb[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/any2.vb#5)]

<span data-ttu-id="5b98b-228">Das folgende Beispiel entspricht dem vorherigen, abgesehen davon, dass zum Aktivieren der Einzelzeilenoption die Inlineoption `(?s)` verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="5b98b-228">The following example is equivalent to the previous one, except that it uses the inline option `(?s)` to enable single-line mode.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/singleline1.cs#5)]
[!code-vb[Conceptual.Regex.Language.Options#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/singleline1.vb#5)]

## <a name="explicit-captures-only"></a><span data-ttu-id="5b98b-229">Nur explizite Erfassungen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-229">Explicit Captures Only</span></span>

<span data-ttu-id="5b98b-230">Standardmäßig werden Erfassungsgruppen durch die Verwendung von Klammern im Muster eines regulären Ausdrucks definiert.</span><span class="sxs-lookup"><span data-stu-id="5b98b-230">By default, capturing groups are defined by the use of parentheses in the regular expression pattern.</span></span> <span data-ttu-id="5b98b-231">Benannten Gruppen wird über die `(?<`*Name*`>`*Teilausdruck*`)`-Sprachoption ein Name oder eine Zahl zugewiesen, wohingegen auf unbenannte Gruppen über den Index zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="5b98b-231">Named groups are assigned a name or number by the `(?<`*name*`>`*subexpression*`)` language option, whereas unnamed groups are accessible by index.</span></span> <span data-ttu-id="5b98b-232">Im <xref:System.Text.RegularExpressions.GroupCollection>-Objekt gehen unbenannte Gruppen benannten Gruppen voraus.</span><span class="sxs-lookup"><span data-stu-id="5b98b-232">In the <xref:System.Text.RegularExpressions.GroupCollection> object, unnamed groups precede named groups.</span></span>

<span data-ttu-id="5b98b-233">Gruppierungskonstrukte werden häufig nur verwendet, um Quantifizierer für mehrere Sprachelemente zu übernehmen, und die erfassten Teilzeichenfolgen sind nicht von Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="5b98b-233">Grouping constructs are often used only to apply quantifiers to multiple language elements, and the captured substrings are of no interest.</span></span> <span data-ttu-id="5b98b-234">Wenn beispielsweise der reguläre Ausdruck wie folgt lautet:</span><span class="sxs-lookup"><span data-stu-id="5b98b-234">For example, if the following regular expression:</span></span>

`\b\(?((\w+),?\s?)+[\.!?]\)?`

<span data-ttu-id="5b98b-235">sollen nur Sätze mit einem Punkt, Ausrufezeichen oder Fragezeichen am Ende aus einem Dokument extrahiert werden. Nur der resultierende Satz (der durch das <xref:System.Text.RegularExpressions.Match>-Objekt dargestellt wird) ist von Interesse.</span><span class="sxs-lookup"><span data-stu-id="5b98b-235">is intended only to extract sentences that end with a period, exclamation point, or question mark from a document, only the resulting sentence (which is represented by the <xref:System.Text.RegularExpressions.Match> object) is of interest.</span></span> <span data-ttu-id="5b98b-236">Die einzelnen Wörter in der Auflistung sind irrelevant.</span><span class="sxs-lookup"><span data-stu-id="5b98b-236">The individual words in the collection are not.</span></span>

<span data-ttu-id="5b98b-237">Erfassungsgruppen, die anschließend nicht verwendet werden, können speicherintensiv sein, da die Engine für reguläre Ausdrücke sowohl das <xref:System.Text.RegularExpressions.GroupCollection>- als auch das <xref:System.Text.RegularExpressions.CaptureCollection>-Auflistungsobjekt auffüllen muss.</span><span class="sxs-lookup"><span data-stu-id="5b98b-237">Capturing groups that are not subsequently used can be expensive, because the regular expression engine must populate both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collection objects.</span></span> <span data-ttu-id="5b98b-238">Alternativ können Sie entweder die <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>-Option oder die `n`-Inlineoption verwenden, um anzugeben, dass die einzigen gültigen Erfassungen explizit benannte oder nummerierte Gruppen sind, die durch das Konstrukt `(?<`*Name*`>` *Teilausdruck*`)` angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-238">As an alternative, you can use either the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option or the `n` inline option to specify that the only valid captures are explicitly named or numbered groups that are designated by the `(?<`*name*`>` *subexpression*`)` construct.</span></span>

<span data-ttu-id="5b98b-239">Das folgende Beispiel zeigt Informationen zu den Übereinstimmungen an, die vom Muster eines regulären Ausdrucks `\b\(?((\w+),?\s?)+[\.!?]\)?` zurückgegeben werden, wenn die <xref:System.Text.RegularExpressions.Regex.Match%2A>-Methode mit und ohne die <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>-Option aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="5b98b-239">The following example displays information about the matches returned by the `\b\(?((\w+),?\s?)+[\.!?]\)?` regular expression pattern when the <xref:System.Text.RegularExpressions.Regex.Match%2A> method is called with and without the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="5b98b-240">Wie die Ausgabe des ersten Methodenaufrufs zeigt, füllt die Engine für reguläre Ausdrücke das <xref:System.Text.RegularExpressions.GroupCollection>-Auflistungsobjekt und das <xref:System.Text.RegularExpressions.CaptureCollection>-Auflistungsobjekt vollständig mit Informationen zu erfassten Teilzeichenfolgen auf.</span><span class="sxs-lookup"><span data-stu-id="5b98b-240">As the output from the first method call shows, the regular expression engine fully populates the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collection objects with information about captured substrings.</span></span> <span data-ttu-id="5b98b-241">Da die zweite Methode mit `options` mit dem Wert <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> aufgerufen wird, werden keine Informationen zu Gruppen erfasst.</span><span class="sxs-lookup"><span data-stu-id="5b98b-241">Because the second method is called with `options` set to <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>, it does not capture information on groups.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit1.cs#9)]
[!code-vb[Conceptual.Regex.Language.Options#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit1.vb#9)]

<span data-ttu-id="5b98b-242">Das Muster für reguläre Ausdrücke `\b\(?((?>\w+),?\s?)+[\.!?]\)?` ist entsprechend der folgenden Tabelle definiert.</span><span class="sxs-lookup"><span data-stu-id="5b98b-242">The regular expression pattern`\b\(?((?>\w+),?\s?)+[\.!?]\)?` is defined as shown in the following table.</span></span>

|<span data-ttu-id="5b98b-243">Muster</span><span class="sxs-lookup"><span data-stu-id="5b98b-243">Pattern</span></span>|<span data-ttu-id="5b98b-244">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="5b98b-244">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="5b98b-245">Bei einer Wortgrenze beginnen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-245">Begin at a word boundary.</span></span>|
|`\(?`|<span data-ttu-id="5b98b-246">Sucht nach einer Übereinstimmung mit null oder einem Vorkommen der öffnenden Klammer ("(").</span><span class="sxs-lookup"><span data-stu-id="5b98b-246">Match zero or one occurrences of the opening parenthesis ("(").</span></span>|
|`(?>\w+),?`|<span data-ttu-id="5b98b-247">Sucht nach einer Übereinstimmung mit einem oder mehreren Wortzeichen gefolgt von keinem oder einem Komma.</span><span class="sxs-lookup"><span data-stu-id="5b98b-247">Match one or more word characters, followed by zero or one commas.</span></span> <span data-ttu-id="5b98b-248">Bei übereinstimmenden Wortzeichen findet keine Rückverfolgung statt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-248">Do not backtrack when matching word characters.</span></span>|
|`\s?`|<span data-ttu-id="5b98b-249">Sucht nach einer Übereinstimmung mit keinem oder einem Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-249">Match zero or one white-space characters.</span></span>|
|`((\w+),?\s?)+`|<span data-ttu-id="5b98b-250">Entspricht der Kombination von mindestens einem Wortzeichen gefolgt von keinem oder einem Komma und keinem oder einem Leerzeichen (ein- oder mehrfach).</span><span class="sxs-lookup"><span data-stu-id="5b98b-250">Match the combination of one or more word characters, zero or one commas, and zero or one white-space characters one or more times.</span></span>|
|`[\.!?]\)?`|<span data-ttu-id="5b98b-251">Entspricht jedem der drei Interpunktionszeichen, gefolgt von keiner oder einer schließenden Klammer (")").</span><span class="sxs-lookup"><span data-stu-id="5b98b-251">Match any of the three punctuation symbols, followed by zero or one closing parentheses (")").</span></span>|

<span data-ttu-id="5b98b-252">Sie können auch das `(?n)`-Inlineelement verwenden, um automatische Aufzeichnungen zu unterdrücken.</span><span class="sxs-lookup"><span data-stu-id="5b98b-252">You can also use the `(?n)` inline element to suppress automatic captures.</span></span> <span data-ttu-id="5b98b-253">Im folgenden Beispiel wird das vorherige Muster eines regulären Ausdrucks so geändert, dass das Inlineelement `(?n)` anstelle der <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>-Option verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="5b98b-253">The following example modifies the previous regular expression pattern to use the `(?n)` inline element instead of the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit2.cs#10)]
[!code-vb[Conceptual.Regex.Language.Options#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit2.vb#10)]

<span data-ttu-id="5b98b-254">Abschließend können Sie mit dem Inlinegruppenelement `(?n:)` automatische Erfassungen gruppenweise unterdrücken.</span><span class="sxs-lookup"><span data-stu-id="5b98b-254">Finally, you can use the inline group element `(?n:)` to suppress automatic captures on a group-by-group basis.</span></span> <span data-ttu-id="5b98b-255">Im folgenden Beispiel wird das vorherige Muster geändert, sodass unbenannte Erfassungen in der äußeren Gruppe `((?>\w+),?\s?)` unterdrückt werden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-255">The following example modifies the previous pattern to suppress unnamed captures in the outer group, `((?>\w+),?\s?)`.</span></span> <span data-ttu-id="5b98b-256">Beachten Sie, dass dadurch auch unbenannte Erfassungen in der inneren Gruppe unterdrückt werden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-256">Note that this suppresses unnamed captures in the inner group as well.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit3.cs#11)]
[!code-vb[Conceptual.Regex.Language.Options#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit3.vb#11)]

## <a name="compiled-regular-expressions"></a><span data-ttu-id="5b98b-257">Kompilierte reguläre Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="5b98b-257">Compiled Regular Expressions</span></span>

<span data-ttu-id="5b98b-258">Standardmäßig werden reguläre Ausdrücke in .NET interpretiert.</span><span class="sxs-lookup"><span data-stu-id="5b98b-258">By default, regular expressions in .NET are interpreted.</span></span> <span data-ttu-id="5b98b-259">Wenn ein <xref:System.Text.RegularExpressions.Regex>-Objekt instanziiert oder eine statische <xref:System.Text.RegularExpressions.Regex>-Methode aufgerufen wird, wird das Muster eines regulären Ausdrucks in einen Satz benutzerdefinierter Opcodes analysiert, und ein Interpreter führt den regulären Ausdruck mithilfe dieser Opcodes aus.</span><span class="sxs-lookup"><span data-stu-id="5b98b-259">When a <xref:System.Text.RegularExpressions.Regex> object is instantiated or a static <xref:System.Text.RegularExpressions.Regex> method is called, the regular expression pattern is parsed into a set of custom opcodes, and an interpreter uses these opcodes to run the regular expression.</span></span> <span data-ttu-id="5b98b-260">Dabei wird ein Kompromiss eingegangen: Der Aufwand für die Initialisierung der Engine für reguläre Ausdrücke wird auf Kosten der Runtimeleistung minimiert.</span><span class="sxs-lookup"><span data-stu-id="5b98b-260">This involves a tradeoff: The cost of initializing the regular expression engine is minimized at the expense of run-time performance.</span></span>

<span data-ttu-id="5b98b-261">Sie können kompilierte statt interpretierter regulärer Ausdrücke mit der <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType>-Option verwenden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-261">You can use compiled instead of interpreted regular expressions by using the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="5b98b-262">Wenn in diesem Fall ein Muster an die Engine für reguläre Ausdrücke übergeben wird, wird es in einen Satz von Opcodes aufgeschlüsselt und dann nach MSIL (Microsoft Intermediate Language) konvertiert, sodass es direkt an die Common Language Runtime übergeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="5b98b-262">In this case, when a pattern is passed to the regular expression engine, it is parsed into a set of opcodes and then converted to Microsoft intermediate language (MSIL), which can be passed directly to the common language runtime.</span></span> <span data-ttu-id="5b98b-263">Kompilierte reguläre Ausdrücke maximieren die Laufzeitleistung auf Kosten der Initialisierungszeit.</span><span class="sxs-lookup"><span data-stu-id="5b98b-263">Compiled regular expressions maximize run-time performance at the expense of initialization time.</span></span>

> [!NOTE]
> <span data-ttu-id="5b98b-264">Ein regulärer Ausdruck kann nur kompiliert werden, indem der <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType>-Wert an den `options`-Parameter eines <xref:System.Text.RegularExpressions.Regex>-Klassenkonstruktors oder einer statischen Mustervergleichsmethode übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="5b98b-264">A regular expression can be compiled only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or a static pattern-matching method.</span></span> <span data-ttu-id="5b98b-265">Es besteht keine Verfügbarkeit als Inlineoption.</span><span class="sxs-lookup"><span data-stu-id="5b98b-265">It is not available as an inline option.</span></span>

<span data-ttu-id="5b98b-266">Sie können kompilierte reguläre Ausdrücke in Aufrufen von statischen regulären Ausdrücken und solchen für Instanzen verwenden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-266">You can use compiled regular expressions in calls to both static and instance regular expressions.</span></span> <span data-ttu-id="5b98b-267">In statischen regulären Ausdrücken wird die <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType>-Option an den `options`-Parameter der Vergleichsmethode des regulären Ausdrucks übergeben.</span><span class="sxs-lookup"><span data-stu-id="5b98b-267">In static regular expressions, the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option is passed to the `options` parameter of the regular expression pattern-matching method.</span></span> <span data-ttu-id="5b98b-268">In regulären Ausdrucksinstanzen wird sie an den `options`-Parameter des <xref:System.Text.RegularExpressions.Regex>-Klassenkonstruktors übergeben.</span><span class="sxs-lookup"><span data-stu-id="5b98b-268">In instance regular expressions, it is passed to the `options` parameter of the <xref:System.Text.RegularExpressions.Regex> class constructor.</span></span> <span data-ttu-id="5b98b-269">In beiden Fällen führt dies zu einer besseren Leistung.</span><span class="sxs-lookup"><span data-stu-id="5b98b-269">In both cases, it results in enhanced performance.</span></span>

<span data-ttu-id="5b98b-270">Diese Verbesserung der Leistung tritt jedoch nur unter den folgenden Bedingungen auf:</span><span class="sxs-lookup"><span data-stu-id="5b98b-270">However, this improvement in performance occurs only under the following conditions:</span></span>

- <span data-ttu-id="5b98b-271">Ein <xref:System.Text.RegularExpressions.Regex>-Objekt, das einen bestimmten regulären Ausdruck darstellt, wird in mehreren Aufrufen regulärer Ausdrucksmustervergleichsmethoden verwendet.</span><span class="sxs-lookup"><span data-stu-id="5b98b-271">A <xref:System.Text.RegularExpressions.Regex> object that represents a particular regular expression is used in multiple calls to regular expression pattern-matching methods.</span></span>

- <span data-ttu-id="5b98b-272">Das <xref:System.Text.RegularExpressions.Regex>-Objekt darf den Gültigkeitsbereich nicht verlassen, daher kann es wiederverwendet werden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-272">The <xref:System.Text.RegularExpressions.Regex> object is not allowed to go out of scope, so it can be reused.</span></span>

- <span data-ttu-id="5b98b-273">Ein statischer regulärer Ausdruck wird in mehreren Aufrufen regulärer Ausdrucksmustervergleichsmethoden verwendet.</span><span class="sxs-lookup"><span data-stu-id="5b98b-273">A static regular expression is used in multiple calls to regular expression pattern-matching methods.</span></span> <span data-ttu-id="5b98b-274">(Die Leistungsverbesserung ist möglich, da reguläre in statischen Methodenaufrufen verwendete Ausdrücke von der Engine für reguläre Ausdrücke zwischengespeichert werden.)</span><span class="sxs-lookup"><span data-stu-id="5b98b-274">(The performance improvement is possible because regular expressions used in static method calls are cached by the regular expression engine.)</span></span>

> [!NOTE]
> <span data-ttu-id="5b98b-275">Die <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType>-Option steht in keinem Zusammenhang mit der <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>-Methode, die eine zweckgebundene Assembly erstellt, die vordefinierte kompilierte reguläre Ausdrücke enthält.</span><span class="sxs-lookup"><span data-stu-id="5b98b-275">The <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option is unrelated to the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, which creates a special-purpose assembly that contains predefined compiled regular expressions.</span></span>

## <a name="ignore-white-space"></a><span data-ttu-id="5b98b-276">Leerstellen ignorieren</span><span class="sxs-lookup"><span data-stu-id="5b98b-276">Ignore White Space</span></span>

<span data-ttu-id="5b98b-277">Standardmäßig werden Leerstellen in einem Muster eines regulären Ausdrucks interpretiert. Die Engine für reguläre Ausdrücke sucht dann nach einem entsprechenden Leerstellenzeichen in der Eingabezeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="5b98b-277">By default, white space in a regular expression pattern is significant; it forces the regular expression engine to match a white-space character in the input string.</span></span> <span data-ttu-id="5b98b-278">Daher sind die regulären Ausdrücke „`\b\w+\s`“ und „`\b\w+`“ weitgehend gleiche reguläre Ausdrücke.</span><span class="sxs-lookup"><span data-stu-id="5b98b-278">Because of this, the regular expression "`\b\w+\s`" and "`\b\w+` " are roughly equivalent regular expressions.</span></span> <span data-ttu-id="5b98b-279">Außerdem wird das Nummernzeichen (#), wenn es in einem Muster eines regulären Ausdrucks gefunden wird, als Literalzeichen interpretiert und nach einer Übereinstimmung gesucht.</span><span class="sxs-lookup"><span data-stu-id="5b98b-279">In addition, when the number sign (#) is encountered in a regular expression pattern, it is interpreted as a literal character to be matched.</span></span>

<span data-ttu-id="5b98b-280">Die <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>-Option oder die `x`-Inlineoption ändert dieses Standardverhalten wie folgt:</span><span class="sxs-lookup"><span data-stu-id="5b98b-280">The <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option, or the `x` inline option, changes this default behavior as follows:</span></span>

- <span data-ttu-id="5b98b-281">Leerstellen ohne Escapezeichen im Muster eines regulären Ausdrucks werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="5b98b-281">Unescaped white space in the regular expression pattern is ignored.</span></span> <span data-ttu-id="5b98b-282">Um Teil eines Musters eines regulären Ausdrucks zu sein, müssen Leerstellenzeichen mit Escapezeichen versehen werden (z. B. „`\s`“ oder „`\`“).</span><span class="sxs-lookup"><span data-stu-id="5b98b-282">To be part of a regular expression pattern, white-space characters must be escaped (for example, as `\s` or "`\` ").</span></span>

- <span data-ttu-id="5b98b-283">Das Nummernzeichen (#) wird als Anfang eines Kommentars interpretiert, nicht als Literalzeichen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-283">The number sign (#) is interpreted as the beginning of a comment, rather than as a literal character.</span></span> <span data-ttu-id="5b98b-284">Der gesamte Text im Muster eines regulären Ausdrucks vom Zeichen "#" bis zum Ende der Zeichenfolge wird als Kommentar interpretiert.</span><span class="sxs-lookup"><span data-stu-id="5b98b-284">All text in the regular expression pattern from the # character to the end of the string is interpreted as a comment.</span></span>

<span data-ttu-id="5b98b-285">In den folgenden Fällen werden Leerzeichen in regulären Ausdrücken jedoch nicht ignoriert, auch wenn Sie die <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>-Option verwenden:</span><span class="sxs-lookup"><span data-stu-id="5b98b-285">However, in the following cases, white-space characters in a regular expression aren't ignored, even if you use the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option:</span></span>

- <span data-ttu-id="5b98b-286">Leerzeichen in einer Zeichenklasse werden stets literal interpretiert.</span><span class="sxs-lookup"><span data-stu-id="5b98b-286">White space within a character class is always interpreted literally.</span></span> <span data-ttu-id="5b98b-287">Der reguläre Ausdruck `[ .,;:]` findet z. B. ein einzelnes Leerstellenzeichen, Punkt, Komma, Semikolon oder einen Doppelpunkt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-287">For example, the regular expression pattern `[ .,;:]` matches any single white-space character, period, comma, semicolon, or colon.</span></span>

- <span data-ttu-id="5b98b-288">Leerzeichen sind innerhalb von in Klammern gesetzten Quantifizierern wie `{`*n*`}`, `{`*n*`,}` und `{`*n*`,`*m*`}` nicht zulässig.</span><span class="sxs-lookup"><span data-stu-id="5b98b-288">White space isn't allowed within a bracketed quantifier, such as `{`*n*`}`, `{`*n*`,}`, and `{`*n*`,`*m*`}`.</span></span> <span data-ttu-id="5b98b-289">Das Muster eines regulären Ausdrucks `\d{1, 3}` findet z. B. keine Übereinstimmung mit Ziffernsequenzen von einer bis zu drei Ziffern, da es ein Leerzeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="5b98b-289">For example, the regular expression pattern `\d{1, 3}` fails to match any sequences of digits from one to three digits because it contains a white-space character.</span></span>

- <span data-ttu-id="5b98b-290">Leerzeichen sind in Zeichenfolgen, die Sprachelemente einleiten, nicht zulässig.</span><span class="sxs-lookup"><span data-stu-id="5b98b-290">White space isn't allowed within a character sequence that introduces a language element.</span></span> <span data-ttu-id="5b98b-291">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="5b98b-291">For example:</span></span>

  - <span data-ttu-id="5b98b-292">Das Sprachelement `(?:`*Teilausdruck*`)` stellt eine nicht erfassende Gruppe dar, und der `(?:`-Teil des Elements darf keine eingebetteten Leerzeichen enthalten.</span><span class="sxs-lookup"><span data-stu-id="5b98b-292">The language element `(?:`*subexpression*`)` represents a noncapturing group, and the `(?:` portion of the element can't have embedded spaces.</span></span> <span data-ttu-id="5b98b-293">Das Muster `(? :`*subexpression*`)` löst zur Laufzeit eine <xref:System.ArgumentException> aus, da die Engine für reguläre Ausdrücke das Muster nicht analysieren kann und das Muster `( ?:`*subexpression*`)` findet keine Übereinstimmung zu *subexpression*.</span><span class="sxs-lookup"><span data-stu-id="5b98b-293">The pattern `(? :`*subexpression*`)` throws an <xref:System.ArgumentException> at run time because the regular expression engine can't parse the pattern, and the pattern `( ?:`*subexpression*`)` fails to match *subexpression*.</span></span>

  - <span data-ttu-id="5b98b-294">Das Sprachelement `\p{`*Name*`}`, das für eine Unicode-Kategorie oder einen benannten Block steht, darf im `\p{`-Teil des Elements kein eingebettetes Leerzeichen enthalten.</span><span class="sxs-lookup"><span data-stu-id="5b98b-294">The language element `\p{`*name*`}`, which represents a Unicode category or named block, can't include embedded spaces in the `\p{` portion of the element.</span></span> <span data-ttu-id="5b98b-295">Falls Sie trotzdem ein Leerzeichen einfügen, löst das Element zur Laufzeit eine <xref:System.ArgumentException> aus.</span><span class="sxs-lookup"><span data-stu-id="5b98b-295">If you do include a white space, the element throws an <xref:System.ArgumentException> at run time.</span></span>

<span data-ttu-id="5b98b-296">Durch das Aktivieren dieser Option werden reguläre Ausdrücke vereinfacht, die oft schwierig zu analysieren und zu verstehen sind.</span><span class="sxs-lookup"><span data-stu-id="5b98b-296">Enabling this option helps simplify regular expressions that are often difficult to parse and to understand.</span></span> <span data-ttu-id="5b98b-297">Dadurch wird Lesbarkeit verbessert, und es wird möglich, einen regulären Ausdruck zu dokumentieren.</span><span class="sxs-lookup"><span data-stu-id="5b98b-297">It improves readability, and makes it possible to document a regular expression.</span></span>

<span data-ttu-id="5b98b-298">Im folgenden Beispiel wird das folgende Muster des regulären Ausdrucks definiert:</span><span class="sxs-lookup"><span data-stu-id="5b98b-298">The following example defines the following regular expression pattern:</span></span>

`\b \(? ( (?>\w+) ,?\s? )+  [\.!?] \)? # Matches an entire sentence.`

<span data-ttu-id="5b98b-299">Dieses Muster ist dem im Abschnitt [Nur explizite Erfassungen](#explicit-captures-only) definierten Muster ähnlich, außer dass mithilfe der <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>-Option Musterleerzeichen ignoriert werden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-299">This pattern is similar to the pattern defined in the [Explicit Captures Only](#explicit-captures-only) section, except that it uses the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option to ignore pattern white space.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace1.cs#12)]
[!code-vb[Conceptual.Regex.Language.Options#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace1.vb#12)]

<span data-ttu-id="5b98b-300">Im folgenden Beispiel wird die Inlineoption `(?x)` verwendet, um Leerzeichen im Muster zu ignorieren.</span><span class="sxs-lookup"><span data-stu-id="5b98b-300">The following example uses the inline option `(?x)` to ignore pattern white space.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#13](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace2.cs#13)]
[!code-vb[Conceptual.Regex.Language.Options#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace2.vb#13)]

## <a name="right-to-left-mode"></a><span data-ttu-id="5b98b-301">Modus "von rechts nach links"</span><span class="sxs-lookup"><span data-stu-id="5b98b-301">Right-to-Left Mode</span></span>

<span data-ttu-id="5b98b-302">Standardmäßig sucht die Engine für reguläre Ausdrücke von links nach rechts.</span><span class="sxs-lookup"><span data-stu-id="5b98b-302">By default, the regular expression engine searches from left to right.</span></span> <span data-ttu-id="5b98b-303">Sie können mit der Option <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> die Suchrichtung umkehren.</span><span class="sxs-lookup"><span data-stu-id="5b98b-303">You can reverse the search direction by using the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="5b98b-304">Die Suche startet automatisch bei der Position des letzten Zeichens der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="5b98b-304">The search automatically begins at the last character position of the string.</span></span> <span data-ttu-id="5b98b-305">Bei Mustervergleichsmethoden, die einen Anfangspositionsparameter enthalten, wie z. B. <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>, ist die Anfangsposition der Index der am weitesten rechts stehenden Zeichenposition, bei der die Suche beginnt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-305">For pattern-matching methods that include a starting position parameter, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>, the starting position is the index of the rightmost character position at which the search is to begin.</span></span>

> [!NOTE]
> <span data-ttu-id="5b98b-306">Der Skriptmodus "von rechts nach links" ist nur verfügbar, wenn der <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>-Wert an den `options`-Parameter eines <xref:System.Text.RegularExpressions.Regex>-Klassenkonstruktors oder einer statischen Mustervergleichsmethode übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="5b98b-306">Right-to-left pattern mode is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="5b98b-307">Es besteht keine Verfügbarkeit als Inlineoption.</span><span class="sxs-lookup"><span data-stu-id="5b98b-307">It is not available as an inline option.</span></span>

<span data-ttu-id="5b98b-308">Die <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>-Option ändert nur die Suchrichtung; sie interpretiert das Muster eines regulären Ausdrucks nicht von rechts nach links.</span><span class="sxs-lookup"><span data-stu-id="5b98b-308">The <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option changes the search direction only; it does not interpret the regular expression pattern from right to left.</span></span> <span data-ttu-id="5b98b-309">Der reguläre Ausdruck `\bb\w+\s` findet z. B. eine Entsprechung für Wörter, die mit dem Buchstaben "b" beginnen und von einem Leerstellenzeichen gefolgt sind.</span><span class="sxs-lookup"><span data-stu-id="5b98b-309">For example, the regular expression `\bb\w+\s` matches words that begin with the letter "b" and are followed by a white-space character.</span></span> <span data-ttu-id="5b98b-310">Im folgenden Beispiel besteht die Eingabezeichenfolge aus drei Wörtern, die ein oder mehrere "b"-Zeichen enthalten.</span><span class="sxs-lookup"><span data-stu-id="5b98b-310">In the following example, the input string consists of three words that include one or more "b" characters.</span></span> <span data-ttu-id="5b98b-311">Das erste Wort beginnt mit "b", das zweite endet mit "b", und das dritte enthält zwei "b"-Zeichen im Wortinnern.</span><span class="sxs-lookup"><span data-stu-id="5b98b-311">The first word begins with "b", the second ends with "b", and the third includes two "b" characters in the middle of the word.</span></span> <span data-ttu-id="5b98b-312">Wie die Ausgabe des Beispiels zeigt, stimmt nur das erste Wort mit dem Muster des regulären Ausdrucks überein.</span><span class="sxs-lookup"><span data-stu-id="5b98b-312">As the output from the example shows, only the first word matches the regular expression pattern.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#17](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft1.cs#17)]
[!code-vb[Conceptual.Regex.Language.Options#17](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft1.vb#17)]

<span data-ttu-id="5b98b-313">Beachten Sie auch, dass die Lookaheadassertion (das `(?=`*Teilausdruck*`)`-Sprachelement) und die Lookbehindassertion (das `(?<=`*Teilausdruck*`)`-Sprachelement) die Richtung nicht ändern.</span><span class="sxs-lookup"><span data-stu-id="5b98b-313">Also note that the lookahead assertion (the `(?=`*subexpression*`)` language element) and the lookbehind assertion (the `(?<=`*subexpression*`)` language element) do not change direction.</span></span> <span data-ttu-id="5b98b-314">Die Lookaheadassertionen prüfen nach rechts, die Lookbehindassertionen nach links.</span><span class="sxs-lookup"><span data-stu-id="5b98b-314">The lookahead assertions look to the right; the lookbehind assertions look to the left.</span></span> <span data-ttu-id="5b98b-315">Der reguläre Ausdruck `(?<=\d{1,2}\s)\w+,?\s\d{4}` testet z. B. mithilfe der Lookbehindassertion auf ein Datum, das einem Monatsnamen vorausgeht.</span><span class="sxs-lookup"><span data-stu-id="5b98b-315">For example, the regular expression `(?<=\d{1,2}\s)\w+,?\s\d{4}` uses the lookbehind assertion to test for a date that precedes a month name.</span></span> <span data-ttu-id="5b98b-316">Der reguläre Ausdruck gleicht dann Monat und Jahr ab.</span><span class="sxs-lookup"><span data-stu-id="5b98b-316">The regular expression then matches the month and the year.</span></span> <span data-ttu-id="5b98b-317">Informationen zu Lookahead- und Lookbehindassertionen finden Sie unter [Gruppierungskonstrukte](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="5b98b-317">For information on lookahead and lookbehind assertions, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#18](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft2.cs#18)]
[!code-vb[Conceptual.Regex.Language.Options#18](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft2.vb#18)]

<span data-ttu-id="5b98b-318">Das Muster für reguläre Ausdrücke ist wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="5b98b-318">The regular expression pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="5b98b-319">Muster</span><span class="sxs-lookup"><span data-stu-id="5b98b-319">Pattern</span></span>|<span data-ttu-id="5b98b-320">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="5b98b-320">Description</span></span>|
|-------------|-----------------|
|`(?<=\d{1,2}\s)`|<span data-ttu-id="5b98b-321">Dem Anfang der Übereinstimmung müssen eine oder zwei von einem Leerzeichen gefolgte Dezimalstellen vorangestellt sein.</span><span class="sxs-lookup"><span data-stu-id="5b98b-321">The beginning of the match must be preceded by one or two decimal digits followed by a space.</span></span>|
|`\w+`|<span data-ttu-id="5b98b-322">Übereinstimmung mit mindestens einem Wortzeichen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-322">Match one or more word characters.</span></span>|
|`,?`|<span data-ttu-id="5b98b-323">Entspricht keinem oder einem Kommazeichen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-323">Match zero or one comma characters.</span></span>|
|`\s`|<span data-ttu-id="5b98b-324">Entsprechung für ein Leerraumzeichen finden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-324">Match a white-space character.</span></span>|
|`\d{4}`|<span data-ttu-id="5b98b-325">Entsprechung für vier Dezimalstellen finden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-325">Match four decimal digits.</span></span>|

## <a name="ecmascript-matching-behavior"></a><span data-ttu-id="5b98b-326">ECMAScript-Vergleichsverhalten</span><span class="sxs-lookup"><span data-stu-id="5b98b-326">ECMAScript Matching Behavior</span></span>

<span data-ttu-id="5b98b-327">Standardmäßig verwendet die Engine für reguläre Ausdrücke das kanonische Verhalten, wenn ein Muster eines regulären Ausdrucks mit dem Eingabetext verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="5b98b-327">By default, the regular expression engine uses canonical behavior when matching a regular expression pattern to input text.</span></span> <span data-ttu-id="5b98b-328">Sie können jedoch die Engine für reguläre Ausdrücke anweisen, das ECMAScript-Vergleichsverhalten zu verwenden, indem Sie die <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType>-Option angeben.</span><span class="sxs-lookup"><span data-stu-id="5b98b-328">However, you can instruct the regular expression engine to use ECMAScript matching behavior by specifying the <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> option.</span></span>

> [!NOTE]
> <span data-ttu-id="5b98b-329">ECMAScript-kompatibles Verhalten ist nur verfügbar, wenn der <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType>-Wert an den `options`-Parameter eines <xref:System.Text.RegularExpressions.Regex>-Klassenkonstruktors oder einer statischen Mustervergleichsmethode übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="5b98b-329">ECMAScript-compliant behavior is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="5b98b-330">Es besteht keine Verfügbarkeit als Inlineoption.</span><span class="sxs-lookup"><span data-stu-id="5b98b-330">It is not available as an inline option.</span></span>

<span data-ttu-id="5b98b-331">Die <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType>-Option kann nur mit den Optionen <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-331">The <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> option can be combined only with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> options.</span></span> <span data-ttu-id="5b98b-332">Die Verwendung einer die oft ausgegebene Befehlszeilen  anderen Option in einem regulären Ausdruck führt zu einer <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="5b98b-332">The use of any other option in a regular expression results in an <xref:System.ArgumentOutOfRangeException>.</span></span>

<span data-ttu-id="5b98b-333">Das Verhalten von ECMAScript und kanonischen regulären Ausdrücke unterscheidet sich in drei Bereichen: Zeichenklassensyntax, bei Selbstverweisen von Erfassungsgruppen sowie bei der Interpretation von Oktalwerten und Rückverweisen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-333">The behavior of ECMAScript and canonical regular expressions differs in three areas: character class syntax, self-referencing capturing groups, and octal versus backreference interpretation.</span></span>

- <span data-ttu-id="5b98b-334">Zeichenklassensyntax.</span><span class="sxs-lookup"><span data-stu-id="5b98b-334">Character class syntax.</span></span> <span data-ttu-id="5b98b-335">Da kanonische reguläre Ausdrücke im Gegensatz zu ECMAScript Unicode unterstützen, weisen Zeichenklassen in ECMAScript eine beschränktere Syntax auf, und einige Zeichenklassensprachelemente haben eine andere Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="5b98b-335">Because canonical regular expressions support Unicode whereas ECMAScript does not, character classes in ECMAScript have a more limited syntax, and some character class language elements have a different meaning.</span></span> <span data-ttu-id="5b98b-336">ECMAScript unterstützt z. B. keine Sprachelemente wie die Kategorie- oder Blockelemente `\p` und `\P` von Unicode.</span><span class="sxs-lookup"><span data-stu-id="5b98b-336">For example, ECMAScript does not support language elements such as the Unicode category or block elements `\p` and `\P`.</span></span> <span data-ttu-id="5b98b-337">Entsprechend ist das `\w`-Element, das einem Wortzeichen entspricht, äquivalent zur `[a-zA-Z_0-9]`-Zeichenklasse beim Verwenden von ECMAScript bzw. äquivalent zu `[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]` beim Verwenden des kanonischen Verhaltens.</span><span class="sxs-lookup"><span data-stu-id="5b98b-337">Similarly, the `\w` element, which matches a word character, is equivalent to the `[a-zA-Z_0-9]` character class when using ECMAScript and `[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]` when using canonical behavior.</span></span> <span data-ttu-id="5b98b-338">Weitere Informationen finden Sie unter [Zeichenklassen in regulären Ausdrücken](character-classes-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="5b98b-338">For more information, see [Character Classes](character-classes-in-regular-expressions.md).</span></span>

  <span data-ttu-id="5b98b-339">Im folgenden Beispiel wird der Unterschied zwischen kanonischen und ECMAScript-Mustervergleichen veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="5b98b-339">The following example illustrates the difference between canonical and ECMAScript pattern matching.</span></span> <span data-ttu-id="5b98b-340">Dabei wird ein regulärer Ausdruck, `\b(\w+\s*)+`, definiert, der eine Entsprechung für Wörter findet, denen Leerstellenzeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-340">It defines a regular expression, `\b(\w+\s*)+`, that matches words followed by white-space characters.</span></span> <span data-ttu-id="5b98b-341">Die Eingabe besteht aus zwei Zeichenfolgen, einer mit dem lateinischen Zeichensatz und einer mit dem kyrillischen Zeichensatz.</span><span class="sxs-lookup"><span data-stu-id="5b98b-341">The input consists of two strings, one that uses the Latin character set and the other that uses the Cyrillic character set.</span></span> <span data-ttu-id="5b98b-342">Wie die Ausgabe zeigt, findet der Aufruf der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>-Methode, die ECMAScript verwendet, keine Entsprechung für die kyrillischen Wörter, wohingegen der Methodenaufruf, der einen kanonischen Vergleich verwendet, eine Entsprechung für diese Wörter findet.</span><span class="sxs-lookup"><span data-stu-id="5b98b-342">As the output shows, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method that uses ECMAScript matching fails to match the Cyrillic words, whereas the method call that uses canonical matching does match these words.</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#16](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript1.cs#16)]
  [!code-vb[Conceptual.Regex.Language.Options#16](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript1.vb#16)]

- <span data-ttu-id="5b98b-343">Auf sich selbst verweisende Erfassungsgruppen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-343">Self-referencing capturing groups.</span></span> <span data-ttu-id="5b98b-344">Eine Aufzeichnungsklasse für einen regulären Ausdruck mit einem Rückverweis auf sich selbst muss mit jeder Aufzeichnungsiteration aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-344">A regular expression capture class with a backreference to itself must be updated with each capture iteration.</span></span> <span data-ttu-id="5b98b-345">Wie das folgende Beispiel zeigt, aktiviert diese Funktion den regulären Ausdruck `((a+)(\1) ?)+`, um eine Entsprechung für die Eingabezeichenfolge " aa aaaa aaaaaa " zu finden, wenn ECMAScript verwendet wird, jedoch nicht, wenn kanonische Vergleiche verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-345">As the following example shows, this feature enables the regular expression `((a+)(\1) ?)+` to match the input string " aa aaaa aaaaaa " when using ECMAScript, but not when using canonical matching.</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#21](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript2.cs#21)]
  [!code-vb[Conceptual.Regex.Language.Options#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript2.vb#21)]

  <span data-ttu-id="5b98b-346">Der reguläre Ausdruck wird entsprechend der Darstellung in der folgenden Tabelle definiert:</span><span class="sxs-lookup"><span data-stu-id="5b98b-346">The regular expression is defined as shown in the following table.</span></span>

  |<span data-ttu-id="5b98b-347">Muster</span><span class="sxs-lookup"><span data-stu-id="5b98b-347">Pattern</span></span>|<span data-ttu-id="5b98b-348">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="5b98b-348">Description</span></span>|
  |-------------|-----------------|
  |<span data-ttu-id="5b98b-349">(a+)</span><span class="sxs-lookup"><span data-stu-id="5b98b-349">(a+)</span></span>|<span data-ttu-id="5b98b-350">Entspricht einem oder mehreren Vorkommen des Buchstabens "a".</span><span class="sxs-lookup"><span data-stu-id="5b98b-350">Match the letter "a" one or more times.</span></span> <span data-ttu-id="5b98b-351">Dies ist die zweite Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="5b98b-351">This is the second capturing group.</span></span>|
  |<span data-ttu-id="5b98b-352">(\1)</span><span class="sxs-lookup"><span data-stu-id="5b98b-352">(\1)</span></span>|<span data-ttu-id="5b98b-353">Entspricht der Teilzeichenfolge, die von der ersten Erfassungsgruppe erfasst wurde.</span><span class="sxs-lookup"><span data-stu-id="5b98b-353">Match the substring captured by the first capturing group.</span></span> <span data-ttu-id="5b98b-354">Dies ist die dritte Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="5b98b-354">This is the third capturing group.</span></span>|
  |<span data-ttu-id="5b98b-355">?</span><span class="sxs-lookup"><span data-stu-id="5b98b-355">?</span></span>|<span data-ttu-id="5b98b-356">Entspricht keinem oder einem Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-356">Match zero or one space characters.</span></span>|
  |<span data-ttu-id="5b98b-357">((a+)(\1) ?)+</span><span class="sxs-lookup"><span data-stu-id="5b98b-357">((a+)(\1) ?)+</span></span>|<span data-ttu-id="5b98b-358">Entspricht mindestens einem "a", ein- oder mehrmals gefolgt von einer Zeichenfolge, die der ersten Erfassungsgruppe entspricht, und keinem oder mehr Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-358">Match the pattern of one or more "a" characters followed by a string that matches the first capturing group followed by zero or one space characters one or more times.</span></span> <span data-ttu-id="5b98b-359">Dies ist die erste Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="5b98b-359">This is the first capturing group.</span></span>|

- <span data-ttu-id="5b98b-360">Auflösung von Zweideutigkeiten zwischen Oktalescapezeichen und Rückverweisen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-360">Resolution of ambiguities between octal escapes and backreferences.</span></span> <span data-ttu-id="5b98b-361">Die folgende Tabelle fasst die Unterschiede zwischen der Oktal- und der Rückverweisinterpretation durch kanonische reguläre Ausdrücke und reguläre ECMAScript-Ausdrücke zusammen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-361">The following table summarizes the differences in octal versus backreference interpretation by canonical and ECMAScript regular expressions.</span></span>

  |<span data-ttu-id="5b98b-362">Regulärer Ausdruck</span><span class="sxs-lookup"><span data-stu-id="5b98b-362">Regular expression</span></span>|<span data-ttu-id="5b98b-363">Kanonisches Verhalten</span><span class="sxs-lookup"><span data-stu-id="5b98b-363">Canonical behavior</span></span>|<span data-ttu-id="5b98b-364">ECMAScript-Verhalten</span><span class="sxs-lookup"><span data-stu-id="5b98b-364">ECMAScript behavior</span></span>|
  |------------------------|------------------------|-------------------------|
  |<span data-ttu-id="5b98b-365">`\0` gefolgt von 0 bis 2 Oktalziffern</span><span class="sxs-lookup"><span data-stu-id="5b98b-365">`\0` followed by 0 to 2 octal digits</span></span>|<span data-ttu-id="5b98b-366">Als Oktalwert interpretieren.</span><span class="sxs-lookup"><span data-stu-id="5b98b-366">Interpret as an octal.</span></span> <span data-ttu-id="5b98b-367">Zum Beispiel wird `\044` immer als Oktalwert interpretiert und bedeutet "$".</span><span class="sxs-lookup"><span data-stu-id="5b98b-367">For example, `\044` is always interpreted as an octal value and means "$".</span></span>|<span data-ttu-id="5b98b-368">Gleiches Verhalten.</span><span class="sxs-lookup"><span data-stu-id="5b98b-368">Same behavior.</span></span>|
  |<span data-ttu-id="5b98b-369">`\` gefolgt von einer Ziffer zwischen 1 und 9 ohne nachfolgende Dezimalziffern</span><span class="sxs-lookup"><span data-stu-id="5b98b-369">`\` followed by a digit from 1 to 9, followed by no additional decimal digits,</span></span>|<span data-ttu-id="5b98b-370">Als Rückverweis interpretieren.</span><span class="sxs-lookup"><span data-stu-id="5b98b-370">Interpret as a backreference.</span></span> <span data-ttu-id="5b98b-371">Zum Beispiel bedeutet `\9` immer Rückverweis 9, auch wenn keine Erfassungsgruppe 9 vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="5b98b-371">For example, `\9` always means backreference 9, even if a ninth capturing group does not exist.</span></span> <span data-ttu-id="5b98b-372">Wenn die Aufzeichnungsgruppe nicht vorhanden ist, löst der Parser für den regulären Ausdruck eine <xref:System.ArgumentException> aus.</span><span class="sxs-lookup"><span data-stu-id="5b98b-372">If the capturing group does not exist, the regular expression parser throws an <xref:System.ArgumentException>.</span></span>|<span data-ttu-id="5b98b-373">Wenn eine Erfassungsgruppe einer einzigen Dezimalziffer vorhanden ist, wird ein Rückverweis auf diese Ziffer ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-373">If a single decimal digit capturing group exists, backreference to that digit.</span></span> <span data-ttu-id="5b98b-374">Andernfalls wird der Wert als Literal interpretiert.</span><span class="sxs-lookup"><span data-stu-id="5b98b-374">Otherwise, interpret the value as a literal.</span></span>|
  |<span data-ttu-id="5b98b-375">`\` gefolgt von einer Ziffer zwischen 1 und 9 mit nachfolgenden Dezimalziffern</span><span class="sxs-lookup"><span data-stu-id="5b98b-375">`\` followed by a digit from 1 to 9, followed by additional decimal digits</span></span>|<span data-ttu-id="5b98b-376">Ziffern als Dezimalwert interpretieren.</span><span class="sxs-lookup"><span data-stu-id="5b98b-376">Interpret the digits as a decimal value.</span></span> <span data-ttu-id="5b98b-377">Wenn diese Erfassungsgruppe vorhanden ist, wird der Ausdruck als Rückverweis interpretiert.</span><span class="sxs-lookup"><span data-stu-id="5b98b-377">If that capturing group exists, interpret the expression as a backreference.</span></span><br /><br /> <span data-ttu-id="5b98b-378">Ansonsten werden die vorangestellten Oktalziffern bis zur Oktalzahl 377 interpretiert. Das bedeutet, dass nur die unteren 8 Bits des Werts berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-378">Otherwise, interpret the leading octal digits up to octal 377; that is, consider only the low 8 bits of the value.</span></span> <span data-ttu-id="5b98b-379">Verbleibende Ziffern als Literale interpretieren.</span><span class="sxs-lookup"><span data-stu-id="5b98b-379">Interpret the remaining digits as literals.</span></span> <span data-ttu-id="5b98b-380">Beispiel: Wenn im Ausdruck `\3000` die Erfassungsgruppe 300 vorhanden ist, wird der Ausdruck als Rückverweis 300 interpretiert. Wenn die Erfassungsgruppe 300 nicht vorhanden ist, wird er als Oktalzahl 300 gefolgt von 0 interpretiert.</span><span class="sxs-lookup"><span data-stu-id="5b98b-380">For example, in the expression `\3000`, if capturing group 300 exists, interpret as backreference 300; if capturing group 300 does not exist, interpret as octal 300 followed by 0.</span></span>|<span data-ttu-id="5b98b-381">Als Rückverweis interpretieren, indem so viele Ziffern wie möglich in einen Dezimalwert konvertiert werden, der auf eine Erfassung verweisen kann.</span><span class="sxs-lookup"><span data-stu-id="5b98b-381">Interpret as a backreference by converting as many digits as possible to a decimal value that can refer to a capture.</span></span> <span data-ttu-id="5b98b-382">Wenn keine Ziffern konvertiert werden können, wird der Ausdruck als Oktalzahl unter Verwendung der ersten Oktalziffern bis zu Oktalzahl 377 interpretiert, und die restlichen Ziffern werden als Literale interpretiert.</span><span class="sxs-lookup"><span data-stu-id="5b98b-382">If no digits can be converted, interpret as an octal by using the leading octal digits up to octal 377; interpret the remaining digits as literals.</span></span>|

## <a name="comparison-using-the-invariant-culture"></a><span data-ttu-id="5b98b-383">Vergleiche mit der invarianten Kultur</span><span class="sxs-lookup"><span data-stu-id="5b98b-383">Comparison Using the Invariant Culture</span></span>

<span data-ttu-id="5b98b-384">Standardmäßig verwendet die Engine für reguläre Ausdrücke bei Vergleichen ohne Berücksichtigung der Groß- und Kleinschreibung die Groß-/Kleinschreibungskonventionen der aktuellen Kultur, um äquivalente Groß- und Kleinbuchstaben zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="5b98b-384">By default, when the regular expression engine performs case-insensitive comparisons, it uses the casing conventions of the current culture to determine equivalent uppercase and lowercase characters.</span></span>

<span data-ttu-id="5b98b-385">Dieses Verhalten ist jedoch für einige Typen von Vergleichen unerwünscht, insbesondere wenn Benutzereingaben mit Namen von Systemressourcen wie Kennwörtern, Dateien oder URLs verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-385">However, this behavior is undesirable for some types of comparisons, particularly when comparing user input to the names of system resources, such as passwords, files, or URLs.</span></span> <span data-ttu-id="5b98b-386">Dieser Prozess wird anhand des folgenden Szenarios veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="5b98b-386">The following example illustrates such as scenario.</span></span> <span data-ttu-id="5b98b-387">Der Code ist dazu gedacht, den Zugriff auf jede Ressource zu blockieren, deren URL mit **FILE://** beginnt.</span><span class="sxs-lookup"><span data-stu-id="5b98b-387">The code is intended to block access to any resource whose URL is prefaced with **FILE://**.</span></span> <span data-ttu-id="5b98b-388">Der reguläre Ausdruck sucht nach einer Übereinstimmung ohne Beachtung der Groß-/Kleinschreibung mit der Zeichenfolge unter Verwendung des regulären Ausdrucks `$FILE://`.</span><span class="sxs-lookup"><span data-stu-id="5b98b-388">The regular expression attempts a case-insensitive match with the string by using the regular expression `$FILE://`.</span></span> <span data-ttu-id="5b98b-389">Wenn die aktuelle Systemkultur jedoch "tr-TR (Türkisch-Türkei)" ist, ist "I" nicht der entsprechende Großbuchstabe zu "i".</span><span class="sxs-lookup"><span data-stu-id="5b98b-389">However, when the current system culture is tr-TR (Turkish-Turkey), "I" is not the uppercase equivalent of "i".</span></span> <span data-ttu-id="5b98b-390">Als Ergebnis gibt der Aufruf der <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType>-Methode `false` zurück, und der Zugriff auf die Datei wird zugelassen.</span><span class="sxs-lookup"><span data-stu-id="5b98b-390">As a result, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method returns `false`, and access to the file is allowed.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#14](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#14)]
[!code-vb[Conceptual.Regex.Language.Options#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#14)]

> [!NOTE]
> <span data-ttu-id="5b98b-391">Weitere Informationen zu Zeichenfolgenvergleichen, bei denen die Groß-/Kleinschreibung beachtet wird und die die invariante Kultur verwenden, finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen](best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="5b98b-391">For more information about string comparisons that are case-sensitive and that use the invariant culture, see [Best Practices for Using Strings](best-practices-strings.md).</span></span>

<span data-ttu-id="5b98b-392">Statt die Vergleiche von der aktuellen Kultur zu verwenden, bei denen nicht zwischen Groß- und Kleinschreibung unterschieden wird, können Sie die <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>-Option angeben, um kulturelle Unterschiede in der Sprache zu ignorieren und die Konventionen der invarianten Kultur zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="5b98b-392">Instead of using the case-insensitive comparisons of the current culture, you can specify the <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> option to ignore cultural differences in language and to use the conventions of the invariant culture.</span></span>

> [!NOTE]
> <span data-ttu-id="5b98b-393">Vergleiche mit der invarianten Kultur sind nur möglich, indem der <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>-Wert an den `options`-Parameter eines <xref:System.Text.RegularExpressions.Regex>-Klassenkonstruktors oder einer statischen Mustervergleichsmethode übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="5b98b-393">Comparison using the invariant culture is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="5b98b-394">Es besteht keine Verfügbarkeit als Inlineoption.</span><span class="sxs-lookup"><span data-stu-id="5b98b-394">It is not available as an inline option.</span></span>

<span data-ttu-id="5b98b-395">Das folgende Beispiel ist mit dem vorherigen Beispiel identisch, abgesehen davon, dass die statische <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>-Methode mit Optionen aufgerufen wird, die <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> enthalten.</span><span class="sxs-lookup"><span data-stu-id="5b98b-395">The following example is identical to the previous example, except that the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method is called with options that include <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5b98b-396">Auch wenn die aktuelle Kultur auf "Türkisch (Türkei)" gesetzt ist, kann die Engine für reguläre Ausdrücke "FILE" und "file" erfolgreich zuordnen und den Zugriff auf die Dateiressource blockieren.</span><span class="sxs-lookup"><span data-stu-id="5b98b-396">Even when the current culture is set to Turkish (Turkey), the regular expression engine is able to successfully match "FILE" and "file" and block access to the file resource.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#15](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#15)]
[!code-vb[Conceptual.Regex.Language.Options#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#15)]

## <a name="see-also"></a><span data-ttu-id="5b98b-397">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="5b98b-397">See also</span></span>

- [<span data-ttu-id="5b98b-398">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</span><span class="sxs-lookup"><span data-stu-id="5b98b-398">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
