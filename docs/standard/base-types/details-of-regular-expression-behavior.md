---
title: Einzelheiten zum Verhalten regulärer Ausdrücke
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: 6a7f29a95cd3042cda1c508ad7472e9378817ebe
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 10/30/2019
ms.locfileid: "73126439"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="25b0e-102">Einzelheiten zum Verhalten regulärer Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="25b0e-102">Details of Regular Expression Behavior</span></span>
<span data-ttu-id="25b0e-103">Die .NET Framework-Engine für reguläre Ausdrücke ist eine zurückverfolgende Engine zum Abgleich regulärer Ausdrücke, die eine herkömmliche NFA-Engine (Nondeterministic Finite Automaton) beinhaltet, wie sie beispielsweise auch von Perl, Python, Emacs und Tcl verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="25b0e-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="25b0e-104">Dadurch unterscheidet es sich von schnelleren, aber vom Umfang her beschränkten DFA-Engines (Deterministic Finite Automaton), die reine reguläre Ausdrücke verwenden. Diese werden z.B. in awk, egrep oder lex verwendet.</span><span class="sxs-lookup"><span data-stu-id="25b0e-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="25b0e-105">Außerdem unterscheidet es sich dadurch von standardisierten, aber langsameren POSIX-NFAs.</span><span class="sxs-lookup"><span data-stu-id="25b0e-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="25b0e-106">Im folgenden Abschnitt werden die drei Typen von Engines für reguläre Ausdrücke beschrieben, und es wird erklärt, warum reguläre Ausdrücke in .NET Framework mit einer herkömmlichen NFA-Engine implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="25b0e-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>  
  
## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="25b0e-107">Vorteile der NFA-Engine</span><span class="sxs-lookup"><span data-stu-id="25b0e-107">Benefits of the NFA Engine</span></span>  
 <span data-ttu-id="25b0e-108">Wenn DFA-Engines Mustervergleiche durchführen, wird die Verarbeitungsreihenfolge durch die Eingabezeichenfolge gesteuert.</span><span class="sxs-lookup"><span data-stu-id="25b0e-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="25b0e-109">Die Engine beginnt am Anfang der Eingabezeichenfolge und geht sequenziell vor, um zu bestimmen, ob das nächste Zeichen mit dem Muster für reguläre Ausdrücke übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="25b0e-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="25b0e-110">So wird garantiert die längstmögliche Zeichenfolge abgeglichen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="25b0e-111">Da dasselbe Zeichen niemals zweimal getestet wird, unterstützen DFA-Engines keine Rückverfolgung.</span><span class="sxs-lookup"><span data-stu-id="25b0e-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="25b0e-112">Da eine DFA-Engine nur einen endlichen Zustand enthält, kann damit kein Muster mit Rückverweisen abgeglichen werden, und weil es keine explizite Erweiterung erstellt, kann es keine Teilausdrücke erfassen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>  
  
 <span data-ttu-id="25b0e-113">Im Gegensatz zu DFA-Engines wird beim Musterabgleich durch herkömmliche NFA-Engines die Verarbeitungsreihenfolge durch das Muster für reguläre Ausdrücke gesteuert.</span><span class="sxs-lookup"><span data-stu-id="25b0e-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="25b0e-114">Während der Verarbeitung eines bestimmten Sprachelements verwendet die Engine den gierigen Abgleich, das heißt, sie gleicht so viel wie irgend möglich von der Eingabezeichenfolge ab.</span><span class="sxs-lookup"><span data-stu-id="25b0e-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="25b0e-115">Es speichert jedoch auch seinen Zustand, nachdem ein Teilausdruck erfolgreich abgeglichen wurde.</span><span class="sxs-lookup"><span data-stu-id="25b0e-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="25b0e-116">Wenn keine Übereinstimmung gefunden wurde, kann die Engine in einen gespeicherten Zustand zurückkehren, um weitere Abgleiche auszuführen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="25b0e-117">Dieser Prozess, bei dem ein erfolgreicher Teilausdrucksabgleich verlassen wird, um spätere Sprachelemente im regulären Ausdruck ebenfalls finden zu können, wird als „Backtracking“ oder *Rückverfolgung* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="25b0e-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="25b0e-118">NFA-Engines verwenden die Rückverfolgung, um alle möglichen Erweiterungen eines regulären Ausdrucks in einer bestimmten Reihenfolge zu testen und die erste Übereinstimmung zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="25b0e-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="25b0e-119">Da eine herkömmliche NFA-Engine für einen erfolgreichen Abgleich eine spezielle Erweiterung des regulären Ausdrucks erstellt, können Übereinstimmungen mit Teilausdrücken erfasst und Übereinstimmungen mit Rückverweisen gefunden werden.</span><span class="sxs-lookup"><span data-stu-id="25b0e-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="25b0e-120">Allerdings kann ein herkömmliches NFA aufgrund der Rückverfolgung den gleichen Zustand über unterschiedliche Pfade mehrmals erreichen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="25b0e-121">Das Resultat ist im ungünstigsten Fall ein exponentiell verlangsamtes Laufzeitverhalten.</span><span class="sxs-lookup"><span data-stu-id="25b0e-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="25b0e-122">Da von einer herkömmlichen NFA-Engine die erste Übereinstimmung akzeptiert wird, bleiben weitere (möglicherweise längere) Übereinstimmungen unentdeckt.</span><span class="sxs-lookup"><span data-stu-id="25b0e-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>  
  
 <span data-ttu-id="25b0e-123">POSIX-NFA-Engines arbeiten wie herkömmliche NFA-Engines, jedoch mit einem Unterschied: Die Rückverfolgung wird so lange fortgesetzt, bis gewährleistet ist, dass die längstmögliche Übereinstimmung gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="25b0e-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="25b0e-124">Aus diesem Grund ist eine POSIX-NFA-Engine langsamer als eine herkömmliche NFA-Engine. Außerdem ist es bei Verwendung einer POSIX-NFA-Engine nicht möglich, durch eine Änderung der Reihenfolge bei der Rückverfolgungssuche einer kürzeren Übereinstimmung Vorrang vor einer längeren zu geben.</span><span class="sxs-lookup"><span data-stu-id="25b0e-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>  
  
 <span data-ttu-id="25b0e-125">Programmierer bevorzugen meist herkömmliche NFA-Engines, da sie eine umfassendere Kontrolle des Zeichenfolgenabgleichs bieten als DFA- oder POSIX-NFA-Engines.</span><span class="sxs-lookup"><span data-stu-id="25b0e-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="25b0e-126">Obwohl sie im ungünstigsten Fall langsam sind, kann durch die Verwendung von Suchmustern, die Mehrdeutigkeiten vermeiden und die Rückverfolgung einschränken, ein lineares oder polynomisches Laufzeitverhalten erreicht werden.</span><span class="sxs-lookup"><span data-stu-id="25b0e-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="25b0e-127">Anders ausgedrückt werden bei NFA-Engines zwar Kompromisse bei der Leistung zugunsten von Funktionalität und Flexibilität eingegangen, doch bieten sie meist eine gute bis akzeptable Leistung, wenn ein regulärer Ausdruck gut geschrieben wurde und Fälle vermieden werden, in denen die Rückverfolgung die Leistung exponentiell beeinträchtigt.</span><span class="sxs-lookup"><span data-stu-id="25b0e-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well-written and avoids cases in which backtracking degrades performance exponentially.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="25b0e-128">Weitere Informationen über die durch eine übermäßige Rückverfolgung verursachten Leistungseinbußen sowie über Methoden, einen regulären Ausdruck zur Umgehung dieses Problems zu erstellen, finden Sie unter [Rückverfolgung](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="25b0e-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="25b0e-129">Funktionen der .NET Framework-Engine</span><span class="sxs-lookup"><span data-stu-id="25b0e-129">.NET Framework Engine Capabilities</span></span>  
 <span data-ttu-id="25b0e-130">Um die Vorteile eines herkömmlichen NFA-Engine voll ausschöpfen zu können, enthält die .NET Framework-Engine für reguläre Ausdrücke einen vollständigen Satz von Konstrukten, mit deren Hilfe Programmierer die Rückverfolgungs-Engine steuern können.</span><span class="sxs-lookup"><span data-stu-id="25b0e-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="25b0e-131">Diese Konstrukte können dazu verwendet werden, Übereinstimmungen schneller zu finden oder spezielle Erweiterungen eines regulären Ausdrucks anderen vorzuziehen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>  
  
 <span data-ttu-id="25b0e-132">Weitere Funktionen der .NET Framework-Engine für reguläre Ausdrücke:</span><span class="sxs-lookup"><span data-stu-id="25b0e-132">Other features of the .NET Framework regular expression engine include the following:</span></span>  
  
- <span data-ttu-id="25b0e-133">Verzögerte Quantifizierer: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="25b0e-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="25b0e-134">Diese Konstrukte veranlassen die Rückverfolgungs-Engine, zuerst die kleinste Anzahl von Wiederholungen zu durchsuchen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="25b0e-135">Im Gegensatz dazu wird bei „gierigen“ Quantifizierern die maximale Anzahl an Wiederholungen zuerst berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="25b0e-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="25b0e-136">Das folgende Beispiel veranschaulicht die Unterschiede zwischen beiden.</span><span class="sxs-lookup"><span data-stu-id="25b0e-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="25b0e-137">Mit einem regulären Ausdruck wird nach einem Satz gesucht, der auf eine Zahl endet, und zum Erfassen dieser Zahl ist eine Erfassungsgruppe vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="25b0e-138">Der reguläre Ausdruck `.+(\d+)\.` schließt den gierigen Quantifizierer `.+` ein, der bewirkt, dass die Engine für reguläre Ausdrücke nur die letzte Ziffer der Zahl erfasst.</span><span class="sxs-lookup"><span data-stu-id="25b0e-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="25b0e-139">Im Gegensatz dazu schließt der reguläre Ausdruck `.+?(\d+)\.` den trägen Quantifizierer `.+?` ein, der bewirkt, dass die Engine für reguläre Ausdrücke die gesamte Zahl erfasst.</span><span class="sxs-lookup"><span data-stu-id="25b0e-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]  
  
     <span data-ttu-id="25b0e-140">Die gierigen und trägen Versionen dieses regulären Ausdrucks werden der folgenden Tabelle entsprechend definiert:</span><span class="sxs-lookup"><span data-stu-id="25b0e-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>
  
    |<span data-ttu-id="25b0e-141">Muster</span><span class="sxs-lookup"><span data-stu-id="25b0e-141">Pattern</span></span>|<span data-ttu-id="25b0e-142">BESCHREIBUNG</span><span class="sxs-lookup"><span data-stu-id="25b0e-142">Description</span></span>|  
    |-------------|-----------------|  
    |<span data-ttu-id="25b0e-143">`.+` (gieriger Quantifizierer)</span><span class="sxs-lookup"><span data-stu-id="25b0e-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="25b0e-144">Sucht nach mindestens einem Vorkommen eines beliebigen Zeichens.</span><span class="sxs-lookup"><span data-stu-id="25b0e-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="25b0e-145">Dadurch sucht die Engine für reguläre Ausdrücke nach einer Übereinstimmung mit der gesamten Zeichenfolge und führt dann bei Bedarf die Rückverfolgung aus, um im Rest des Musters eine Übereinstimmung zu finden.</span><span class="sxs-lookup"><span data-stu-id="25b0e-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|  
    |<span data-ttu-id="25b0e-146">`.+?` (träger Quantifizierer)</span><span class="sxs-lookup"><span data-stu-id="25b0e-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="25b0e-147">Sucht nach mindestens einem Vorkommen eines beliebigen Zeichens, jedoch so wenigen wie möglich.</span><span class="sxs-lookup"><span data-stu-id="25b0e-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|  
    |`(\d+)`|<span data-ttu-id="25b0e-148">Sucht nach mindestens einem numerischen Zeichen und weist dieses der ersten Erfassungsgruppe zu.</span><span class="sxs-lookup"><span data-stu-id="25b0e-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|  
    |`\.`|<span data-ttu-id="25b0e-149">Entsprechung für einen Punkt finden.</span><span class="sxs-lookup"><span data-stu-id="25b0e-149">Match a period.</span></span>|  
  
     <span data-ttu-id="25b0e-150">Weitere Informationen zu verzögerten Quantifizierern finden Sie unter [Quantifizierer](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="25b0e-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="25b0e-151">Positives Lookahead: `(?=`*Teilausdruck*`)`.</span><span class="sxs-lookup"><span data-stu-id="25b0e-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="25b0e-152">Diese Funktion ermöglicht es der Rückverfolgungs-Engine, nach dem Finden eines Teilausdrucks zu derselben Textstelle zurückzukehren.</span><span class="sxs-lookup"><span data-stu-id="25b0e-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="25b0e-153">Um einen Text vollständig zu durchsuchen, empfiehlt es sich, unterschiedliche Muster von derselben Startposition aus anzuwenden.</span><span class="sxs-lookup"><span data-stu-id="25b0e-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="25b0e-154">Zudem kann die Engine überprüfen, ob eine Teilzeichenfolge am Ende der Übereinstimmung vorhanden ist, ohne dass die Teilzeichenfolge im übereinstimmenden Text enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="25b0e-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="25b0e-155">Im folgenden Beispiel werden die Wörter in einem Satz, denen keine Interpunktionszeichen folgen, mithilfe eines positiven Lookaheads extrahiert.</span><span class="sxs-lookup"><span data-stu-id="25b0e-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]  
  
     <span data-ttu-id="25b0e-156">Der reguläre Ausdruck `\b[A-Z]+\b(?=\P{P})` wird entsprechend der Darstellung in der folgenden Tabelle definiert:</span><span class="sxs-lookup"><span data-stu-id="25b0e-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="25b0e-157">Muster</span><span class="sxs-lookup"><span data-stu-id="25b0e-157">Pattern</span></span>|<span data-ttu-id="25b0e-158">BESCHREIBUNG</span><span class="sxs-lookup"><span data-stu-id="25b0e-158">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="25b0e-159">Der Vergleich beginnt an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="25b0e-159">Begin the match at a word boundary.</span></span>|  
    |`[A-Z]+`|<span data-ttu-id="25b0e-160">Sucht ein- oder mehrmals nach einer Übereinstimmung mit einem beliebigen Buchstabenzeichen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="25b0e-161">Bei diesem Vergleich wird die Groß-/Kleinschreibung nicht beachtet, da die <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType>-Methode mit der <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>-Option aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="25b0e-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|  
    |`\b`|<span data-ttu-id="25b0e-162">Der Vergleich endet an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="25b0e-162">End the match at a word boundary.</span></span>|  
    |`(?=\P{P})`|<span data-ttu-id="25b0e-163">Lookahead, um zu bestimmen, ob es sich beim nächsten Zeichen um ein Interpunktionszeichen handelt.</span><span class="sxs-lookup"><span data-stu-id="25b0e-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="25b0e-164">Wenn dies nicht der Fall ist, ist der Abgleich erfolgreich.</span><span class="sxs-lookup"><span data-stu-id="25b0e-164">If it is not, the match succeeds.</span></span>|  
  
     <span data-ttu-id="25b0e-165">Weitere Informationen zu positiven Lookaheadassertionen finden Sie unter [Gruppierungskonstrukte](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="25b0e-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="25b0e-166">Negatives Lookahead: `(?!`*Teilausdruck*`)`.</span><span class="sxs-lookup"><span data-stu-id="25b0e-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="25b0e-167">Diese Funktion ermöglicht es, nur dann eine Übereinstimmung mit einem Ausdruck zu erhalten, wenn ein Teilausdruck kein Ergebnis liefert.</span><span class="sxs-lookup"><span data-stu-id="25b0e-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="25b0e-168">Dies ist beim Bereinigen einer Suche besonders effektiv, da es oftmals einfacher ist, einen Ausdruck für einen auszuschließenden Fall anzugeben als einen Ausdruck für Fälle, die eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-168">This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="25b0e-169">Beispielsweise ist es schwierig, einen Ausdruck für Wörter zu schreiben, die nicht mit „un“ beginnen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="25b0e-170">Im folgenden Beispiel erfolgt der Ausschluss mithilfe eines negativen Lookaheads.</span><span class="sxs-lookup"><span data-stu-id="25b0e-170">The following example uses negative lookahead to exclude them.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]  
  
     <span data-ttu-id="25b0e-171">Das Muster für reguläre Ausdrücke `\b(?!non)\w+\b` wird entsprechend der folgenden Tabelle definiert:</span><span class="sxs-lookup"><span data-stu-id="25b0e-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="25b0e-172">Muster</span><span class="sxs-lookup"><span data-stu-id="25b0e-172">Pattern</span></span>|<span data-ttu-id="25b0e-173">BESCHREIBUNG</span><span class="sxs-lookup"><span data-stu-id="25b0e-173">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="25b0e-174">Der Vergleich beginnt an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="25b0e-174">Begin the match at a word boundary.</span></span>|  
    |`(?!non)`|<span data-ttu-id="25b0e-175">Lookahead, um sicherzustellen, dass die aktuelle Zeichenfolge nicht mit „non“ beginnt.</span><span class="sxs-lookup"><span data-stu-id="25b0e-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="25b0e-176">Andernfalls wird keine Übereinstimmung gefunden.</span><span class="sxs-lookup"><span data-stu-id="25b0e-176">If it does, the match fails.</span></span>|  
    |`(\w+)`|<span data-ttu-id="25b0e-177">Übereinstimmung mit mindestens einem Wortzeichen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-177">Match one or more word characters.</span></span>|  
    |`\b`|<span data-ttu-id="25b0e-178">Der Vergleich endet an einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="25b0e-178">End the match at a word boundary.</span></span>|  
  
     <span data-ttu-id="25b0e-179">Weitere Informationen zu negativen Lookaheadassertionen finden Sie unter [Gruppierungskonstrukte](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="25b0e-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="25b0e-180">Bedingte Auswertung: `(?(`*Ausdruck*`)`*ja*`|`*nein*`)` und `(?(`*Name*`)`*ja*`|`*nein*`)`, wobei *Ausdruck* ein zu suchender Teilausdruck ist, *Name* der Name einer Erfassungsgruppe, *ja* die zu suchende Zeichenfolge, wenn *Ausdruck* gefunden wurde oder *Name* eine gültige, nicht leere Erfassungsgruppe ist, und *nein* der zu suchende Teilausdruck ist, wenn *Ausdruck* nicht gefunden wurde oder *Name* keine gültige, nicht leere Erfassungsgruppe ist.</span><span class="sxs-lookup"><span data-stu-id="25b0e-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="25b0e-181">Mit dieser Funktion kann die Engine je nach Ergebnis eines vorherigen Teilausdrucksabgleichs oder je nach Ergebnis einer Assertion mit einer Breite von 0 (null) anhand mehrerer Alternativmuster suchen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="25b0e-182">Dies lässt eine leistungsstärkere Form von Rückverfolgung zu, die es beispielsweise erlaubt, einen Teilausdruck auf der Grundlage davon zu suchen, ob eine Übereinstimmung mit einem vorherigen Teilausdruck gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="25b0e-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="25b0e-183">Der reguläre Ausdruck im folgenden Beispiel gleicht Absätze ab, die sowohl für die öffentliche als auch für die interne Verwendung vorgesehen sind.</span><span class="sxs-lookup"><span data-stu-id="25b0e-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="25b0e-184">Absätze, die nur für die interne Verwendung vorgesehen sind, beginnen mit einem `<PRIVATE>`-Tag.</span><span class="sxs-lookup"><span data-stu-id="25b0e-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="25b0e-185">Das Muster für reguläre Ausdrücke `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` weist den Inhalt von Absätzen, die für die öffentliche und interne Verwendung vorgesehen sind, mithilfe einer bedingten Auswertung zu, um Erfassungsgruppen zu trennen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="25b0e-186">Diese Absätze können dann unterschiedlich behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="25b0e-186">These paragraphs can then be handled differently.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]  
  
     <span data-ttu-id="25b0e-187">Das Muster für reguläre Ausdrücke ist wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="25b0e-187">The regular expression pattern is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="25b0e-188">Muster</span><span class="sxs-lookup"><span data-stu-id="25b0e-188">Pattern</span></span>|<span data-ttu-id="25b0e-189">BESCHREIBUNG</span><span class="sxs-lookup"><span data-stu-id="25b0e-189">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="25b0e-190">Beginnt den Abgleich am Anfang einer Zeile.</span><span class="sxs-lookup"><span data-stu-id="25b0e-190">Begin the match at the beginning of a line.</span></span>|  
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="25b0e-191">Sucht nach 0 oder 1 Vorkommen der Zeichenfolge `<PRIVATE>`, gefolgt von einem Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="25b0e-192">Weist die Übereinstimmung der Erfassungsgruppe `Pvt` zu.</span><span class="sxs-lookup"><span data-stu-id="25b0e-192">Assign the match to a capturing group named `Pvt`.</span></span>|  
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="25b0e-193">Wenn die Erfassungsgruppe `Pvt` vorhanden ist, wird nach einem oder mehreren Vorkommen eines oder mehrerer Wortzeichen gesucht, denen 0 oder 1 Interpunktionszeichen und dann ein Leerzeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="25b0e-194">Weist die Teilzeichenfolge der ersten Erfassungsgruppe zu.</span><span class="sxs-lookup"><span data-stu-id="25b0e-194">Assign the substring to the first capturing group.</span></span>|  
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="25b0e-195">Wenn die Erfassungsgruppe `Pvt` nicht vorhanden ist, wird nach einem oder mehreren Vorkommen eines oder mehrerer Wortzeichen gesucht, denen 0 oder 1 Interpunktionszeichen und dann ein Leerzeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="25b0e-196">Weist die Teilzeichenfolge der dritten Erfassungsgruppe zu.</span><span class="sxs-lookup"><span data-stu-id="25b0e-196">Assign the substring to the third capturing group.</span></span>|  
    |`\r?$`|<span data-ttu-id="25b0e-197">Gleicht das Ende einer Zeile oder das Ende der Zeichenfolge ab.</span><span class="sxs-lookup"><span data-stu-id="25b0e-197">Match the end of a line or the end of the string.</span></span>|  
  
     <span data-ttu-id="25b0e-198">Weitere Informationen zur bedingten Auswertung finden Sie unter [Alternierungskonstrukte](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="25b0e-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="25b0e-199">Ausgleichen von Gruppendefinitionen: `(?<`*Name1*`-`*Name2*`>`*Teilausdruck*`)`.</span><span class="sxs-lookup"><span data-stu-id="25b0e-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="25b0e-200">Diese Funktion ermöglicht es der Engine für reguläre Ausdrücke, geschachtelte Konstrukte nachzuverfolgen, z.B. runde Klammern oder öffnende und schließende eckige Klammern.</span><span class="sxs-lookup"><span data-stu-id="25b0e-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="25b0e-201">Ein Beispiel finden Sie unter [Gruppierungskonstrukte](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="25b0e-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="25b0e-202">Nicht zurückverfolgender Teilausdruck (auch als gierige Teilausdrücke bezeichnet): `(?>`*Teilausdruck*`)`.</span><span class="sxs-lookup"><span data-stu-id="25b0e-202">Nonbacktracking subexpressions (also known as greedy subexpressions): `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="25b0e-203">Durch diese Funktion kann die Rückverfolgungs-Engine sicherstellen, dass nur die erste Übereinstimmung mit einem Teilausdruck geliefert wird, so als wäre der Teilausdruck unabhängig von dem vollständigen Ausdruck.</span><span class="sxs-lookup"><span data-stu-id="25b0e-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="25b0e-204">Wenn Sie dieses Konstrukt nicht verwenden, kann das Verhalten eines Teilausdrucks durch Suchläufe mit Rückverfolgung über den längeren Ausdruck beeinflusst werden.</span><span class="sxs-lookup"><span data-stu-id="25b0e-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="25b0e-205">Der reguläre Ausdruck `(a+)\w` stimmt beispielsweise mit einem oder mehreren „a“-Zeichen sowie einem Wortzeichen überein, das der Sequenz von „a“-Zeichen folgt, und weist die Sequenz von „a“-Zeichen der ersten Erfassungsgruppe zu. Wenn das abschließende Zeichen der Eingabezeichenfolge jedoch ebenfalls ein „a“ ist, wird es mit dem Sprachelement `\w` abgeglichen und nicht in die Erfassungsgruppe aufgenommen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group, However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]  
  
     <span data-ttu-id="25b0e-206">Der reguläre Ausdruck `((?>a+))\w` verhindert dieses Verhalten.</span><span class="sxs-lookup"><span data-stu-id="25b0e-206">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="25b0e-207">Da alle aufeinander folgenden „a“-Zeichen ohne Rückverfolgung abgeglichen werden, sind alle aufeinander folgenden „a“-Zeichen in der ersten Erfassungsgruppe enthalten.</span><span class="sxs-lookup"><span data-stu-id="25b0e-207">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="25b0e-208">Wenn dem „a“-Zeichen nicht mindestens ein weiteres Zeichen folgt, bei dem es sich nicht um „a“ handelt, liegt keine Übereinstimmung vor.</span><span class="sxs-lookup"><span data-stu-id="25b0e-208">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]  
  
     <span data-ttu-id="25b0e-209">Weitere Informationen zu nicht zurückverfolgenden Teilausdrücken finden Sie unter [Gruppierungskonstrukte](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="25b0e-209">For more information about nonbacktracking subexpressions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="25b0e-210">Der Abgleich von rechts nach links, der durch Festlegen der <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>-Option für eine Suchmethode für <xref:System.Text.RegularExpressions.Regex>-Klassenkonstruktoren oder statische Instanzen angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="25b0e-210">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="25b0e-211">Diese Funktion eignet sich für die Suche von rechts nach links (statt von links nach rechts) oder in Fällen, in denen es effektiver ist, auf der rechten Seite eines Musters mit der Suche zu beginnen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-211">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="25b0e-212">Wie im folgenden Beispiel veranschaulicht, kann mit dem Abgleich von rechts nach links das Verhalten gieriger Quantifizierer geändert werden.</span><span class="sxs-lookup"><span data-stu-id="25b0e-212">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="25b0e-213">Im Beispiel werden zwei Suchen nach einem Satz ausgeführt, der auf eine Zahl endet.</span><span class="sxs-lookup"><span data-stu-id="25b0e-213">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="25b0e-214">Mit der Suche von links nach rechts, für die der gierige Quantifizierer `+` verwendet wird, wird eine der sechs Ziffern im Satz gefunden. Hingegen werden bei der Suche von rechts nach links alle sechs Ziffern gefunden.</span><span class="sxs-lookup"><span data-stu-id="25b0e-214">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="25b0e-215">Eine Beschreibung des Musters für reguläre Ausdrücke finden Sie weiter oben in diesem Abschnitt im Beispiel zur Veranschaulichung träger Quantifizierer.</span><span class="sxs-lookup"><span data-stu-id="25b0e-215">For an description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]  
  
     <span data-ttu-id="25b0e-216">Weitere Informationen zum Abgleich von rechts nach links finden Sie unter [Optionen für reguläre Ausdrücke](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="25b0e-216">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
- <span data-ttu-id="25b0e-217">Positives und negatives Lookbehind: `(?<=`*Teilausdruck*`)` für positives Lookbehind und `(?<!`*Teilausdruck*`)` für negatives Lookbehind.</span><span class="sxs-lookup"><span data-stu-id="25b0e-217">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="25b0e-218">Diese Funktion ähnelt dem zuvor in diesem Thema erläuterten Lookahead.</span><span class="sxs-lookup"><span data-stu-id="25b0e-218">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="25b0e-219">Reguläre Ausdrücke gestatten uneingeschränkte Lookbehinds, da eine vollständige Suche nach Übereinstimmungen von rechts nach links möglich ist.</span><span class="sxs-lookup"><span data-stu-id="25b0e-219">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="25b0e-220">Positives und negatives Lookbehind können auch verwendet werden, um das Schachteln von Quantifizierern zu vermeiden, wenn der geschachtelte Teilausdruck eine Obermenge eines äußeren Ausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="25b0e-220">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="25b0e-221">Reguläre Ausdrücke mit solchen geschachtelten Quantifizierern bieten oft eine schlechte Leistung.</span><span class="sxs-lookup"><span data-stu-id="25b0e-221">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="25b0e-222">Im folgenden Beispiel wird z.B. überprüft, ob eine Zeichenfolge mit einem alphanumerischen Zeichen beginnt und endet und ob ein beliebiges anderes Zeichen in der Zeichenfolge zu einer größeren Teilmenge gehört.</span><span class="sxs-lookup"><span data-stu-id="25b0e-222">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="25b0e-223">Sie bildet einen Teil des regulären Ausdrucks zum Überprüfen von E-Mail-Adressen. Weitere Informationen finden Sie unter [Vorgehensweise: Überprüfen, ob Zeichenfolgen ein gültiges E-Mail-Format aufweisen](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="25b0e-223">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]  
  
     <span data-ttu-id="25b0e-224">Der reguläre Ausdruck ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` wird entsprechend der Darstellung in der folgenden Tabelle definiert:</span><span class="sxs-lookup"><span data-stu-id="25b0e-224">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="25b0e-225">Muster</span><span class="sxs-lookup"><span data-stu-id="25b0e-225">Pattern</span></span>|<span data-ttu-id="25b0e-226">BESCHREIBUNG</span><span class="sxs-lookup"><span data-stu-id="25b0e-226">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="25b0e-227">Beginnt die Suche am Anfang der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="25b0e-227">Begin the match at the beginning of the string.</span></span>|  
    |`[A-Z0-9]`|<span data-ttu-id="25b0e-228">Übereinstimmung mit beliebigem numerischen oder alphanumerischen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-228">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="25b0e-229">(Beim Vergleich wird die Groß-und Kleinschreibung nicht berücksichtigt.)</span><span class="sxs-lookup"><span data-stu-id="25b0e-229">(The comparison is case-insensitive.)</span></span>|  
    |<span data-ttu-id="25b0e-230"><code>([-!#$%&'.\*+/=?^\`{}&#124;~\w])\*</code>|Übereinstimmung mit 0 („null“) oder mehr Vorkommen eines beliebigen Wortzeichens oder eines der folgenden Zeichen: -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, \`, {, }, &#124; oder ~.</span><span class="sxs-lookup"><span data-stu-id="25b0e-230"><code>([-!#$%&'.\*+/=?^\`{}&#124;~\w])\*</code>|Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, \`, {, }, &#124;, or ~.</span></span>|  
    |`(?<=[A-Z0-9])`|<span data-ttu-id="25b0e-231">Lookbehind für vorheriges Zeichen, das numerisch oder alphanumerisch sein muss.</span><span class="sxs-lookup"><span data-stu-id="25b0e-231">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="25b0e-232">(Beim Vergleich wird die Groß-und Kleinschreibung nicht berücksichtigt.)</span><span class="sxs-lookup"><span data-stu-id="25b0e-232">(The comparison is case-insensitive.)</span></span>|  
    |`$`|<span data-ttu-id="25b0e-233">Beendet die Suche am Ende der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="25b0e-233">End the match at the end of the string.</span></span>|  
  
     <span data-ttu-id="25b0e-234">Weitere Informationen zu positivem und negativem Lookbehind finden Sie unter [Gruppierungskonstrukte](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="25b0e-234">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="25b0e-235">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="25b0e-235">Related Topics</span></span>  
  
|<span data-ttu-id="25b0e-236">Titel</span><span class="sxs-lookup"><span data-stu-id="25b0e-236">Title</span></span>|<span data-ttu-id="25b0e-237">BESCHREIBUNG</span><span class="sxs-lookup"><span data-stu-id="25b0e-237">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="25b0e-238">Backtracking</span><span class="sxs-lookup"><span data-stu-id="25b0e-238">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="25b0e-239">Informationen über die Verwendung der Rückverfolgung bei regulären Ausdrücken, um mit Verzweigungen nach alternativen Übereinstimmungen zu suchen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-239">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|  
|[<span data-ttu-id="25b0e-240">Kompilierung und Wiederverwendung</span><span class="sxs-lookup"><span data-stu-id="25b0e-240">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="25b0e-241">Informationen zum Kompilieren und Wiederverwenden regulärer Ausdrücke mit dem Ziel der Leistungsverbesserung.</span><span class="sxs-lookup"><span data-stu-id="25b0e-241">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|  
|[<span data-ttu-id="25b0e-242">Threadsicherheit</span><span class="sxs-lookup"><span data-stu-id="25b0e-242">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="25b0e-243">Informationen zur Threadsicherheit bei regulären Ausdrücken und Erläuterungen zur Notwendigkeit eines synchronisierten Zugriffs auf Objekte in regulären Ausdrücken.</span><span class="sxs-lookup"><span data-stu-id="25b0e-243">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|  
|[<span data-ttu-id="25b0e-244">Reguläre Ausdrücke von .NET Framework</span><span class="sxs-lookup"><span data-stu-id="25b0e-244">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="25b0e-245">Übersicht über die programmiersprachenbezogenen Aspekte von regulären Ausdrücken.</span><span class="sxs-lookup"><span data-stu-id="25b0e-245">Provides an overview of the programming language aspect of regular expressions.</span></span>|  
|[<span data-ttu-id="25b0e-246">Das Objektmodell für reguläre Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="25b0e-246">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="25b0e-247">Informationen und Codebeispiele, die die Verwendung von Klassen für reguläre Ausdrücke veranschaulichen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-247">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|  
|[<span data-ttu-id="25b0e-248">Beispiele für reguläre Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="25b0e-248">Regular Expression Examples</span></span>](../../../docs/standard/base-types/regular-expression-examples.md)|<span data-ttu-id="25b0e-249">Codebeispiele, die die Verwendung regulärer Ausdrücke in üblichen Anwendungen veranschaulichen.</span><span class="sxs-lookup"><span data-stu-id="25b0e-249">Contains code examples that illustrate the use of regular expressions in common applications.</span></span>|  
|[<span data-ttu-id="25b0e-250">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</span><span class="sxs-lookup"><span data-stu-id="25b0e-250">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="25b0e-251">Informationen zu Zeichensatz, Operatoren und Konstrukten, mit denen Sie reguläre Ausdrücke definieren können.</span><span class="sxs-lookup"><span data-stu-id="25b0e-251">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="25b0e-252">Referenz</span><span class="sxs-lookup"><span data-stu-id="25b0e-252">Reference</span></span>  
 <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
