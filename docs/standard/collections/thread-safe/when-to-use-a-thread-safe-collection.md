---
title: Verwendung einer threadsicheren Auflistung
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, when to upgrade
ms.assetid: a9babe97-e457-4ff3-b528-a1bc940d5320
ms.openlocfilehash: 5a0abef6de9f932f44fc7e3239b98c3a27846580
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/15/2020
ms.locfileid: "75711219"
---
# <a name="when-to-use-a-thread-safe-collection"></a><span data-ttu-id="497db-102">Verwendung einer threadsicheren Auflistung</span><span class="sxs-lookup"><span data-stu-id="497db-102">When to Use a Thread-Safe Collection</span></span>
<span data-ttu-id="497db-103">Mit .NET Framework 4 werden fünf neue Auflistungstypen eingeführt, die speziell für die Unterstützung von Hinzufügungs- und Entfernungsvorgängen in mehreren Threads konzipiert sind.</span><span class="sxs-lookup"><span data-stu-id="497db-103">The .NET Framework 4 introduces five new collection types that are specially designed to support multi-threaded add and remove operations.</span></span> <span data-ttu-id="497db-104">Zur Gewährleistung von Threadsicherheit verwenden diese neuen Typen unterschiedliche Arten effizienter sperrender und sperrfreier Synchronisierungsmechanismen.</span><span class="sxs-lookup"><span data-stu-id="497db-104">To achieve thread-safety, these new types use various kinds of efficient locking and lock-free synchronization mechanisms.</span></span> <span data-ttu-id="497db-105">Ein Vorgang wird durch Synchronisierung aufwändiger.</span><span class="sxs-lookup"><span data-stu-id="497db-105">Synchronization adds overhead to an operation.</span></span> <span data-ttu-id="497db-106">Das Ausmaß des Aufwands hängt von der Art der verwendeten Synchronisierung, der Art der ausgeführten Vorgänge und von anderen Faktoren ab, z.B. der Anzahl der Threads, die versuchen, gleichzeitig auf die Sammlung zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="497db-106">The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</span></span>  
  
 <span data-ttu-id="497db-107">In einigen Szenarien ist der Synchronisierungsaufwand unwesentlich und ermöglicht eine deutlich schnellere Ausführung und bessere Skalierbarkeit des Multithreadtyps als beim nicht threadsicheren Äquivalent, wenn ein Schutz durch eine externe Sperre besteht.</span><span class="sxs-lookup"><span data-stu-id="497db-107">In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</span></span> <span data-ttu-id="497db-108">In anderen Szenarien kann der Aufwand dazu führen, dass der threadsichere Typ in etwa mit der gleichen oder sogar einer geringeren Leistung und Skalierbarkeit ausgeführt wird wie die extern gesperrte, nicht threadsichere Version des Typs.</span><span class="sxs-lookup"><span data-stu-id="497db-108">In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</span></span>  
  
 <span data-ttu-id="497db-109">Die folgenden Abschnitte enthalten eine allgemeine Anleitung dazu, wann eine threadsichere Sammlung anstelle ihres nicht threadsicheren Äquivalents verwendet wird, das eine vom Benutzer bereitgestellte Sperre für die Lese- und Schreibvorgänge besitzt.</span><span class="sxs-lookup"><span data-stu-id="497db-109">The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</span></span> <span data-ttu-id="497db-110">Da die Leistung von vielen Faktoren abhängig sein kann, handelt es sich nicht um eine spezielle Anleitung, die daher nicht unter allen Umständen gültig ist.</span><span class="sxs-lookup"><span data-stu-id="497db-110">Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</span></span> <span data-ttu-id="497db-111">Wenn die Leistung sehr wichtig ist, ist die am besten geeignete Methode zur Bestimmung des zu verwendenden Sammlungstyps die Messung der Leistung auf Basis von repräsentativen Computerkonfigurationen und Lasten.</span><span class="sxs-lookup"><span data-stu-id="497db-111">If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</span></span> <span data-ttu-id="497db-112">In diesem Dokument werden die folgenden Begriffe verwendet:</span><span class="sxs-lookup"><span data-stu-id="497db-112">This document uses the following terms:</span></span>  
  
 <span data-ttu-id="497db-113">*Reines Producer-Consumer-Szenario*</span><span class="sxs-lookup"><span data-stu-id="497db-113">*Pure producer-consumer scenario*</span></span>  
 <span data-ttu-id="497db-114">In jedem vorhandenen Thread werden Elemente entweder hinzugefügt oder entfernt, es finden jedoch nicht beide Vorgänge statt.</span><span class="sxs-lookup"><span data-stu-id="497db-114">Any given thread is either adding or removing elements, but not both.</span></span>  
  
 <span data-ttu-id="497db-115">*Gemischtes Producer-Consumer-Szenario*</span><span class="sxs-lookup"><span data-stu-id="497db-115">*Mixed producer-consumer scenario*</span></span>  
 <span data-ttu-id="497db-116">In jedem vorhandenen Thread werden Elemente sowohl hinzugefügt als auch entfernt.</span><span class="sxs-lookup"><span data-stu-id="497db-116">Any given thread is both adding and removing elements.</span></span>  
  
 <span data-ttu-id="497db-117">*Geschwindigkeitszuwachs*</span><span class="sxs-lookup"><span data-stu-id="497db-117">*Speedup*</span></span>  
 <span data-ttu-id="497db-118">Höhere algorithmische Leistung relativ zu einem anderen Typ im gleichen Szenario.</span><span class="sxs-lookup"><span data-stu-id="497db-118">Faster algorithmic performance relative to another type in the same scenario.</span></span>  
  
 <span data-ttu-id="497db-119">*Skalierbarkeit*</span><span class="sxs-lookup"><span data-stu-id="497db-119">*Scalability*</span></span>  
 <span data-ttu-id="497db-120">Die Zunahme der Leistung, die proportional zur Anzahl der Kerne des Computers ist.</span><span class="sxs-lookup"><span data-stu-id="497db-120">The increase in performance that is proportional to the number of cores on the computer.</span></span> <span data-ttu-id="497db-121">Mit einem Algorithmus, der skaliert wird, werden bei acht Kernen höhere Leistungen erzielt als bei zwei Kernen.</span><span class="sxs-lookup"><span data-stu-id="497db-121">An algorithm that scales performs faster on eight cores than it does on two cores.</span></span>  
  
## <a name="concurrentqueuet-vs-queuet"></a><span data-ttu-id="497db-122">ConcurrentQueue(T) oder Queue(T)</span><span class="sxs-lookup"><span data-stu-id="497db-122">ConcurrentQueue(T) vs. Queue(T)</span></span>  
 <span data-ttu-id="497db-123">In reinen Producer-Consumer-Szenarien, in denen die Verarbeitungszeit für jedes Element sehr kurz ist (einige Anweisungen), kann <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> geringfügige Leistungsvorteile gegenüber <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> mit einer externen Sperre bieten.</span><span class="sxs-lookup"><span data-stu-id="497db-123">In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> can offer modest performance benefits over a <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> that has an external lock.</span></span> <span data-ttu-id="497db-124">In diesem Szenario erzielt <xref:System.Collections.Concurrent.ConcurrentQueue%601> die beste Leistung, wenn sich ein dedizierter Thread in der Warteschlange befindet und ein dedizierter Thread die Warteschlange verlässt.</span><span class="sxs-lookup"><span data-stu-id="497db-124">In this scenario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</span></span> <span data-ttu-id="497db-125">Wenn Sie diese Regel nicht erzwingen, kann <xref:System.Collections.Generic.Queue%601> sogar etwas schneller als <xref:System.Collections.Concurrent.ConcurrentQueue%601> auf Computern mit mehreren Kernen ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="497db-125">If you do not enforce this rule, then <xref:System.Collections.Generic.Queue%601> might even perform slightly faster than <xref:System.Collections.Concurrent.ConcurrentQueue%601> on computers that have multiple cores.</span></span>  
  
 <span data-ttu-id="497db-126">Wenn die Verarbeitungszeit bei etwa 500 FLOPS (Gleitkommavorgänge) oder höher liegt, gilt die Zwei-Thread-Regel nicht für <xref:System.Collections.Concurrent.ConcurrentQueue%601>, sodass dann eine sehr gute Skalierbarkeit möglich ist.</span><span class="sxs-lookup"><span data-stu-id="497db-126">When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <xref:System.Collections.Concurrent.ConcurrentQueue%601>, which then has very good scalability.</span></span> <span data-ttu-id="497db-127"><xref:System.Collections.Generic.Queue%601> lässt sich in diesem Szenario nicht vorteilhaft skalieren.</span><span class="sxs-lookup"><span data-stu-id="497db-127"><xref:System.Collections.Generic.Queue%601> does not scale well in this scenario.</span></span>  
  
 <span data-ttu-id="497db-128">Bei sehr geringer Verarbeitungszeit zeichnet sich <xref:System.Collections.Generic.Queue%601> mit einer externen Sperre in gemischten Producer-Consumer-Szenarien durch eine bessere Skalierbarkeit als <xref:System.Collections.Concurrent.ConcurrentQueue%601> aus.</span><span class="sxs-lookup"><span data-stu-id="497db-128">In mixed producer-consumer scenarios, when the processing time is very small, a <xref:System.Collections.Generic.Queue%601> that has an external lock scales better than <xref:System.Collections.Concurrent.ConcurrentQueue%601> does.</span></span> <span data-ttu-id="497db-129">Wenn die Verarbeitungszeit jedoch bei etwa 500 FLOPS oder darüber liegt, kann <xref:System.Collections.Concurrent.ConcurrentQueue%601> besser skaliert werden.</span><span class="sxs-lookup"><span data-stu-id="497db-129">However, when processing time is around 500 FLOPS or more, then the <xref:System.Collections.Concurrent.ConcurrentQueue%601> scales better.</span></span>  
  
## <a name="concurrentstack-vs-stack"></a><span data-ttu-id="497db-130">ConcurrentStack oder Stapel</span><span class="sxs-lookup"><span data-stu-id="497db-130">ConcurrentStack vs. Stack</span></span>  
 <span data-ttu-id="497db-131">In reinen Producer-Consumer-Szenarien erzielen <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> und <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> mit einer externen Sperre bei sehr geringer Verarbeitungszeit wahrscheinlich annähernd die gleiche Leistung mit einem dedizierten Thread für Ablegevorgänge und einem dedizierten Thread für Abholvorgänge.</span><span class="sxs-lookup"><span data-stu-id="497db-131">In pure producer-consumer scenarios, when processing time is very small, then <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</span></span> <span data-ttu-id="497db-132">Bei zunehmender Anzahl der Threads werden jedoch beide Typen aufgrund des stärkeren Konflikts langsamer, und mit <xref:System.Collections.Generic.Stack%601> werden unter Umständen bessere Leistungen als mit <xref:System.Collections.Concurrent.ConcurrentStack%601> erzielt.</span><span class="sxs-lookup"><span data-stu-id="497db-132">However, as the number of threads increases, both types slow down because of increased contention, and <xref:System.Collections.Generic.Stack%601> might perform better than <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span></span> <span data-ttu-id="497db-133">Wenn die Verarbeitungszeit bei rund 500 FLOPS oder darüber liegt, werden beide Typen mit der etwa gleichen Rate skaliert.</span><span class="sxs-lookup"><span data-stu-id="497db-133">When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</span></span>  
  
 <span data-ttu-id="497db-134">In gemischten Producer-Consumer-Szenarien ist <xref:System.Collections.Concurrent.ConcurrentStack%601> für kleine und große Arbeitsauslastungen schneller.</span><span class="sxs-lookup"><span data-stu-id="497db-134">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentStack%601> is faster for both small and large workloads.</span></span>  
  
 <span data-ttu-id="497db-135">Die Verwendung von <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> und <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> kann die Zugriffszeiten unter Umständen erheblich beschleunigen.</span><span class="sxs-lookup"><span data-stu-id="497db-135">The use of the <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> and <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> may greatly speed up access times.</span></span>  
  
## <a name="concurrentdictionary-vs-dictionary"></a><span data-ttu-id="497db-136">ConcurrentDictionary oder Dictionary</span><span class="sxs-lookup"><span data-stu-id="497db-136">ConcurrentDictionary vs. Dictionary</span></span>  
 <span data-ttu-id="497db-137">Verwenden Sie <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> im Allgemeinen in jedem Szenario, in dem Sie Schlüssel oder Werte gleichzeitig aus mehreren Threads hinzufügen und aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="497db-137">In general, use a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</span></span> <span data-ttu-id="497db-138">In Szenarien, die häufige Updates und relativ wenige Lesevorgänge umfassen, bietet <xref:System.Collections.Concurrent.ConcurrentDictionary%602> in der Regel geringfügige Vorteile.</span><span class="sxs-lookup"><span data-stu-id="497db-138">In scenarios that involve frequent updates and relatively few reads, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally offers modest benefits.</span></span> <span data-ttu-id="497db-139">In Szenarien, die zahlreiche Lesevorgänge und Updates umfassen, ist <xref:System.Collections.Concurrent.ConcurrentDictionary%602> im Allgemeinen auf Computern bedeutend schneller, die über eine beliebige Anzahl von Kernen verfügen.</span><span class="sxs-lookup"><span data-stu-id="497db-139">In scenarios that involve many reads and many updates, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally is significantly faster on computers that have any number of cores.</span></span>  
  
 <span data-ttu-id="497db-140">In Szenarien, die häufige Updates umfassen, können Sie den Grad der Parallelität in <xref:System.Collections.Concurrent.ConcurrentDictionary%602> erhöhen und anschließend ermitteln, ob sich die Leistung auf Computern mit einer größeren Anzahl von Kernen verbessert.</span><span class="sxs-lookup"><span data-stu-id="497db-140">In scenarios that involve frequent updates, you can increase the degree of concurrency in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and then measure to see whether performance increases on computers that have more cores.</span></span> <span data-ttu-id="497db-141">Wenn Sie die Parallelitätsebene ändern, vermeiden Sie so weit wie möglich globale Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="497db-141">If you change the concurrency level, avoid global operations as much as possible.</span></span>  
  
 <span data-ttu-id="497db-142">Wenn Sie nur Schlüssel oder Werte lesen, ist <xref:System.Collections.Generic.Dictionary%602> schneller, da keine Synchronisierung erforderlich ist, wenn das Wörterbuch nicht von Threads geändert wird.</span><span class="sxs-lookup"><span data-stu-id="497db-142">If you are only reading key or values, the <xref:System.Collections.Generic.Dictionary%602> is faster because no synchronization is required if the dictionary is not being modified by any threads.</span></span>  
  
## <a name="concurrentbag"></a><span data-ttu-id="497db-143">ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="497db-143">ConcurrentBag</span></span>  
 <span data-ttu-id="497db-144">In reinen Producer-Consumer-Szenarien ist <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> wahrscheinlich langsamer als die anderen gleichzeitigen Sammlungstypen.</span><span class="sxs-lookup"><span data-stu-id="497db-144">In pure producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> will probably perform more slowly than the other concurrent collection types.</span></span>  
  
 <span data-ttu-id="497db-145">In gemischten Producer-Consumer-Szenarien ist <xref:System.Collections.Concurrent.ConcurrentBag%601> sowohl bei großen als auch bei kleinen Arbeitsauslastungen im Allgemeinen viel schneller und besser skalierbar als ein beliebiger anderer gleichzeitiger Sammlungstyp.</span><span class="sxs-lookup"><span data-stu-id="497db-145">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</span></span>  
  
## <a name="blockingcollection"></a><span data-ttu-id="497db-146">BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="497db-146">BlockingCollection</span></span>  
 <span data-ttu-id="497db-147">Wenn Begrenzungs- und Blockierungssemantiken erforderlich sind, wird <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> wahrscheinlich schneller als jede beliebige benutzerdefinierte Implementierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="497db-147">When bounding and blocking semantics are required, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> will probably perform faster than any custom implementation.</span></span> <span data-ttu-id="497db-148">Zudem werden umfassende Möglichkeiten für die Abbruch-, Enumerations- und Ausnahmebehandlung unterstützt.</span><span class="sxs-lookup"><span data-stu-id="497db-148">It also supports rich cancellation, enumeration, and exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="497db-149">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="497db-149">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="497db-150">Threadsichere Sammlungen</span><span class="sxs-lookup"><span data-stu-id="497db-150">Thread-Safe Collections</span></span>](../../../../docs/standard/collections/thread-safe/index.md)
- [<span data-ttu-id="497db-151">Parallele Programmierung</span><span class="sxs-lookup"><span data-stu-id="497db-151">Parallel Programming</span></span>](../../../../docs/standard/parallel-programming/index.md)
