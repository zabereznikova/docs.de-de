---
title: Verwaltetes und nicht verwaltetes Threading in Windows
ms.date: 10/24/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], unmanaged
- threading [.NET Framework], managed
- threading [.NET], managed
- threads and fibers [.NET]
- managed threading
ms.assetid: 4fb6452f-c071-420d-9e71-da16dee7a1eb
ms.openlocfilehash: 6ab0cc7c1ec2f7bbc633ac966dd18ab3ea7a395b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/15/2020
ms.locfileid: "73127544"
---
# <a name="managed-and-unmanaged-threading-in-windows"></a><span data-ttu-id="09112-102">Verwaltetes und nicht verwaltetes Threading in Windows</span><span class="sxs-lookup"><span data-stu-id="09112-102">Managed and unmanaged threading in Windows</span></span>

<span data-ttu-id="09112-103">Die Verwaltung aller Threads erfolgt über die <xref:System.Threading.Thread> -Klasse, einschließlich Threads, die von der Common Language Runtime erstellt werden, und Threads, die außerhalb der Runtime erstellt werden und in die verwaltete Umgebung eintreten, um Code auszuführen.</span><span class="sxs-lookup"><span data-stu-id="09112-103">Management of all threads is done through the <xref:System.Threading.Thread> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code.</span></span> <span data-ttu-id="09112-104">Die Laufzeit überwacht alle Threads in ihrem Prozess, die jemals Code in der verwalteten Ausführungsumgebung ausgeführt haben.</span><span class="sxs-lookup"><span data-stu-id="09112-104">The runtime monitors all the threads in its process that have ever executed code within the managed execution environment.</span></span> <span data-ttu-id="09112-105">Sie verfolgt keine anderen Threads.</span><span class="sxs-lookup"><span data-stu-id="09112-105">It does not track any other threads.</span></span> <span data-ttu-id="09112-106">Threads können über COM-Interop (da die Runtime verwaltete Objekte als COM-Objekte für die nicht verwaltete Umgebung verfügbar macht), über die COM- [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) -Funktion und über einen Plattformaufruf in die verwaltete Ausführungsumgebung eintreten.</span><span class="sxs-lookup"><span data-stu-id="09112-106">Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) function, and platform invoke.</span></span>  
  
 <span data-ttu-id="09112-107">Wenn ein nicht verwalteter Thread beispielsweise über einen COM Callable Wrapper in die Runtime eintritt, überprüft das System den lokalen Threadspeicher auf ein intern verwaltetes <xref:System.Threading.Thread> -Objekt.</span><span class="sxs-lookup"><span data-stu-id="09112-107">When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <xref:System.Threading.Thread> object.</span></span> <span data-ttu-id="09112-108">Wird eins gefunden, ist der Laufzeit dieser Thread bereits bewusst.</span><span class="sxs-lookup"><span data-stu-id="09112-108">If one is found, the runtime is already aware of this thread.</span></span> <span data-ttu-id="09112-109">Wird keins gefunden, erstellt die Runtime jedoch ein neues <xref:System.Threading.Thread> -Objekt und installiert es im lokalen Threadspeicher dieses Threads.</span><span class="sxs-lookup"><span data-stu-id="09112-109">If it cannot find one, however, the runtime builds a new <xref:System.Threading.Thread> object and installs it in the thread-local store of that thread.</span></span>  
  
 <span data-ttu-id="09112-110">Beim verwalteten Threading ist <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> die stabile ID für den verwalteten Thread.</span><span class="sxs-lookup"><span data-stu-id="09112-110">In managed threading, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> is the stable managed thread identification.</span></span> <span data-ttu-id="09112-111">Für die Lebensdauer des Threads wird kein Konflikt mit dem Wert eines anderen Threads entstehen, unabhängig von der Anwendungsdomäne, aus der Sie diesen Wert erhalten.</span><span class="sxs-lookup"><span data-stu-id="09112-111">For the lifetime of your thread, it will not collide with the value from any other thread, regardless of the application domain from which you obtain this value.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="09112-112">Eine Betriebssystem- **ThreadId** hat keine feste Beziehung zu einem verwalteten Thread, da ein nicht verwalteter Host die Beziehung zwischen verwalteten und nicht verwalteten Threads steuern kann.</span><span class="sxs-lookup"><span data-stu-id="09112-112">An operating-system **ThreadId** has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="09112-113">Insbesondere kann ein komplexer Host die Fiber-API verwenden, um viele verwaltete mit demselben Betriebssystemthread zu verwalten oder einen verwalteten Thread unter verschiedenen Betriebssystemthreads zu verschieben.</span><span class="sxs-lookup"><span data-stu-id="09112-113">Specifically, a sophisticated host can use the Fiber API to schedule many managed threads against the same operating system thread, or to move a managed thread among different operating system threads.</span></span>  
  
## <a name="mapping-from-win32-threading-to-managed-threading"></a><span data-ttu-id="09112-114">Zuordnen zwischen Win32-Threading und verwaltetem Threading</span><span class="sxs-lookup"><span data-stu-id="09112-114">Mapping from Win32 threading to managed threading</span></span>

 <span data-ttu-id="09112-115">In der folgenden Tabelle sind Win32-Threadingelemente ihren ungefähren Laufzeitentsprechungen zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="09112-115">The following table maps Win32 threading elements to their approximate runtime equivalent.</span></span> <span data-ttu-id="09112-116">Beachten Sie, dass diese Zuordnung keine identische Funktionalität darstellt.</span><span class="sxs-lookup"><span data-stu-id="09112-116">Note that this mapping does not represent identical functionality.</span></span> <span data-ttu-id="09112-117">**TerminateThread** führt beispielsweise keine **finally** -Klauseln aus, setzt keine Ressourcen frei und kann nicht vermieden werden.</span><span class="sxs-lookup"><span data-stu-id="09112-117">For example, **TerminateThread** does not execute **finally** clauses or free up resources, and cannot be prevented.</span></span> <span data-ttu-id="09112-118"><xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> jedoch führt Ihren gesamten Rollbackcode aus, gibt alle Ressourcen frei und kann über <xref:System.Threading.Thread.ResetAbort%2A>verweigert werden.</span><span class="sxs-lookup"><span data-stu-id="09112-118">However, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executes all your rollback code, reclaims all the resources, and can be denied using <xref:System.Threading.Thread.ResetAbort%2A>.</span></span> <span data-ttu-id="09112-119">Lesen Sie unbedingt sorgfältig die Dokumentation, bevor Sie Annahmen über die Funktionalität treffen.</span><span class="sxs-lookup"><span data-stu-id="09112-119">Be sure to read the documentation closely before making assumptions about functionality.</span></span>  
  
|<span data-ttu-id="09112-120">In Win32</span><span class="sxs-lookup"><span data-stu-id="09112-120">In Win32</span></span>|<span data-ttu-id="09112-121">In der Common Language Runtime</span><span class="sxs-lookup"><span data-stu-id="09112-121">In the common language runtime</span></span>|  
|--------------|------------------------------------|  
|<span data-ttu-id="09112-122">**CreateThread**</span><span class="sxs-lookup"><span data-stu-id="09112-122">**CreateThread**</span></span>|<span data-ttu-id="09112-123">Kombination aus **Thread** und <xref:System.Threading.ThreadStart></span><span class="sxs-lookup"><span data-stu-id="09112-123">Combination of **Thread** and <xref:System.Threading.ThreadStart></span></span>|  
|<span data-ttu-id="09112-124">**TerminateThread**</span><span class="sxs-lookup"><span data-stu-id="09112-124">**TerminateThread**</span></span>|<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="09112-125">**SuspendThread**</span><span class="sxs-lookup"><span data-stu-id="09112-125">**SuspendThread**</span></span>|<xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="09112-126">**ResumeThread**</span><span class="sxs-lookup"><span data-stu-id="09112-126">**ResumeThread**</span></span>|<xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="09112-127">**Sleep**</span><span class="sxs-lookup"><span data-stu-id="09112-127">**Sleep**</span></span>|<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="09112-128">**WaitForSingleObject** im Threadhandle</span><span class="sxs-lookup"><span data-stu-id="09112-128">**WaitForSingleObject** on the thread handle</span></span>|<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="09112-129">**ExitThread**</span><span class="sxs-lookup"><span data-stu-id="09112-129">**ExitThread**</span></span>|<span data-ttu-id="09112-130">Keine Entsprechung</span><span class="sxs-lookup"><span data-stu-id="09112-130">No equivalent</span></span>|  
|<span data-ttu-id="09112-131">**GetCurrentThread**</span><span class="sxs-lookup"><span data-stu-id="09112-131">**GetCurrentThread**</span></span>|<xref:System.Threading.Thread.CurrentThread%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="09112-132">**SetThreadPriority**</span><span class="sxs-lookup"><span data-stu-id="09112-132">**SetThreadPriority**</span></span>|<xref:System.Threading.Thread.Priority%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="09112-133">Keine Entsprechung</span><span class="sxs-lookup"><span data-stu-id="09112-133">No equivalent</span></span>|<xref:System.Threading.Thread.Name%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="09112-134">Keine Entsprechung</span><span class="sxs-lookup"><span data-stu-id="09112-134">No equivalent</span></span>|<xref:System.Threading.Thread.IsBackground%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="09112-135">Nahe an **CoInitializeEx** (OLE32.DLL)</span><span class="sxs-lookup"><span data-stu-id="09112-135">Close to **CoInitializeEx** (OLE32.DLL)</span></span>|<xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>|  
  
## <a name="managed-threads-and-com-apartments"></a><span data-ttu-id="09112-136">Verwaltete Threads und COM-Apartments</span><span class="sxs-lookup"><span data-stu-id="09112-136">Managed threads and COM apartments</span></span>

<span data-ttu-id="09112-137">Ein verwalteter Thread kann gekennzeichnet werden, um anzugeben, dass er ein [Singlethread](/windows/desktop/com/single-threaded-apartments) - oder ein [Multithread](/windows/desktop/com/multithreaded-apartments) -Apartment hostet.</span><span class="sxs-lookup"><span data-stu-id="09112-137">A managed thread can be marked to indicate that it will host a [single-threaded](/windows/desktop/com/single-threaded-apartments) or [multithreaded](/windows/desktop/com/multithreaded-apartments) apartment.</span></span> <span data-ttu-id="09112-138">(Weitere Informationen zur COM-Threadingarchitektur finden Sie unter [Prozesse, Threads und Apartments](/windows/desktop/com/processes--threads--and-apartments).) Die Methoden <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A> und <xref:System.Threading.Thread.TrySetApartmentState%2A> der <xref:System.Threading.Thread>-Klasse geben den Apartmentzustand eines Threads zurück und weisen ihn zu.</span><span class="sxs-lookup"><span data-stu-id="09112-138">(For more information on the COM threading architecture, see [Processes, Threads, and Apartments](/windows/desktop/com/processes--threads--and-apartments).) The <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods of the <xref:System.Threading.Thread> class return and assign the apartment state of a thread.</span></span> <span data-ttu-id="09112-139">Wurde der Zustand nicht festgelegt, gibt <xref:System.Threading.Thread.GetApartmentState%2A> den Wert <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> zurück.</span><span class="sxs-lookup"><span data-stu-id="09112-139">If the state has not been set, <xref:System.Threading.Thread.GetApartmentState%2A> returns <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="09112-140">Die Eigenschaft kann nur festgelegt werden, wenn sich der Thread im Zustand <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> befindet. Die Eigenschaft kann für einen Thread nur einmal festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="09112-140">The property can be set only when the thread is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state; it can be set only once for a thread.</span></span>  
  
 <span data-ttu-id="09112-141">Wenn der Apartmentzustand nicht festgelegt ist, bevor der Thread gestartet wird, wird der Thread als Multithread-Apartment (MTA) initialisiert.</span><span class="sxs-lookup"><span data-stu-id="09112-141">If the apartment state is not set before the thread is started, the thread is initialized as a multithreaded apartment (MTA).</span></span> <span data-ttu-id="09112-142">Der Finalizerthread und alle von <xref:System.Threading.ThreadPool> gesteuerten Threads sind MTAs.</span><span class="sxs-lookup"><span data-stu-id="09112-142">The finalizer thread and all threads controlled by <xref:System.Threading.ThreadPool> are MTA.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="09112-143">Bei Anwendungsstartcode besteht die einzige Möglichkeit zum Steuern des Apartmentstatus darin, <xref:System.MTAThreadAttribute> oder <xref:System.STAThreadAttribute> für das Einstiegspunktverfahren anzuwenden.</span><span class="sxs-lookup"><span data-stu-id="09112-143">For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure.</span></span> <span data-ttu-id="09112-144">In .NET Framework 1.0 und 1.1 kann die Eigenschaft <xref:System.Threading.Thread.ApartmentState%2A> als erste Codezeile festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="09112-144">In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code.</span></span> <span data-ttu-id="09112-145">Das ist in .NET Framework 2.0 nicht zulässig.</span><span class="sxs-lookup"><span data-stu-id="09112-145">This is not permitted in the .NET Framework 2.0.</span></span>  
  
 <span data-ttu-id="09112-146">Verwaltete Objekte, die für COM verfügbar gemacht werden, verhalten sich, als hätten sie den Freethread-Marshaler aggregiert.</span><span class="sxs-lookup"><span data-stu-id="09112-146">Managed objects that are exposed to COM behave as if they had aggregated the free-threaded marshaler.</span></span> <span data-ttu-id="09112-147">Anders gesagt können Sie von jedem COM-Apartment auf eine Freethreadweise aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="09112-147">In other words, they can be called from any COM apartment in a free-threaded manner.</span></span> <span data-ttu-id="09112-148">Die einzigen verwalteten Objekte, die dieses Freethread-Verhalten nicht zeigen, die Objekte, die von <xref:System.EnterpriseServices.ServicedComponent> oder <xref:System.Runtime.InteropServices.StandardOleMarshalObject> abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="09112-148">The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <xref:System.EnterpriseServices.ServicedComponent> or <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span></span>  
  
 <span data-ttu-id="09112-149">In der verwalteten Umgebung wird <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> nur unterstützt, wenn Sie Kontexte und kontextgebundene verwaltete Instanzen verwenden.</span><span class="sxs-lookup"><span data-stu-id="09112-149">In the managed world, there is no support for the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> unless you use contexts and context-bound managed instances.</span></span> <span data-ttu-id="09112-150">Wenn Sie Enterprise Services verwenden, muss Ihr Objekt aus der <xref:System.EnterpriseServices.ServicedComponent>-Klasse abgeleitet sein (die wiederum selbst aus <xref:System.ContextBoundObject> abgeleitet ist).</span><span class="sxs-lookup"><span data-stu-id="09112-150">If you are using Enterprise Services, then your object must derive from <xref:System.EnterpriseServices.ServicedComponent> (which is itself derived from <xref:System.ContextBoundObject>).</span></span>  
  
 <span data-ttu-id="09112-151">Wenn verwalteter Code COM-Objekte aufruft, befolgt er immer COM-Regeln.</span><span class="sxs-lookup"><span data-stu-id="09112-151">When managed code calls out to COM objects, it always follows COM rules.</span></span> <span data-ttu-id="09112-152">Anders gesagt erfolgt der Aufruf über COM-Apartmentproxies und COM+ 1.0-Kontext-Wrapper, wie von OLE32 vorgegeben.</span><span class="sxs-lookup"><span data-stu-id="09112-152">In other words, it calls through COM apartment proxies and COM+ 1.0 context wrappers as dictated by OLE32.</span></span>  
  
## <a name="blocking-issues"></a><span data-ttu-id="09112-153">Blockierprobleme</span><span class="sxs-lookup"><span data-stu-id="09112-153">Blocking issues</span></span>  

<span data-ttu-id="09112-154">Wenn ein Thread einen nicht verwalteten Aufruf in der Betriebssystem vornimmt, das den Thread in nicht verwaltetem Code blockiert hat, übernimmt die Laufzeit keine Kontrolle darüber für <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> oder <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09112-154">If a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09112-155">Im Fall von <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>kennzeichnet die Laufzeit den Thread für **Abort** und übernimmt die Kontrolle darüber, wenn der verwaltete Code erneut eingegeben wird.</span><span class="sxs-lookup"><span data-stu-id="09112-155">In the case of <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, the runtime marks the thread for **Abort** and takes control of it when it re-enters managed code.</span></span> <span data-ttu-id="09112-156">Sie sollten vorzugsweise die verwaltete Blockierung statt die nicht verwaltete Blockierung verwenden.</span><span class="sxs-lookup"><span data-stu-id="09112-156">It is preferable for you to use managed blocking rather than unmanaged blocking.</span></span> <span data-ttu-id="09112-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>und so weiter reagieren alle auf <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> und auf <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="09112-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, and so on are all responsive to <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and to <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09112-158">Wenn sich Ihr Thread in einem Singlethread-Apartment befindet, werden all diese verwalteten Blockierungsvorgänge außerdem Meldungen in Ihr Apartment verschieben, während Ihr Thread blockiert ist.</span><span class="sxs-lookup"><span data-stu-id="09112-158">Also, if your thread is in a single-threaded apartment, all these managed blocking operations will correctly pump messages in your apartment while your thread is blocked.</span></span>  

## <a name="threads-and-fibers"></a><span data-ttu-id="09112-159">Threads und Fibers</span><span class="sxs-lookup"><span data-stu-id="09112-159">Threads and fibers</span></span>

<span data-ttu-id="09112-160">Das .NET-Threadingmodell unterstützt keine [Fibers](/windows/desktop/procthread/fibers).</span><span class="sxs-lookup"><span data-stu-id="09112-160">The .NET threading model does not support [fibers](/windows/desktop/procthread/fibers).</span></span> <span data-ttu-id="09112-161">Sie sollten keine nicht verwaltete Funktion aufrufen, die mithilfe von Fibers implementiert wurde.</span><span class="sxs-lookup"><span data-stu-id="09112-161">You should not call into any unmanaged function that is implemented by using fibers.</span></span> <span data-ttu-id="09112-162">Solche Aufrufe können zu einem Absturz der .NET-Runtime führen.</span><span class="sxs-lookup"><span data-stu-id="09112-162">Such calls may result in a crash of the .NET runtime.</span></span>

## <a name="see-also"></a><span data-ttu-id="09112-163">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="09112-163">See also</span></span>

- <xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>
- <xref:System.Threading.ThreadState>
- <xref:System.EnterpriseServices.ServicedComponent>
- <xref:System.Threading.Thread>
- <xref:System.Threading.Monitor>
