---
title: EventWaitHandle
ms.date: 03/30/2017
helpviewer_keywords:
- threading [.NET], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET]
- threading [.NET], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
ms.openlocfilehash: 5e448397e4aabe0acb4144abe1469af6a631aeaa
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/18/2020
ms.locfileid: "94819915"
---
# <a name="eventwaithandle"></a><span data-ttu-id="fb6a0-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="fb6a0-102">EventWaitHandle</span></span>

<span data-ttu-id="fb6a0-103">Die <xref:System.Threading.EventWaitHandle>-Klasse ermöglicht Threads, durch Signalisieren und Warten auf Signale miteinander zu kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="fb6a0-104">Ereignis-Wait-Handles (die auch einfach als „Ereignisse“ bezeichnet werden) sind Wait-Handles, die als Signale verwendet werden können, damit ein oder mehrere wartende Threads freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="fb6a0-105">Nachdem ein Ereignis-Wait-Handle als Signal verwendet wurde, wird es entweder manuell oder automatisch zurückgesetzt.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="fb6a0-106">Die <xref:System.Threading.EventWaitHandle>-Klasse kann entweder ein lokales Ereignis-Wait-Handle (lokales Ereignis) darstellen oder ein Ereignis-Wait-Handle eines benannten Systems (benanntes Ereignis oder Systemereignis, für alle Prozesse sichtbar).</span><span class="sxs-lookup"><span data-stu-id="fb6a0-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="fb6a0-107">Ereignis-Wait-Handles sind keine .NET-[Ereignisse](../events/index.md).</span><span class="sxs-lookup"><span data-stu-id="fb6a0-107">Event wait handles are not .NET [events](../events/index.md).</span></span> <span data-ttu-id="fb6a0-108">Es sind keine Delegaten oder Ereignishandler beteiligt.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="fb6a0-109">Zur Beschreibung wird das Wort „Ereignis“ verwendet, weil diese Handles traditionell als Betriebssystemereignisse bezeichnet wurden und weil durch Verwenden eines Wait-Handles als Signal wartende Threads darüber informiert werden, dass ein Ereignis aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="fb6a0-110">Sowohl lokale als auch benannte Ereignis-Wait-Handles verwenden Synchronisierungsobjekte des Systems, die durch <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>-Wrapper geschützt sind, um sicherzustellen, dass die Ressourcen freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="fb6a0-111">Sie können die <xref:System.Threading.WaitHandle.Dispose%2A>-Methode verwenden, um die Ressourcen sofort freizugeben, nachdem die Verwendung des Objekts beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="fb6a0-112">Ereignis-Wait-Handles mit automatischer Rücksetzung</span><span class="sxs-lookup"><span data-stu-id="fb6a0-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="fb6a0-113">Sie können ein Ereignis mit automatischer Rücksetzung erstellen, indem Sie <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> angeben, wenn Sie das <xref:System.Threading.EventWaitHandle>-Objekt erstellen.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="fb6a0-114">Wie der Name schon sagt, wird dieses Synchronisierungsereignis nach der Verwendung als Signal automatisch zurückgesetzt, nachdem ein einzelner wartender Thread freigegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="fb6a0-115">Verwenden Sie das Ereignis als Signal, indem Sie seine <xref:System.Threading.EventWaitHandle.Set%2A>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="fb6a0-116">Um den exklusiven Zugriff auf eine Ressource für einen einzelnen Thread zu einem bestimmten Zeitpunkt sicherzustellen, werden Ereignisse mit automatischer Rücksetzung verwendet.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="fb6a0-117">Ein Thread fordert die Ressource durch Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode an.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="fb6a0-118">Wenn kein anderer Thread das Wait-Handle enthält, gibt die Methode `true` zurück, und der aufrufende Thread erhält die Steuerung über die Ressource.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="fb6a0-119">Wie bei allen Synchronisierungsmechanismen müssen Sie sicherstellen, dass alle Codepfade vor dem Zugriff auf eine geschützte Ressource auf das entsprechende Wait-Handle warten.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="fb6a0-120">Die Threadsynchronisierung ist kooperativ.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="fb6a0-121">Wenn ein Ereignis mit automatischer Rücksetzung als Signal verwendet wird und zu diesem Zeitpunkt keine Threads warten, bleibt es ein Signal, bis ein Thread versucht, darauf zu warten.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="fb6a0-122">Das Ereignis gibt den Thread frei und wird sofort zurückgesetzt, sodass nachfolgende Threads blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="fb6a0-123">Ereignis-Wait-Handles mit manueller Rücksetzung</span><span class="sxs-lookup"><span data-stu-id="fb6a0-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="fb6a0-124">Sie können ein Ereignis mit manueller Rücksetzung erstellen, indem Sie <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> angeben, wenn Sie das <xref:System.Threading.EventWaitHandle>-Objekt erstellen.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="fb6a0-125">Wie der Name schon sagt, muss dieses Synchronisierungsereignis nach der Verwendung als Signal manuell zurückgesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="fb6a0-126">Bis das Ereignis durch Aufrufen der <xref:System.Threading.EventWaitHandle.Reset%2A>-Methode zurückgesetzt wird, können Threads, die auf das Ereignishandle warten, sofort fortgesetzt werden, ohne blockiert zu werden.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="fb6a0-127">Ein Ereignis mit manueller Rücksetzung funktioniert wie das Gatter einer Pferdekoppel.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="fb6a0-128">Wenn das Ereignis nicht als Signal verwendet wird, sind Threads, die darauf warten, blockiert, also sozusagen wie Pferde auf einer Koppel eingesperrt.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="fb6a0-129">Wenn das Ereignis durch Aufrufen der <xref:System.Threading.EventWaitHandle.Set%2A>-Methode als Signal verwendet wird, werden alle Threads befreit und können fortgesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="fb6a0-130">Das Ereignis bleibt so lange ein Signal, bis seine <xref:System.Threading.EventWaitHandle.Reset%2A>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="fb6a0-131">Daher ist das Ereignis mit manueller Rücksetzung eine ideale Möglichkeit, Threads zu verzögern, die warten müssen, bis ein bestimmter Thread einen Task abgeschlossen hat.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="fb6a0-132">Wie bei Pferden auf einer Koppel dauert es eine Zeitlang, bis die freigegebenen Threads vom Betriebssystem geplant werden und die Ausführung fortgesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="fb6a0-133">Wenn die <xref:System.Threading.EventWaitHandle.Reset%2A>-Methode aufgerufen wird, bevor die Ausführung aller Threads fortgesetzt wird, werden die verbleibenden Threads erneut blockiert.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="fb6a0-134">Welche Threads fortgesetzt und welche blockiert werden, hängt von zufälligen Faktoren ab, wie z.B. der Auslastung des Systems, der Anzahl von Threads, die auf den Planer warten, usw.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="fb6a0-135">Dies ist kein Problem, wenn der Thread, der ein Ereignis als Signal verwendet, danach beendet wird. Dies ist das häufigste Verwendungsmuster.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="fb6a0-136">Wenn Sie möchten, dass der Thread, der das Ereignis als Signal verwendet hat, nach dem Fortsetzen aller wartenden Threads einen neuen Task beginnt, müssen Sie den Thread blockieren, bis alle wartenden Threads fortgesetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="fb6a0-137">Andernfalls liegt eine Racebedingung vor, und das Verhalten des Codes ist unvorhersehbar.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="fb6a0-138">Gemeinsame Features für automatische und manuelle Ereignisse</span><span class="sxs-lookup"><span data-stu-id="fb6a0-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="fb6a0-139">In der Regel ist mindestens ein Thread in einem <xref:System.Threading.EventWaitHandle> blockiert, bis ein nicht blockierter Thread die <xref:System.Threading.EventWaitHandle.Set%2A>-Methode aufruft, die (bei Ereignissen mit automatischer Rücksetzung) einen wartenden Thread oder (bei Ereignissen mit manueller Rücksetzung) alle wartenden Threads freigibt.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="fb6a0-140">Ein Thread kann ein <xref:System.Threading.EventWaitHandle> als Signal verwenden und dann durch Aufrufen der statischen <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType>-Methode als atomischer Vorgang blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="fb6a0-141"><xref:System.Threading.EventWaitHandle>-Objekte können mit den statischen Methoden <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> und <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="fb6a0-142">Da die Klassen <xref:System.Threading.EventWaitHandle> und <xref:System.Threading.Mutex> von <xref:System.Threading.WaitHandle> abgeleitet werden, können Sie beide Klassen mit diesen Methoden verwenden.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="fb6a0-143">Benannte Ereignisse</span><span class="sxs-lookup"><span data-stu-id="fb6a0-143">Named Events</span></span>  
 <span data-ttu-id="fb6a0-144">Das Windows-Betriebssystem ermöglicht es, Event-Wait-Handles zu benennen.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="fb6a0-145">Ein benanntes Ereignis ist systemweit sichtbar.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-145">A named event is system wide.</span></span> <span data-ttu-id="fb6a0-146">Das heißt, sobald das benannte Ereignis erstellt wurde, ist es für alle Threads in allen Prozessen sichtbar.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="fb6a0-147">Folglich können benannte Ereignisse zum Synchronisieren der Aktivitäten von Prozessen und Threads verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="fb6a0-148">Sie können ein <xref:System.Threading.EventWaitHandle>-Objekt erstellen, das ein benanntes Systemereignis darstellt, indem Sie einen der Konstruktoren verwenden, die einen Ereignisnamen angeben.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="fb6a0-149">Da benannte Ereignisse systemweit sichtbar sind, ist es möglich, über mehrere <xref:System.Threading.EventWaitHandle>-Objekte zu verfügen, die dasselbe benannte Ereignis darstellen.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="fb6a0-150">Bei jedem Aufruf eines Konstruktors oder der <xref:System.Threading.EventWaitHandle.OpenExisting%2A>-Methode wird ein neues <xref:System.Threading.EventWaitHandle>-Objekt erstellt.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="fb6a0-151">Wenn Sie wiederholt denselben Namen angeben, werden mehrere Objekte erstellt, die dasselbe benannte Ereignis darstellen.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="fb6a0-152">Bei der Verwendung von benannten Ereignissen ist Vorsicht geboten.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-152">Caution is advised in using named events.</span></span> <span data-ttu-id="fb6a0-153">Da sie systemweit sichtbar sind, kann ein anderer Prozess, der den gleichen Namen verwendet, Ihre Threads unerwartet blockieren.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="fb6a0-154">Böswilliger Code, der auf demselben Computer ausgeführt wird, könnte dies als Grundlage für einen Denial-of-Service-Angriff verwenden.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="fb6a0-155">Verwenden Sie die Zugriffssteuerungssicherheit zum Schutz eines <xref:System.Threading.EventWaitHandle>-Objekts, das ein benanntes Ereignis darstellt, vorzugsweise durch Verwendung eines Konstruktors, der ein <xref:System.Security.AccessControl.EventWaitHandleSecurity>-Objekt angibt.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="fb6a0-156">Sie können die Zugriffssteuerungssicherheit auch mithilfe der <xref:System.Threading.EventWaitHandle.SetAccessControl%2A>-Methode anwenden, allerdings entsteht dann zwischen der Erstellung und dem Schutz des Ereignis-Wait-Handles ein Zeitraum, in dem ein Sicherheitsrisiko besteht.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="fb6a0-157">Der Schutz von Ereignissen mit Zugriffssteuerungssicherheit hilft dabei, böswillige Angriffe zu verhindern, das Problem unbeabsichtigter Namenskonflikte wird dadurch aber nicht gelöst.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="fb6a0-158">Im Gegensatz zur <xref:System.Threading.EventWaitHandle>-Klasse können die abgeleiteten Klassen <xref:System.Threading.AutoResetEvent> und <xref:System.Threading.ManualResetEvent> nur lokale Wait-Handles darstellen.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="fb6a0-159">Sie können keine benannten Systemereignisse darstellen.</span><span class="sxs-lookup"><span data-stu-id="fb6a0-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="fb6a0-160">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="fb6a0-160">See also</span></span>

- <xref:System.Threading.EventWaitHandle>
- <xref:System.Threading.WaitHandle>
- <xref:System.Threading.AutoResetEvent>
- <xref:System.Threading.ManualResetEvent>
