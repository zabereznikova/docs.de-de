---
title: Abbruch in verwalteten Threads
description: Machen Sie sich mit dem Abbrechen in verwalteten Threads vertraut. Erfahren Sie mehr über Abbruchtoken bei kooperativem Abbruch von asynchronen Vorgängen oder synchronen Vorgängen mit langer Laufzeit.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- cancellation in .NET, overview
ms.assetid: eea11fe5-d8b0-4314-bb5d-8a58166fb1c3
ms.openlocfilehash: 9af4a64e50eff65023d5ed5bda868af2f8323a96
ms.sourcegitcommit: 7137e12f54c4e83a94ae43ec320f8cf59c1772ea
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 06/10/2020
ms.locfileid: "84662835"
---
# <a name="cancellation-in-managed-threads"></a><span data-ttu-id="0cf8e-104">Abbruch in verwalteten Threads</span><span class="sxs-lookup"><span data-stu-id="0cf8e-104">Cancellation in Managed Threads</span></span>
<span data-ttu-id="0cf8e-105">Ab .NET Framework 4 verwendet das .NET Framework ein einheitliches Modell für den kooperativen Abbruch von asynchronen oder lang andauernden synchronen Vorgängen.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-105">Starting with the .NET Framework 4, the .NET Framework uses a unified model for cooperative cancellation of asynchronous or long-running synchronous operations.</span></span> <span data-ttu-id="0cf8e-106">Dieses Modell basiert auf einem einfachen Objekt, dem sogenannten "Abbruchtoken".</span><span class="sxs-lookup"><span data-stu-id="0cf8e-106">This model is based on a lightweight object called a cancellation token.</span></span> <span data-ttu-id="0cf8e-107">Das Objekt, das einen oder mehrere abbrechbare Vorgänge aufruft, z. B. durch Erstellen neuer Threads oder Aufgaben, übergibt das Token an jeden Vorgang.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-107">The object that invokes one or more cancelable operations, for example by creating new threads or tasks, passes the token to each operation.</span></span> <span data-ttu-id="0cf8e-108">Einzelne Vorgänge können wiederum Kopien des Tokens an andere Vorgänge übergeben.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-108">Individual operations can in turn pass copies of the token to other operations.</span></span> <span data-ttu-id="0cf8e-109">Zu einem späteren Zeitpunkt kann das Objekt, das das Token erstellt hat, damit anfordern, dass die Vorgänge ihre aktuelle Aktivität einstellen.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-109">At some later time, the object that created the token can use it to request that the operations stop what they are doing.</span></span> <span data-ttu-id="0cf8e-110">Nur das anfordernde Objekt kann die Abbruchanforderung ausgeben, und jeder Listener ist dafür verantwortlich, die Anforderung zu bemerken und angemessen und rechtzeitig darauf zu reagieren.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-110">Only the requesting object can issue the cancellation request, and each listener is responsible for noticing the request and responding to it in an appropriate and timely manner.</span></span>  
  
 <span data-ttu-id="0cf8e-111">Das allgemeine Muster für die Implementierung des kooperativen Abbruchmodells lautet:</span><span class="sxs-lookup"><span data-stu-id="0cf8e-111">The general pattern for implementing the cooperative cancellation model is:</span></span>  
  
- <span data-ttu-id="0cf8e-112">Instanziieren Sie ein <xref:System.Threading.CancellationTokenSource>-Objekt, das die Abbruchbenachrichtigung verwaltet und an die einzelnen Abbruchtoken sendet.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-112">Instantiate a <xref:System.Threading.CancellationTokenSource> object, which manages and sends cancellation notification to the individual cancellation tokens.</span></span>  
  
- <span data-ttu-id="0cf8e-113">Übergeben Sie das zurückgegebene Token über die <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType>-Eigenschaft an jede Aufgabe oder Thread, der zum Lauschen verwendet wird, um den Abbruch zu bemerken.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-113">Pass the token returned by the <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> property to each task or thread that listens for cancellation.</span></span>  
  
- <span data-ttu-id="0cf8e-114">Stellen Sie einen Mechanismus für jede Aufgabe oder Thread bereit, um auf den Abbruch zu reagieren.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-114">Provide a mechanism for each task or thread to respond to cancellation.</span></span>  
  
- <span data-ttu-id="0cf8e-115">Rufen Sie die <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType>-Methode auf, um eine Benachrichtigung über den Abbruch bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-115">Call the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to provide notification of cancellation.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="0cf8e-116">Die <xref:System.Threading.CancellationTokenSource>-Klasse implementiert die <xref:System.IDisposable>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-116">The <xref:System.Threading.CancellationTokenSource> class implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="0cf8e-117">Sie sollten darauf achten, die <xref:System.Threading.CancellationTokenSource.Dispose%2A?displayProperty=nameWithType>-Methode aufzurufen, wenn Sie die Verwendung der Abbruchtokenquelle abgeschlossen haben, um alle darin enthaltenen, nicht verwalteten Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-117">You should be sure to call the <xref:System.Threading.CancellationTokenSource.Dispose%2A?displayProperty=nameWithType> method when you have finished using the cancellation token source to free any unmanaged resources it holds.</span></span>  
  
 <span data-ttu-id="0cf8e-118">Die folgende Abbildung zeigt die Beziehung zwischen einer Tokenquelle und allen Kopien des Tokens.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-118">The following illustration shows the relationship between a token source and all the copies of its token.</span></span>  
  
 <span data-ttu-id="0cf8e-119">![CancellationTokenSource und Abbruchtokens](media/vs-cancellationtoken.png "VS_CancellationToken")</span><span class="sxs-lookup"><span data-stu-id="0cf8e-119">![CancellationTokenSource and cancellation tokens](media/vs-cancellationtoken.png "VS_CancellationToken")</span></span>  
  
 <span data-ttu-id="0cf8e-120">Das neue Abbruchmodell vereinfacht die Erstellung von abbruchfähigen Anwendungen und Bibliotheken, und es unterstützt die folgenden Funktionen:</span><span class="sxs-lookup"><span data-stu-id="0cf8e-120">The new cancellation model makes it easier to create cancellation-aware applications and libraries, and it supports the following features:</span></span>  
  
- <span data-ttu-id="0cf8e-121">Der Abbruch ist kooperativ und wird für den Listener nicht erzwungen.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-121">Cancellation is cooperative and is not forced on the listener.</span></span> <span data-ttu-id="0cf8e-122">Der Listener bestimmt, wie die ordnungsgemäße Beendigung als Reaktion auf eine Abbruchanforderung durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-122">The listener determines how to gracefully terminate in response to a cancellation request.</span></span>  
  
- <span data-ttu-id="0cf8e-123">Die Anforderung unterscheidet sich vom Lauschvorgang.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-123">Requesting is distinct from listening.</span></span> <span data-ttu-id="0cf8e-124">Ein Objekt, das einen abbrechbaren Vorgang aufruft, kann steuern, wann (falls überhaupt) der Abbruch angefordert wird.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-124">An object that invokes a cancelable operation can control when (if ever) cancellation is requested.</span></span>  
  
- <span data-ttu-id="0cf8e-125">Das anfordernde Objekt sendet die Abbruchanforderung mithilfe eines einzigen Methodenaufrufs an alle Kopien des Tokens.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-125">The requesting object issues the cancellation request to all copies of the token by using just one method call.</span></span>  
  
- <span data-ttu-id="0cf8e-126">Ein Listener kann mehrere Token gleichzeitig belauschen, indem diese zu einem *verknüpften Token* verbunden werden.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-126">A listener can listen to multiple tokens simultaneously by joining them into one *linked token*.</span></span>  
  
- <span data-ttu-id="0cf8e-127">Benutzercode kann Abbruchanforderungen aus Bibliothekscode erkennen und auf diese reagieren, während Bibliothekscode Abbruchanforderungen aus Benutzercode erkennen und auf diese reagieren kann.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-127">User code can notice and respond to cancellation requests from library code, and library code can notice and respond to cancellation requests from user code.</span></span>  
  
- <span data-ttu-id="0cf8e-128">Listener können durch Abruf, Rückrufregistrierung oder Warten auf Wait-Handles über Abbruchanforderungen benachrichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-128">Listeners can be notified of cancellation requests by polling, callback registration, or waiting on wait handles.</span></span>  
  
## <a name="cancellation-types"></a><span data-ttu-id="0cf8e-129">Abbruchtypen</span><span class="sxs-lookup"><span data-stu-id="0cf8e-129">Cancellation Types</span></span>  
 <span data-ttu-id="0cf8e-130">Das Abbruchframework ist als Gruppe von verwandten Typen implementiert, die in der folgenden Tabelle aufgeführt sind.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-130">The cancellation framework is implemented as a set of related types, which are listed in the following table.</span></span>  
  
|<span data-ttu-id="0cf8e-131">Typname</span><span class="sxs-lookup"><span data-stu-id="0cf8e-131">Type name</span></span>|<span data-ttu-id="0cf8e-132">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="0cf8e-132">Description</span></span>|  
|---------------|-----------------|  
|<xref:System.Threading.CancellationTokenSource>|<span data-ttu-id="0cf8e-133">Ein Objekt, das ein Abbruchtoken erstellt und auch die Abbruchanforderung für alle Kopien dieses Token ausgibt.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-133">Object that creates a cancellation token, and also issues the cancellation request for all copies of that token.</span></span>|  
|<xref:System.Threading.CancellationToken>|<span data-ttu-id="0cf8e-134">Ein einfacher Werttyp, der in der Regel als Methodenparameter an mindestens einen Listener übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-134">Lightweight value type passed to one or more listeners, typically as a method parameter.</span></span> <span data-ttu-id="0cf8e-135">Listener überwachen den Wert der `IsCancellationRequested`-Eigenschaft des Token durch Abruf, Rückruf oder Wait-Handle.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-135">Listeners monitor the value of the `IsCancellationRequested` property of the token by polling, callback, or wait handle.</span></span>|  
|<xref:System.OperationCanceledException>|<span data-ttu-id="0cf8e-136">Überladungen des Konstruktors dieser Ausnahme akzeptieren ein <xref:System.Threading.CancellationToken> als Parameter.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-136">Overloads of this exception's constructor accept a <xref:System.Threading.CancellationToken> as a parameter.</span></span> <span data-ttu-id="0cf8e-137">Listener können diese Ausnahme optional auslösen, um die Quelle des Abbruchs zu überprüfen und andere darüber zu benachrichtigen, dass auf eine Abbruchanforderung reagiert wurde.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-137">Listeners can optionally throw this exception to verify the source of the cancellation and notify others that it has responded to a cancellation request.</span></span>|  
  
 <span data-ttu-id="0cf8e-138">Das neue Abbruchmodell ist in .NET Framework in mehreren Formen integriert.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-138">The new cancellation model is integrated into the .NET Framework in several types.</span></span> <span data-ttu-id="0cf8e-139">Die wichtigsten sind <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> und <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-139">The most important ones are <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> and <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0cf8e-140">Sie sollten dieses neue Abbruchmodell für sämtlichen neuen Bibliotheks- und Anwendungscode verwenden.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-140">We recommend that you use this new cancellation model for all new library and application code.</span></span>  
  
## <a name="code-example"></a><span data-ttu-id="0cf8e-141">Codebeispiel</span><span class="sxs-lookup"><span data-stu-id="0cf8e-141">Code Example</span></span>  
 <span data-ttu-id="0cf8e-142">Im folgenden Beispiel erstellt das anfordernde Objekt ein <xref:System.Threading.CancellationTokenSource>-Objekt und übergibt dann seine <xref:System.Threading.CancellationTokenSource.Token%2A>-Eigenschaft an den abbrechbaren Vorgang.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-142">In the following example, the requesting object creates a <xref:System.Threading.CancellationTokenSource> object, and then passes its <xref:System.Threading.CancellationTokenSource.Token%2A> property to the cancelable operation.</span></span> <span data-ttu-id="0cf8e-143">Der Vorgang, der die Anforderung empfängt, überwacht den Wert von der <xref:System.Threading.CancellationToken.IsCancellationRequested%2A>-Eigenschaft des Token durch Abruf.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-143">The operation that receives the request monitors the value of the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property of the token by polling.</span></span> <span data-ttu-id="0cf8e-144">Wenn der Wert zu `true` wechselt, kann der Listener auf geeignete Weise beendet werden.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-144">When the value becomes `true`, the listener can terminate in whatever manner is appropriate.</span></span> <span data-ttu-id="0cf8e-145">In diesem Beispiel wird die Methode einfach beendet und das ist auch häufig alles, was erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-145">In this example, the method just exits, which is all that is required in many cases.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0cf8e-146">Im Beispiel wird die <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>-Methode verwendet, um zu veranschaulichen, dass das neue Abbruchframework mit Legacy-APIs kompatibel ist.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-146">The example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to demonstrate that the new cancellation framework is compatible with legacy APIs.</span></span> <span data-ttu-id="0cf8e-147">Ein Beispiel, das den neuen bevorzugten <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>-Typ verwendet, finden Sie unter [Gewusst wie: Abbrechen einer Aufgabe und ihrer untergeordneten Elemente](../parallel-programming/how-to-cancel-a-task-and-its-children.md).</span><span class="sxs-lookup"><span data-stu-id="0cf8e-147">For an example that uses the new, preferred <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> type, see [How to: Cancel a Task and Its Children](../parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
 [!code-csharp[Cancellation#1](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex1.cs#1)]
 [!code-vb[Cancellation#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex1.vb#1)]  
  
## <a name="operation-cancellation-versus-object-cancellation"></a><span data-ttu-id="0cf8e-148">Vorgangsabbruch im Vergleich zum Objektabbruch</span><span class="sxs-lookup"><span data-stu-id="0cf8e-148">Operation Cancellation Versus Object Cancellation</span></span>  
 <span data-ttu-id="0cf8e-149">Im neuen Abbruchframework bezieht sich Abbruch auf Vorgänge und nicht auf Objekte.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-149">In the new cancellation framework, cancellation refers to operations, not objects.</span></span> <span data-ttu-id="0cf8e-150">Die Abbruchanforderung bedeutet, dass der Vorgang so schnell wie möglich beendet werden soll, nachdem alle erforderlichen Bereinigungen ausgeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-150">The cancellation request means that the operation should stop as soon as possible after any required cleanup is performed.</span></span> <span data-ttu-id="0cf8e-151">Ein Abbruchtoken sollte auf einen "abbrechbaren Vorgang" verweisen, aber dieser Vorgang kann in Ihrem Programm implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-151">One cancellation token should refer to one "cancelable operation," however that operation may be implemented in your program.</span></span> <span data-ttu-id="0cf8e-152">Nachdem die <xref:System.Threading.CancellationToken.IsCancellationRequested%2A>-Eigenschaft des Tokens auf `true` festgelegt wurde, kann sie nicht wieder auf `false` zurückgesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-152">After the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property of the token has been set to `true`, it cannot be reset to `false`.</span></span> <span data-ttu-id="0cf8e-153">Daher können Abbruchtoken nicht wiederverwendet werden, nachdem sie abgebrochen wurden.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-153">Therefore, cancellation tokens cannot be reused after they have been canceled.</span></span>  
  
 <span data-ttu-id="0cf8e-154">Wenn Sie einen Objektabbruchmechanismus benötigen, können Sie ihn durch Aufrufen der <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType>-Methode auf dem Vorgangsabbruchmechanismus basieren lassen, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-154">If you require an object cancellation mechanism, you can base it on the operation cancellation mechanism by calling the <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> method, as shown in the following example.</span></span>  
  
 [!code-csharp[Cancellation#2](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/objectcancellation1.cs#2)]
 [!code-vb[Cancellation#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/objectcancellation1.vb#2)]  
  
 <span data-ttu-id="0cf8e-155">Wenn ein Objekt mehrere gleichzeitig abbrechbare Vorgänge unterstützt, übergeben Sie ein separates Token als Eingabe für die einzelnen abbrechbaren Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-155">If an object supports more than one concurrent cancelable operation, pass a separate token as input to each distinct cancelable operation.</span></span> <span data-ttu-id="0cf8e-156">Auf diese Weise kann ein Vorgang ohne Auswirkung auf die anderen abgebrochen werden.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-156">That way, one operation can be cancelled without affecting the others.</span></span>  
  
## <a name="listening-and-responding-to-cancellation-requests"></a><span data-ttu-id="0cf8e-157">Lauschen und Reagieren auf Abbruchanforderungen</span><span class="sxs-lookup"><span data-stu-id="0cf8e-157">Listening and Responding to Cancellation Requests</span></span>  
 <span data-ttu-id="0cf8e-158">Im Benutzerdelegaten bestimmt der Implementierer eines abbrechbaren Vorgangs, wie der Vorgang als Reaktion auf eine Abbruchanforderung beendet wird.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-158">In the user delegate, the implementer of a cancelable operation determines how to terminate the operation in response to a cancellation request.</span></span> <span data-ttu-id="0cf8e-159">In vielen Fällen kann der Benutzerdelegat einfach die erforderliche Bereinigung ausführen und dann sofort zurückkehren.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-159">In many cases, the user delegate can just perform any required cleanup and then return immediately.</span></span>  
  
 <span data-ttu-id="0cf8e-160">In komplexeren Fällen ist es für den Benutzerdelegaten möglicherweise erforderlich, den Bibliothekscode darüber zu benachrichtigen, dass der Abbruch aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-160">However, in more complex cases, it might be necessary for the user delegate to notify library code that cancellation has occurred.</span></span> <span data-ttu-id="0cf8e-161">In solchen Fällen besteht für den Delegaten die richtige Methode zum Beenden des Vorgangs darin, die <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A>-Methode aufzurufen, die zum Auslösen einer <xref:System.OperationCanceledException> führt.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-161">In such cases, the correct way to terminate the operation is for the delegate to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A>, method, which will cause an <xref:System.OperationCanceledException> to be thrown.</span></span> <span data-ttu-id="0cf8e-162">Bibliothekscode kann diese Ausnahme im Benutzerdelegatthread abfangen und das Token der Ausnahme untersuchen, um zu ermitteln, ob die Ausnahme auf einen kooperativen Abbruch oder eine andere Ausnahmesituation hinweist.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-162">Library code can catch this exception on the user delegate thread and examine the exception's token to determine whether the exception indicates cooperative cancellation or some other exceptional situation.</span></span>  
  
 <span data-ttu-id="0cf8e-163">Die <xref:System.Threading.Tasks.Task>-Klasse behandelt <xref:System.OperationCanceledException> auf diese Weise.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-163">The <xref:System.Threading.Tasks.Task> class handles <xref:System.OperationCanceledException> in this way.</span></span> <span data-ttu-id="0cf8e-164">Weitere Informationen finden Sie unter [Aufgabenabbruch](../parallel-programming/task-cancellation.md).</span><span class="sxs-lookup"><span data-stu-id="0cf8e-164">For more information, see [Task Cancellation](../parallel-programming/task-cancellation.md).</span></span>  
  
### <a name="listening-by-polling"></a><span data-ttu-id="0cf8e-165">Lauschen durch Abruf</span><span class="sxs-lookup"><span data-stu-id="0cf8e-165">Listening by Polling</span></span>  
 <span data-ttu-id="0cf8e-166">Bei langandauernden Berechnungen mit Schleifen oder Rekursionen können Sie auf eine Abbruchanforderung lauschen, indem Sie den Wert der <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType>-Eigenschaft in regelmäßigen Abständen abfragen.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-166">For long-running computations that loop or recurse, you can listen for a cancellation request by periodically polling the value of the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="0cf8e-167">Wenn der Wert `true` lautet, sollte die Methode die Bereinigung vornehmen und so schnell wie möglich beendet werden.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-167">If its value is `true`, the method should clean up and terminate as quickly as possible.</span></span> <span data-ttu-id="0cf8e-168">Die optimale Häufigkeit für das Abrufen hängt vom Typ der Anwendung ab.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-168">The optimal frequency of polling depends on the type of application.</span></span> <span data-ttu-id="0cf8e-169">Es ist Aufgabe des Entwicklers, die beste Abrufhäufigkeit für ein Programm zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-169">It is up to the developer to determine the best polling frequency for any given program.</span></span> <span data-ttu-id="0cf8e-170">Der Abruf selbst hat keinen signifikanten Einfluss auf die Leistung.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-170">Polling itself does not significantly impact performance.</span></span> <span data-ttu-id="0cf8e-171">Im folgenden Beispiel wird eine Möglichkeit für den Abruf veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-171">The following example shows one possible way to poll.</span></span>  
  
 [!code-csharp[Cancellation#3](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex11.cs#3)]
 [!code-vb[Cancellation#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex11.vb#3)]  
  
 <span data-ttu-id="0cf8e-172">Ein ausführlicheres Beispiel finden Sie unter [Vorgehensweise: Lauschen auf Abbruchanforderungen durch Abruf](how-to-listen-for-cancellation-requests-by-polling.md).</span><span class="sxs-lookup"><span data-stu-id="0cf8e-172">For a more complete example, see [How to: Listen for Cancellation Requests by Polling](how-to-listen-for-cancellation-requests-by-polling.md).</span></span>  
  
### <a name="listening-by-registering-a-callback"></a><span data-ttu-id="0cf8e-173">Lauschen durch Registrieren eines Rückrufs</span><span class="sxs-lookup"><span data-stu-id="0cf8e-173">Listening by Registering a Callback</span></span>  
 <span data-ttu-id="0cf8e-174">Einige Vorgänge können so blockiert werden, dass sie den Wert des Abbruchtokens nicht rechtzeitig überprüfen können.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-174">Some operations can become blocked in such a way that they cannot check the value of the cancellation token in a timely manner.</span></span> <span data-ttu-id="0cf8e-175">In diesen Fällen können Sie eine Rückrufmethode registrieren, die die Blockierung der Methode aufhebt, wenn eine Abbruchanforderung empfangen wird.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-175">For these cases, you can register a callback method that unblocks the method when a cancellation request is received.</span></span>  
  
 <span data-ttu-id="0cf8e-176">Die <xref:System.Threading.CancellationToken.Register%2A>-Methode gibt ein <xref:System.Threading.CancellationTokenRegistration>-Objekt zurück, das speziell für diesen Zweck verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-176">The <xref:System.Threading.CancellationToken.Register%2A> method returns a <xref:System.Threading.CancellationTokenRegistration> object that is used specifically for this purpose.</span></span> <span data-ttu-id="0cf8e-177">Das folgende Beispiel zeigt, wie Sie die <xref:System.Threading.CancellationToken.Register%2A>-Methode zum Abbrechen einer asynchronen Webanforderung verwenden.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-177">The following example shows how to use the <xref:System.Threading.CancellationToken.Register%2A> method to cancel an asynchronous Web request.</span></span>  
  
 [!code-csharp[Cancellation#4](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex4.cs#4)]
 [!code-vb[Cancellation#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex4.vb#4)]  
  
 <span data-ttu-id="0cf8e-178">Das <xref:System.Threading.CancellationTokenRegistration>-Objekt verwaltet die Threadsynchronisierung und stellt sicher, dass die Ausführung des Rückrufs zu einem bestimmten Zeitpunkt beendet wird.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-178">The <xref:System.Threading.CancellationTokenRegistration> object manages thread synchronization and ensures that the callback will stop executing at a precise point in time.</span></span>  
  
 <span data-ttu-id="0cf8e-179">Um die Reaktionsfähigkeit des Systems sicherzustellen und Deadlocks zu vermeiden, müssen die folgenden Richtlinien beim Registrieren von Rückrufen beachtet werden:</span><span class="sxs-lookup"><span data-stu-id="0cf8e-179">In order to ensure system responsiveness and to avoid deadlocks, the following guidelines must be followed when registering callbacks:</span></span>  
  
- <span data-ttu-id="0cf8e-180">Die Rückrufmethode muss schnell sein, da sie synchron aufgerufen wird und der Aufruf von <xref:System.Threading.CancellationTokenSource.Cancel%2A> daher nicht zurückgegeben wird, bevor der Rückruf zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-180">The callback method should be fast because it is called synchronously and therefore the call to <xref:System.Threading.CancellationTokenSource.Cancel%2A> does not return until the callback returns.</span></span>  
  
- <span data-ttu-id="0cf8e-181">Wenn Sie <xref:System.Threading.CancellationTokenRegistration.Dispose%2A> aufrufen, während der Rückruf ausgeführt wird, und Sie eine Sperre aufrechterhalten, auf die der Rückruf wartet, kann für das Programm ein Deadlock auftreten.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-181">If you call <xref:System.Threading.CancellationTokenRegistration.Dispose%2A> while the callback is running, and you hold a lock that the callback is waiting on, your program can deadlock.</span></span> <span data-ttu-id="0cf8e-182">Nachdem `Dispose` zurückgegeben wurde, können Sie alle für den Rückruf erforderlichen Ressourcen freigeben.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-182">After `Dispose` returns, you can free any resources required by the callback.</span></span>  
  
- <span data-ttu-id="0cf8e-183">Rückrufe sollten keine manuellen Threads durchführen oder <xref:System.Threading.SynchronizationContext> in einem Rückruf verwenden.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-183">Callbacks should not perform any manual thread or <xref:System.Threading.SynchronizationContext> usage in a callback.</span></span> <span data-ttu-id="0cf8e-184">Wenn ein Rückruf für einen bestimmten Thread ausgeführt werden muss, verwenden Sie den <xref:System.Threading.CancellationTokenRegistration?displayProperty=nameWithType>-Konstruktor, mit dem Sie angeben können, dass der Zielsynchronisierungskontext das aktive <xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType> ist.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-184">If a callback must run on a particular thread, use the <xref:System.Threading.CancellationTokenRegistration?displayProperty=nameWithType> constructor that enables you to specify that the target syncContext is the active <xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0cf8e-185">Manuelles Threading in einem Rückruf kann zu einem Deadlock führen.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-185">Performing manual threading in a callback can cause deadlock.</span></span>  
  
 <span data-ttu-id="0cf8e-186">Ein ausführlicheres Beispiel finden Sie unter [Vorgehensweise: Registrieren von Rückrufen für Abbruchanforderungen](how-to-register-callbacks-for-cancellation-requests.md).</span><span class="sxs-lookup"><span data-stu-id="0cf8e-186">For a more complete example, see [How to: Register Callbacks for Cancellation Requests](how-to-register-callbacks-for-cancellation-requests.md).</span></span>  
  
### <a name="listening-by-using-a-wait-handle"></a><span data-ttu-id="0cf8e-187">Lauschen mithilfe eines Wait-Handles</span><span class="sxs-lookup"><span data-stu-id="0cf8e-187">Listening by Using a Wait Handle</span></span>  
 <span data-ttu-id="0cf8e-188">Wenn ein abbrechbarer Vorgang blockiert werden kann, während er auf einen primitiven Synchronisierungstyp wie <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> oder <xref:System.Threading.Semaphore?displayProperty=nameWithType> wartet, können Sie die <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>-Eigenschaft verwenden, um es dem Vorgang zu ermöglichen, auf das Ereignis und die Abbruchanforderung zu warten.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-188">When a cancelable operation can block while it waits on a synchronization primitive such as a <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> or <xref:System.Threading.Semaphore?displayProperty=nameWithType>, you can use the <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType> property to enable the operation to wait on both the event and the cancellation request.</span></span> <span data-ttu-id="0cf8e-189">Das Wait-Handle des Abbruchtokens wird als Reaktion auf eine Abbruchanforderung signalisiert, und die Methode kann anhand des Rückgabewerts der <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode bestimmen, ob das Abbruchtoken signalisiert hat.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-189">The wait handle of the cancellation token will become signaled in response to a cancellation request, and the method can use the return value of the <xref:System.Threading.WaitHandle.WaitAny%2A> method to determine whether it was the cancellation token that signaled.</span></span> <span data-ttu-id="0cf8e-190">Der Vorgang kann dann einfach beenden oder ggf. eine <xref:System.OperationCanceledException> auslösen.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-190">The operation can then just exit, or throw a <xref:System.OperationCanceledException>, as appropriate.</span></span>  
  
 [!code-csharp[Cancellation#5](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex9.cs#5)]
 [!code-vb[Cancellation#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex9.vb#5)]  
  
 <span data-ttu-id="0cf8e-191">Im neuen Code, der auf .NET Framework 4 ausgerichtet ist, unterstützen <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> und <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> das neue Abbruchframework in ihren `Wait`-Methoden.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-191">In new code that targets the .NET Framework 4, <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> both support the new cancellation framework in their `Wait` methods.</span></span> <span data-ttu-id="0cf8e-192">Sie können das <xref:System.Threading.CancellationToken> an die Methode übergeben und bei der Abbruchanforderung wird das Ereignis reaktiviert, das ein <xref:System.OperationCanceledException> auslöst.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-192">You can pass the <xref:System.Threading.CancellationToken> to the method, and when the cancellation is requested, the event wakes up and throws an <xref:System.OperationCanceledException>.</span></span>  
  
 [!code-csharp[Cancellation#6](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex10.cs#6)]
 [!code-vb[Cancellation#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex10.vb#6)]  
  
 <span data-ttu-id="0cf8e-193">Ein ausführlicheres Beispiel finden Sie unter [Vorgehensweise: Lauschen auf Abbruchanforderungen mit Wait-Handles](how-to-listen-for-cancellation-requests-that-have-wait-handles.md).</span><span class="sxs-lookup"><span data-stu-id="0cf8e-193">For a more complete example, see [How to: Listen for Cancellation Requests That Have Wait Handles](how-to-listen-for-cancellation-requests-that-have-wait-handles.md).</span></span>  
  
### <a name="listening-to-multiple-tokens-simultaneously"></a><span data-ttu-id="0cf8e-194">Gleichzeitiges Lauschen auf mehrere Token</span><span class="sxs-lookup"><span data-stu-id="0cf8e-194">Listening to Multiple Tokens Simultaneously</span></span>  
 <span data-ttu-id="0cf8e-195">In einigen Fällen muss ein Listener möglicherweise auf mehrere Abbruchtoken gleichzeitig lauschen.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-195">In some cases, a listener may have to listen to multiple cancellation tokens simultaneously.</span></span> <span data-ttu-id="0cf8e-196">Ein abbrechbarer Vorgang muss z. B. möglicherweise zusätzlich zu einem extern als Argument an einen Methodenparameter übergebenen Token ein internes Abbruchtoken überwachen.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-196">For example, a cancelable operation may have to monitor an internal cancellation token in addition to a token passed in externally as an argument to a method parameter.</span></span> <span data-ttu-id="0cf8e-197">Zu diesem Zweck erstellen Sie eine verknüpfte Tokenquelle, die zwei oder mehr Token zu einem Token verbinden kann, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-197">To accomplish this, create a linked token source that can join two or more tokens into one token, as shown in the following example.</span></span>  
  
 [!code-csharp[Cancellation#7](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex13.cs#7)]
 [!code-vb[Cancellation#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex13.vb#7)]  
  
 <span data-ttu-id="0cf8e-198">Beachten Sie, dass Sie `Dispose` für die verknüpfte Tokenquelle aufrufen müssen, wenn Sie damit fertig sind.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-198">Notice that you must call `Dispose` on the linked token source when you are done with it.</span></span> <span data-ttu-id="0cf8e-199">Ein ausführlicheres Beispiel finden Sie unter [Vorgehensweise: Lauschen auf mehrere Abbruchanforderungen](how-to-listen-for-multiple-cancellation-requests.md).</span><span class="sxs-lookup"><span data-stu-id="0cf8e-199">For a more complete example, see [How to: Listen for Multiple Cancellation Requests](how-to-listen-for-multiple-cancellation-requests.md).</span></span>  
  
## <a name="cooperation-between-library-code-and-user-code"></a><span data-ttu-id="0cf8e-200">Kooperation zwischen Bibliothekscode und Benutzercode</span><span class="sxs-lookup"><span data-stu-id="0cf8e-200">Cooperation Between Library Code and User Code</span></span>  
 <span data-ttu-id="0cf8e-201">Das einheitliche Abbruchframework ermöglicht es dem Bibliothekscode, den Benutzercode abzubrechen. Ebenso ermöglicht es dem Benutzercode, den Bibliothekscode auf kooperative Weise abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-201">The unified cancellation framework makes it possible for library code to cancel user code, and for user code to cancel library code in a cooperative manner.</span></span> <span data-ttu-id="0cf8e-202">Die problemlose Zusammenarbeit hängt davon ab, ob die beiden Seiten die folgenden Richtlinien beachten:</span><span class="sxs-lookup"><span data-stu-id="0cf8e-202">Smooth cooperation depends on each side following these guidelines:</span></span>  
  
- <span data-ttu-id="0cf8e-203">Wenn der Bibliothekscode abbrechbare Vorgänge bereitstellt, sollten auch öffentliche Methoden bereitgestellt werden, die ein externes Abbruchtoken akzeptieren, damit der Benutzercode den Abbruch anfordern kann.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-203">If library code provides cancelable operations, it should also provide public methods that accept an external cancellation token so that user code can request cancellation.</span></span>  
  
- <span data-ttu-id="0cf8e-204">Wenn der Bibliothekscode einen Aufruf innerhalb des Benutzercodes ausführt, sollte der Bibliothekscode ein OperationCanceledException(externalToken) als *kooperativen Abbruch* und nicht notwendigerweise als Fehlerausnahme interpretieren.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-204">If library code calls into user code, the library code should interpret an OperationCanceledException(externalToken) as *cooperative cancellation*, and not necessarily as a failure exception.</span></span>  
  
- <span data-ttu-id="0cf8e-205">Benutzerdelegaten sollten versuchen, zeitnah auf Abbruchanforderungen aus Bibliothekscode zu reagieren.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-205">User-delegates should attempt to respond to cancellation requests from library code in a timely manner.</span></span>  
  
 <span data-ttu-id="0cf8e-206"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> und <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> sind Beispiele für Klassen, die diese Richtlinien einhalten.</span><span class="sxs-lookup"><span data-stu-id="0cf8e-206"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> are examples of classes that follow these guidelines.</span></span> <span data-ttu-id="0cf8e-207">Weitere Informationen finden Sie unter [Aufgabenabbruch](../parallel-programming/task-cancellation.md) und [Vorgehensweise: Abbrechen einer PLINQ-Abfrage](../parallel-programming/how-to-cancel-a-plinq-query.md).</span><span class="sxs-lookup"><span data-stu-id="0cf8e-207">For more information, see [Task Cancellation](../parallel-programming/task-cancellation.md) and [How to: Cancel a PLINQ Query](../parallel-programming/how-to-cancel-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0cf8e-208">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="0cf8e-208">See also</span></span>

- [<span data-ttu-id="0cf8e-209">Grundlagen des verwalteten Threadings</span><span class="sxs-lookup"><span data-stu-id="0cf8e-209">Managed Threading Basics</span></span>](managed-threading-basics.md)
