---
title: Übersicht über Synchronisierungsprimitive
description: Erfahren Sie mehr über .NET-Threadsynchronisierungsprimitive zum Synchronisieren des Zugriffs auf eine freigegebene Ressource oder die Steuerthreadinteraktion.
ms.date: 10/01/2018
helpviewer_keywords:
- synchronization, threads
- threading [.NET],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
ms.openlocfilehash: 9dfaaa6050cc6e9a6b86f991aa6d2ce2a815959a
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/18/2020
ms.locfileid: "94819655"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="55b44-103">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="55b44-103">Overview of synchronization primitives</span></span>

<span data-ttu-id="55b44-104">.NET bietet eine Reihe von Typen, mit denen Sie den Zugriff auf eine freigegebene Ressource synchronisieren oder die Threadinteraktion koordinieren können.</span><span class="sxs-lookup"><span data-stu-id="55b44-104">.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="55b44-105">Verwenden Sie die gleiche Synchronisierungsprimitivinstanz, um den Zugriff einer freigegebenen Ressource zu schützen.</span><span class="sxs-lookup"><span data-stu-id="55b44-105">Use the same synchronization primitive instance to protect access of a shared resource.</span></span> <span data-ttu-id="55b44-106">Wenn Sie verschiedene Synchronisierungsprimitivinstanzen verwenden, um dieselbe Ressource zu schützen, umgehen Sie den Schutz, der von einem Synchronisierungsprimitive bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="55b44-106">If you use different synchronization primitive instances to protect the same resource, you'll circumvent the protection provided by a synchronization primitive.</span></span>

## <a name="waithandle-class-and-lightweight-synchronization-types"></a><span data-ttu-id="55b44-107">WaitHandle-Klasse und einfache Synchronisierungstypen</span><span class="sxs-lookup"><span data-stu-id="55b44-107">WaitHandle class and lightweight synchronization types</span></span>

<span data-ttu-id="55b44-108">Von der <xref:System.Threading.WaitHandle?displayProperty=nameWithType>-Klasse werden mehrere .NET-Synchronisierungsprimitive abgeleitet, die ein natives Handle für die Betriebssystemsynchronisierung kapselt, und einen Signalmechanismus für die Threadinteraktion verwendet.</span><span class="sxs-lookup"><span data-stu-id="55b44-108">Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.</span></span> <span data-ttu-id="55b44-109">Diese Klassen umfassen:</span><span class="sxs-lookup"><span data-stu-id="55b44-109">Those classes include:</span></span>

- <span data-ttu-id="55b44-110"><xref:System.Threading.Mutex?displayProperty=nameWithType> gewährt exklusiven Zugriff auf eine freigegebene Ressource.</span><span class="sxs-lookup"><span data-stu-id="55b44-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource.</span></span> <span data-ttu-id="55b44-111">Der Zustand eines Mutex wird signalisiert, wenn er nicht in Besitz eines Threads ist.</span><span class="sxs-lookup"><span data-stu-id="55b44-111">The state of a mutex is signaled if no thread owns it.</span></span>
- <span data-ttu-id="55b44-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType> schränkt die Anzahl von Threads ein, die gleichzeitig auf eine freigegebene Ressource oder einen Pool von Ressourcen zugreifen können.</span><span class="sxs-lookup"><span data-stu-id="55b44-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="55b44-113">Der Status eines Semaphors wird auf „signalisiert“ festgelegt, wenn die Anzahl größer als Null ist, bzw. wird auf „nicht signalisiert“ gesetzt, wenn die Anzahl Null ist.</span><span class="sxs-lookup"><span data-stu-id="55b44-113">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>
- <span data-ttu-id="55b44-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> stellt ein Threadsynchronisierungsereignis dar und kann sich entweder in einem signalisierten oder nicht signalisierten Zustand befinden.</span><span class="sxs-lookup"><span data-stu-id="55b44-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.</span></span>
- <span data-ttu-id="55b44-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> wird aus <xref:System.Threading.EventWaitHandle> abgeleitet und wird nach der Freigabe eines einzelnen wartenden Threads automatisch in einen nicht signalisierten Zustand zurückgesetzt, wenn einen Signalisierung eintritt.</span><span class="sxs-lookup"><span data-stu-id="55b44-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</span></span>
- <span data-ttu-id="55b44-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> wird aus <xref:System.Threading.EventWaitHandle> abgeleitet bleibt bei einer Signalisierung in einem signalisierten Zustand, bis die <xref:System.Threading.EventWaitHandle.Reset%2A>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="55b44-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>

<span data-ttu-id="55b44-117">Da <xref:System.Threading.WaitHandle> aus <xref:System.MarshalByRefObject?displayProperty=nameWithType> abgeleitet wird, können diese Typen im .NET Framework verwendet werden, um die Aktivitäten von Threads über Anwendungsdomänengrenzen hinweg zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="55b44-117">In .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.</span></span>

<span data-ttu-id="55b44-118">Im .NET Framework, in .NET Core und in .NET 5 oder höheren Versionen können einige dieser Typen benannte Systemsynchronisierungshandles darstellen, die im gesamten Betriebssystem sichtbar sind und die für die prozessübergreifende Synchronisierung verwendet werden können:</span><span class="sxs-lookup"><span data-stu-id="55b44-118">In .NET Framework, .NET Core, and .NET 5+, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</span></span>

- <xref:System.Threading.Mutex>
- <span data-ttu-id="55b44-119"><xref:System.Threading.Semaphore> (unter Windows)</span><span class="sxs-lookup"><span data-stu-id="55b44-119"><xref:System.Threading.Semaphore> (on Windows)</span></span>
- <span data-ttu-id="55b44-120"><xref:System.Threading.EventWaitHandle> (unter Windows)</span><span class="sxs-lookup"><span data-stu-id="55b44-120"><xref:System.Threading.EventWaitHandle> (on Windows)</span></span>

<span data-ttu-id="55b44-121">Weitere Informationen finden Sie in der Referenz für die <xref:System.Threading.WaitHandle>-API.</span><span class="sxs-lookup"><span data-stu-id="55b44-121">For more information, see the <xref:System.Threading.WaitHandle> API reference.</span></span>

<span data-ttu-id="55b44-122">Einfache Synchronisierungstypen basieren nicht auf zugrunde liegende Betriebssystemhandles und bieten in der Regel eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="55b44-122">Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.</span></span> <span data-ttu-id="55b44-123">Allerdings können sie nicht für die prozessübergreifende Synchronisierung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="55b44-123">However, they cannot be used for the inter-process synchronization.</span></span> <span data-ttu-id="55b44-124">Verwenden Sie diese Typen für die Threadsynchronisierung innerhalb einer Anwendung.</span><span class="sxs-lookup"><span data-stu-id="55b44-124">Use those types for thread synchronization within one application.</span></span>

<span data-ttu-id="55b44-125">Einige dieser Typen stellen Alternativen zu den aus <xref:System.Threading.WaitHandle> abgeleiteten Typen dar.</span><span class="sxs-lookup"><span data-stu-id="55b44-125">Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="55b44-126">Beispielsweise ist <xref:System.Threading.SemaphoreSlim> eine einfache Alternative zu <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="55b44-126">For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.</span></span>

## <a name="synchronization-of-access-to-a-shared-resource"></a><span data-ttu-id="55b44-127">Synchronisieren des Zugriffs auf eine freigegebene Ressource</span><span class="sxs-lookup"><span data-stu-id="55b44-127">Synchronization of access to a shared resource</span></span>

<span data-ttu-id="55b44-128">.NET stellt eine Reihe von Synchronisierungsprimitiven zum Steuern des Zugriffs auf eine freigegebene Ressource von mehreren Threads bereit.</span><span class="sxs-lookup"><span data-stu-id="55b44-128">.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</span></span>

### <a name="monitor-class"></a><span data-ttu-id="55b44-129">Monitor-Klasse</span><span class="sxs-lookup"><span data-stu-id="55b44-129">Monitor class</span></span>

<span data-ttu-id="55b44-130">Die <xref:System.Threading.Monitor?displayProperty=nameWithType>-Klasse gewährt den gegenseitig exklusiven Zugriff auf eine freigegebene Ressource, indem sie eine Sperre für das Objekt, das die Ressource identifiziert, abruft oder aufhebt.</span><span class="sxs-lookup"><span data-stu-id="55b44-130">The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</span></span> <span data-ttu-id="55b44-131">Während eine Sperre aufrechterhalten wird, kann der Thread, der die Sperre aufrechterhält, die Sperre abrufen und aufheben.</span><span class="sxs-lookup"><span data-stu-id="55b44-131">While a lock is held, the thread that holds the lock can again acquire and release the lock.</span></span> <span data-ttu-id="55b44-132">Für jeden anderen Thread wird das Abrufen der Sperre blockiert, und die <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>-Methode wartet auf die Aufhebung.</span><span class="sxs-lookup"><span data-stu-id="55b44-132">Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released.</span></span> <span data-ttu-id="55b44-133">Die <xref:System.Threading.Monitor.Enter%2A>-Methode ruft eine freigegebene Sperre ab.</span><span class="sxs-lookup"><span data-stu-id="55b44-133">The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock.</span></span> <span data-ttu-id="55b44-134">Sie können die <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>-Methode auch verwenden, um die Zeitspanne anzugeben, in der ein Thread versucht, eine Sperre abzurufen.</span><span class="sxs-lookup"><span data-stu-id="55b44-134">You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock.</span></span> <span data-ttu-id="55b44-135">Da die <xref:System.Threading.Monitor>-Klasse Threadaffinität hat, muss der Thread, der eine Sperre erhalten hat, die Sperre durch Aufruf der <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>-Methode freigeben.</span><span class="sxs-lookup"><span data-stu-id="55b44-135">Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="55b44-136">Sie können die Interaktion von Threads, die eine Sperre für dasselbe Objekt erhalten, mit den Methoden <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> und <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> koordinieren.</span><span class="sxs-lookup"><span data-stu-id="55b44-136">You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>

<span data-ttu-id="55b44-137">Weitere Informationen finden Sie in der Referenz für die <xref:System.Threading.Monitor>-API.</span><span class="sxs-lookup"><span data-stu-id="55b44-137">For more information, see the <xref:System.Threading.Monitor> API reference.</span></span>

> [!NOTE]
> <span data-ttu-id="55b44-138">Verwenden Sie die [lock](../../csharp/language-reference/keywords/lock-statement.md)-Anweisung in C# und die [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md)-Anweisung in Visual Basic, um den Zugriff auf eine freigegebene Ressource zu synchronisieren, anstatt die <xref:System.Threading.Monitor>-Klasse direkt zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="55b44-138">Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly.</span></span> <span data-ttu-id="55b44-139">Die Anweisungen werden mithilfe der <xref:System.Threading.Monitor.Enter%2A>- und <xref:System.Threading.Monitor.Exit%2A>-Methoden implementiert und verwenden den `try…finally`-Block, um sicherzustellen, dass die erhaltene Sperre aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="55b44-139">Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `try…finally` block to ensure that the acquired lock is always released.</span></span>

### <a name="mutex-class"></a><span data-ttu-id="55b44-140">Mutex-Klasse</span><span class="sxs-lookup"><span data-stu-id="55b44-140">Mutex class</span></span>

<span data-ttu-id="55b44-141">Die <xref:System.Threading.Mutex?displayProperty=nameWithType>-Klasse gewährt wie <xref:System.Threading.Monitor> exklusiven Zugriff auf eine freigegebene Ressource.</span><span class="sxs-lookup"><span data-stu-id="55b44-141">The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource.</span></span> <span data-ttu-id="55b44-142">Verwenden Sie eine der [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>)-Methodenüberladungen, um den Besitz eines Mutex anzufordern.</span><span class="sxs-lookup"><span data-stu-id="55b44-142">Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex.</span></span> <span data-ttu-id="55b44-143">Wie <xref:System.Threading.Monitor> hat auch <xref:System.Threading.Mutex> Threadaffinität und der Thread, der eine Mutex erworben hat, muss diesen durch den Aufruf der <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType>-Methode freigeben.</span><span class="sxs-lookup"><span data-stu-id="55b44-143">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="55b44-144">Im Gegensatz zu <xref:System.Threading.Monitor> kann die <xref:System.Threading.Mutex>-Klasse für die prozessübergreifende Synchronisierung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="55b44-144">Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization.</span></span> <span data-ttu-id="55b44-145">Verwenden Sie dazu einen benannten Mutex, der im gesamten Betriebssystem sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="55b44-145">To do that, use a named mutex, which is visible throughout the operating system.</span></span> <span data-ttu-id="55b44-146">Verwenden Sie zum Erstellen einer benannten Mutexinstanz einen [Mutex-Konstruktor](<xref:System.Threading.Mutex.%23ctor%2A>), der einen Namen angibt.</span><span class="sxs-lookup"><span data-stu-id="55b44-146">To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name.</span></span> <span data-ttu-id="55b44-147">Sie können auch die <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType>-Methode aufrufen, um ein vorhandenes benanntes Systemmutex zu öffnen.</span><span class="sxs-lookup"><span data-stu-id="55b44-147">You can also call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.</span></span>
  
<span data-ttu-id="55b44-148">Weitere Informationen finden Sie im Artikel [Mutexe](mutexes.md) und in der Referenz zur <xref:System.Threading.Mutex>-API.</span><span class="sxs-lookup"><span data-stu-id="55b44-148">For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.</span></span>

### <a name="spinlock-structure"></a><span data-ttu-id="55b44-149">SpinLock-Struktur</span><span class="sxs-lookup"><span data-stu-id="55b44-149">SpinLock structure</span></span>

<span data-ttu-id="55b44-150">Die <xref:System.Threading.SpinLock?displayProperty=nameWithType>-Struktur gewährt wie <xref:System.Threading.Monitor> exklusiven Zugriff auf eine freigegebene Ressource, basierend auf der Verfügbarkeit einer Sperre.</span><span class="sxs-lookup"><span data-stu-id="55b44-150">The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock.</span></span> <span data-ttu-id="55b44-151">Wenn <xref:System.Threading.SpinLock> versucht, eine nicht verfügbare Sperre zu erhalten, wartet sie in einer Schleife und überprüft wiederholt, ob die Sperre verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="55b44-151">When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</span></span>

<span data-ttu-id="55b44-152">Weitere Informationen zu den Vor- und Nachteilen der Verwendung von SpinLock finden Sie im [SpinLock](spinlock.md)-Artikel und in der Referenz zur <xref:System.Threading.SpinLock>-API.</span><span class="sxs-lookup"><span data-stu-id="55b44-152">For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.</span></span>

### <a name="readerwriterlockslim-class"></a><span data-ttu-id="55b44-153">ReaderWriterLockSlim-Klasse</span><span class="sxs-lookup"><span data-stu-id="55b44-153">ReaderWriterLockSlim class</span></span>

<span data-ttu-id="55b44-154">Die <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType>-Klasse gewährt exklusiven Schreibzugriff auf eine freigegebene Ressource und ermöglicht es mehreren Threads, gleichzeitig zum Lesen auf die Ressource zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="55b44-154">The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</span></span> <span data-ttu-id="55b44-155">Möglicherweise möchten Sie <xref:System.Threading.ReaderWriterLockSlim> verwenden, um den Zugriff auf eine freigegebene Datenstruktur zu synchronisieren, die threadsichere Lesevorgänge unterstützt, aber exklusiven Zugriff für die Durchführung von Schreibvorgängen benötigt.</span><span class="sxs-lookup"><span data-stu-id="55b44-155">You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.</span></span> <span data-ttu-id="55b44-156">Wenn ein Thread exklusiven Zugriff anfordert (z.B. durch Aufrufen der <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType>-Methode), werden nachfolgende Writeranforderungen blockiert, bis alle vorhandenen Reader die Sperre beendet haben und der Writer die Sperre aktiviert und beendet hat.</span><span class="sxs-lookup"><span data-stu-id="55b44-156">When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>
  
<span data-ttu-id="55b44-157">Weitere Informationen finden Sie in der Referenz für die <xref:System.Threading.ReaderWriterLockSlim>-API.</span><span class="sxs-lookup"><span data-stu-id="55b44-157">For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.</span></span>

### <a name="semaphore-and-semaphoreslim-classes"></a><span data-ttu-id="55b44-158">Semaphore- und SemaphoreSlim-Klassen</span><span class="sxs-lookup"><span data-stu-id="55b44-158">Semaphore and SemaphoreSlim classes</span></span>

<span data-ttu-id="55b44-159">Die <xref:System.Threading.Semaphore?displayProperty=nameWithType>- und <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>-Klassen schränken die Anzahl von Threads ein, die gleichzeitig auf eine freigegebene Ressource oder einen Pool von Ressourcen zugreifen können.</span><span class="sxs-lookup"><span data-stu-id="55b44-159">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="55b44-160">Zusätzliche Threads, die die Ressource anfordern, warten, bis ein Thread das Semaphor freigibt.</span><span class="sxs-lookup"><span data-stu-id="55b44-160">Additional threads that request the resource wait until any thread releases the semaphore.</span></span> <span data-ttu-id="55b44-161">Da das Semaphor keine Threadaffinität hat, kann ein Thread das Semaphor erhalten und ein anderer kann es freigeben.</span><span class="sxs-lookup"><span data-stu-id="55b44-161">Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.</span></span>

<span data-ttu-id="55b44-162"><xref:System.Threading.SemaphoreSlim> ist eine einfache Alternative zu <xref:System.Threading.Semaphore> und kann nur für die Synchronisierung innerhalb einer einzelnen Prozessgrenze verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="55b44-162"><xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.</span></span>

<span data-ttu-id="55b44-163">Unter Windows können Sie <xref:System.Threading.Semaphore> für die prozessübergreifende Synchronisierung verwenden.</span><span class="sxs-lookup"><span data-stu-id="55b44-163">On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization.</span></span> <span data-ttu-id="55b44-164">Erstellen Sie dafür eine <xref:System.Threading.Semaphore>-Instanz, die ein benanntes Systemsemaphor darstellt, indem Sie einen der [Semaphorskonstruktoren](<xref:System.Threading.Semaphore.%23ctor%2A>) verwenden, die einen Namen oder die <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType>-Methode angeben.</span><span class="sxs-lookup"><span data-stu-id="55b44-164">To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="55b44-165"><xref:System.Threading.SemaphoreSlim> unterstützt keine benannten Systemsemaphoren.</span><span class="sxs-lookup"><span data-stu-id="55b44-165"><xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.</span></span>

<span data-ttu-id="55b44-166">Weitere Informationen finden Sie im Artikel [Semaphore und SemaphoreSlim](semaphore-and-semaphoreslim.md) und in der Referenz zur <xref:System.Threading.Semaphore>- oder <xref:System.Threading.SemaphoreSlim>-API.</span><span class="sxs-lookup"><span data-stu-id="55b44-166">For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.</span></span>

## <a name="thread-interaction-or-signaling"></a><span data-ttu-id="55b44-167">Threadinteraktionen oder -signalisierung</span><span class="sxs-lookup"><span data-stu-id="55b44-167">Thread interaction, or signaling</span></span>

<span data-ttu-id="55b44-168">Threadinteraktionen (oder Threadsignalisierung) bedeutet, dass ein Thread zum Fortsetzen des Vorgangs auf eine Benachrichtigung oder ein Signal von einem oder mehreren Threads warten muss.</span><span class="sxs-lookup"><span data-stu-id="55b44-168">Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</span></span> <span data-ttu-id="55b44-169">Wenn beispielsweise Thread A die <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>-Methode von Thread B aufruft, wird Thread A blockiert, bis Thread B abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="55b44-169">For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes.</span></span> <span data-ttu-id="55b44-170">Die im vorhergehenden Abschnitt beschriebenen Synchronisierungsprimitive bieten einen anderen Mechanismus für die Signalisierung: Durch die Freigabe einer Sperre benachrichtigt ein Thread einen anderen Thread, dass er durch den Erhalt der Sperre fortgesetzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="55b44-170">The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.</span></span>

<span data-ttu-id="55b44-171">Dieser Abschnitt beschreibt zusätzliche Signalisierungskonstrukte, die von .NET bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="55b44-171">This section describes additional signaling constructs provided by .NET.</span></span>

### <a name="eventwaithandle-autoresetevent-manualresetevent-and-manualreseteventslim-classes"></a><span data-ttu-id="55b44-172">EventWaitHandle-, AutoResetEvent-, ManualResetEvent- und ManualResetEventSlim-Klassen</span><span class="sxs-lookup"><span data-stu-id="55b44-172">EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes</span></span>

<span data-ttu-id="55b44-173">Die <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>-Klasse stellt ein Threadsynchronisierungsereignis dar.</span><span class="sxs-lookup"><span data-stu-id="55b44-173">The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.</span></span>

<span data-ttu-id="55b44-174">Ein Synchronisierungsereignis kann entweder in einem nicht signalisierten oder signalisierten Zustand sein.</span><span class="sxs-lookup"><span data-stu-id="55b44-174">A synchronization event can be either in an unsignaled or signaled state.</span></span> <span data-ttu-id="55b44-175">Wenn der Zustand eines Ereignisses nicht signalisiert ist, wird ein Thread, der die <xref:System.Threading.WaitHandle.WaitOne%2A?>-Überladung des Ereignisses aufruft, blockiert, bis ein Ereignis signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="55b44-175">When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled.</span></span> <span data-ttu-id="55b44-176">Die <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> Methode legt den Zustand eines Ereignisses auf „signalisiert“ fest.</span><span class="sxs-lookup"><span data-stu-id="55b44-176">The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.</span></span>

<span data-ttu-id="55b44-177">Das Verhalten einer signalisierten <xref:System.Threading.EventWaitHandle> hängt von den Zurücksetzmodus ab:</span><span class="sxs-lookup"><span data-stu-id="55b44-177">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:</span></span>

- <span data-ttu-id="55b44-178">Eine mit der <xref:System.Threading.EventWaitHandle>-Flag erstellten <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> wird nach der Freigabe eines einzelnen wartenden Threads automatisch zurückgesetzt.</span><span class="sxs-lookup"><span data-stu-id="55b44-178">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread.</span></span> <span data-ttu-id="55b44-179">Es ist wie ein Drehkreuz, das bei jeder Signalisierung nur einen Thread durchlässt.</span><span class="sxs-lookup"><span data-stu-id="55b44-179">It's like a turnstile that allows only one thread through each time it's signaled.</span></span> <span data-ttu-id="55b44-180">Die <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>-Klasse, die von <xref:System.Threading.EventWaitHandle> abgeleitet wird, stellt dieses Verhalten dar.</span><span class="sxs-lookup"><span data-stu-id="55b44-180">The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span>
- <span data-ttu-id="55b44-181">Eine mit der <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>-Flag erstellte <xref:System.Threading.EventWaitHandle.Reset%2A> bleibt so lange ein Signal, bis die <xref:System.Threading.EventWaitHandle>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="55b44-181">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="55b44-182">Es ist wie ein Tor, das bis zum Signal geschlossen wird und dann offen bleibt, bis es jemand schließt.</span><span class="sxs-lookup"><span data-stu-id="55b44-182">It's like a gate that is closed until signaled and then stays open until someone closes it.</span></span> <span data-ttu-id="55b44-183">Die <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>-Klasse, die von <xref:System.Threading.EventWaitHandle> abgeleitet wird, stellt dieses Verhalten dar.</span><span class="sxs-lookup"><span data-stu-id="55b44-183">The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span> <span data-ttu-id="55b44-184">Die <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>-Klasse ist eine einfache Alternative zu <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="55b44-184">The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.</span></span>

<span data-ttu-id="55b44-185">Unter Windows können Sie <xref:System.Threading.EventWaitHandle> für die prozessübergreifende Synchronisierung verwenden.</span><span class="sxs-lookup"><span data-stu-id="55b44-185">On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization.</span></span> <span data-ttu-id="55b44-186">Erstellen Sie dafür eine <xref:System.Threading.EventWaitHandle>-Instanz, die ein benanntes Systemsynchronisierungsereignis darstellt, indem Sie einen der [EventWaitHandle-Konstruktoren](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) verwenden, die einen Namen oder die <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType>-Methode angeben.</span><span class="sxs-lookup"><span data-stu-id="55b44-186">To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="55b44-187">Weitere Informationen finden Sie im Artikel [EventWaitHandle](eventwaithandle.md).</span><span class="sxs-lookup"><span data-stu-id="55b44-187">For more information, see the [EventWaitHandle](eventwaithandle.md) article.</span></span> <span data-ttu-id="55b44-188">Die API-Referenz finden Sie unter <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent> und <xref:System.Threading.ManualResetEventSlim>.</span><span class="sxs-lookup"><span data-stu-id="55b44-188">For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.</span></span>

### <a name="countdownevent-class"></a><span data-ttu-id="55b44-189">CountdownEvent-Klasse</span><span class="sxs-lookup"><span data-stu-id="55b44-189">CountdownEvent class</span></span>

<span data-ttu-id="55b44-190">Die <xref:System.Threading.CountdownEvent?displayProperty=nameWithType>-Klasse stellt ein Ereignis dar, das festgelegt wird, wenn die Anzahl null ist.</span><span class="sxs-lookup"><span data-stu-id="55b44-190">The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero.</span></span> <span data-ttu-id="55b44-191">Wenn <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> größer als Null ist, wird ein Thread, der <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> abruft, blockiert.</span><span class="sxs-lookup"><span data-stu-id="55b44-191">While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked.</span></span> <span data-ttu-id="55b44-192">Rufen Sie <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> auf, um die Anzahl eines Ereignisses zu verringern.</span><span class="sxs-lookup"><span data-stu-id="55b44-192">Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.</span></span>

<span data-ttu-id="55b44-193">Im Gegensatz zu <xref:System.Threading.ManualResetEvent> oder <xref:System.Threading.ManualResetEventSlim>, mit denen Sie mehrere Threads mit einem Signal von einem Thread entsperren können, können Sie mit <xref:System.Threading.CountdownEvent> einen oder mehrere Threads mit Signalen von mehreren Threads entsperren.</span><span class="sxs-lookup"><span data-stu-id="55b44-193">In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.</span></span>

<span data-ttu-id="55b44-194">Weitere Informationen finden Sie im Artikel [CountdownEvent](countdownevent.md) und in der Referenz zur <xref:System.Threading.CountdownEvent>-API.</span><span class="sxs-lookup"><span data-stu-id="55b44-194">For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.</span></span>

### <a name="barrier-class"></a><span data-ttu-id="55b44-195">Barrier-Klasse</span><span class="sxs-lookup"><span data-stu-id="55b44-195">Barrier class</span></span>

<span data-ttu-id="55b44-196">Die <xref:System.Threading.Barrier?displayProperty=nameWithType> Klasse stellt eine Barriere zur Threadausführung dar.</span><span class="sxs-lookup"><span data-stu-id="55b44-196">The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier.</span></span> <span data-ttu-id="55b44-197">Ein Thread, der die <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType>-Methode aufruft, signalisiert, dass er die Barriere erreicht hat und wartet, bis andere teilnehmenden Threads die Barriere erreichen.</span><span class="sxs-lookup"><span data-stu-id="55b44-197">A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier.</span></span> <span data-ttu-id="55b44-198">Wenn alle teilnehmenden Threads die Barriere erreichen, werden sie weiter ausgeführt, und die Barriere wird zurückgesetzt und kann wieder verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="55b44-198">When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</span></span>

<span data-ttu-id="55b44-199">Sie können <xref:System.Threading.Barrier> verwenden, wenn ein oder mehrere Threads die Ergebnisse anderer Threads benötigen, bevor Sie mit der nächsten Berechnungsphase fortfahren.</span><span class="sxs-lookup"><span data-stu-id="55b44-199">You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.</span></span>

<span data-ttu-id="55b44-200">Weitere Informationen finden Sie im Artikel [Barriere](barrier.md) und in der Referenz zur <xref:System.Threading.Barrier>-API.</span><span class="sxs-lookup"><span data-stu-id="55b44-200">For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.</span></span>

## <a name="interlocked-class"></a><span data-ttu-id="55b44-201">Interlocked-Klasse</span><span class="sxs-lookup"><span data-stu-id="55b44-201">Interlocked class</span></span>

<span data-ttu-id="55b44-202">Die <xref:System.Threading.Interlocked?displayProperty=nameWithType>-Klasse stellt statische Methoden zur Verfügung, die einfache atomare Operationen an einer Variablen durchführen.</span><span class="sxs-lookup"><span data-stu-id="55b44-202">The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable.</span></span> <span data-ttu-id="55b44-203">Diese atomaren Operationen umfassen Addition, Inkrementieren und Dekrementieren, Austausch, bedingter Austausch je nach Vergleich und Lesevorgänge für einen 64-Bit-Ganzzahlenwert.</span><span class="sxs-lookup"><span data-stu-id="55b44-203">Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.</span></span>

<span data-ttu-id="55b44-204">Weitere Informationen finden Sie in der Referenz für die <xref:System.Threading.Interlocked>-API.</span><span class="sxs-lookup"><span data-stu-id="55b44-204">For more information, see the <xref:System.Threading.Interlocked> API reference.</span></span>

## <a name="spinwait-structure"></a><span data-ttu-id="55b44-205">SpinWait-Struktur</span><span class="sxs-lookup"><span data-stu-id="55b44-205">SpinWait structure</span></span>

<span data-ttu-id="55b44-206">Die <xref:System.Threading.SpinWait?displayProperty=nameWithType>-Struktur stellt Unterstützung für Spin-basierte Wartevorgänge bereit.</span><span class="sxs-lookup"><span data-stu-id="55b44-206">The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting.</span></span> <span data-ttu-id="55b44-207">Sie können die Struktur verwenden, wenn ein Thread warten muss, bis ein Ereignis signalisiert oder eine Bedingung erfüllt wird, außer wenn die tatsächliche Wartezeit voraussichtlich kürzer als die erforderliche Wartezeit beim Verwenden eines Wait-Handles oder einer anderen Blockierung des Threads ist.</span><span class="sxs-lookup"><span data-stu-id="55b44-207">You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.</span></span> <span data-ttu-id="55b44-208">Mithilfe von <xref:System.Threading.SpinWait> können Sie einen kurzen Wartezeitraum angeben und danach nur dann auslösen (z. B. durch Warten oder Ruhezustand), wenn die Bedingung nicht in der angegebenen Zeit erfüllt wurde.</span><span class="sxs-lookup"><span data-stu-id="55b44-208">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>

<span data-ttu-id="55b44-209">Weitere Informationen finden Sie im Artikel [SpinWait](spinwait.md) und in der Referenz zur <xref:System.Threading.SpinWait>-API.</span><span class="sxs-lookup"><span data-stu-id="55b44-209">For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.</span></span>

## <a name="see-also"></a><span data-ttu-id="55b44-210">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="55b44-210">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="55b44-211">Threadsichere Sammlungen</span><span class="sxs-lookup"><span data-stu-id="55b44-211">Thread-safe collections</span></span>](../collections/thread-safe/index.md)
- [<span data-ttu-id="55b44-212">Threadingobjekte und -funktionen</span><span class="sxs-lookup"><span data-stu-id="55b44-212">Threading objects and features</span></span>](threading-objects-and-features.md)
