---
title: Auswählen zwischen Klasse und Struktur
description: Erfahren Sie, wie Sie entscheiden, ob Sie einen Typ als Klasse entwerfen oder einen Typ als Struktur entwerfen möchten. Erfahren Sie, wie Verweis Typen und Werttypen in .net unterschiedlich sind.
ms.date: 10/22/2008
helpviewer_keywords:
- class library design guidelines [.NET Framework], structures
- class library design guidelines [.NET Framework], classes
- structures [.NET Framework], vs. classes
- classes [.NET Framework], design guidelines
- type design guidelines, structures
- structures [.NET Framework], design guidelines
- classes [.NET Framework], vs. structures
- type design guidelines, classes
ms.assetid: f8b8ec9b-0ba7-4dea-aadf-a93395cd804f
ms.openlocfilehash: 05ba9abbc9495d927b7f58ebb06f152c0c15772f
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/24/2020
ms.locfileid: "95701249"
---
# <a name="choosing-between-class-and-struct"></a><span data-ttu-id="c2d70-104">Auswählen zwischen Klasse und Struktur</span><span class="sxs-lookup"><span data-stu-id="c2d70-104">Choosing Between Class and Struct</span></span>

<span data-ttu-id="c2d70-105">Eine der grundlegenden Entwurfsentscheidungen jedes Framework-Designers besteht darin, einen Typ als Klasse (einen Verweistyp) oder als Struktur (Werttyp) zu entwerfen.</span><span class="sxs-lookup"><span data-stu-id="c2d70-105">One of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type).</span></span> <span data-ttu-id="c2d70-106">Ein gutes Verständnis der Unterschiede im Verhalten von Verweis Typen und Werttypen ist wichtig für diese Auswahl.</span><span class="sxs-lookup"><span data-stu-id="c2d70-106">Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.</span></span>

 <span data-ttu-id="c2d70-107">Der erste Unterschied zwischen Verweis Typen und Werttypen, die wir in Erwägung gezogen werden, besteht darin, dass Verweis Typen auf dem Heap und der Garbage Collection zugeordnet werden, wohingegen Werttypen entweder auf dem Stapel oder Inline in enthaltenden Typen zugeordnet werden und die Zuordnung aufgehoben wird, wenn der Stapel entladen wird oder wenn deren Zuordnung aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="c2d70-107">The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated.</span></span> <span data-ttu-id="c2d70-108">Daher sind Zuordnungen und Aufhebungen von Werttypen im allgemeinen günstiger als Zuordnungen und Aufhebungen von Verweis Typen.</span><span class="sxs-lookup"><span data-stu-id="c2d70-108">Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</span></span>

 <span data-ttu-id="c2d70-109">Als nächstes werden Arrays von Verweis Typen out-of-Line zugeordnet, was bedeutet, dass die Array Elemente lediglich Verweise auf Instanzen des Verweis Typs sind, die sich auf dem Heap befinden.</span><span class="sxs-lookup"><span data-stu-id="c2d70-109">Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap.</span></span> <span data-ttu-id="c2d70-110">Werttyp Arrays werden Inline zugeordnet, d. h., die Array Elemente sind die tatsächlichen Instanzen des Werttyps.</span><span class="sxs-lookup"><span data-stu-id="c2d70-110">Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type.</span></span> <span data-ttu-id="c2d70-111">Daher sind Zuordnungen und Aufhebungen von Werttyp Arrays weitaus günstiger als Zuordnungen und Aufhebungen von Verweistyp Arrays.</span><span class="sxs-lookup"><span data-stu-id="c2d70-111">Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays.</span></span> <span data-ttu-id="c2d70-112">Außerdem weisen Werttyp Arrays in den meisten Fällen eine viel bessere Lokalität auf.</span><span class="sxs-lookup"><span data-stu-id="c2d70-112">In addition, in a majority of cases value type arrays exhibit much better locality of reference.</span></span>

 <span data-ttu-id="c2d70-113">Der nächste Unterschied bezieht sich auf die Speicherauslastung.</span><span class="sxs-lookup"><span data-stu-id="c2d70-113">The next difference is related to memory usage.</span></span> <span data-ttu-id="c2d70-114">Werttypen werden bei der Umwandlung in einen Verweistyp oder in eine der Schnittstellen, die Sie implementieren, als gekapselt.</span><span class="sxs-lookup"><span data-stu-id="c2d70-114">Value types get boxed when cast to a reference type or one of the interfaces they implement.</span></span> <span data-ttu-id="c2d70-115">Sie werden bei der Umwandlung zurück in den Werttyp Unboxing.</span><span class="sxs-lookup"><span data-stu-id="c2d70-115">They get unboxed when cast back to the value type.</span></span> <span data-ttu-id="c2d70-116">Da es sich bei Feldern um Objekte handelt, die auf dem Heap zugeordnet sind und für die eine Garbage Collection durchgeführt wird, können sich zu viele Boxing-und Unboxing-Objekte negativ auf den Heap, den Garbage Collector und schließlich die Leistung der Anwendung auswirken.</span><span class="sxs-lookup"><span data-stu-id="c2d70-116">Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application.</span></span>  <span data-ttu-id="c2d70-117">Im Gegensatz dazu kommt es nicht zu einem solchen Boxing, wenn Verweis Typen umgewandelt werden.</span><span class="sxs-lookup"><span data-stu-id="c2d70-117">In contrast, no such boxing occurs as reference types are cast.</span></span> <span data-ttu-id="c2d70-118">(Weitere Informationen finden Sie unter [Boxing und Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span><span class="sxs-lookup"><span data-stu-id="c2d70-118">(For more information, see [Boxing and Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span></span>

 <span data-ttu-id="c2d70-119">Im nächsten Schritt kopieren Verweistyp Zuweisungen den Verweis, während Werttyp Zuweisungen den gesamten Wert kopieren.</span><span class="sxs-lookup"><span data-stu-id="c2d70-119">Next, reference type assignments copy the reference, whereas value type assignments copy the entire value.</span></span> <span data-ttu-id="c2d70-120">Daher sind Zuweisungen von großen Verweis Typen günstiger als Zuweisungen von großen Werttypen.</span><span class="sxs-lookup"><span data-stu-id="c2d70-120">Therefore, assignments of large reference types are cheaper than assignments of large value types.</span></span>

 <span data-ttu-id="c2d70-121">Schließlich werden Verweis Typen als Verweis übermittelt, wohingegen Werttypen als Wert übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="c2d70-121">Finally, reference types are passed by reference, whereas value types are passed by value.</span></span> <span data-ttu-id="c2d70-122">Änderungen an einer Instanz eines Verweis Typs wirken sich auf alle Verweise aus, die auf die-Instanz verweisen.</span><span class="sxs-lookup"><span data-stu-id="c2d70-122">Changes to an instance of a reference type affect all references pointing to the instance.</span></span> <span data-ttu-id="c2d70-123">Werttyp Instanzen werden kopiert, wenn Sie als Wert übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="c2d70-123">Value type instances are copied when they are passed by value.</span></span> <span data-ttu-id="c2d70-124">Wenn eine Instanz eines Werttyps geändert wird, wirkt sich dies natürlich nicht auf seine Kopien aus.</span><span class="sxs-lookup"><span data-stu-id="c2d70-124">When an instance of a value type is changed, it of course does not affect any of its copies.</span></span> <span data-ttu-id="c2d70-125">Da die Kopien nicht explizit vom Benutzer erstellt werden, sondern implizit erstellt werden, wenn Argumente übermittelt werden oder Rückgabewerte zurückgegeben werden, können Werttypen, die geändert werden können, für viele Benutzer verwirrend sein.</span><span class="sxs-lookup"><span data-stu-id="c2d70-125">Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users.</span></span> <span data-ttu-id="c2d70-126">Daher sollten Werttypen unveränderlich sein.</span><span class="sxs-lookup"><span data-stu-id="c2d70-126">Therefore, value types should be immutable.</span></span>

 <span data-ttu-id="c2d70-127">Als Faustregel gilt: die Mehrzahl der Typen in einem Framework sollten Klassen sein.</span><span class="sxs-lookup"><span data-stu-id="c2d70-127">As a rule of thumb, the majority of types in a framework should be classes.</span></span> <span data-ttu-id="c2d70-128">Es gibt jedoch einige Situationen, in denen die Merkmale eines Werttyps die Verwendung von Strukturen erleichtern.</span><span class="sxs-lookup"><span data-stu-id="c2d70-128">There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.</span></span>

 <span data-ttu-id="c2d70-129">✔️ sollten eine Struktur anstelle einer Klasse definieren, wenn Instanzen des Typs klein und häufig kurzlebig sind oder häufig in andere Objekte eingebettet sind.</span><span class="sxs-lookup"><span data-stu-id="c2d70-129">✔️ CONSIDER defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.</span></span>

 <span data-ttu-id="c2d70-130">❌ Vermeiden Sie die Definition einer Struktur, es sei denn, der Typ hat alle der folgenden Eigenschaften:</span><span class="sxs-lookup"><span data-stu-id="c2d70-130">❌ AVOID defining a struct unless the type has all of the following characteristics:</span></span>

- <span data-ttu-id="c2d70-131">Sie stellt logisch einen einzelnen Wert dar, ähnlich wie primitive Typen ( `int` , `double` usw.).</span><span class="sxs-lookup"><span data-stu-id="c2d70-131">It logically represents a single value, similar to primitive types (`int`, `double`, etc.).</span></span>

- <span data-ttu-id="c2d70-132">Sie verfügt über eine instanzgröße von weniger als 16 Bytes.</span><span class="sxs-lookup"><span data-stu-id="c2d70-132">It has an instance size under 16 bytes.</span></span>

- <span data-ttu-id="c2d70-133">Er ist unveränderlich.</span><span class="sxs-lookup"><span data-stu-id="c2d70-133">It is immutable.</span></span>

- <span data-ttu-id="c2d70-134">Er muss nicht häufig geachtelt werden.</span><span class="sxs-lookup"><span data-stu-id="c2d70-134">It will not have to be boxed frequently.</span></span>

 <span data-ttu-id="c2d70-135">In allen anderen Fällen sollten Sie die Typen als Klassen definieren.</span><span class="sxs-lookup"><span data-stu-id="c2d70-135">In all other cases, you should define your types as classes.</span></span>

 <span data-ttu-id="c2d70-136">*Teile © 2005, 2009 Microsoft Corporation. Alle Rechte vorbehalten.*</span><span class="sxs-lookup"><span data-stu-id="c2d70-136">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>

 <span data-ttu-id="c2d70-137">*Nachdruck mit Genehmigung von Pearson Education, Inc aus [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) von Krzysztof Cwalina und Brad Abrams, veröffentlicht am 22. Oktober 2008 durch Addison-Wesley Professional als Teil der Microsoft Windows Development Series.*</span><span class="sxs-lookup"><span data-stu-id="c2d70-137">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>

## <a name="see-also"></a><span data-ttu-id="c2d70-138">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="c2d70-138">See also</span></span>

- [<span data-ttu-id="c2d70-139">Typentwurfs Richtlinien</span><span class="sxs-lookup"><span data-stu-id="c2d70-139">Type Design Guidelines</span></span>](type.md)
- [<span data-ttu-id="c2d70-140">Framework-Entwurfs Richtlinien</span><span class="sxs-lookup"><span data-stu-id="c2d70-140">Framework Design Guidelines</span></span>](index.md)
