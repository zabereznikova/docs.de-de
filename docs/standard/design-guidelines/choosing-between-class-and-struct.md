---
title: Auswählen zwischen Klasse und Struktur
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- class library design guidelines [.NET Framework], structures
- class library design guidelines [.NET Framework], classes
- structures [.NET Framework], vs. classes
- classes [.NET Framework], design guidelines
- type design guidelines, structures
- structures [.NET Framework], design guidelines
- classes [.NET Framework], vs. structures
- type design guidelines, classes
ms.assetid: f8b8ec9b-0ba7-4dea-aadf-a93395cd804f
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 7590d5628f4951a8c7c2199f0e954007ed9fa962
ms.sourcegitcommit: b5cd9d5d3b75a5537fc9ad8a3f085f0bb1845ee0
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/07/2018
ms.locfileid: "50757425"
---
# <a name="choosing-between-class-and-struct"></a><span data-ttu-id="c6cb5-102">Auswählen zwischen Klasse und Struktur</span><span class="sxs-lookup"><span data-stu-id="c6cb5-102">Choosing Between Class and Struct</span></span>
<span data-ttu-id="c6cb5-103">Eine der grundlegenden entwurfsentscheidungen, die alle Framework-Designer zeigt ist, ob einen Typ als eine Klasse (Referenztyp) oder als eine Struktur (Werttyp) entwerfen.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-103">One of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type).</span></span> <span data-ttu-id="c6cb5-104">Die Kenntnis der Unterschiede im Verhalten von Verweistypen und Werttypen ist in dieser Auswahl entscheidend.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-104">Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.</span></span>  
  
 <span data-ttu-id="c6cb5-105">Das erste der Unterschied zwischen Verweistypen und Werttypen, die wir berücksichtigen werden, besteht darin, dass Verweistypen sind, auf dem Heap reserviert und die Garbage Collection, während bei Werttypen werden entweder auf dem Stapel zugeordnet oder Inline im mit Typen und aufgehoben, wenn des Stapels Entlädt oder bei ihrem enthaltenden Typ Ruft die Zuordnung aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-105">The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated.</span></span> <span data-ttu-id="c6cb5-106">Speicherzuordnungen und Aufhebungen von Werttypen werden daher im Allgemeinen günstiger sein als die speicherzuordnungen und Aufhebungen von Verweistypen sind.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-106">Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</span></span>  
  
 <span data-ttu-id="c6cb5-107">Als Nächstes Arrays von Verweisen auf Typen werden Out-of-Line, d. h. das Array die Elemente sind nur die Verweise auf Instanzen des Referenztyps auf dem Heap zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-107">Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap.</span></span> <span data-ttu-id="c6cb5-108">Wert Typ Arrays werden Inline, was bedeutet, dass die Elemente des Arrays, die eigentlichen Instanzen des Werttyps sind zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-108">Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type.</span></span> <span data-ttu-id="c6cb5-109">Aus diesem Grund werden speicherzuordnungen und Aufhebungen von Typ Wertarrays wesentlich günstiger als speicherzuordnungen und Aufhebungen von Verweistyparrays.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-109">Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays.</span></span> <span data-ttu-id="c6cb5-110">Darüber hinaus eine Wertarrays-Typ in der Mehrheit der Fälle viel bessere Positionierung von Verweisen auf.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-110">In addition, in a majority of cases value type arrays exhibit much better locality of reference.</span></span>  
  
 <span data-ttu-id="c6cb5-111">Nächste Unterschied bezieht sich auf die speicherauslastung.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-111">The next difference is related to memory usage.</span></span> <span data-ttu-id="c6cb5-112">Werttypen erste geschachtelt beim Konvertieren in ein Verweistyp oder eine der Schnittstellen, die sie implementieren.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-112">Value types get boxed when cast to a reference type or one of the interfaces they implement.</span></span> <span data-ttu-id="c6cb5-113">Sie erhalten nicht geschachtelte beim Konvertieren in den Werttyp zurück.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-113">They get unboxed when cast back to the value type.</span></span> <span data-ttu-id="c6cb5-114">Da Felder Objekte sind, die auf dem Heap reserviert sind und Garbage Collection zu viel Boxing und unboxing können sich negativ auf dem Heap der Garbage Collector und letztlich die Leistung der Anwendung haben.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-114">Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application.</span></span>  <span data-ttu-id="c6cb5-115">Im Gegensatz dazu tritt auf, keine solche Boxing-Konvertierung, da Verweistypen umgewandelt werden.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-115">In contrast, no such boxing occurs as reference types are cast.</span></span> <span data-ttu-id="c6cb5-116">(Weitere Informationen finden Sie unter [Boxing und Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span><span class="sxs-lookup"><span data-stu-id="c6cb5-116">(For more information, see [Boxing and Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span></span>
  
 <span data-ttu-id="c6cb5-117">Kopieren Sie anschließend den Verweis-Typ-Zuweisungen die Referenz während der Wert bei typzuweisungen kopieren Sie den gesamten Wert.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-117">Next, reference type assignments copy the reference, whereas value type assignments copy the entire value.</span></span> <span data-ttu-id="c6cb5-118">Aus diesem Grund sind Zuweisungen von großen Verweistypen günstiger als Zuweisungen von Typen mit umfangreichen Werten.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-118">Therefore, assignments of large reference types are cheaper than assignments of large value types.</span></span>  
  
 <span data-ttu-id="c6cb5-119">Schließlich werden die Verweistypen als Verweis übergeben, während Werttypen als Wert übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-119">Finally, reference types are passed by reference, whereas value types are passed by value.</span></span> <span data-ttu-id="c6cb5-120">Änderungen an einer Instanz eines Referenztyps Auswirkungen auf alle Verweise auf die Instanz verweist.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-120">Changes to an instance of a reference type affect all references pointing to the instance.</span></span> <span data-ttu-id="c6cb5-121">Wert von Typinstanzen werden kopiert, wenn sie nach Wert übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-121">Value type instances are copied when they are passed by value.</span></span> <span data-ttu-id="c6cb5-122">Wenn eine Instanz eines Werttyps geändert wird, wirkt es natürlich seine Kopien sich nicht.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-122">When an instance of a value type is changed, it of course does not affect any of its copies.</span></span> <span data-ttu-id="c6cb5-123">Da die Kopien werden nicht explizit vom Benutzer erstellt, aber es werden implizit erstellt werden, wenn Argumente übergeben oder zurückgegeben wird, dass die Werte zurückgegeben werden, können Werttypen, die geändert werden können, für viele Benutzer verwirrend sein.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-123">Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users.</span></span> <span data-ttu-id="c6cb5-124">Aus diesem Grund sollten Werttypen unveränderlich sein.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-124">Therefore, value types should be immutable.</span></span>  
  
 <span data-ttu-id="c6cb5-125">Als Faustregel gilt sollten die meisten Typen in einem Framework Klassen sein.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-125">As a rule of thumb, the majority of types in a framework should be classes.</span></span> <span data-ttu-id="c6cb5-126">Es gibt jedoch einige Situationen, in denen die Merkmale eines Werttyps besser geeignet, verwenden Sie Strukturen zu erleichtern.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-126">There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.</span></span>  
  
 <span data-ttu-id="c6cb5-127">**✓ CONSIDER** eine Struktur anstelle einer Klasse definieren, wenn Instanzen des Typs klein und im Allgemeinen kurzlebig sind oder in anderen Objekten eingebettet sind.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-127">**✓ CONSIDER** defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.</span></span>  
  
 <span data-ttu-id="c6cb5-128">**X AVOID** eine Struktur definieren, es sei denn, der Typ aller folgende Merkmale aufweist:</span><span class="sxs-lookup"><span data-stu-id="c6cb5-128">**X AVOID** defining a struct unless the type has all of the following characteristics:</span></span>  
  
-   <span data-ttu-id="c6cb5-129">Es logisch einen einzelnen Wert, der ähnlich wie primitive Typen darstellt (`int`, `double`usw..).</span><span class="sxs-lookup"><span data-stu-id="c6cb5-129">It logically represents a single value, similar to primitive types (`int`, `double`, etc.).</span></span>  
  
-   <span data-ttu-id="c6cb5-130">Es hat eine Größe der Instanz unter 16 Bytes.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-130">It has an instance size under 16 bytes.</span></span>  
  
-   <span data-ttu-id="c6cb5-131">Er ist unveränderlich.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-131">It is immutable.</span></span>  
  
-   <span data-ttu-id="c6cb5-132">Es wird keine häufig geschachtelt werden.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-132">It will not have to be boxed frequently.</span></span>  
  
 <span data-ttu-id="c6cb5-133">In allen anderen Fällen sollten Sie die Typen als Klassen definieren.</span><span class="sxs-lookup"><span data-stu-id="c6cb5-133">In all other cases, you should define your types as classes.</span></span>  
  
 <span data-ttu-id="c6cb5-134">*Teile ©2005, 2009 Microsoft Corporation. Alle Rechte vorbehalten.*</span><span class="sxs-lookup"><span data-stu-id="c6cb5-134">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>  
  
 <span data-ttu-id="c6cb5-135">*Nachdruck mit Genehmigung von Pearson Education, Inc aus [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) von Krzysztof Cwalina und Brad Abrams, veröffentlicht am 22. Oktober 2008 durch Addison-Wesley Professional als Teil der Microsoft Windows Development Series.*</span><span class="sxs-lookup"><span data-stu-id="c6cb5-135">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c6cb5-136">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="c6cb5-136">See also</span></span>

- [<span data-ttu-id="c6cb5-137">Richtlinien für den Entwurf von Typen</span><span class="sxs-lookup"><span data-stu-id="c6cb5-137">Type Design Guidelines</span></span>](../../../docs/standard/design-guidelines/type.md)  
- [<span data-ttu-id="c6cb5-138">Frameworkentwurfsrichtlinien</span><span class="sxs-lookup"><span data-stu-id="c6cb5-138">Framework Design Guidelines</span></span>](../../../docs/standard/design-guidelines/index.md)
