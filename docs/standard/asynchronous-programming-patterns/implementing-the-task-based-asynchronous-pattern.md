---
title: Implementieren des aufgabenbasierten asynchronen Entwurfsmusters
description: In diesem Artikel wird erläutert, wie das aufgabenbasierte asynchrone Muster implementiert wird. Sie können damit rechnergebundene und E/A-gebundene asynchrone Vorgänge implementieren.
ms.date: 06/14/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- asynchronous design patterns, .NET
- TAP, .NET support for
- Task-based Asynchronous Pattern, .NET support for
- .NET, asynchronous design patterns
ms.assetid: fab6bd41-91bd-44ad-86f9-d8319988aa78
ms.openlocfilehash: 7613d93e1ca2ac9594759434966745a238ba166e
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/24/2020
ms.locfileid: "95726729"
---
# <a name="implementing-the-task-based-asynchronous-pattern"></a><span data-ttu-id="a8107-104">Implementieren des aufgabenbasierten asynchronen Entwurfsmusters</span><span class="sxs-lookup"><span data-stu-id="a8107-104">Implementing the Task-based Asynchronous Pattern</span></span>

<span data-ttu-id="a8107-105">Sie können das aufgabenbasierte asynchrone Muster (Task-based Asynchronous Pattern, TAP) auf drei Arten implementieren: mit C# und den Visual Basic-Compilern in Visual Studio, manuell oder mit einer Kombination von Compilermethoden und manuellen Methoden.</span><span class="sxs-lookup"><span data-stu-id="a8107-105">You can implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span> <span data-ttu-id="a8107-106">In den folgenden Abschnitten wird jede dieser Methoden ausführlich erörtert.</span><span class="sxs-lookup"><span data-stu-id="a8107-106">The following sections discuss each method in detail.</span></span> <span data-ttu-id="a8107-107">Mit dem TAP-Muster können sowohl rechnergebundene als auch E/A-gebundene asynchrone Vorgänge implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="a8107-107">You can use the TAP pattern to implement both compute-bound and I/O-bound asynchronous operations.</span></span> <span data-ttu-id="a8107-108">Im Abschnitt [Workloads](#workloads) werden die einzelnen Vorgangstypen erläutert.</span><span class="sxs-lookup"><span data-stu-id="a8107-108">The [Workloads](#workloads) section discusses each type of operation.</span></span>

## <a name="generating-tap-methods"></a><span data-ttu-id="a8107-109">Generieren von TAP-Methoden</span><span class="sxs-lookup"><span data-stu-id="a8107-109">Generating TAP methods</span></span>

### <a name="using-the-compilers"></a><span data-ttu-id="a8107-110">Verwenden der Compiler</span><span class="sxs-lookup"><span data-stu-id="a8107-110">Using the compilers</span></span>

<span data-ttu-id="a8107-111">Ab .NET Framework 4.5 gilt jede Methode, die mit dem Schlüsselwort `async` (`Async` in Visual Basic) attributiert ist, als asynchrone Methode, und die C#- und Visual Basic-Compiler führen die erforderlichen Transformationen aus, um die Methode mithilfe der TAP-Methode als asynchrone Methode zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="a8107-111">Starting with .NET Framework 4.5, any method that is attributed with the `async` keyword (`Async` in Visual Basic) is considered an asynchronous method, and the C# and Visual Basic compilers perform the necessary transformations to implement the method asynchronously by using TAP.</span></span> <span data-ttu-id="a8107-112">Eine asynchrone Methode sollte entweder <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>- oder ein <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>-Objekt zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="a8107-112">An asynchronous method should return either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="a8107-113">Im letzteren Fall sollte der Text der Funktion einen `TResult`-Typ zurückgeben, und der Compiler stellt sicher, dass dieses Ergebnis durch das resultierende Taskobjekt verfügbar gemacht wird.</span><span class="sxs-lookup"><span data-stu-id="a8107-113">For the latter, the body of the function should return a `TResult`, and the compiler ensures that this result is made available through the resulting task object.</span></span> <span data-ttu-id="a8107-114">Entsprechend werden alle Ausnahmen, die im Text der Methode nicht behandelt werden, zur Ausgabeaufgabe gemarshallt und führen dazu, dass die resultierende Aufgabe im Zustand <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> endet.</span><span class="sxs-lookup"><span data-stu-id="a8107-114">Similarly, any exceptions that go unhandled within the body of the method are marshaled to the output task and cause the resulting task to end in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state.</span></span> <span data-ttu-id="a8107-115">Die Ausnahme dieser Regel ist, wenn eine <xref:System.OperationCanceledException> (oder abgeleitete Typen) nicht behandelt wird. In diesem Fall enden die resultierenden Aufgaben im Zustand <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a8107-115">The exception to this rule is when an <xref:System.OperationCanceledException> (or derived type) goes unhandled, in which case the resulting task ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>

### <a name="generating-tap-methods-manually"></a><span data-ttu-id="a8107-116">Manuelles Generieren von TAP-Methoden</span><span class="sxs-lookup"><span data-stu-id="a8107-116">Generating TAP methods manually</span></span>

<span data-ttu-id="a8107-117">Sie können das TAP-Muster manuell implementieren, um eine bessere Kontrolle über die Implementierung zu haben.</span><span class="sxs-lookup"><span data-stu-id="a8107-117">You may implement the TAP pattern manually for better control over implementation.</span></span> <span data-ttu-id="a8107-118">Der Compiler nutzt den öffentlichen Oberflächenbereich, der über den <xref:System.Threading.Tasks?displayProperty=nameWithType>-Namespace verfügbar gemacht wird, und unterstützende Typen im <xref:System.Runtime.CompilerServices?displayProperty=nameWithType>-Namespace.</span><span class="sxs-lookup"><span data-stu-id="a8107-118">The compiler relies on the public surface area exposed from the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace and supporting types in the <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="a8107-119">Wenn Sie das TAP selbst implementieren möchten, erstellen Sie ein <xref:System.Threading.Tasks.TaskCompletionSource%601>-Objekt, führen Sie den asynchronen Vorgang aus, und wenn er abgeschlossen wurde, rufen Sie die Methode <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> oder <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> oder die `Try`-Version einer dieser Methoden auf.</span><span class="sxs-lookup"><span data-stu-id="a8107-119">To implement the TAP yourself, you create a <xref:System.Threading.Tasks.TaskCompletionSource%601> object, perform the asynchronous operation, and when it completes, call the <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, or <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> method, or the `Try` version of one of these methods.</span></span> <span data-ttu-id="a8107-120">Wenn Sie eine TAP-Methode manuell implementieren, müssen Sie sicherstellen, dass die resultierende Aufgabe abgeschlossen wird, wenn der dargestellte asynchrone Vorgang abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="a8107-120">When you implement a TAP method manually, you must complete the resulting task when the represented asynchronous operation completes.</span></span> <span data-ttu-id="a8107-121">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="a8107-121">For example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#1)]
[!code-vb[Conceptual.TAP_Patterns#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#1)]

### <a name="hybrid-approach"></a><span data-ttu-id="a8107-122">Hybrider Ansatz</span><span class="sxs-lookup"><span data-stu-id="a8107-122">Hybrid approach</span></span>

 <span data-ttu-id="a8107-123">Möglicherweise finden Sie es sinnvoll, das TAP-Muster manuell zu implementieren, die Kernlogik für die Implementierung jedoch an den Compiler zu delegieren.</span><span class="sxs-lookup"><span data-stu-id="a8107-123">You may find it useful to implement the TAP pattern manually but to delegate the core logic for the implementation to the compiler.</span></span> <span data-ttu-id="a8107-124">Sie sollen den hybriden Ansatz beispielsweise verwenden, wenn Sie Argumente außerhalb einer vom Compiler generierten asynchronen Methode überprüfen möchten, damit die Ausnahmen zum direkten Aufrufer der Methode überwechseln können, anstatt durch das Objekt <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> verfügbar gemacht zu werden:</span><span class="sxs-lookup"><span data-stu-id="a8107-124">For example, you may want to use the hybrid approach when you want to verify arguments outside a compiler-generated asynchronous method so that exceptions can escape to the method's direct caller rather than being exposed through the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object:</span></span>

 [!code-csharp[Conceptual.TAP_Patterns#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#2)]
 [!code-vb[Conceptual.TAP_Patterns#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#2)]

 <span data-ttu-id="a8107-125">Eine solche Delegierung ist auch sinnvoll, wenn Sie eine Beschleunigungsoptimierung implementieren und eine zwischengespeicherte Aufgabe zurückgeben möchten.</span><span class="sxs-lookup"><span data-stu-id="a8107-125">Another case where such delegation is useful is when you're implementing fast-path optimization and want to return a cached task.</span></span>

## <a name="workloads"></a><span data-ttu-id="a8107-126">Arbeitslasten</span><span class="sxs-lookup"><span data-stu-id="a8107-126">Workloads</span></span>

<span data-ttu-id="a8107-127">Sowohl rechnergebundene als auch E/A-gebundene asynchrone Vorgänge können als TAP-Methoden implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="a8107-127">You may implement both compute-bound and I/O-bound asynchronous operations as TAP methods.</span></span> <span data-ttu-id="a8107-128">Wenn sie jedoch aus einer Bibliothek öffentlich verfügbar gemacht werden, sollten TAP-Methoden nur für Arbeitslasten bereitgestellt werden, die E/A-gebundene Vorgänge enthalten (sie können auch Berechnungen enthalten, jedoch nicht ausschließlich).</span><span class="sxs-lookup"><span data-stu-id="a8107-128">However, when TAP methods are exposed publicly from a library, they should be provided only for workloads that involve I/O-bound operations (they may also involve computation, but should not be purely computational).</span></span> <span data-ttu-id="a8107-129">Wenn eine Methode ausschließlich rechnergebunden ist, sollte sie nur als synchrone Implementierung verfügbar gemacht werden.</span><span class="sxs-lookup"><span data-stu-id="a8107-129">If a method is purely compute-bound, it should be exposed only as a synchronous implementation.</span></span> <span data-ttu-id="a8107-130">Der verwendende Code kann dann entscheiden, ob ein Aufruf dieser synchronen Methode durch einen Task umschlossen werden soll, um die Arbeit in einen anderen Thread auszulagern oder Parallelität zu erreichen.</span><span class="sxs-lookup"><span data-stu-id="a8107-130">The code that consumes it may then choose whether to wrap an invocation of that synchronous method into a task to offload the work to another thread or to achieve parallelism.</span></span> <span data-ttu-id="a8107-131">Wenn eine Methode dagegen E/A-gebunden ist, sollte sie ausschließlich als asynchrone Implementierung verfügbar gemacht werden.</span><span class="sxs-lookup"><span data-stu-id="a8107-131">And if a method is I/O-bound, it should be exposed only as an asynchronous implementation.</span></span>

### <a name="compute-bound-tasks"></a><span data-ttu-id="a8107-132">Rechnergebundene Tasks</span><span class="sxs-lookup"><span data-stu-id="a8107-132">Compute-bound tasks</span></span>

<span data-ttu-id="a8107-133">Die <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>-Klasse ist perfekt zur Darstellung von rechenintensiven Vorgängen geeignet.</span><span class="sxs-lookup"><span data-stu-id="a8107-133">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class is ideally suited for representing computationally intensive operations.</span></span> <span data-ttu-id="a8107-134">Standardmäßig nutzt sie spezielle Unterstützung innerhalb der <xref:System.Threading.ThreadPool>-Klasse, um die effiziente Ausführung bereitzustellen, und bietet auch bedeutende Kontrolle darüber, wann, wo und wie asynchrone Berechnungen durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="a8107-134">By default, it takes advantage of special support within the <xref:System.Threading.ThreadPool> class to provide efficient execution, and it also provides significant control over when, where, and how asynchronous computations execute.</span></span>

<span data-ttu-id="a8107-135">Sie können rechnergebundene Aufgaben auf die folgenden Arten generieren:</span><span class="sxs-lookup"><span data-stu-id="a8107-135">You can generate compute-bound tasks in the following ways:</span></span>

- <span data-ttu-id="a8107-136">Verwenden Sie in .NET Framework 4.5 und höheren Versionen (einschließlich .NET Core und .NET 5 und höher) die statische Methode <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> als Verknüpfung zu <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a8107-136">In .NET Framework 4.5 and later versions (including .NET Core and .NET 5+), use the static <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method as a shortcut to <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a8107-137">Sie können <xref:System.Threading.Tasks.Task.Run%2A> verwenden, um problemlos eine rechnergebundene Aufgabe zu starten, die auf den Threadpool abzielt.</span><span class="sxs-lookup"><span data-stu-id="a8107-137">You may use <xref:System.Threading.Tasks.Task.Run%2A> to easily launch a compute-bound task that targets the thread pool.</span></span> <span data-ttu-id="a8107-138">Dies ist der bevorzugte Mechanismus für das Starten eines computegebundenen Tasks.</span><span class="sxs-lookup"><span data-stu-id="a8107-138">This is the preferred mechanism for launching a compute-bound task.</span></span> <span data-ttu-id="a8107-139">Verwenden Sie `StartNew` nur dann direkt, wenn Sie eine präzisere Kontrolle über den Task haben möchten.</span><span class="sxs-lookup"><span data-stu-id="a8107-139">Use `StartNew` directly only when you want more fine-grained control over the task.</span></span>

- <span data-ttu-id="a8107-140">Verwenden Sie in .NET Framework 4 die <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>-Methode, die akzeptiert, dass ein Delegat (in der Regel ein <xref:System.Action%601>- oder ein <xref:System.Func%601>-Delegat) asynchron ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="a8107-140">In .NET Framework 4, use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, which accepts a delegate (typically an <xref:System.Action%601> or a <xref:System.Func%601>) to be executed asynchronously.</span></span> <span data-ttu-id="a8107-141">Wenn Sie einen <xref:System.Action%601>-Delegaten bereitstellen, gibt die Methode ein <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>-Objekt zurück, das die asynchrone Ausführung dieses Delegaten darstellt.</span><span class="sxs-lookup"><span data-stu-id="a8107-141">If you provide an <xref:System.Action%601> delegate, the method returns a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object that represents the asynchronous execution of that delegate.</span></span> <span data-ttu-id="a8107-142">Wenn Sie einen <xref:System.Func%601>-Delegaten bereitstellen, gibt die Methode ein <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>-Objekt zurück.</span><span class="sxs-lookup"><span data-stu-id="a8107-142">If you provide a <xref:System.Func%601> delegate, the method returns a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="a8107-143">Überladungen der <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>-Methode akzeptieren ein Abbruchtoken (<xref:System.Threading.CancellationToken>), Aufgabenerstellungsoptionen (<xref:System.Threading.Tasks.TaskCreationOptions>) und einen Aufgabenplaner (<xref:System.Threading.Tasks.TaskScheduler>), die alle eine präzisere Steuerung der Planung und Ausführung der Aufgabe ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="a8107-143">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method accept a cancellation token (<xref:System.Threading.CancellationToken>), task creation options (<xref:System.Threading.Tasks.TaskCreationOptions>), and a task scheduler (<xref:System.Threading.Tasks.TaskScheduler>), all of which provide fine-grained control over the scheduling and execution of the task.</span></span> <span data-ttu-id="a8107-144">Eine Factoryinstanz für den aktuellen Aufgabenplaner ist als statische Eigenschaft (<xref:System.Threading.Tasks.Task.Factory%2A>) der <xref:System.Threading.Tasks.Task>-Klasse verfügbar, z. B. `Task.Factory.StartNew(…)`.</span><span class="sxs-lookup"><span data-stu-id="a8107-144">A factory instance that targets the current task scheduler is available as a static property (<xref:System.Threading.Tasks.Task.Factory%2A>) of the <xref:System.Threading.Tasks.Task> class; for example: `Task.Factory.StartNew(…)`.</span></span>

- <span data-ttu-id="a8107-145">Verwenden Sie die Konstruktoren des Typs `Task` oder der Methode `Start`, wenn Sie die Aufgabe separat generieren und planen möchten.</span><span class="sxs-lookup"><span data-stu-id="a8107-145">Use the constructors of the `Task` type or the `Start` method if you want to generate and schedule the task separately.</span></span> <span data-ttu-id="a8107-146">Öffentliche Methoden dürfen nur Aufgaben zurückgeben, die bereits gestartet wurden.</span><span class="sxs-lookup"><span data-stu-id="a8107-146">Public methods must only return tasks that have already been started.</span></span>

- <span data-ttu-id="a8107-147">Verwenden Sie die Überladungen der <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType>-Methode.</span><span class="sxs-lookup"><span data-stu-id="a8107-147">Use the overloads of the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a8107-148">Diese Methode erstellt eine neue Aufgabe, die geplant wird, wenn eine andere Aufgabe abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="a8107-148">This method creates a new task that is scheduled when another task completes.</span></span> <span data-ttu-id="a8107-149">Einige der <xref:System.Threading.Tasks.Task.ContinueWith%2A>-Überladungen akzeptieren ein Abbruchtoken, Fortsetzungsmöglichkeiten und einen Aufgabenplaner für eine bessere Steuerung der Planung und Ausführung der Fortsetzungsaufgabe.</span><span class="sxs-lookup"><span data-stu-id="a8107-149">Some of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> overloads accept a cancellation token, continuation options, and a task scheduler for better control over the scheduling and execution of the continuation task.</span></span>

- <span data-ttu-id="a8107-150">Verwenden Sie die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType>-Methode und die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType>-Methode.</span><span class="sxs-lookup"><span data-stu-id="a8107-150">Use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="a8107-151">Diese Methoden erstellen eine neue Aufgabe, die geplant wird, wenn eine oder alle Aufgaben in einem bereitgestellten Satz von Aufgaben abgeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="a8107-151">These methods create a new task that is scheduled when all or any of a supplied set of tasks completes.</span></span> <span data-ttu-id="a8107-152">Außerdem stellen diese Methoden Überladungen bereit, um die Planung und die Ausführung dieser Tasks zu steuern.</span><span class="sxs-lookup"><span data-stu-id="a8107-152">These methods also provide overloads to control the scheduling and execution of these tasks.</span></span>

<span data-ttu-id="a8107-153">In rechnergebundenen Aufgaben kann das System die Ausführung einer geplanten Aufgabe verhindern, wenn es vor Start der Aufgabe eine Abbruchanforderung empfängt.</span><span class="sxs-lookup"><span data-stu-id="a8107-153">In compute-bound tasks, the system can prevent the execution of a scheduled task if it receives a cancellation request before it starts running the task.</span></span> <span data-ttu-id="a8107-154">Wenn Sie also ein Abbruchtoken (<xref:System.Threading.CancellationToken>- Objekt) bereitstellen, können Sie dieses Token an den asynchronen Code übergeben, der das Token überwacht.</span><span class="sxs-lookup"><span data-stu-id="a8107-154">As such, if you provide a cancellation token (<xref:System.Threading.CancellationToken> object), you can pass that token to the asynchronous code that monitors the token.</span></span> <span data-ttu-id="a8107-155">Sie können das Token auch an eine der zuvor erwähnten Methoden wie `StartNew` oder `Run` bereitstellen, damit die Laufzeit der `Task` auch das Token überwachen kann.</span><span class="sxs-lookup"><span data-stu-id="a8107-155">You can also provide the token to one of the previously mentioned methods such as `StartNew` or `Run` so that the `Task` runtime may also monitor the token.</span></span>

<span data-ttu-id="a8107-156">Betrachten Sie beispielsweise eine asynchrone Methode, die ein Bild rendert.</span><span class="sxs-lookup"><span data-stu-id="a8107-156">For example, consider an asynchronous method that renders an image.</span></span> <span data-ttu-id="a8107-157">Der Text der Aufgabe kann das Abbruchtoken abrufen, sodass während des Renderns die Ausführung des Codes vorzeitig beendet werden kann, falls eine Abbruchanforderung empfangen wird.</span><span class="sxs-lookup"><span data-stu-id="a8107-157">The body of the task can poll the cancellation token so that the code may exit early if a cancellation request arrives during rendering.</span></span> <span data-ttu-id="a8107-158">Zudem sollten Sie den Renderingvorgang verhindern, wenn die Abbruchsanforderung eintrifft, bevor das Rendering beginnt:</span><span class="sxs-lookup"><span data-stu-id="a8107-158">In addition, if the cancellation request arrives before rendering starts, you'll want to prevent the rendering operation:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#3)]
[!code-vb[Conceptual.TAP_Patterns#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#3)]

<span data-ttu-id="a8107-159">Rechnergebundene Aufgaben werden im Zustand <xref:System.Threading.Tasks.TaskStatus.Canceled> beendet, wenn mindestens eine der folgenden Bedingungen erfüllt ist:</span><span class="sxs-lookup"><span data-stu-id="a8107-159">Compute-bound tasks end in a <xref:System.Threading.Tasks.TaskStatus.Canceled> state if at least one of the following conditions is true:</span></span>

- <span data-ttu-id="a8107-160">Eine Abbruchanforderung geht über das <xref:System.Threading.CancellationToken>-Objekt ein, das als Argument an die Erstellungsmethode bereitgestellt wird (beispielsweise, `StartNew` oder `Run`), bevor die Aufgabe zum Zustand <xref:System.Threading.Tasks.TaskStatus.Running> übergeht.</span><span class="sxs-lookup"><span data-stu-id="a8107-160">A cancellation request arrives through the <xref:System.Threading.CancellationToken> object, which is provided as an argument to the creation method (for example, `StartNew` or `Run`) before the task transitions to the <xref:System.Threading.Tasks.TaskStatus.Running> state.</span></span>

- <span data-ttu-id="a8107-161">Eine <xref:System.OperationCanceledException>-Ausnahme wird im Text einer solchen Aufgabe nicht behandelt, diese Ausnahme enthält das gleiche <xref:System.Threading.CancellationToken>, das an die Aufgabe übergeben wird und dieses Token stellt dar, dass der Abbruch angefordert wird.</span><span class="sxs-lookup"><span data-stu-id="a8107-161">An <xref:System.OperationCanceledException> exception goes unhandled within the body of such a task, that exception contains the same <xref:System.Threading.CancellationToken> that is passed to the task, and that token shows that cancellation is requested.</span></span>

<span data-ttu-id="a8107-162">Wenn im Text der Aufgabe eine weitere Ausnahme nicht behandelt wird, wird diese im Zustand <xref:System.Threading.Tasks.TaskStatus.Faulted> beendet, und jeder Versuch, auf die Aufgabe zu warten oder auf ihr Ergebnis zuzugreifen, löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="a8107-162">If another exception goes unhandled within the body of the task, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, and any attempts to wait on the task or access its result causes an exception to be thrown.</span></span>

### <a name="io-bound-tasks"></a><span data-ttu-id="a8107-163">E/A-gebundene Tasks</span><span class="sxs-lookup"><span data-stu-id="a8107-163">I/O-bound tasks</span></span>

<span data-ttu-id="a8107-164">Um eine Aufgabe zu erstellen, die nicht vollständig in einem Thread ausgeführt werden sollen, wird der <xref:System.Threading.Tasks.TaskCompletionSource%601>-Typ verwendet.</span><span class="sxs-lookup"><span data-stu-id="a8107-164">To create a task that should not be directly backed by a thread for the entirety of its execution, use the <xref:System.Threading.Tasks.TaskCompletionSource%601> type.</span></span> <span data-ttu-id="a8107-165">Dieser Typ macht eine <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A>-Eigenschaft verfügbar, die eine zugeordnete <xref:System.Threading.Tasks.Task%601>-Instanz zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="a8107-165">This type exposes a <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> property that returns an associated <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="a8107-166">Der Lebenszyklus dieser Aufgabe wird durch <xref:System.Threading.Tasks.TaskCompletionSource%601>-Methoden wie <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> und ihre `TrySet` Varianten gesteuert.</span><span class="sxs-lookup"><span data-stu-id="a8107-166">The life cycle of this task is controlled by <xref:System.Threading.Tasks.TaskCompletionSource%601> methods such as <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, and their `TrySet` variants.</span></span>

<span data-ttu-id="a8107-167">Nehmen wir beispielsweise an, dass Sie eine Aufgabe erstellen möchten, die nach einem bestimmten Zeitraum abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="a8107-167">Let's say that you want to create a task that will complete after a specified period of time.</span></span> <span data-ttu-id="a8107-168">Beispielsweise könnten Sie eine Aktivität in der Benutzeroberfläche verzögern.</span><span class="sxs-lookup"><span data-stu-id="a8107-168">For example, you may want to delay an activity in the user interface.</span></span> <span data-ttu-id="a8107-169">Die <xref:System.Threading.Timer?displayProperty=nameWithType>-Klasse ermöglicht es bereits, einen Delegaten nach einem angegebenen Zeitraum asynchron aufzurufen, und mit <xref:System.Threading.Tasks.TaskCompletionSource%601> lässt sich eine <xref:System.Threading.Tasks.Task%601>-Front für den Timer erstellen, wie im folgenden Beispiel:</span><span class="sxs-lookup"><span data-stu-id="a8107-169">The <xref:System.Threading.Timer?displayProperty=nameWithType> class already provides the ability to asynchronously invoke a delegate after a specified period of time, and by using <xref:System.Threading.Tasks.TaskCompletionSource%601> you can put a <xref:System.Threading.Tasks.Task%601> front on the timer, for example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#4)]
[!code-vb[Conceptual.TAP_Patterns#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#4)]

<span data-ttu-id="a8107-170">Die <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType>-Methode wird zu diesem Zweck bereitgestellt. Sie können sie in einer anderen asynchronen Methode verwenden, beispielsweise zum Implementieren einer asynchrone Abrufschleife:</span><span class="sxs-lookup"><span data-stu-id="a8107-170">The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method is provided for this purpose, and you can use it inside another asynchronous method, for example, to implement an asynchronous polling loop:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#5)]
[!code-vb[Conceptual.TAP_Patterns#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#5)]

<span data-ttu-id="a8107-171">Die <xref:System.Threading.Tasks.TaskCompletionSource%601>-Klasse hat keine nicht generische Entsprechung.</span><span class="sxs-lookup"><span data-stu-id="a8107-171">The <xref:System.Threading.Tasks.TaskCompletionSource%601> class doesn't have a non-generic counterpart.</span></span> <span data-ttu-id="a8107-172"><xref:System.Threading.Tasks.Task%601> wird jedoch von <xref:System.Threading.Tasks.Task> abgeleitet, sodass das generische <xref:System.Threading.Tasks.TaskCompletionSource%601>-Objekt für Ein-/Ausgabe-gebundene Methoden verwendet werden kann, die einfach eine Aufgabe zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="a8107-172">However, <xref:System.Threading.Tasks.Task%601> derives from <xref:System.Threading.Tasks.Task>, so you can use the generic <xref:System.Threading.Tasks.TaskCompletionSource%601> object for I/O-bound methods that simply return a task.</span></span> <span data-ttu-id="a8107-173">Um dies zu erreichen, können Sie eine Quelle mit einem Dummy-`TResult` (<xref:System.Boolean>) verwenden. Das ist eine gute Standardmöglichkeit, aber wenn Sie darüber besorgt sind, dass der Benutzer der <xref:System.Threading.Tasks.Task> sie in eine <xref:System.Threading.Tasks.Task%601> umwandeln wird, können Sie stattdessen einen privaten `TResult`-Typ verwenden).</span><span class="sxs-lookup"><span data-stu-id="a8107-173">To do this, you can use a source with a dummy `TResult` (<xref:System.Boolean> is a good default choice, but if you're concerned about the user of the <xref:System.Threading.Tasks.Task> downcasting it to a <xref:System.Threading.Tasks.Task%601>, you can use a private `TResult` type instead).</span></span> <span data-ttu-id="a8107-174">Beispielsweise wurde die zuvor gezeigte `Delay`-Methode entwickelt, um die aktuelle Zeit zusammen mit dem resultierenden Offset (`Task<DateTimeOffset>`) zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="a8107-174">For example, the `Delay` method in the previous example returns the current time along with the resulting offset (`Task<DateTimeOffset>`).</span></span> <span data-ttu-id="a8107-175">Wenn ein solcher Ergebniswert nicht erforderlich ist, kann die Methode stattdessen wie folgt codiert werden (beachten Sie die Änderung des Rückgabetyps und die Änderung des Arguments in <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span><span class="sxs-lookup"><span data-stu-id="a8107-175">If such a result value is unnecessary, the method could instead be coded as follows (note the change of return type and the change of argument to <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span></span>

[!code-csharp[Conceptual.TAP_Patterns#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#6)]
[!code-vb[Conceptual.TAP_Patterns#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#6)]

### <a name="mixed-compute-bound-and-io-bound-tasks"></a><span data-ttu-id="a8107-176">Tasks, die sowohl rechnergebunden als auch E/A-gebunden sind</span><span class="sxs-lookup"><span data-stu-id="a8107-176">Mixed compute-bound and I/O-bound tasks</span></span>

<span data-ttu-id="a8107-177">Asynchrone Methoden sind nicht auf ausschließlich rechnergebundene oder ausschließlich E/A-gebundene Vorgänge beschränkt, sondern können eine Mischung aus beiden Vorgangsarten darstellen.</span><span class="sxs-lookup"><span data-stu-id="a8107-177">Asynchronous methods are not limited to just compute-bound or I/O-bound operations but may represent a mixture of the two.</span></span> <span data-ttu-id="a8107-178">Tatsächlich werden mehrere asynchrone Operationen häufig zu größeren Mischvorgängen kombiniert.</span><span class="sxs-lookup"><span data-stu-id="a8107-178">In fact, multiple asynchronous operations are often combined into larger mixed operations.</span></span> <span data-ttu-id="a8107-179">Die bereits gezeigte `RenderAsync`-Methode hat beispielsweise einen rechenintensiven Vorgang ausgeführt, um ein Bild auf Grundlage von eingegebenen `imageData` zu rendern.</span><span class="sxs-lookup"><span data-stu-id="a8107-179">For example, the `RenderAsync` method in a previous example performed a computationally intensive operation to render an image based on some input `imageData`.</span></span> <span data-ttu-id="a8107-180">Die `imageData` können aus einem Webdienst stammen, auf den asynchron zugegriffen wird:</span><span class="sxs-lookup"><span data-stu-id="a8107-180">This `imageData` could come from a web service that you asynchronously access:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#7)]
[!code-vb[Conceptual.TAP_Patterns#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#7)]

<span data-ttu-id="a8107-181">Dieses Beispiel zeigt auch, wie ein einzelnes Abbruchstoken nacheinander in mehreren asynchronen Vorgängen verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="a8107-181">This example also demonstrates how a single cancellation token may be threaded through multiple asynchronous operations.</span></span> <span data-ttu-id="a8107-182">Weitere Informationen finden Sie im Abschnitt zur Verwendung von Abbruchtokens unter [Verwenden des aufgabenbasierten asynchronen Musters](consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="a8107-182">For more information, see the cancellation usage section in [Consuming the Task-based Asynchronous Pattern](consuming-the-task-based-asynchronous-pattern.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="a8107-183">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="a8107-183">See also</span></span>

- [<span data-ttu-id="a8107-184">Aufgabenbasiertes asynchrones Muster (TAP, Task-based Asynchronous Pattern)</span><span class="sxs-lookup"><span data-stu-id="a8107-184">Task-based Asynchronous Pattern (TAP)</span></span>](task-based-asynchronous-pattern-tap.md)
- [<span data-ttu-id="a8107-185">Nutzen des aufgabenbasierten asynchronen Musters</span><span class="sxs-lookup"><span data-stu-id="a8107-185">Consuming the Task-based Asynchronous Pattern</span></span>](consuming-the-task-based-asynchronous-pattern.md)
- [<span data-ttu-id="a8107-186">Interoperabilität mit anderen asynchronen Mustern und Typen</span><span class="sxs-lookup"><span data-stu-id="a8107-186">Interop with Other Asynchronous Patterns and Types</span></span>](interop-with-other-asynchronous-patterns-and-types.md)
