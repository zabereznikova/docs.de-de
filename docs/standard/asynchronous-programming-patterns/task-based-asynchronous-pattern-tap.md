---
title: Aufgabenbasiertes asynchrones Muster (TAP, Task-based Asynchronous Pattern)
description: In diesem Artikel erfahren Sie mehr über das taskbasierte asynchrone Entwurfsmuster (Task-based Asynchronous Pattern, TAP). TAP ist das empfohlene asynchrone Entwurfsmuster für Entwicklungen in .NET.
ms.date: 02/26/2019
dev_langs:
- csharp
- vb
helpviewer_keywords:
- asynchronous design patterns, .NET
- TAP, .NET support for
- Task-based Asynchronous Pattern, .NET support for
- .NET, asynchronous design patterns
ms.assetid: 8cef1fcf-6f9f-417c-b21f-3fd8bac75007
ms.openlocfilehash: f194a0bafa0ab7b9606d72f091dbb12e94f31099
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/18/2020
ms.locfileid: "94824017"
---
# <a name="task-based-asynchronous-pattern"></a><span data-ttu-id="2383b-104">Taskbasiertes asynchrones Muster</span><span class="sxs-lookup"><span data-stu-id="2383b-104">Task-based asynchronous pattern</span></span>

<span data-ttu-id="2383b-105">Das taskbasierte asynchrone Muster (Task-based Asynchronous Pattern, TAP) basiert auf den Typen <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> und <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> im <xref:System.Threading.Tasks?displayProperty=nameWithType>-Namespace, mit denen beliebige asynchrone Vorgänge dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="2383b-105">The task-based asynchronous pattern (TAP) is based on the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types in the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace, which are used to represent arbitrary asynchronous operations.</span></span> <span data-ttu-id="2383b-106">TAP ist das empfohlene Entwurfsmuster für asynchrone Neuentwicklungen.</span><span class="sxs-lookup"><span data-stu-id="2383b-106">TAP is the recommended asynchronous design pattern for new development.</span></span>  
  
## <a name="naming-parameters-and-return-types"></a><span data-ttu-id="2383b-107">Benennung, Parameter und Rückgabetypen</span><span class="sxs-lookup"><span data-stu-id="2383b-107">Naming, parameters, and return types</span></span>

<span data-ttu-id="2383b-108">TAP verwendet eine einfache Methode, um die Initiierung und den Abschluss eines asynchronen Vorgangs darzustellen.</span><span class="sxs-lookup"><span data-stu-id="2383b-108">TAP uses a single method to represent the initiation and completion of an asynchronous operation.</span></span> <span data-ttu-id="2383b-109">Dies steht sowohl zum Muster des asynchronen Programmiermodells (Asynchronous Programming Model, APM oder `IAsyncResult`) als auch dem ereignisbasierten asynchronen Muster (Event-based Asynchronous Pattern, EAP) im Kontrast.</span><span class="sxs-lookup"><span data-stu-id="2383b-109">This contrasts with both the Asynchronous Programming Model (APM or `IAsyncResult`) pattern and the Event-based Asynchronous Pattern (EAP).</span></span> <span data-ttu-id="2383b-110">APM erfordert die Methoden `Begin` und `End`.</span><span class="sxs-lookup"><span data-stu-id="2383b-110">APM requires `Begin` and `End` methods.</span></span> <span data-ttu-id="2383b-111">EAP erfordert eine Methode, die das `Async`-Suffix hat, und auch mindestens ein Ereignis, einen Ereignishandler-Delegattypen und aus `EventArg` abgeleitete Typen.</span><span class="sxs-lookup"><span data-stu-id="2383b-111">EAP requires a method that has the `Async` suffix and also requires one or more events, event handler delegate types, and `EventArg`-derived types.</span></span> <span data-ttu-id="2383b-112">Asynchrone Methoden im TAP umfassen das Suffix `Async` nach dem Vorgangsnamen für Methoden, die awaitable-Typen zurückgeben, z.B. <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask> und <xref:System.Threading.Tasks.ValueTask%601>.</span><span class="sxs-lookup"><span data-stu-id="2383b-112">Asynchronous methods in TAP include the `Async` suffix after the operation name for methods that return awaitable types, such as <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask>, and <xref:System.Threading.Tasks.ValueTask%601>.</span></span> <span data-ttu-id="2383b-113">Ein asynchroner `Get`-Vorgang, der einen `Task<String>` zurückgibt, kann z.B. mit `GetAsync` benannt werden.</span><span class="sxs-lookup"><span data-stu-id="2383b-113">For example, an asynchronous `Get` operation that returns a `Task<String>` can be named `GetAsync`.</span></span> <span data-ttu-id="2383b-114">Wenn Sie eine TAP-Methode einer Klasse hinzufügen, die bereits eine EAP-Methode mit dem `Async`-Suffix enthält, verwenden Sie stattdessen das Suffix `TaskAsync`.</span><span class="sxs-lookup"><span data-stu-id="2383b-114">If you're adding a TAP method to a class that already contains an EAP method name with the `Async` suffix, use the suffix `TaskAsync` instead.</span></span> <span data-ttu-id="2383b-115">Wenn beispielsweise die Klasse bereits über eine `GetAsync`-Methode verfügt, verwenden Sie den Namen `GetTaskAsync`.</span><span class="sxs-lookup"><span data-stu-id="2383b-115">For example, if the class already has a `GetAsync` method, use the name `GetTaskAsync`.</span></span> <span data-ttu-id="2383b-116">Wenn eine Methode einen asynchronen Vorgang startet, aber keinen awaitable-Typ zurückgibt, sollte ihr Name mit `Begin`, `Start` oder einem ähnlichen Verb beginnen, sodass eindeutig ist, dass diese Methode nicht das Ergebnis des Vorgangs zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="2383b-116">If a method starts an asynchronous operation but does not return an awaitable type, its name should start with `Begin`, `Start`, or some other verb to suggest that this method does not return or throw the result of the operation.</span></span>  
  
 <span data-ttu-id="2383b-117">Die TAP-Methode gibt entweder <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> oder <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> zurück. Das hängt davon ab, ob die entsprechende synchrone Methode „void“ oder einen `TResult`-Typ zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="2383b-117">A TAP method returns either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, based on whether the corresponding synchronous method returns void or a type `TResult`.</span></span>  
  
 <span data-ttu-id="2383b-118">Die Parameter einer TAP-Methode sollten mit den Parametern der synchronen Entsprechung übereinstimmen und in der gleichen Reihenfolge bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="2383b-118">The parameters of a TAP method should match the parameters of its synchronous counterpart and should be provided in the same order.</span></span>  <span data-ttu-id="2383b-119">Diese Regel gilt jedoch nicht für den `out`-Parameter und den `ref`-Parameter. Diese Parameter sollten vollständig vermieden werden.</span><span class="sxs-lookup"><span data-stu-id="2383b-119">However, `out` and `ref` parameters are exempt from this rule and should be avoided entirely.</span></span> <span data-ttu-id="2383b-120">Alle Daten, die über einen `out`-Parameter oder einen `ref`-Parameter zurückgegeben werden, sollten stattdessen als Teil des von `TResult` zurückgegebenen <xref:System.Threading.Tasks.Task%601> zurückgegeben werden, wobei für die Verwendung mehrerer Werte ein Tupel oder eine benutzerdefinierte Datenstruktur genutzt wird.</span><span class="sxs-lookup"><span data-stu-id="2383b-120">Any data that would have been returned through an `out` or `ref` parameter should instead be returned as part of the `TResult` returned by <xref:System.Threading.Tasks.Task%601>, and should use a tuple or a custom data structure to accommodate multiple values.</span></span> <span data-ttu-id="2383b-121">Unter Umständen sollten Sie auch einen <xref:System.Threading.CancellationToken>-Parameter hinzuzufügen, selbst dann, wenn die synchrone Entsprechung der TAP-Methode keinen anbietet.</span><span class="sxs-lookup"><span data-stu-id="2383b-121">Also, consider adding a <xref:System.Threading.CancellationToken> parameter even if the TAP method's synchronous counterpart does not offer one.</span></span>

 <span data-ttu-id="2383b-122">Methoden, die ausschließlich zur Erstellung, Bearbeitung oder Kombination von Tasks dienen (wobei die asynchrone Verwendung der Methode im Methodennamen oder im Namen des Typs, zu dem die Methode gehört, angegeben wird), müssen nicht nach diesem Benennungsmuster benannt werden. Diese Methoden werden häufig als *Combinators* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="2383b-122">Methods that are devoted exclusively to the creation, manipulation, or combination of tasks (where the asynchronous intent of the method is clear in the method name or in the name of the type to which the method belongs) need not follow this naming pattern; such methods are often referred to as *combinators*.</span></span> <span data-ttu-id="2383b-123">Beispiele für Combinators umfassen <xref:System.Threading.Tasks.Task.WhenAll%2A> und <xref:System.Threading.Tasks.Task.WhenAny%2A> und werden im Abschnitt [Verwenden der integrierten taskbasierten Combinators](consuming-the-task-based-asynchronous-pattern.md#combinators) des Artikels [Verwenden des taskbasierten asynchronen Musters](consuming-the-task-based-asynchronous-pattern.md) erläutert.</span><span class="sxs-lookup"><span data-stu-id="2383b-123">Examples of combinators include <xref:System.Threading.Tasks.Task.WhenAll%2A> and <xref:System.Threading.Tasks.Task.WhenAny%2A>, and are discussed in the [Using the Built-in Task-based Combinators](consuming-the-task-based-asynchronous-pattern.md#combinators) section of the article [Consuming the Task-based Asynchronous Pattern](consuming-the-task-based-asynchronous-pattern.md).</span></span>  
  
 <span data-ttu-id="2383b-124">Beispiele dafür, wie die TAP-Syntax sich von der Syntax in Legacyversionen des asynchronen Programmiermusters (beispielsweise dem asynchronen Programmiermodell (kurz APM) und dem ereignisbasierten asynchronen Muster (EAP)) unterscheidet, finden Sie unter [Muster für die asynchrone Programmierung](index.md).</span><span class="sxs-lookup"><span data-stu-id="2383b-124">For examples of how the TAP syntax differs from the syntax used in legacy asynchronous programming patterns such as the Asynchronous Programming Model (APM) and the Event-based Asynchronous Pattern (EAP), see [Asynchronous Programming Patterns](index.md).</span></span>  
  
## <a name="initiating-an-asynchronous-operation"></a><span data-ttu-id="2383b-125">Initiieren eines asynchronen Vorgangs</span><span class="sxs-lookup"><span data-stu-id="2383b-125">Initiating an asynchronous operation</span></span>  
 <span data-ttu-id="2383b-126">Eine asynchrone Methode, die auf TAP basiert, kann eine kleine Menge an Arbeit synchron ausführen, beispielsweise das Überprüfen von Argumenten und das Initiieren des asynchronen Vorgangs, bevor sie die resultierende Aufgabe zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="2383b-126">An asynchronous method that is based on TAP can do a small amount of work synchronously, such as validating arguments and initiating the asynchronous operation, before it returns the resulting task.</span></span> <span data-ttu-id="2383b-127">Synchrone Arbeiten sollten auf ein Minimum beschränkt werden, damit die asynchrone Methode schnell zurückgeben kann.</span><span class="sxs-lookup"><span data-stu-id="2383b-127">Synchronous work should be kept to the minimum so the asynchronous method can return quickly.</span></span> <span data-ttu-id="2383b-128">Gründe für eine schnelle Rückgabe sind u. a.:</span><span class="sxs-lookup"><span data-stu-id="2383b-128">Reasons for a quick return include:</span></span>  
  
- <span data-ttu-id="2383b-129">Asynchrone Methoden können von den Threads der Benutzeroberfläche aufgerufen werden und jede synchrone Arbeit mit langer Laufzeit kann die Reaktionszeit der Anwendung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="2383b-129">Asynchronous methods may be invoked from user interface (UI) threads, and any long-running synchronous work could harm the responsiveness of the application.</span></span>  
  
- <span data-ttu-id="2383b-130">Mehrere asynchrone Methoden können gleichzeitig ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="2383b-130">Multiple asynchronous methods may be launched concurrently.</span></span> <span data-ttu-id="2383b-131">Daher kann jede Arbeit mit langer Laufzeit im synchronen Teil einer asynchronen Methode die Initiierung anderer asynchroner Operationen verzögern und so sie die Vorteile der Nebenläufigkeit verringern.</span><span class="sxs-lookup"><span data-stu-id="2383b-131">Therefore, any long-running work in the synchronous portion of an asynchronous method could delay the initiation of other asynchronous operations, thereby decreasing the benefits of concurrency.</span></span>  
  
 <span data-ttu-id="2383b-132">In einigen Fällen ist der Arbeitsaufwand, der erforderlich ist, um den Vorgang abzuschließen, kleiner als der Arbeitsaufwand, der erforderlich ist, um den Vorgang asynchron zu starten.</span><span class="sxs-lookup"><span data-stu-id="2383b-132">In some cases, the amount of work required to complete the operation is less than the amount of work required to launch the operation asynchronously.</span></span> <span data-ttu-id="2383b-133">Lesen aus einem Stream, bei dem der Lesevorgang durch Daten erfüllt werden kann, die bereits im Arbeitsspeicher gepuffert werden, ist ein Beispiel für ein solches Szenario.</span><span class="sxs-lookup"><span data-stu-id="2383b-133">Reading from a stream where the read operation can be satisfied by data that is already buffered in memory is an example of such a scenario.</span></span> <span data-ttu-id="2383b-134">In solchen Fällen wird der Vorgang möglicherweise synchron abgeschlossen, und eine bereits abgeschlossene Aufgabe kann zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="2383b-134">In such cases, the operation may complete synchronously, and may return a task that has already been completed.</span></span>  
  
## <a name="exceptions"></a><span data-ttu-id="2383b-135">Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="2383b-135">Exceptions</span></span>  
 <span data-ttu-id="2383b-136">Eine asynchrone Methode sollte nur Ausnahmen auslösen, die aufgrund eines Verwendungsfehlers beim Aufruf der asynchronen Methode ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="2383b-136">An asynchronous method should raise an exception to be thrown out of the asynchronous method call only in response to a usage error.</span></span> <span data-ttu-id="2383b-137">Verwendungsfehler sollten nie im Produktionscode auftreten.</span><span class="sxs-lookup"><span data-stu-id="2383b-137">Usage errors should never occur in production code.</span></span> <span data-ttu-id="2383b-138">Verursacht die Übergabe eines Nullverweises (`Nothing` in Visual Basic) als Methodenargument beispielsweise einen Fehlerzustand (normalerweise dargestellt durch eine <xref:System.ArgumentNullException>-Ausnahme), können Sie den Aufrufcode ändern, um sicherzustellen, dass Nullverweise nie übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="2383b-138">For example, if passing a null reference (`Nothing` in Visual Basic) as one of the method's arguments causes an error state (usually represented by an <xref:System.ArgumentNullException> exception), you can modify the calling code to ensure that a null reference is never passed.</span></span> <span data-ttu-id="2383b-139">Für alle anderen Fehler sollten Ausnahmen, die beim Ausführen einer asynchronen Methode auftreten, der zurückgegebenen Aufgabe zugewiesen werden. Dies gilt auch dann, wenn die asynchrone Methode zufällig synchron abschließt, bevor die Aufgabe zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="2383b-139">For all other errors, exceptions that occur when an asynchronous method is running should be assigned to the returned task, even if the asynchronous method happens to complete synchronously before the task is returned.</span></span> <span data-ttu-id="2383b-140">In der Regel enthält eine Aufgabe höchstens eine Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="2383b-140">Typically, a task contains at most one exception.</span></span> <span data-ttu-id="2383b-141">Falls die Aufgabe jedoch mehrere Vorgänge darstellt (beispielsweise bei <xref:System.Threading.Tasks.Task.WhenAll%2A>), können einer einzelnen Aufgabe mehrere Ausnahmen zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="2383b-141">However, if the task represents multiple operations (for example, <xref:System.Threading.Tasks.Task.WhenAll%2A>), multiple exceptions may be associated with a single task.</span></span>  
  
## <a name="target-environment"></a><span data-ttu-id="2383b-142">Zielumgebung</span><span class="sxs-lookup"><span data-stu-id="2383b-142">Target environment</span></span>  
 <span data-ttu-id="2383b-143">Wenn Sie eine TAP-Methode implementieren, können Sie bestimmen, wo die asynchrone Ausführung auftritt.</span><span class="sxs-lookup"><span data-stu-id="2383b-143">When you implement a TAP method, you can determine where asynchronous execution occurs.</span></span> <span data-ttu-id="2383b-144">Sie können die Arbeitsauslastung im Threadpool ausführen, sie mithilfe einer asynchronen E/A implementieren (sodass sie für den Großteil der Ausführung des Vorgangs nicht an einen Thread gebunden ist), sie in einem bestimmten Thread (z. B. dem UI-Thread) ausführen lassen oder in einer beliebigen Anzahl von anderen potenziellen Kontexten verwenden.</span><span class="sxs-lookup"><span data-stu-id="2383b-144">You may choose to execute the workload on the thread pool, implement it by using asynchronous I/O (without being bound to a thread for the majority of the operation's execution), run it on a specific thread (such as the UI thread), or use any number of potential contexts.</span></span> <span data-ttu-id="2383b-145">Es kann sogar vorkommen, dass eine TAP-Methode nichts ausführt und nur einen <xref:System.Threading.Tasks.Task> zurückgibt, der das Auftreten einer Bedingung an anderer Stelle im System darstellt (z.B. einen Task, der bei einer Datenstruktur in der Warteschlange eingehende Daten darstellt).</span><span class="sxs-lookup"><span data-stu-id="2383b-145">A TAP method may even have nothing to execute, and may just return a <xref:System.Threading.Tasks.Task> that represents the occurrence of a condition elsewhere in the system (for example, a task that represents data arriving at a queued data structure).</span></span>

 <span data-ttu-id="2383b-146">Die aufrufende Funktion der TAP-Methode blockiert möglicherweise den Wartevorgang für die TAP-Methode, indem synchron auf den resultierenden Task gewartet wird, oder führt eventuell zusätzlichen (Fortsetzungs-)Code aus, wenn der asynchrone Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="2383b-146">The caller of the TAP method may block waiting for the TAP method to complete by synchronously waiting on the resulting task, or may run additional (continuation) code when the asynchronous operation completes.</span></span> <span data-ttu-id="2383b-147">Der Ersteller des Fortsetzungscodes steuert, wo dieser Code ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="2383b-147">The creator of the continuation code has control over where that code executes.</span></span> <span data-ttu-id="2383b-148">Sie können diesen Fortsetzungscode entweder explizit durch Methoden der <xref:System.Threading.Tasks.Task>-Klasse (z. B. <xref:System.Threading.Tasks.Task.ContinueWith%2A>) oder implizit mithilfe von Sprachunterstützung erstellen, die auf Fortsetzungen aufbaut (zum Beispiel `await` in C#, `Await` in Visual Basic, `AwaitValue` in F#).</span><span class="sxs-lookup"><span data-stu-id="2383b-148">You may create the continuation code either explicitly, through methods on the <xref:System.Threading.Tasks.Task> class (for example, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) or implicitly, by using language support built on top of continuations (for example, `await` in C#, `Await` in Visual Basic, `AwaitValue` in F#).</span></span>  
  
## <a name="task-status"></a><span data-ttu-id="2383b-149">Aufgabenstatus</span><span class="sxs-lookup"><span data-stu-id="2383b-149">Task status</span></span>  
 <span data-ttu-id="2383b-150">Die <xref:System.Threading.Tasks.Task>-Klasse stellt einen Lebenszyklus für asynchrone Vorgänge bereit, und dieser Zyklus wird durch die <xref:System.Threading.Tasks.TaskStatus>-Enumeration dargestellt.</span><span class="sxs-lookup"><span data-stu-id="2383b-150">The <xref:System.Threading.Tasks.Task> class provides a life cycle for asynchronous operations, and that cycle is represented by the <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span> <span data-ttu-id="2383b-151">Für die Unterstützung von Ausnahmefällen von Typen, die von <xref:System.Threading.Tasks.Task> und <xref:System.Threading.Tasks.Task%601> abgeleitet werden, sowie für die Unterstützung der Trennung von Erstellung und Planung macht die <xref:System.Threading.Tasks.Task>-Klasse eine <xref:System.Threading.Tasks.Task.Start%2A>-Methode verfügbar.</span><span class="sxs-lookup"><span data-stu-id="2383b-151">To support corner cases of types that derive from <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601>,  and to support the separation of construction from scheduling, the <xref:System.Threading.Tasks.Task> class exposes a <xref:System.Threading.Tasks.Task.Start%2A> method.</span></span> <span data-ttu-id="2383b-152">Von den öffentlichen <xref:System.Threading.Tasks.Task>-Konstruktoren erstellte Tasks werden als *inaktive Tasks* bezeichnet, da ihr Lebenszyklus im nicht geplanten Zustand <xref:System.Threading.Tasks.TaskStatus.Created> beginnt und sie erst im geplanten Zustand sind, wenn <xref:System.Threading.Tasks.Task.Start%2A> für diese Instanzen aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="2383b-152">Tasks that are created by the public <xref:System.Threading.Tasks.Task> constructors are referred to as *cold tasks*, because they begin their life cycle in the non-scheduled <xref:System.Threading.Tasks.TaskStatus.Created> state and are scheduled only when <xref:System.Threading.Tasks.Task.Start%2A> is called on these instances.</span></span>

 <span data-ttu-id="2383b-153">Der Lebenszyklus aller anderen Aufgaben beginnt im aktiven Zustand. Dies bedeutet, dass die asynchronen Vorgänge, die sie darstellen, bereits initiiert wurden, und dass ihr Aufgabenzustand ein anderer Enumerationswert als <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType> ist.</span><span class="sxs-lookup"><span data-stu-id="2383b-153">All other tasks begin their life cycle in a hot state, which means that the asynchronous operations they represent have already been initiated and their task status is an enumeration value other than <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2383b-154">Alle Aufgaben, die von TAP-Methoden zurückgegeben werden, müssen aktiviert sein.</span><span class="sxs-lookup"><span data-stu-id="2383b-154">All tasks that are returned from TAP methods must be activated.</span></span> <span data-ttu-id="2383b-155">**Wenn eine TAP-Methode intern den zurückzugebenden Task mit dem Konstruktor des Tasks instanziiert, muss die TAP-Methode vor dem Zurückgeben des Tasks <xref:System.Threading.Tasks.Task.Start%2A> im <xref:System.Threading.Tasks.Task>-Objekt aufrufen.**</span><span class="sxs-lookup"><span data-stu-id="2383b-155">**If a TAP method internally uses a task's constructor to instantiate the task to be returned, the TAP method must call <xref:System.Threading.Tasks.Task.Start%2A> on the <xref:System.Threading.Tasks.Task> object before returning it.**</span></span> <span data-ttu-id="2383b-156">Consumer einer TAP-Methode können davon ausgehen, dass die zurückgegebene Aufgabe aktiv ist, und sollten nicht versuchen, <xref:System.Threading.Tasks.Task.Start%2A> für einen von einer TAP-Methode zurückgegebenen <xref:System.Threading.Tasks.Task> aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="2383b-156">Consumers of a TAP method may safely assume that the returned task is active and should not try to call <xref:System.Threading.Tasks.Task.Start%2A> on any <xref:System.Threading.Tasks.Task> that is returned from a TAP method.</span></span> <span data-ttu-id="2383b-157">Der Aufruf von <xref:System.Threading.Tasks.Task.Start%2A> für eine aktive Aufgabe führt zu einer <xref:System.InvalidOperationException>-Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="2383b-157">Calling <xref:System.Threading.Tasks.Task.Start%2A> on an active task results in an <xref:System.InvalidOperationException> exception.</span></span>  
  
## <a name="cancellation-optional"></a><span data-ttu-id="2383b-158">Abbruch (optional)</span><span class="sxs-lookup"><span data-stu-id="2383b-158">Cancellation (optional)</span></span>  
 <span data-ttu-id="2383b-159">Im TAP ist Abbruch sowohl für Implementierer asynchroner Methoden als auch für Consumer asynchroner Methoden optional.</span><span class="sxs-lookup"><span data-stu-id="2383b-159">In TAP, cancellation is optional for both asynchronous method implementers and asynchronous method consumers.</span></span> <span data-ttu-id="2383b-160">Wenn ein Vorgang einen Abbruch zulässt, macht er eine Überladung der asynchronen Methode verfügbar, die ein Abbruchtoken akzeptiert (<xref:System.Threading.CancellationToken>-Instanz).</span><span class="sxs-lookup"><span data-stu-id="2383b-160">If an operation allows cancellation, it exposes an overload of the asynchronous method that accepts a cancellation token (<xref:System.Threading.CancellationToken> instance).</span></span> <span data-ttu-id="2383b-161">Gemäß der Konvention lautet der Name des Parameters `cancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="2383b-161">By convention, the parameter is named `cancellationToken`.</span></span>  
  
 [!code-csharp[Conceptual.TAP#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#1)]
 [!code-vb[Conceptual.TAP#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#1)]  
  
 <span data-ttu-id="2383b-162">Der asynchrone Vorgang überwacht dieses Token auf Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="2383b-162">The asynchronous operation monitors this token for cancellation requests.</span></span> <span data-ttu-id="2383b-163">Wenn es eine Abbruchanforderung empfängt, kann es diese Anforderung erfüllen und den Vorgang abbrechen.</span><span class="sxs-lookup"><span data-stu-id="2383b-163">If it receives a cancellation request, it may choose to honor that request and cancel the operation.</span></span> <span data-ttu-id="2383b-164">Wenn die Abbruchanforderung dazu führt, dass die Arbeit vorzeitig beendet wird, gibt die TAP-Methode eine Aufgabe zurück, die im <xref:System.Threading.Tasks.TaskStatus.Canceled>-Zustand beendet wird. Es ist kein Ergebnis verfügbar und keine Ausnahme wird ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="2383b-164">If the cancellation request results in work being ended prematurely, the TAP method returns a task that ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state; there is no available result and no exception is thrown.</span></span>  <span data-ttu-id="2383b-165">Der Zustand <xref:System.Threading.Tasks.TaskStatus.Canceled> gilt als endgültiger (abgeschlossener) Zustand einer Aufgabe, ebenso wie die Zustände <xref:System.Threading.Tasks.TaskStatus.Faulted> und <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span><span class="sxs-lookup"><span data-stu-id="2383b-165">The <xref:System.Threading.Tasks.TaskStatus.Canceled> state is considered to be a final (completed) state for a task, along with the <xref:System.Threading.Tasks.TaskStatus.Faulted> and <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> states.</span></span> <span data-ttu-id="2383b-166">Wenn eine Aufgabe im Zustand <xref:System.Threading.Tasks.TaskStatus.Canceled> ist, gibt ihre <xref:System.Threading.Tasks.Task.IsCompleted%2A>-Eigenschaft `true` zurück.</span><span class="sxs-lookup"><span data-stu-id="2383b-166">Therefore, if a task is in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, its <xref:System.Threading.Tasks.Task.IsCompleted%2A> property returns `true`.</span></span> <span data-ttu-id="2383b-167">Wenn eine Aufgabe im <xref:System.Threading.Tasks.TaskStatus.Canceled>-Zustand abgeschlossen wird, werden alle mit der Aufgabe registrierten Fortsetzungen geplant oder ausgeführt, es sei denn, eine Fortsetzungsmöglichkeit wie <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> wurde angegeben, um die Fortsetzung zu beenden.</span><span class="sxs-lookup"><span data-stu-id="2383b-167">When a task completes in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, any continuations registered with the task are scheduled or executed, unless a continuation option such as <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> was specified to opt out of continuation.</span></span> <span data-ttu-id="2383b-168">Die Ausführung von jedem Code, der mithilfe von Sprachfunktionen asynchron auf eine abgebrochene Aufgabe wartet, wird weiter ausgeführt, aber der Code empfängt eine <xref:System.OperationCanceledException>-Ausnahme oder eine von ihr abgeleitete Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="2383b-168">Any code that is asynchronously waiting for a canceled task through use of language features continues to run but receives an <xref:System.OperationCanceledException> or an exception derived from it.</span></span> <span data-ttu-id="2383b-169">Synchron blockierter Code, der durch Methoden wie <xref:System.Threading.Tasks.Task.Wait%2A> und <xref:System.Threading.Tasks.Task.WaitAll%2A> auf die Aufgabe wartet, wird ebenso weiter mit einer Ausnahme ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="2383b-169">Code that is blocked synchronously waiting on the task through methods such as <xref:System.Threading.Tasks.Task.Wait%2A> and <xref:System.Threading.Tasks.Task.WaitAll%2A> also continue to run with an exception.</span></span>  
  
 <span data-ttu-id="2383b-170">Wenn ein Abbruchtoken den Abbruch angefordert hat, bevor die TAP-Methode, die dieses Token akzeptiert, aufgerufen wurde, sollte die TAP-Methode eine <xref:System.Threading.Tasks.TaskStatus.Canceled>-Aufgabe zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2383b-170">If a cancellation token has requested cancellation before the TAP method that accepts that token is called, the TAP method should return a <xref:System.Threading.Tasks.TaskStatus.Canceled> task.</span></span>  <span data-ttu-id="2383b-171">Wenn jedoch der Abbruch während der Ausführung des asynchronen Vorgangs angefordert wird, muss der asynchrone Vorgang die Abbruchanforderung nicht erfüllen.</span><span class="sxs-lookup"><span data-stu-id="2383b-171">However, if cancellation is requested while the asynchronous operation is running, the asynchronous operation need not accept the cancellation request.</span></span>  <span data-ttu-id="2383b-172">Die zurückgegebene Aufgabe sollte nur dann im <xref:System.Threading.Tasks.TaskStatus.Canceled>-Zustand enden, wenn der Vorgang aufgrund einer Abbruchanforderung beendet wird.</span><span class="sxs-lookup"><span data-stu-id="2383b-172">The returned task should end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state only if the operation ends as a result of the cancellation request.</span></span> <span data-ttu-id="2383b-173">Wird der Abbruch angefordert aber dennoch ein Ergebnis oder eine Ausnahme erzeugt, sollte die Aufgabe im Zustand <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> oder <xref:System.Threading.Tasks.TaskStatus.Faulted> enden.</span><span class="sxs-lookup"><span data-stu-id="2383b-173">If cancellation is requested but a result or an exception is still produced, the task should end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> or <xref:System.Threading.Tasks.TaskStatus.Faulted> state.</span></span>

 <span data-ttu-id="2383b-174">Für asynchrone Methoden, die als Erstes abgebrochen können werden sollen, müssen Sie keine Überladung bereitstellen, die kein Abbruchtoken akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="2383b-174">For asynchronous methods that want to expose the ability to be canceled first and foremost, you don't have to provide an overload that doesn't accept a cancellation token.</span></span> <span data-ttu-id="2383b-175">Für Methoden, die nicht abgebrochen werden können, sollten keine Überladungen bereitgestellt werden, die ein Abbruchstoken akzeptieren. So lässt sich leichter dem Aufrufer mitteilen, ob die Zielmethode tatsächlich abgebrochen werden kann.</span><span class="sxs-lookup"><span data-stu-id="2383b-175">For methods that cannot be canceled, do not provide overloads that accept a cancellation token; this helps indicate to the caller whether the target method is actually cancelable.</span></span>  <span data-ttu-id="2383b-176">Consumercode, der keinen Abbruch wünscht, wird möglicherweise eine Methode aufrufen, die <xref:System.Threading.CancellationToken> akzeptiert und <xref:System.Threading.CancellationToken.None%2A> als den Argumentwert bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="2383b-176">Consumer code that does not desire cancellation may call a method that accepts a <xref:System.Threading.CancellationToken> and provide <xref:System.Threading.CancellationToken.None%2A> as the argument value.</span></span> <span data-ttu-id="2383b-177"><xref:System.Threading.CancellationToken.None%2A> ist zu dem standardmäßigen <xref:System.Threading.CancellationToken> funktional äquivalent.</span><span class="sxs-lookup"><span data-stu-id="2383b-177"><xref:System.Threading.CancellationToken.None%2A> is functionally equivalent to the default <xref:System.Threading.CancellationToken>.</span></span>  
  
## <a name="progress-reporting-optional"></a><span data-ttu-id="2383b-178">Statusberichterstellung (optional)</span><span class="sxs-lookup"><span data-stu-id="2383b-178">Progress reporting (optional)</span></span>  
 <span data-ttu-id="2383b-179">Mehrere asynchrone Vorgänge profitieren von dem Bereitstellen von Statusbenachrichtigungen. Diese werden in der Regel verwendet, um eine Benutzeroberfläche mit Informationen zum Status der asynchronen Operation zu aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="2383b-179">Some asynchronous operations benefit from providing progress notifications; these are typically used to update a user interface with information about the progress of the asynchronous operation.</span></span>

 <span data-ttu-id="2383b-180">In TAP wird der Status wird durch eine <xref:System.IProgress%601>-Schnittstelle behandelt, die der asynchronen Methode als Parameter übergeben wird, der normalerweise `progress` genannt wird.</span><span class="sxs-lookup"><span data-stu-id="2383b-180">In TAP, progress is handled through an <xref:System.IProgress%601> interface, which is passed to the asynchronous method as a parameter that is usually named `progress`.</span></span>  <span data-ttu-id="2383b-181">Durch das Bereitstellen der Statusschnittstelle zum Zeitpunkt des Aufrufs der asynchronen Methode lassen sich leichter Racebedingungen vermeiden, die aus falscher Verwendung resultieren (d. h., wenn Ereignishandler, die nach dem Aufruf des Vorgangs nicht ordnungsgemäß registriert wurden, möglicherweise Updates verpassen).</span><span class="sxs-lookup"><span data-stu-id="2383b-181">Providing the progress interface when the asynchronous method is called helps eliminate race conditions that result from incorrect usage (that is, when event handlers that are incorrectly registered after the operation starts may miss updates).</span></span>  <span data-ttu-id="2383b-182">Vor allem unterstützt die Statusschnittstelle jedoch verschiedene Implementierungen des Status, die durch den verwendeten Code bestimmt werden.</span><span class="sxs-lookup"><span data-stu-id="2383b-182">More importantly, the progress interface supports varying implementations of progress, as determined by the consuming code.</span></span>  <span data-ttu-id="2383b-183">Beispielsweise sollte der verwendete Code sich möglicherweise nur für das neueste Statusupdate interessieren oder alle Updates puffern oder eine Aktion für jedes Update aufrufen oder steuern, ob der Aufruf eines bestimmten Thread gemarshallt wird.</span><span class="sxs-lookup"><span data-stu-id="2383b-183">For example, the consuming code may only care about the latest progress update, or may want to buffer all updates, or may want to invoke an action for each update, or may want to control whether the invocation is marshaled to a particular thread.</span></span> <span data-ttu-id="2383b-184">All dies wird mithilfe einer anderen Implementierung der Schnittstelle erreicht, die an bestimmte Anforderungen des Consumers angepasst wird.</span><span class="sxs-lookup"><span data-stu-id="2383b-184">All these options may be achieved by using a different implementation of the interface, customized to the particular consumer's needs.</span></span>  <span data-ttu-id="2383b-185">Wie bei einem Abbruch sollten auch TAP-Implementierungen nur dann einen <xref:System.IProgress%601>-Parameter bereitstellen, wenn die API Statusbenachrichtigungen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="2383b-185">As with cancellation, TAP implementations should provide an <xref:System.IProgress%601> parameter only if the API supports progress notifications.</span></span>

 <span data-ttu-id="2383b-186">Wenn beispielsweise die weiter oben in diesem Artikel beschriebene `ReadAsync`-Methode in der Lage ist, einen Zwischenstatus in Form der Anzahl von bisher gelesenen Bytes zu melden, könnte der Statusrückruf eine <xref:System.IProgress%601>-Schnittstelle sein:</span><span class="sxs-lookup"><span data-stu-id="2383b-186">For example, if the `ReadAsync` method discussed earlier in this article is able to report intermediate progress in the form of the number of bytes read thus far, the progress callback could be an <xref:System.IProgress%601> interface:</span></span>  
  
 [!code-csharp[Conceptual.TAP#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#2)]
 [!code-vb[Conceptual.TAP#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#2)]  
  
 <span data-ttu-id="2383b-187">Wenn eine `FindFilesAsync`-Methode eine Liste aller Dateien zurückgibt, die einem bestimmten Suchmuster entsprechen, kann der Statusrückruf einen geschätzten Prozentsatz der abgeschlossenen Arbeit sowie die aktuellen partiellen Ergebnisse bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="2383b-187">If a `FindFilesAsync` method returns a list of all files that meet a particular search pattern, the progress callback could provide an estimate of the percentage of work completed and the current set of partial results.</span></span> <span data-ttu-id="2383b-188">Diese Informationen können entweder als Tuple:</span><span class="sxs-lookup"><span data-stu-id="2383b-188">It could provide this information with either a tuple:</span></span>  
  
 [!code-csharp[Conceptual.TAP#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#3)]
 [!code-vb[Conceptual.TAP#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#3)]  
  
 <span data-ttu-id="2383b-189">Oder mit einem API-spezifischen Datentyp bereitgestellt werden:</span><span class="sxs-lookup"><span data-stu-id="2383b-189">or with a data type that's specific to the API:</span></span>  
  
 [!code-csharp[Conceptual.TAP#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#4)]
 [!code-vb[Conceptual.TAP#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#4)]  
  
 <span data-ttu-id="2383b-190">In letzterem Fall wird an den speziellen Datentyp für gewöhnlich das Suffix `ProgressInfo` angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="2383b-190">In the latter case, the special data type is usually suffixed with `ProgressInfo`.</span></span>  
  
 <span data-ttu-id="2383b-191">Wenn TAP-Implementierungen Überladungen bereitstellen, die einen `progress`-Parameter akzeptieren, müssen sie `null` als Argument zulassen. In diesem Fall wird kein Status gemeldet.</span><span class="sxs-lookup"><span data-stu-id="2383b-191">If TAP implementations provide overloads that accept a `progress` parameter, they must allow the argument to be `null`, in which case no progress is reported.</span></span> <span data-ttu-id="2383b-192">TAP-Implementierungen müssen den Status synchron an das <xref:System.Progress%601>-Objekt melden, was es der asynchronen Methode ermöglicht, den Status schnell zu melden.</span><span class="sxs-lookup"><span data-stu-id="2383b-192">TAP implementations should report the progress to the <xref:System.Progress%601> object synchronously, which enables the asynchronous method to quickly provide progress.</span></span> <span data-ttu-id="2383b-193">Außerdem kann der Statusconsumer ermitteln, wie und wo die Informationen am besten verarbeitet werden sollten.</span><span class="sxs-lookup"><span data-stu-id="2383b-193">It also allows the consumer of the progress to determine how and where best to handle the information.</span></span> <span data-ttu-id="2383b-194">Zum Beispiel kann die Statusinstanz Rückrufe marshallen und Ereignisse auf einem aufgezeichneten Synchronisierungskontext auslösen.</span><span class="sxs-lookup"><span data-stu-id="2383b-194">For example, the progress instance could choose to marshal callbacks and raise events on a captured synchronization context.</span></span>  
  
## <a name="iprogresst-implementations"></a><span data-ttu-id="2383b-195">IProgress\<T>-Implementierungen</span><span class="sxs-lookup"><span data-stu-id="2383b-195">IProgress\<T> implementations</span></span>  
<span data-ttu-id="2383b-196">.NET stellt die <xref:System.Progress%601>-Klasse bereit, die <xref:System.IProgress%601> implementiert.</span><span class="sxs-lookup"><span data-stu-id="2383b-196">.NET provides the <xref:System.Progress%601> class, which implements <xref:System.IProgress%601>.</span></span> <span data-ttu-id="2383b-197">Die <xref:System.Progress%601>-Klasse wird folgendermaßen deklariert:</span><span class="sxs-lookup"><span data-stu-id="2383b-197">The <xref:System.Progress%601> class is declared as follows:</span></span>  
  
```csharp  
public class Progress<T> : IProgress<T>  
{  
    public Progress();  
    public Progress(Action<T> handler);  
    protected virtual void OnReport(T value);  
    public event EventHandler<T>? ProgressChanged;  
}  
```
  
 <span data-ttu-id="2383b-198">Eine Instanz von <xref:System.Progress%601> macht ein <xref:System.Progress%601.ProgressChanged>-Ereignis verfügbar, das jedes Mal ausgelöst wird, wenn der asynchrone Vorgang ein Statusupdate meldet.</span><span class="sxs-lookup"><span data-stu-id="2383b-198">An instance of <xref:System.Progress%601> exposes a <xref:System.Progress%601.ProgressChanged> event, which is raised every time the asynchronous operation reports a progress update.</span></span> <span data-ttu-id="2383b-199">Das <xref:System.Progress%601.ProgressChanged>-Ereignis wird auf das <xref:System.Threading.SynchronizationContext>-Objekt ausgelöst, das aufgezeichnet wurde, als die <xref:System.Progress%601>-Instanz instanziiert wurde.</span><span class="sxs-lookup"><span data-stu-id="2383b-199">The <xref:System.Progress%601.ProgressChanged> event is raised on the <xref:System.Threading.SynchronizationContext> object that was captured when the <xref:System.Progress%601> instance was instantiated.</span></span> <span data-ttu-id="2383b-200">Wenn kein Synchronisierungskontext verfügbar war, wird ein Standardkontext, der auf den Threadpool abzielt, verwendet.</span><span class="sxs-lookup"><span data-stu-id="2383b-200">If no synchronization context was available, a default context that targets the thread pool is used.</span></span> <span data-ttu-id="2383b-201">Handler können mit diesem Ereignis registriert werden.</span><span class="sxs-lookup"><span data-stu-id="2383b-201">Handlers may be registered with this event.</span></span> <span data-ttu-id="2383b-202">Ein einzelner Handler kann auch dem <xref:System.Progress%601>-Konstruktor nach Wunsch bereitgestellt werden und verhält sich wie ein Ereignishandler für das <xref:System.Progress%601.ProgressChanged>-Ereignis.</span><span class="sxs-lookup"><span data-stu-id="2383b-202">A single handler may also be provided to the <xref:System.Progress%601> constructor for convenience, and behaves just like an event handler for the <xref:System.Progress%601.ProgressChanged> event.</span></span> <span data-ttu-id="2383b-203">Statusupdates werden asynchron ausgelöst, um den asynchronen Vorgang zu verzögern, während der Ereignishandler ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="2383b-203">Progress updates are raised asynchronously to avoid delaying the asynchronous operation while event handlers are executing.</span></span> <span data-ttu-id="2383b-204">Eine andere <xref:System.IProgress%601>-Implementierung kann festlegen, dass andere Semantik anzuwenden ist.</span><span class="sxs-lookup"><span data-stu-id="2383b-204">Another <xref:System.IProgress%601> implementation could choose to apply different semantics.</span></span>  
  
## <a name="choosing-the-overloads-to-provide"></a><span data-ttu-id="2383b-205">Auswählen der bereitzustellenden Überladungen</span><span class="sxs-lookup"><span data-stu-id="2383b-205">Choosing the overloads to provide</span></span>  
 <span data-ttu-id="2383b-206">Verwendet eine TAP-Implementierung sowohl den optionalen Parameter <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> als auch den optionalen Parameter <xref:System.IProgress%601>, kann dies möglicherweise bis zu vier Überladungen erfordern:</span><span class="sxs-lookup"><span data-stu-id="2383b-206">If a TAP implementation uses both the optional <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> and optional <xref:System.IProgress%601> parameters, it could potentially require up to four overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
public Task MethodNameAsync(…, IProgress<T> progress);
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken cancellationToken) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="2383b-207">Viele TAP-Implementierungen bieten jedoch keine Abbruchs- oder Statusfunktionen und erfordern daher eine einzelne Methode:</span><span class="sxs-lookup"><span data-stu-id="2383b-207">However, many TAP implementations don't provide cancellation or progress capabilities, so they require a single method:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
```  
  
 <span data-ttu-id="2383b-208">Wenn eine TAP-Implementierung entweder Abbruch oder Status, jedoch nicht beides unterstützt, kann sie zwei Überladungen bereitstellen:</span><span class="sxs-lookup"><span data-stu-id="2383b-208">If a TAP implementation supports either cancellation or progress but not both, it may provide two overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
  
// … or …  
  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken) As Task  
  
' … or …  
  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="2383b-209">Wenn eine TAP-Implementierung Abbruch und Status unterstützt, kann sie alle vier Überladungen verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="2383b-209">If a TAP implementation supports both cancellation and progress, it may expose all four overloads.</span></span> <span data-ttu-id="2383b-210">Sie kann jedoch möglicherweise nur die Folgenden zwei bereitstellen:</span><span class="sxs-lookup"><span data-stu-id="2383b-210">However, it may provide only the following two:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="2383b-211">Als Ausgleich für die zwei fehlenden Zwischenkombinationen können Entwickler <xref:System.Threading.CancellationToken.None%2A> oder ein standardmäßiges <xref:System.Threading.CancellationToken> für den `cancellationToken`-Parameter und `null` für den `progress`-Parameter übergeben.</span><span class="sxs-lookup"><span data-stu-id="2383b-211">To compensate for the two missing intermediate combinations, developers may pass <xref:System.Threading.CancellationToken.None%2A> or a default <xref:System.Threading.CancellationToken> for the `cancellationToken` parameter and `null` for the `progress` parameter.</span></span>  
  
 <span data-ttu-id="2383b-212">Wenn Sie erwarten, dass jede Verwendung der TAP-Methode einen Abbruch oder Status unterstützt, können Sie die Überladungen weglassen, die den relevanten Parameter nicht akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="2383b-212">If you expect every usage of the TAP method to support cancellation or progress, you may omit the overloads that don't accept the relevant parameter.</span></span>  
  
 <span data-ttu-id="2383b-213">Wenn Sie mehrere Überladungen verfügbar machen, um einen Abbruch oder Status als optional zu konfigurieren, sollte das Verhalten der Überladungen, die einen Abbruch oder Status nicht unterstützen, dem Verhalten einer Überladung entsprechen, die <xref:System.Threading.CancellationToken.None%2A> für den Abbruch oder `null` für den Status an die Überladung übergibt, die diese Vorgänge jeweils unterstützt.</span><span class="sxs-lookup"><span data-stu-id="2383b-213">If you decide to expose multiple overloads to make cancellation or progress optional, the overloads that don't support cancellation or progress should behave as if they passed <xref:System.Threading.CancellationToken.None%2A> for cancellation or `null` for progress to the overload that does support these.</span></span>  
  
## <a name="related-articles"></a><span data-ttu-id="2383b-214">Verwandte Artikel</span><span class="sxs-lookup"><span data-stu-id="2383b-214">Related articles</span></span>
  
|<span data-ttu-id="2383b-215">Titel</span><span class="sxs-lookup"><span data-stu-id="2383b-215">Title</span></span>|<span data-ttu-id="2383b-216">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="2383b-216">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="2383b-217">Muster für die asynchrone Programmierung</span><span class="sxs-lookup"><span data-stu-id="2383b-217">Asynchronous Programming Patterns</span></span>](index.md)|<span data-ttu-id="2383b-218">Stellt die drei Muster zum Ausführen von asynchronen Vorgängen vor: das aufgabenbasierte asynchrone Muster (TAP), das asynchrone Programmiermodell (APM) und das ereignisbasierte asynchrone Muster (EAP).</span><span class="sxs-lookup"><span data-stu-id="2383b-218">Introduces the three patterns for performing asynchronous operations: the Task-based Asynchronous Pattern (TAP), the Asynchronous Programming Model (APM), and the Event-based Asynchronous Pattern (EAP).</span></span>|  
|[<span data-ttu-id="2383b-219">Implementieren des aufgabenbasierten asynchronen Entwurfsmusters</span><span class="sxs-lookup"><span data-stu-id="2383b-219">Implementing the Task-based Asynchronous Pattern</span></span>](implementing-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="2383b-220">Beschreibt, wie Sie das aufgabenbasierte asynchrone Muster (Task-based Asynchronous Pattern, TAP) auf drei Arten implementieren können: mit C# und den Visual Basic-Compilern in Visual Studio, manuell oder mit einer Kombination von Compilermethoden und manuellen Methoden.</span><span class="sxs-lookup"><span data-stu-id="2383b-220">Describes how to implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span>|  
|[<span data-ttu-id="2383b-221">Nutzen des aufgabenbasierten asynchronen Musters</span><span class="sxs-lookup"><span data-stu-id="2383b-221">Consuming the Task-based Asynchronous Pattern</span></span>](consuming-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="2383b-222">Beschreibt, wie Sie Aufgaben und Rückrufe verwenden können, um eine Verzögerung ohne Blockierung zu erreichen.</span><span class="sxs-lookup"><span data-stu-id="2383b-222">Describes how you can use tasks and callbacks to achieve waiting without blocking.</span></span>|  
|[<span data-ttu-id="2383b-223">Interoperabilität mit anderen asynchronen Mustern und Typen</span><span class="sxs-lookup"><span data-stu-id="2383b-223">Interop with Other Asynchronous Patterns and Types</span></span>](interop-with-other-asynchronous-patterns-and-types.md)|<span data-ttu-id="2383b-224">Beschreibt, wie das aufgabenbasierte asynchrone Muster (TAP) verwendet werden kann, um das asynchrone Programmiermodell (APM) und das ereignisbasierte asynchrone Muster (EAP) zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2383b-224">Describes how to use the Task-based Asynchronous Pattern (TAP) to implement the Asynchronous Programming Model (APM) and Event-based Asynchronous Pattern (EAP).</span></span>|
