---
title: Grundlagen der Garbage Collection
description: Erfahren Sie, wie der Garbage Collector funktioniert und wie er für eine optimale Leistung konfiguriert werden kann.
ms.date: 11/15/2019
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background
- garbage collection, concurrent
- garbage collection, server
- garbage collection, workstation
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
ms.openlocfilehash: 322e079a1be556efb536b24e216e480c1950bd8c
ms.sourcegitcommit: ef50c99928183a0bba75e07b9f22895cd4c480f8
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 08/07/2020
ms.locfileid: "87917030"
---
# <a name="fundamentals-of-garbage-collection"></a><span data-ttu-id="5aa6b-103">Grundlagen der Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="5aa6b-103">Fundamentals of garbage collection</span></span>

<span data-ttu-id="5aa6b-104">In der Common Language Runtime (CLR) dient der Garbage Collector (GC) als automatischer Speicher-Manager.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-104">In the common language runtime (CLR), the garbage collector (GC) serves as an automatic memory manager.</span></span> <span data-ttu-id="5aa6b-105">Der Garbage Collector verwaltet die Belegung und Freigabe von Arbeitsspeicher für eine Anwendung.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-105">The garbage collector manages the allocation and release of memory for an application.</span></span> <span data-ttu-id="5aa6b-106">Das bedeutet, dass beim Entwickeln mit verwaltetem Code kein Code für Aufgaben hinsichtlich der Speicherverwaltung geschrieben werden muss.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-106">For developers working with managed code, this means that you don't have to write code to perform memory management tasks.</span></span> <span data-ttu-id="5aa6b-107">Mithilfe der automatischen Speicherverwaltung können häufig auftretende Probleme beseitigt werden, z. B. wenn ein Objekt versehentlich nicht freigegeben wurde und dadurch Arbeitsspeicherverluste entstehen oder wenn auf den Speicher für ein Objekt zugegriffen wird, das bereits freigegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-107">Automatic memory management can eliminate common problems, such as forgetting to free an object and causing a memory leak or attempting to access memory for an object that's already been freed.</span></span>

<span data-ttu-id="5aa6b-108">In diesem Artikel werden die wichtigsten Konzepte der Garbage Collection beschrieben.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-108">This article describes the core concepts of garbage collection.</span></span>

## <a name="benefits"></a><span data-ttu-id="5aa6b-109">Vorteile</span><span class="sxs-lookup"><span data-stu-id="5aa6b-109">Benefits</span></span>

<span data-ttu-id="5aa6b-110">Der Garbage Collector bietet die folgenden Vorteile:</span><span class="sxs-lookup"><span data-stu-id="5aa6b-110">The garbage collector provides the following benefits:</span></span>

- <span data-ttu-id="5aa6b-111">Entwickler müssen nicht mehr manuell Arbeitsspeicher freigeben.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-111">Frees developers from having to manually release memory.</span></span>

- <span data-ttu-id="5aa6b-112">Ordnet dem verwalteten Heap effizient Objekte zu.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-112">Allocates objects on the managed heap efficiently.</span></span>

- <span data-ttu-id="5aa6b-113">Gibt Objekte frei, die nicht mehr verwendet werden, löscht den Speicher und hält Speicher für zukünftige Belegungen bereit.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-113">Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</span></span> <span data-ttu-id="5aa6b-114">Verwaltete Objekte beginnen automatisch mit einem bereinigten Inhalt, damit ihre Konstruktoren nicht jedes Datenfeld initialisieren müssen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-114">Managed objects automatically get clean content to start with, so their constructors don't have to initialize every data field.</span></span>

- <span data-ttu-id="5aa6b-115">Bietet Speichersicherheit, indem sichergestellt wird, dass ein Objekt den Inhalt eines anderen Objekts nicht verwenden kann.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-115">Provides memory safety by making sure that an object cannot use the content of another object.</span></span>

## <a name="fundamentals-of-memory"></a><span data-ttu-id="5aa6b-116">Grundlagen des Arbeitsspeichers</span><span class="sxs-lookup"><span data-stu-id="5aa6b-116">Fundamentals of memory</span></span>

<span data-ttu-id="5aa6b-117">Die folgende Liste liefert eine Zusammenfassung wichtiger Arbeitsspeicherkonzepte der CLR.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-117">The following list summarizes important CLR memory concepts.</span></span>

- <span data-ttu-id="5aa6b-118">Jeder Prozess verfügt über einen eigenen separaten virtuellen Adressraum.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-118">Each process has its own, separate virtual address space.</span></span> <span data-ttu-id="5aa6b-119">Alle Prozesse auf demselben Computer verwenden den gleichen physischen Speicher und die gleiche Auslagerungsdatei, sofern vorhanden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-119">All processes on the same computer share the same physical memory and the page file, if there is one.</span></span>

- <span data-ttu-id="5aa6b-120">In der Standardeinstellung verfügt jeder Prozess auf 32-Bit-Computern über einen virtuellen Adressraum von 2 GB im Benutzermodus.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-120">By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</span></span>

- <span data-ttu-id="5aa6b-121">Als Anwendungsentwickler arbeiten Sie immer mit einem virtuellem Adressraum und manipulieren niemals direkt den physischen Speicher.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-121">As an application developer, you work only with virtual address space and never manipulate physical memory directly.</span></span> <span data-ttu-id="5aa6b-122">Der Garbage Collector belegt und gibt virtuellen Arbeitsspeicher auf dem verwalteten Heap frei.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-122">The garbage collector allocates and frees virtual memory for you on the managed heap.</span></span>

  <span data-ttu-id="5aa6b-123">Wenn Sie nativen Code schreiben, verwenden Sie die Windows-Funktionen für das Arbeiten mit dem virtuellen Adressraum.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-123">If you're writing native code, you use Windows functions to work with the virtual address space.</span></span> <span data-ttu-id="5aa6b-124">Diese Funktionen belegen und geben für Sie virtuellen Arbeitsspeicher auf systemeigenen Heaps frei.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-124">These functions allocate and free virtual memory for you on native heaps.</span></span>

- <span data-ttu-id="5aa6b-125">Virtueller Arbeitsspeicher kann sich in einem von drei Zuständen befinden:</span><span class="sxs-lookup"><span data-stu-id="5aa6b-125">Virtual memory can be in three states:</span></span>

  | <span data-ttu-id="5aa6b-126">Zustand</span><span class="sxs-lookup"><span data-stu-id="5aa6b-126">State</span></span> | <span data-ttu-id="5aa6b-127">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="5aa6b-127">Description</span></span> |
  |---------|---------|
  | <span data-ttu-id="5aa6b-128">Kostenlos</span><span class="sxs-lookup"><span data-stu-id="5aa6b-128">Free</span></span> | <span data-ttu-id="5aa6b-129">Es sind keine Verweise auf den Speicherblock vorhanden, und der Speicherblock ist für eine Speicherbelegung verfügbar.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-129">The block of memory has no references to it and is available for allocation.</span></span> |
  | <span data-ttu-id="5aa6b-130">Reserviert</span><span class="sxs-lookup"><span data-stu-id="5aa6b-130">Reserved</span></span> | <span data-ttu-id="5aa6b-131">Der Speicherblock ist für die Verwendung verfügbar und kann nicht durch andere Anforderungen belegt werden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-131">The block of memory is available for your use and cannot be used for any other allocation request.</span></span> <span data-ttu-id="5aa6b-132">Sie können jedoch keine Daten in diesem Speicherblock speichern, bis eine Zusicherung erfolgt ist.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-132">However, you cannot store data to this memory block until it is committed.</span></span> |
  | <span data-ttu-id="5aa6b-133">Committet</span><span class="sxs-lookup"><span data-stu-id="5aa6b-133">Committed</span></span> | <span data-ttu-id="5aa6b-134">Der Speicherblock ist einem physischen Speicher zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-134">The block of memory is assigned to physical storage.</span></span> |

- <span data-ttu-id="5aa6b-135">Im virtuellen Adressraum können Fragmentierungen auftreten.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-135">Virtual address space can get fragmented.</span></span> <span data-ttu-id="5aa6b-136">Das bedeutet, dass freie Blöcke (Lücken) im Adressraum vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-136">This means that there are free blocks, also known as holes, in the address space.</span></span> <span data-ttu-id="5aa6b-137">Wenn eine virtuelle Speicherbelegung angefordert wird, muss der Manager für virtuellen Arbeitsspeicher einen einzelnen freien Block finden, der groß genug ist, um die Belegungsanforderung zu erfüllen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-137">When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</span></span> <span data-ttu-id="5aa6b-138">Selbst wenn 2 GB freier Speicherplatz verfügbar sind, schlägt eine Speicherbelegung, die 2 GB angefordert hat, fehl, wenn der freie Speicherplatz nicht in einem einzelnen Adressblock verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-138">Even if you have 2 GB of free space, an allocation that requires 2 GB will be unsuccessful unless all of that free space is in a single address block.</span></span>

- <span data-ttu-id="5aa6b-139">Es kann vorkommen, dass nicht mehr genügend Arbeitsspeicher zur Verfügung steht, weil der für Belegungen verfügbare virtuelle Adressraum oder der für Zusicherungen verfügbare physische Speicher nicht mehr ausreicht.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-139">You can run out of memory if there isn't enough virtual address space to reserve or physical space to commit.</span></span>

  <span data-ttu-id="5aa6b-140">Die Auslagerungsdatei wird auch dann verwendet, wenn der tatsächliche physische Speicherbedarf insgesamt eher niedrig ist.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-140">The page file is used even if physical memory pressure (that is, demand for physical memory) is low.</span></span> <span data-ttu-id="5aa6b-141">Wenn das erste Mal eine hohe physische Speicherauslastung auftritt, muss das Betriebssystem im physischen Speicher freien Platz für die Datenspeicherung schaffen. Zu diesem Zweck werden einige Daten aus dem physischen Speicher in die Auslagerungsdatei verschoben.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-141">The first time that physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</span></span> <span data-ttu-id="5aa6b-142">Für diese Daten erfolgt solange keine neue Speicherzuordnung, bis sie tatsächlich benötigt werden. Daher können Situationen entstehen, in denen auch bei einer geringen physischen Speicherauslastung Daten in der Auslagerungsdatei abgelegt sind.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-142">That data is not paged until it's needed, so it's possible to encounter paging in situations where the physical memory pressure is low.</span></span>
  
### <a name="memory-allocation"></a><span data-ttu-id="5aa6b-143">Arbeitsspeicherbelegung</span><span class="sxs-lookup"><span data-stu-id="5aa6b-143">Memory allocation</span></span>

<span data-ttu-id="5aa6b-144">Wenn Sie einen neuen Prozess initialisieren, wird diesem durch die Common Language Runtime ein zusammenhängender Adressraum reserviert.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-144">When you initialize a new process, the runtime reserves a contiguous region of address space for the process.</span></span> <span data-ttu-id="5aa6b-145">Dieser reservierte Adressraum wird als verwalteter Heap bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-145">This reserved address space is called the managed heap.</span></span> <span data-ttu-id="5aa6b-146">Im verwalteten Heap steht ein Zeiger zur Verfügung, der auf die Adresse des nächsten im Heap zu speichernden Objekts zeigt.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-146">The managed heap maintains a pointer to the address where the next object in the heap will be allocated.</span></span> <span data-ttu-id="5aa6b-147">Anfangs ist dieser Zeiger auf die Basisadresse des verwalteten Heaps eingestellt.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-147">Initially, this pointer is set to the managed heap's base address.</span></span> <span data-ttu-id="5aa6b-148">Alle Referenztypen werden im verwalteten Heap zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-148">All reference types are allocated on the managed heap.</span></span> <span data-ttu-id="5aa6b-149">Wurde von einer Anwendung der erste Referenztyp erstellt, wird für diesen Typ an der Basisadresse des verwalteten Heaps Speicherplatz belegt.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-149">When an application creates the first reference type, memory is allocated for the type at the base address of the managed heap.</span></span> <span data-ttu-id="5aa6b-150">Wenn das nächste Objekt von der Anwendung erstellt wird, belegt der Garbage Collector Speicherplatz im Adressraum direkt hinter dem ersten Objekt.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-150">When the application creates the next object, the garbage collector allocates memory for it in the address space immediately following the first object.</span></span> <span data-ttu-id="5aa6b-151">Solange ein Adressbereich verfügbar ist, fährt der Garbage Collector auf diese Weise mit der Belegung von Arbeitsspeicher für neue Objekte fort.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-151">As long as address space is available, the garbage collector continues to allocate space for new objects in this manner.</span></span>

<span data-ttu-id="5aa6b-152">Das Belegen von Speicher im verwalteten Heap beansprucht weniger Zeit als die nicht verwaltete Speicherbelegung.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-152">Allocating memory from the managed heap is faster than unmanaged memory allocation.</span></span> <span data-ttu-id="5aa6b-153">Da durch die Common Language Runtime Speicher für ein Objekt durch Hinzufügen eines Werts zu einem Zeiger belegt wird, ist diese Methode fast so schnell wie das Reservieren von Speicher im Stapel.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-153">Because the runtime allocates memory for an object by adding a value to a pointer, it's almost as fast as allocating memory from the stack.</span></span> <span data-ttu-id="5aa6b-154">Außerdem werden neue Objekte, für die Speicher reserviert wird, ständig nacheinander im verwalteten Heap gespeichert. Dadurch kann eine Anwendung schnell auf diese Objekte zugreifen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-154">In addition, because new objects that are allocated consecutively are stored contiguously in the managed heap, an application can access the objects quickly.</span></span>

### <a name="memory-release"></a><span data-ttu-id="5aa6b-155">Speicherfreigabe</span><span class="sxs-lookup"><span data-stu-id="5aa6b-155">Memory release</span></span>

<span data-ttu-id="5aa6b-156">Durch die Optimierungs-Engine des Garbage Collectors wird der beste Zeitpunkt für das Ausführen einer Garbage Collection bestimmt, die auf den erfolgten Speicherbelegungen basiert.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-156">The garbage collector's optimizing engine determines the best time to perform a collection based on the allocations being made.</span></span> <span data-ttu-id="5aa6b-157">Beim Ausführen einer Garbage Collection wird Speicher freigegeben, den von der Anwendung nicht mehr benötigte Objekte beanspruchen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-157">When the garbage collector performs a collection, it releases the memory for objects that are no longer being used by the application.</span></span> <span data-ttu-id="5aa6b-158">Durch Überprüfen der *Stammelemente* der Anwendung wird ermittelt, welche Objekte nicht mehr verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-158">It determines which objects are no longer being used by examining the application's *roots*.</span></span> <span data-ttu-id="5aa6b-159">Die Stammelemente einer Anwendung beinhalten statische Felder, lokale Variablen und Parameter im Stapel des Threads sowie CPU-Register.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-159">An application's roots include static fields, local variables and parameters on a thread's stack, and CPU registers.</span></span> <span data-ttu-id="5aa6b-160">Jedes Stammelement bezieht sich entweder auf ein Objekt im verwalteten Heap oder ist auf NULL festgelegt.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-160">Each root either refers to an object on the managed heap or is set to null.</span></span> <span data-ttu-id="5aa6b-161">Der Garbage Collector hat Zugriff auf eine Liste der aktiven Stammelemente, die vom JIT-Compiler (Just-In-Time) und der Common Language Runtime verwaltet wird.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-161">The garbage collector has access to the list of active roots that the just-in-time (JIT) compiler and the runtime maintain.</span></span> <span data-ttu-id="5aa6b-162">Mithilfe dieser Liste erstellt der Garbage Collector ein Diagramm mit allen Objekten, die von den Stammelementen aus erreichbar sind.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-162">Using this list, the garbage collector creates a graph that contains all the objects that are reachable from the roots.</span></span>

<span data-ttu-id="5aa6b-163">Objekte, die nicht in diesem Diagramm aufgeführt werden, können von den Stammelementen aus nicht erreicht werden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-163">Objects that are not in the graph are unreachable from the application's roots.</span></span> <span data-ttu-id="5aa6b-164">Diese nicht erreichbaren Objekte werden vom Garbage Collector als Abfall betrachtet, und der von diesen Objekten belegte Speicherplatz wird wieder freigegeben.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-164">The garbage collector considers unreachable objects garbage and releases the memory allocated for them.</span></span> <span data-ttu-id="5aa6b-165">Während einer Garbage Collection wird der verwaltete Heap nach den Blöcken des Adressraums durchsucht, in denen sich nicht erreichbare Objekte befinden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-165">During a collection, the garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</span></span> <span data-ttu-id="5aa6b-166">Beim Auffinden dieser Objekte werden die erreichbaren Objekte mithilfe einer Speicherkopierfunktion im Speicher komprimiert, und die von den nicht erreichbaren Objekten belegten Blöcke des Adressraums werden freigegeben.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-166">As it discovers each unreachable object, it uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</span></span> <span data-ttu-id="5aa6b-167">Nach dem Komprimieren des Speichers für die erreichbaren Objekte werden vom Garbage Collector die erforderlichen Korrekturen am Zeiger vorgenommen, sodass die Stammelemente der Anwendung auf die neuen Speicherorte der Objekte verweisen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-167">Once the memory for the reachable objects has been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</span></span> <span data-ttu-id="5aa6b-168">Außerdem wird der Zeiger des verwalteten Heaps auf die Position hinter dem letzten erreichbaren Objekt gesetzt.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-168">It also positions the managed heap's pointer after the last reachable object.</span></span>

<span data-ttu-id="5aa6b-169">Der Speicher wird nur dann komprimiert, wenn in der Garbage Collection eine signifikante Anzahl nicht erreichbarer Objekte gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-169">Memory is compacted only if a collection discovers a significant number of unreachable objects.</span></span> <span data-ttu-id="5aa6b-170">Wenn nach einer Garbage Collection alle Objekte in einem verwalteten Heap verbleiben, bedarf es auch keiner Speicherkomprimierung.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-170">If all the objects in the managed heap survive a collection, then there is no need for memory compaction.</span></span>

<span data-ttu-id="5aa6b-171">Um die Leistung zu verbessern, wird für große Objekte durch die Common Language Runtime Speicherplatz in einem separaten Heap belegt.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-171">To improve performance, the runtime allocates memory for large objects in a separate heap.</span></span> <span data-ttu-id="5aa6b-172">Der Speicherplatz für große Objekte wird durch den Garbage Collector automatisch freigegeben.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-172">The garbage collector automatically releases the memory for large objects.</span></span> <span data-ttu-id="5aa6b-173">Dieser Speicher wird jedoch nicht komprimiert, um das Verschieben großer Objekte im Speicher zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-173">However, to avoid moving large objects in memory, this memory is usually not compacted.</span></span>

## <a name="conditions-for-a-garbage-collection"></a><span data-ttu-id="5aa6b-174">Bedingungen für eine Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="5aa6b-174">Conditions for a garbage collection</span></span>

<span data-ttu-id="5aa6b-175">Eine Garbage Collection wird durchgeführt, wenn eine der folgenden Bedingungen zutrifft:</span><span class="sxs-lookup"><span data-stu-id="5aa6b-175">Garbage collection occurs when one of the following conditions is true:</span></span>

- <span data-ttu-id="5aa6b-176">Das System verfügt über einen kleinen physikalischen Speicher.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-176">The system has low physical memory.</span></span> <span data-ttu-id="5aa6b-177">Dies wird entweder durch die Meldung des Betriebssystems über zu wenig Arbeitsspeicher oder durch die Meldung des Hosts über zu wenig Arbeitsspeicher erkannt.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-177">This is detected by either the low memory notification from the OS or low memory as indicated by the host.</span></span>

- <span data-ttu-id="5aa6b-178">Der Speicher, der von den zugeordneten Objekten auf dem verwalteten Heap belegt ist, übersteigt einen akzeptablen Schwellenwert.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-178">The memory that's used by allocated objects on the managed heap surpasses an acceptable threshold.</span></span> <span data-ttu-id="5aa6b-179">Dieser Schwellenwert wird während der Prozessausführung kontinuierlich angepasst.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-179">This threshold is continuously adjusted as the process runs.</span></span>

- <span data-ttu-id="5aa6b-180">Die <xref:System.GC.Collect%2A?displayProperty=nameWithType> -Methode wird aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-180">The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="5aa6b-181">In fast allen Fällen müssen Sie diese Methode nicht aufrufen, da der Garbage Collector kontinuierlich ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-181">In almost all cases, you don't have to call this method, because the garbage collector runs continuously.</span></span> <span data-ttu-id="5aa6b-182">Diese Methode wird hauptsächlich für eindeutige Situationen und für Tests verwendet.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-182">This method is primarily used for unique situations and testing.</span></span>

## <a name="the-managed-heap"></a><span data-ttu-id="5aa6b-183">Der verwaltete Heap</span><span class="sxs-lookup"><span data-stu-id="5aa6b-183">The managed heap</span></span>

<span data-ttu-id="5aa6b-184">Nachdem der Garbage Collector von der CLR initialisiert wurde, belegt er ein Arbeitsspeichersegment für die Speicherung und Verwaltung von Objekten.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-184">After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</span></span> <span data-ttu-id="5aa6b-185">Dieser Speicher wird als verwalteter Heap bezeichnet, im Gegensatz zu einem systemeigenen Heap im Betriebssystem.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-185">This memory is called the managed heap, as opposed to a native heap in the operating system.</span></span>

<span data-ttu-id="5aa6b-186">Es gibt einen verwalteten Heap für jeden verwalteten Prozess.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-186">There is a managed heap for each managed process.</span></span> <span data-ttu-id="5aa6b-187">Alle Threads im Prozess ordnen Speicher zu, für Objekte auf dem gleichen Heap.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-187">All threads in the process allocate memory for objects on the same heap.</span></span>

<span data-ttu-id="5aa6b-188">Zum Reservieren von Speicher ruft der Garbage Collector die [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)-Windows-Funktion auf und reserviert jeweils ein Segment des Speichers für verwaltete Anwendungen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-188">To reserve memory, the garbage collector calls the Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function and reserves one segment of memory at a time for managed applications.</span></span> <span data-ttu-id="5aa6b-189">Zudem reserviert der Garbage Collector nach Bedarf weitere Segmente und gibt Segmente wieder für das Betriebssystem frei (nachdem alle Objekte aus diesen entfernt wurden), indem er die [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree)-Windows-Funktion aufruft.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-189">The garbage collector also reserves segments, as needed, and releases segments back to the operating system (after clearing them of any objects) by calling the Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) function.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5aa6b-190">Die Größe der Segmente, die vom Garbage Collector zugeordnet werden, ist implementierungsspezifisch und kann jederzeit, auch in regelmäßigen Updates, geändert werden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-190">The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</span></span> <span data-ttu-id="5aa6b-191">Für eine Anwendung darf weder eine bestimmte Segmentgröße vorausgesetzt werden, noch darf sie von einer bestimmten Segmentgröße abhängen noch darf in ihr versucht werden, die Menge des für Segmentbelegungen verfügbaren Speichers zu konfigurieren.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-191">Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</span></span>

<span data-ttu-id="5aa6b-192">Je weniger Objekte dem Heap zugeordnet sind, desto geringer ist der Arbeitsaufwand für den Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-192">The fewer objects allocated on the heap, the less work the garbage collector has to do.</span></span> <span data-ttu-id="5aa6b-193">Verwenden Sie beim Zuordnen von Objekten keine aufgerundeten Werte, die größer sind als die tatsächlichen Anforderungen. Belegen Sie z. B. kein Array von 32 Byte, wenn Sie nur 15 Byte benötigen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-193">When you allocate objects, don't use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</span></span>

<span data-ttu-id="5aa6b-194">Wenn eine Garbage Collection ausgelöst wird, gibt der Garbage Collector den Speicher frei, der von inaktiven Objekten belegt wird.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-194">When a garbage collection is triggered, the garbage collector reclaims the memory that's occupied by dead objects.</span></span> <span data-ttu-id="5aa6b-195">Bei der Freigabe von Speicher werden aktive Objekte komprimiert, damit sie zusammen verschoben werden, und der inaktive Speicherplatz wird entfernt, sodass der Heap kleiner wird.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-195">The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</span></span> <span data-ttu-id="5aa6b-196">Dadurch wird sichergestellt, dass gemeinsam zugeordnete Objekte auf dem verwalteten Heap zusammenbleiben, um ihren Speicherort beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-196">This ensures that objects that are allocated together stay together on the managed heap to preserve their locality.</span></span>

<span data-ttu-id="5aa6b-197">Die Intrusivität (Häufigkeit und Dauer) von Garbage Collections wird bestimmt durch den Umfang der Speicherbelegungen und der Größe des beibehaltenen Speichers auf dem verwalteten Heap.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-197">The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</span></span>

<span data-ttu-id="5aa6b-198">Der Heap kann als Ansammlung von zwei Heaps betrachtet werden: der [große Objektheap](large-object-heap.md) und der kleine Objektheap.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-198">The heap can be considered as the accumulation of two heaps: the [large object heap](large-object-heap.md) and the small object heap.</span></span> <span data-ttu-id="5aa6b-199">Der große Objektheap enthält Objekte, die mindestens 85.000 Bytes oder mehr umfassen und bei denen es sich in der Regel um Arrays handelt.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-199">The large object heap contains objects that are 85,000 bytes and larger, which are usually arrays.</span></span> <span data-ttu-id="5aa6b-200">Ein Instanzobjekt ist meistens nicht sehr groß.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-200">It's rare for an instance object to be extremely large.</span></span>

> [!TIP]
> <span data-ttu-id="5aa6b-201">Sie können [den Schwellenwert](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) für die Objekte im großen Objektheap festlegen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-201">You can [configure the threshold size](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) for objects to go on the large object heap.</span></span>

## <a name="generations"></a><span data-ttu-id="5aa6b-202">Generationen</span><span class="sxs-lookup"><span data-stu-id="5aa6b-202">Generations</span></span>

<span data-ttu-id="5aa6b-203">Der GC-Algorithmus basiert auf mehreren Überlegungen:</span><span class="sxs-lookup"><span data-stu-id="5aa6b-203">The GC algorithm is based on several considerations:</span></span>

- <span data-ttu-id="5aa6b-204">Die Garbage Collection kann schneller ausgeführt werden, wenn der Speicher nur in einem Teil des verwalteten Heaps und nicht im gesamten Heap komprimiert wird.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-204">It's faster to compact the memory for a portion of the managed heap than for the entire managed heap.</span></span>
- <span data-ttu-id="5aa6b-205">Neuere Objekte haben eine kürzere, ältere Objekte hingegen eine längere Lebensdauer.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-205">Newer objects have shorter lifetimes and older objects have longer lifetimes.</span></span>
- <span data-ttu-id="5aa6b-206">Neuere Objekte tendieren dazu, miteinander in Beziehung zu stehen, und die Anwendung greift etwa zur gleichen Zeit auf sie zu.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-206">Newer objects tend to be related to each other and accessed by the application around the same time.</span></span>

<span data-ttu-id="5aa6b-207">Die Garbage Collection wird hauptsächlich in Verbindung mit der Freigabe kurzlebiger Objekte ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-207">Garbage collection primarily occurs with the reclamation of short-lived objects.</span></span> <span data-ttu-id="5aa6b-208">Der verwaltete Heap wird zur Leistungsoptimierung des Garbage Collectors in die drei Generationen 0, 1 und 2 unterteilt, sodass er langlebige und kurzlebige Objekte separat verarbeiten kann.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-208">To optimize the performance of the garbage collector, the managed heap is divided into three generations, 0, 1, and 2, so it can handle long-lived and short-lived objects separately.</span></span> <span data-ttu-id="5aa6b-209">Der Garbage Collector speichert neue Objekte in Generation 0.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-209">The garbage collector stores new objects in generation 0.</span></span> <span data-ttu-id="5aa6b-210">Objekte, die früh in der Lebensdauer der Anwendung erstellt wurden und nach den Garbage Collections noch vorhanden sind, werden höher gestuft und werden in Generationen 1 und 2 gespeichert.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-210">Objects created early in the application's lifetime that survive collections are promoted and stored in generations 1 and 2.</span></span> <span data-ttu-id="5aa6b-211">Da es weniger Zeit beansprucht, statt des gesamten verwalteten Heaps nur einen Teil davon zu komprimieren, ist es bei diesem Konzept auch möglich, bei einer Garbage Collection lediglich Speicher einer bestimmten Generationsstufe und nicht den des gesamten verwalteten Heaps freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-211">Because it's faster to compact a portion of the managed heap than the entire heap, this scheme allows the garbage collector to release the memory in a specific generation rather than release the memory for the entire managed heap each time it performs a collection.</span></span>

- <span data-ttu-id="5aa6b-212">**Generation 0**.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-212">**Generation 0**.</span></span> <span data-ttu-id="5aa6b-213">Dies ist die jüngste Generation, die kurzlebige Objekte enthält.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-213">This is the youngest generation and contains short-lived objects.</span></span> <span data-ttu-id="5aa6b-214">Ein Beispiel für ein kurzlebiges Objekt ist eine temporäre Variable.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-214">An example of a short-lived object is a temporary variable.</span></span> <span data-ttu-id="5aa6b-215">Die Garbage Collection tritt am häufigsten in dieser Generation auf.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-215">Garbage collection occurs most frequently in this generation.</span></span>

  <span data-ttu-id="5aa6b-216">Neu zugeordnete Objekte bilden eine neue Generation von Objekten und sind implizit Sammlungen der Generation 0.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-216">Newly allocated objects form a new generation of objects and are implicitly generation 0 collections.</span></span> <span data-ttu-id="5aa6b-217">Wenn es sich jedoch um große Objekte handelt, werden sie im großen Objektheap verwaltet, der manchmal auch als *Generation 3* bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-217">However, if they are large objects, they go on the large object heap (LOH), which is sometimes referred to as *generation 3*.</span></span> <span data-ttu-id="5aa6b-218">Generation 3 ist eine physische Generation, die logisch als Teil der Generation 2 erfasst wird.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-218">Generation 3 is a physical generation that's logically collected as part of generation 2.</span></span>

  <span data-ttu-id="5aa6b-219">Die meisten Objekte werden bei einer Garbage Collection für Generation 0 freigegeben und bleiben nicht bis zur nächsten Generation aktiv.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-219">Most objects are reclaimed for garbage collection in generation 0 and don't survive to the next generation.</span></span>
  
  <span data-ttu-id="5aa6b-220">Wenn Generation 0 voll ist und eine Anwendung versucht, ein neues Objekt zu erstellen, führt der Garbage Collector eine Collection durch, um Adressraum für das neue Objekt freizugeben.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-220">If an application attempts to create a new object when generation 0 is full, the garbage collector performs a collection in an attempt to free address space for the object.</span></span> <span data-ttu-id="5aa6b-221">Dabei werden nur die Objekte im Bereich der Generation 0 untersucht und nicht alle Objekte im verwalteten Heap.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-221">The garbage collector starts by examining the objects in generation 0 rather than all objects in the managed heap.</span></span> <span data-ttu-id="5aa6b-222">Eine Garbage Collection für Generation 0 liefert oftmals ausreichend Speicherplatz, sodass von der Anwendung weitere neue Objekte erzeugt werden können.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-222">A collection of generation 0 alone often reclaims enough memory to enable the application to continue creating new objects.</span></span>

- <span data-ttu-id="5aa6b-223">**Generation 1**.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-223">**Generation 1**.</span></span> <span data-ttu-id="5aa6b-224">Diese Generation enthält kurzlebige Objekte und dient als Puffer zwischen kurzlebigen Objekten und langlebigen Objekten.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-224">This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</span></span>

  <span data-ttu-id="5aa6b-225">Nach Durchführung einer Garbage Collection für Generation 0 wird der Speicher für die erreichbaren Objekte komprimiert, die dann auf Generation 1 hochgestuft werden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-225">After the garbage collector performs a collection of generation 0, it compacts the memory for the reachable objects and promotes them to generation 1.</span></span> <span data-ttu-id="5aa6b-226">Da Objekte, die nach Garbage Collections noch vorhanden sind, normalerweise längere Lebensdauern haben, ist es sinnvoll, sie auf eine höhere Generation heraufzustufen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-226">Because objects that survive collections tend to have longer lifetimes, it makes sense to promote them to a higher generation.</span></span> <span data-ttu-id="5aa6b-227">Der Garbage Collector muss die Objekte in Generation 1 und 2 nicht jedes Mal aufs Neue untersuchen, wenn eine Collection für Generation 0 durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-227">The garbage collector doesn't have to reexamine the objects in generations 1 and 2 each time it performs a collection of generation 0.</span></span>
  
  <span data-ttu-id="5aa6b-228">Wenn eine Garbage Collection für Generation 0 nicht genug Speicher für die Anwendung zum Erstellen eines neuen Objekts freigibt, kann der Garbage Collector zunächst eine Collection für Generation 1 und anschließend für Generation 2 durchführen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-228">If a collection of generation 0 does not reclaim enough memory for the application to create a new object, the garbage collector can perform a collection of generation 1, then generation 2.</span></span> <span data-ttu-id="5aa6b-229">Objekte in Generation 1, die nach den Garbage Collections noch vorhanden sind, werden auf Generation 2 hochgestuft.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-229">Objects in generation 1 that survive collections are promoted to generation 2.</span></span>

- <span data-ttu-id="5aa6b-230">**Generation 2**.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-230">**Generation 2**.</span></span> <span data-ttu-id="5aa6b-231">Diese Generation enthält langlebige Objekte.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-231">This generation contains long-lived objects.</span></span> <span data-ttu-id="5aa6b-232">Ein Beispiel für ein langlebiges Objekt ist ein Objekt in einer Serveranwendung, das statische Daten enthält, die für die Dauer des Prozesses aktiv sind.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-232">An example of a long-lived object is an object in a server application that contains static data that's live for the duration of the process.</span></span>

  <span data-ttu-id="5aa6b-233">Objekte in Generation 2, die nach einer Collection noch vorhanden sind, bleiben in Generation 2, bis sie in einer künftigen Collection als nicht erreichbar erkannt werden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-233">Objects in generation 2 that survive a collection remain in generation 2 until they are determined to be unreachable in a future collection.</span></span>
  
  <span data-ttu-id="5aa6b-234">Objekte im großen Objektheap (manchmal auch als *Generation 3* bezeichnet) werden auch in Generation 2 gesammelt.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-234">Objects on the large object heap (which is sometimes referred to as *generation 3* ) are also collected in generation 2.</span></span>

<span data-ttu-id="5aa6b-235">Garbage Collections finden für bestimmte Generationen statt, wenn die Bedingungen dies erfordern.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-235">Garbage collections occur on specific generations as conditions warrant.</span></span> <span data-ttu-id="5aa6b-236">Das Durchführen einer Sammlung für eine Generation bedeutet, dass Objekte in dieser Generation und in allen jüngeren Generationen gesammelt werden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-236">Collecting a generation means collecting objects in that generation and all its younger generations.</span></span> <span data-ttu-id="5aa6b-237">Eine Garbage Collection für Generation 2 wird auch als vollständige Garbage Collection bezeichnet, da hierbei alle Objekte in allen Generationen (d. h. alle Objekte im verwalteten Heap) freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-237">A generation 2 garbage collection is also known as a full garbage collection, because it reclaims objects in all generations (that is, all objects in the managed heap).</span></span>

### <a name="survival-and-promotions"></a><span data-ttu-id="5aa6b-238">Beibehaltene Objekte und Höherstufungen</span><span class="sxs-lookup"><span data-stu-id="5aa6b-238">Survival and promotions</span></span>

<span data-ttu-id="5aa6b-239">Objekte, die bei einer Garbage Collection nicht freigegeben werden, werden als beibehaltene Objekte bezeichnet und auf die nächste Generation hochgestuft.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-239">Objects that are not reclaimed in a garbage collection are known as survivors and are promoted to the next generation:</span></span>

- <span data-ttu-id="5aa6b-240">Objekte, die nach einer Garbage Collection für Generation 0 noch vorhanden sind, werden auf Generation 1 hochgestuft.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-240">Objects that survive a generation 0 garbage collection are promoted to generation 1.</span></span>
- <span data-ttu-id="5aa6b-241">Objekte, die nach einer Garbage Collection für Generation 1 noch vorhanden sind, werden auf Generation 2 hochgestuft.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-241">Objects that survive a generation 1 garbage collection are promoted to generation 2.</span></span>
- <span data-ttu-id="5aa6b-242">Objekte, die nach einer Garbage Collection für Generation 2 noch vorhanden sind, bleiben in Generation 2.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-242">Objects that survive a generation 2 garbage collection remain in generation 2.</span></span>

<span data-ttu-id="5aa6b-243">Wenn der Garbage Collector erkennt, dass die Rate der beibehaltenen Objekte in einer Generation hoch ist, erhöht er den Schwellenwert der Zuteilungen für diese Generation.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-243">When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation.</span></span> <span data-ttu-id="5aa6b-244">Somit wird bei der nächsten Garbage Collection eine beträchtliche Menge an Speicherplatz freigegeben.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-244">The next collection gets a substantial size of reclaimed memory.</span></span> <span data-ttu-id="5aa6b-245">Die CLR wägt ständig zwei Prioritäten gegeneinander ab: Zum einen soll das Workingset einer Anwendung durch die Verzögerung der Garbage Collection nicht zu groß werden, und zum anderen soll die Garbage Collection nicht zu häufig ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-245">The CLR continually balances two priorities: not letting an application's working set get too large by delaying garbage collection and not letting the garbage collection run too frequently.</span></span>

### <a name="ephemeral-generations-and-segments"></a><span data-ttu-id="5aa6b-246">Kurzlebige Generationen und Segmente</span><span class="sxs-lookup"><span data-stu-id="5aa6b-246">Ephemeral generations and segments</span></span>

<span data-ttu-id="5aa6b-247">Da Objekte in Generation 0 und 1 kurzlebig sind, werden diese Generationen als *kurzlebige Generationen* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-247">Because objects in generations 0 and 1 are short-lived, these generations are known as the *ephemeral generations*.</span></span>

<span data-ttu-id="5aa6b-248">Kurzlebige Generationen belegen das Speichersegment, das als kurzlebiges Segment bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-248">Ephemeral generations are allocated in the memory segment that's known as the ephemeral segment.</span></span> <span data-ttu-id="5aa6b-249">Jedes neue vom Garbage Collector abgerufene Segment wird das neue kurzlebige Segment und enthält die Objekte, die nach einer Garbage Collection in Generation 0 noch bestehen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-249">Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</span></span> <span data-ttu-id="5aa6b-250">Das alte kurzlebige Segment wird das neue Segment der Generation 2.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-250">The old ephemeral segment becomes the new generation 2 segment.</span></span>

<span data-ttu-id="5aa6b-251">Die Größe des kurzlebigen Segments variiert abhängig davon, ob es sich um ein 32-Bit- oder ein 64-Bit-System handelt und welchen Typ der Garbage Collector aufweist, der ausgeführt wird ([Garbage Collection für Arbeitsstation oder Server](workstation-server-gc.md)).</span><span class="sxs-lookup"><span data-stu-id="5aa6b-251">The size of the ephemeral segment varies depending on whether a system is 32-bit or 64-bit and on the type of garbage collector it is running ([workstation or server GC](workstation-server-gc.md)).</span></span> <span data-ttu-id="5aa6b-252">Die folgende Tabelle zeigt die Standardgrößen des kurzlebigen Segments.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-252">The following table shows the default sizes of the ephemeral segment.</span></span>

|<span data-ttu-id="5aa6b-253">Garbage Collection für Arbeitsstationen oder Server</span><span class="sxs-lookup"><span data-stu-id="5aa6b-253">Workstation/server GC</span></span>|<span data-ttu-id="5aa6b-254">32-Bit</span><span class="sxs-lookup"><span data-stu-id="5aa6b-254">32-bit</span></span>|<span data-ttu-id="5aa6b-255">64-Bit</span><span class="sxs-lookup"><span data-stu-id="5aa6b-255">64-bit</span></span>|
|-|-------------|-------------|
|<span data-ttu-id="5aa6b-256">Arbeitsstation-GC</span><span class="sxs-lookup"><span data-stu-id="5aa6b-256">Workstation GC</span></span>|<span data-ttu-id="5aa6b-257">16 MB</span><span class="sxs-lookup"><span data-stu-id="5aa6b-257">16 MB</span></span>|<span data-ttu-id="5aa6b-258">256 MB</span><span class="sxs-lookup"><span data-stu-id="5aa6b-258">256 MB</span></span>|
|<span data-ttu-id="5aa6b-259">Server-GC</span><span class="sxs-lookup"><span data-stu-id="5aa6b-259">Server GC</span></span>|<span data-ttu-id="5aa6b-260">64 MB</span><span class="sxs-lookup"><span data-stu-id="5aa6b-260">64 MB</span></span>|<span data-ttu-id="5aa6b-261">4 GB</span><span class="sxs-lookup"><span data-stu-id="5aa6b-261">4 GB</span></span>|
|<span data-ttu-id="5aa6b-262">Server-GC mit > 4 logischen CPUs</span><span class="sxs-lookup"><span data-stu-id="5aa6b-262">Server GC with > 4 logical CPUs</span></span>|<span data-ttu-id="5aa6b-263">32 MB</span><span class="sxs-lookup"><span data-stu-id="5aa6b-263">32 MB</span></span>|<span data-ttu-id="5aa6b-264">2 GB</span><span class="sxs-lookup"><span data-stu-id="5aa6b-264">2 GB</span></span>|
|<span data-ttu-id="5aa6b-265">Server-GC mit > 8 logischen CPUs</span><span class="sxs-lookup"><span data-stu-id="5aa6b-265">Server GC with > 8 logical CPUs</span></span>|<span data-ttu-id="5aa6b-266">16 MB</span><span class="sxs-lookup"><span data-stu-id="5aa6b-266">16 MB</span></span>|<span data-ttu-id="5aa6b-267">1 GB</span><span class="sxs-lookup"><span data-stu-id="5aa6b-267">1 GB</span></span>|

<span data-ttu-id="5aa6b-268">Das kurzlebige Segment kann Objekte der Generation 2 einschließen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-268">The ephemeral segment can include generation 2 objects.</span></span> <span data-ttu-id="5aa6b-269">Objekte der Generation 2 können mehrere Segmente verwenden (so viele, wie der Prozess erfordert und für den Speicher vorgesehen sind).</span><span class="sxs-lookup"><span data-stu-id="5aa6b-269">Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</span></span>

<span data-ttu-id="5aa6b-270">Die Menge an Speicher, der bei einer kurzlebigen Garbage Collection freigegeben wird, ist auf die Größe des kurzlebigen Segments beschränkt.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-270">The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</span></span> <span data-ttu-id="5aa6b-271">Der Umfang des freigegebenen Speichers ist proportional zum Speicherplatz, der von den inaktiven Objekten belegt wurde.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-271">The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</span></span>

## <a name="what-happens-during-a-garbage-collection"></a><span data-ttu-id="5aa6b-272">Was geschieht während einer Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="5aa6b-272">What happens during a garbage collection</span></span>

<span data-ttu-id="5aa6b-273">Eine Garbage Collection umfasst die folgenden Phasen:</span><span class="sxs-lookup"><span data-stu-id="5aa6b-273">A garbage collection has the following phases:</span></span>

- <span data-ttu-id="5aa6b-274">Eine Markierungsphase, die eine Liste aller aktiven Objekte ermittelt und erstellt.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-274">A marking phase that finds and creates a list of all live objects.</span></span>

- <span data-ttu-id="5aa6b-275">Eine Neuzuordnungsphase, in der die Verweise auf die zu komprimierenden Objekte aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-275">A relocating phase that updates the references to the objects that will be compacted.</span></span>

- <span data-ttu-id="5aa6b-276">Eine Komprimierungsphase, in der der von den inaktiven Objekten belegte Speicherplatz freigegeben und die noch bestehenden Objekte komprimiert werden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-276">A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</span></span> <span data-ttu-id="5aa6b-277">In der Komprimierungsphase werden die Objekte, die nach einer Garbage Collection noch vorhanden sind, zum älteren Ende des Segments verschoben.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-277">The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</span></span>

  <span data-ttu-id="5aa6b-278">Da Auflistungen der Generation 2 mehrere Segmente belegen können, können Objekte, die auf Generation 2 höher gestuft werden, in ein älteres Segment verschoben werden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-278">Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</span></span> <span data-ttu-id="5aa6b-279">Objekte, die sowohl Generation 1 als auch Generation 2 überlebt haben, können in ein anderes Segment verschoben werden, da sie auf Generation 2 höher gestuft werden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-279">Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</span></span>

  <span data-ttu-id="5aa6b-280">Normalerweise wird der große Objektheap (LOH) nicht komprimiert, da das Kopieren großer Objekte Leistungseinbußen zur Folge hat.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-280">Ordinarily, the large object heap (LOH) is not compacted, because copying large objects imposes a performance penalty.</span></span> <span data-ttu-id="5aa6b-281">In .NET Core und ab .NET Framework 4.5.1 können Sie jedoch die Eigenschaft <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> verwenden, um bei Bedarf den großen Objektheap zu komprimieren.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-281">However, in .NET Core and in .NET Framework 4.5.1 and later, you can use the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to compact the large object heap on demand.</span></span> <span data-ttu-id="5aa6b-282">Außerdem wird der LOH automatisch komprimiert, wenn eine feste Grenze festgelegt wird, indem Folgendes angegeben wird:</span><span class="sxs-lookup"><span data-stu-id="5aa6b-282">In addition, the LOH is automatically compacted when a hard limit is set by specifying either:</span></span>

  - <span data-ttu-id="5aa6b-283">Arbeitsspeicherlimit für einen Container</span><span class="sxs-lookup"><span data-stu-id="5aa6b-283">A memory limit on a container.</span></span>
  - <span data-ttu-id="5aa6b-284">Runtimekonfigurationsoptionen [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#heap-limit) oder [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#heap-limit-percent)</span><span class="sxs-lookup"><span data-stu-id="5aa6b-284">The [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#heap-limit) or [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#heap-limit-percent) run-time configuration options.</span></span>

<span data-ttu-id="5aa6b-285">Der Garbage Collector bestimmt anhand folgender Informationen, ob Objekte aktiv sind:</span><span class="sxs-lookup"><span data-stu-id="5aa6b-285">The garbage collector uses the following information to determine whether objects are live:</span></span>

- <span data-ttu-id="5aa6b-286">**Stapelstämme**.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-286">**Stack roots**.</span></span> <span data-ttu-id="5aa6b-287">Vom Just-In-Time (JIT)-Compiler bereitgestellte Stapelvariablen und Stackwalker.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-287">Stack variables provided by the just-in-time (JIT) compiler and stack walker.</span></span> <span data-ttu-id="5aa6b-288">Durch JIT-Optimierungen können Bereiche des Codes, in denen Stapelvariablen dem Garbage Collector gemeldet werden, verlängert oder verkürzt werden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-288">JIT optimizations can lengthen or shorten regions of code within which stack variables are reported to the garbage collector.</span></span>

- <span data-ttu-id="5aa6b-289">**Garbage Collection-Handles**.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-289">**Garbage collection handles**.</span></span> <span data-ttu-id="5aa6b-290">Diese Handles zeigen auf verwaltete Objekte und können vom Benutzercode oder der Common Language Runtime zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-290">Handles that point to managed objects and that can be allocated by user code or by the common language runtime.</span></span>

- <span data-ttu-id="5aa6b-291">**Statische Daten**.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-291">**Static data**.</span></span> <span data-ttu-id="5aa6b-292">Statische Objekte in Anwendungsdomänen, die auf andere Objekte verweisen können.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-292">Static objects in application domains that could be referencing other objects.</span></span> <span data-ttu-id="5aa6b-293">Jede Anwendungsdomäne verfolgt die eigenen statischen Objekte.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-293">Each application domain keeps track of its static objects.</span></span>

<span data-ttu-id="5aa6b-294">Vor dem Start einer Garbage Collection werden alle verwalteten Threads bis auf den Thread, der die Garbage Collection ausgelöst hat, angehalten.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-294">Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</span></span>

<span data-ttu-id="5aa6b-295">Die folgende Abbildung zeigt einen Thread, der eine Garbage Collection auslöst und eine Unterbrechung der Ausführung anderer Threads verursacht.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-295">The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</span></span>

![Garbage Collection, die durch einen Thread ausgelöst wird](media/gc-triggered.png)

## <a name="unmanaged-resources"></a><span data-ttu-id="5aa6b-297">Nicht verwaltete Ressourcen</span><span class="sxs-lookup"><span data-stu-id="5aa6b-297">Unmanaged resources</span></span>

<span data-ttu-id="5aa6b-298">Mit einer Garbage Collection werden alle Aufgaben in Bezug auf die Speicherverwaltung für die meisten von einer Anwendung erstellten Objekte automatisch ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-298">For most of the objects that your application creates, you can rely on garbage collection to automatically perform the necessary memory management tasks.</span></span> <span data-ttu-id="5aa6b-299">Allerdings ist bei nicht verwalteten Ressourcen explizites Bereinigen erforderlich.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-299">However, unmanaged resources require explicit cleanup.</span></span> <span data-ttu-id="5aa6b-300">Die häufigsten nicht verwalteten Ressourcen sind Objekte, die eine Betriebssystemressource umschließen, z. B. ein Dateihandle, ein Fensterhandle oder eine Netzwerkverbindung.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-300">The most common type of unmanaged resource is an object that wraps an operating system resource, such as a file handle, window handle, or network connection.</span></span> <span data-ttu-id="5aa6b-301">Obwohl der Garbage Collector die Lebensdauer eines verwalteten Objekts, das eine nicht verwaltete Ressource kapselt, verfolgen kann, stehen ihm keine genauen Informationen zum Bereinigen dieser Ressource zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-301">Although the garbage collector is able to track the lifetime of a managed object that encapsulates an unmanaged resource, it doesn't have specific knowledge about how to clean up the resource.</span></span>

<span data-ttu-id="5aa6b-302">Wenn Sie ein Objekt erstellen möchten, das eine nicht verwaltete Ressource kapselt, ist es ratsam, Code zum Bereinigen der nicht verwalteten Ressource in einer öffentlichen `Dispose`-Methode bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-302">When you create an object that encapsulates an unmanaged resource, it's recommended that you provide the necessary code to clean up the unmanaged resource in a public `Dispose` method.</span></span> <span data-ttu-id="5aa6b-303">Durch Bereitstellen der `Dispose`-Methode wird Benutzern des Objekts die Möglichkeit gegeben, nicht mehr benötigten Speicherplatz explizit freizugeben, sobald das Objekt nicht mehr verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-303">By providing a `Dispose` method, you enable users of your object to explicitly free its memory when they are finished with the object.</span></span> <span data-ttu-id="5aa6b-304">Wenn Sie ein Objekt verwenden, das eine nicht verwaltete Ressource kapselt, sollten Sie bei Bedarf `Dispose` aufrufen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-304">When you use an object that encapsulates an unmanaged resource, make sure to call `Dispose` as necessary.</span></span>

<span data-ttu-id="5aa6b-305">Sorgen Sie außerdem dafür, dass die nicht verwalteten Ressourcen freigegeben werden können, falls ein Consumer Ihres Typs vergisst, `Dispose` aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-305">You must also provide a way for your unmanaged resources to be released in case a consumer of your type forgets to call `Dispose`.</span></span> <span data-ttu-id="5aa6b-306">Sie können entweder ein SafeHandle zum Wrappen der nicht verwalteten Ressource verwenden oder die <xref:System.Object.Finalize?displayProperty=nameWithType>-Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="5aa6b-306">You can either use a safe handle to wrap the unmanaged resource, or override the <xref:System.Object.Finalize?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="5aa6b-307">Weitere Informationen zum Bereinigen nicht verwalteter Ressourcen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="5aa6b-307">For more information about cleaning up unmanaged resources, see [Clean up unmanaged resources](unmanaged.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="5aa6b-308">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="5aa6b-308">See also</span></span>

- [<span data-ttu-id="5aa6b-309">Garbage Collection für die Arbeitsstation und Garbage Collection auf dem Server</span><span class="sxs-lookup"><span data-stu-id="5aa6b-309">Workstation and server garbage collection</span></span>](workstation-server-gc.md)
- [<span data-ttu-id="5aa6b-310">Garbage Collection im Hintergrund</span><span class="sxs-lookup"><span data-stu-id="5aa6b-310">Background garbage collection</span></span>](background-gc.md)
- [<span data-ttu-id="5aa6b-311">Konfigurationsoptionen für die Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="5aa6b-311">Configuration options for GC</span></span>](../../core/run-time-config/garbage-collector.md)
- [<span data-ttu-id="5aa6b-312">Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="5aa6b-312">Garbage collection</span></span>](index.md)
