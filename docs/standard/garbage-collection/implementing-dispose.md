---
title: Implementieren einer Dispose-Methode
description: In diesem Artikel erfahren Sie, wie Sie die Dispose-Methode implementieren, die nicht verwaltete Ressourcen freigibt, die von Ihrem Code in .NET verwendet werden.
ms.date: 09/08/2020
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: ec731ff4c1020100c2b7ff5041d42291141a5209
ms.sourcegitcommit: 6d1ae17e60384f3b5953ca7b45ac859ec6d4c3a0
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/20/2020
ms.locfileid: "94982406"
---
# <a name="implement-a-dispose-method"></a><span data-ttu-id="c0886-103">Implementieren einer Dispose-Methode</span><span class="sxs-lookup"><span data-stu-id="c0886-103">Implement a Dispose method</span></span>

<span data-ttu-id="c0886-104">Die Implementierung der <xref:System.IDisposable.Dispose%2A>-Methode ist hauptsächlich für die Freigabe nicht verwalteter Ressourcen bestimmt.</span><span class="sxs-lookup"><span data-stu-id="c0886-104">Implementing the <xref:System.IDisposable.Dispose%2A> method is primarily for releasing unmanaged resources.</span></span> <span data-ttu-id="c0886-105">Beim Arbeiten mit Instanzmembern, die <xref:System.IDisposable>-Implementierungen sind, werden <xref:System.IDisposable.Dispose%2A>-Aufrufe häufig weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="c0886-105">When working with instance members that are <xref:System.IDisposable> implementations, it's common to cascade <xref:System.IDisposable.Dispose%2A> calls.</span></span> <span data-ttu-id="c0886-106">Es gibt weitere Gründe für die Implementierung von <xref:System.IDisposable.Dispose%2A>, wie beispielsweise das Freigeben von zugeordnetem Arbeitsspeicher, das Entfernen eines Elements, das einer Auflistung hinzugefügt wurde, oder das Signalisieren der Aufhebung einer abgerufenen Sperre.</span><span class="sxs-lookup"><span data-stu-id="c0886-106">There are additional reasons for implementing <xref:System.IDisposable.Dispose%2A>, for example, to free memory that was allocated, remove an item that was added to a collection, or signal the release of a lock that was acquired.</span></span>

<span data-ttu-id="c0886-107">Der [.NET-Garbage Collector](index.md) ordnet nicht verwalteten Arbeitsspeicher weder zu noch gibt er diesen frei.</span><span class="sxs-lookup"><span data-stu-id="c0886-107">The [.NET garbage collector](index.md) does not allocate or release unmanaged memory.</span></span> <span data-ttu-id="c0886-108">Das Muster für das Verwerfen eines Objekts, Dispose-Muster genannt, legt die Ordnung für die Lebensdauer eines Objekts fest.</span><span class="sxs-lookup"><span data-stu-id="c0886-108">The pattern for disposing an object, referred to as the dispose pattern, imposes order on the lifetime of an object.</span></span> <span data-ttu-id="c0886-109">Das Dispose-Muster wird für Objekte verwendet, die die <xref:System.IDisposable>-Schnittstelle implementieren, und ist üblich bei der Interaktion mit Datei- und Pipehandles, Registrierungshandles, Wait-Handles oder Zeigern auf Blöcke nicht verwalteten Speichers.</span><span class="sxs-lookup"><span data-stu-id="c0886-109">The dispose pattern is used for objects that implement the <xref:System.IDisposable> interface, and is common when interacting with file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="c0886-110">Dies liegt daran, dass der Garbage Collector nicht verwaltete Objekte nicht freigeben kann.</span><span class="sxs-lookup"><span data-stu-id="c0886-110">This is because the garbage collector is unable to reclaim unmanaged objects.</span></span>

<span data-ttu-id="c0886-111">Um sicherzustellen, dass Ressourcen immer entsprechend bereinigt werden, sollte eine <xref:System.IDisposable.Dispose%2A>-Methode derart idempotent sein, dass sie mehrmals aufgerufen werden kann, ohne eine Ausnahme auszulösen.</span><span class="sxs-lookup"><span data-stu-id="c0886-111">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be idempotent, such that it is callable multiple times without throwing an exception.</span></span> <span data-ttu-id="c0886-112">Außerdem sollten nachfolgende Aufrufe von <xref:System.IDisposable.Dispose%2A> nichts bewirken.</span><span class="sxs-lookup"><span data-stu-id="c0886-112">Furthermore, subsequent invocations of <xref:System.IDisposable.Dispose%2A> should do nothing.</span></span>

<span data-ttu-id="c0886-113">Das Codebeispiel für die <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType>-Methode veranschaulicht, wie durch Garbage Collection die Ausführung eines Finalizers bewirkt werden kann, während ein nicht verwalteter Verweis auf das Objekt oder den Member weiterhin verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="c0886-113">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how garbage collection can cause a finalizer to run, while an unmanaged reference to the object or its members is still in use.</span></span> <span data-ttu-id="c0886-114">Sie sollten <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> verwenden, damit das Objekt von Beginn der aktuellen Routine bis zum Zeitpunkt des Aufrufs dieser Methode von der Garbage Collection ausgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="c0886-114">It may make sense to utilize <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> to make the object ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span>

## <a name="safe-handles"></a><span data-ttu-id="c0886-115">Sichere Handles</span><span class="sxs-lookup"><span data-stu-id="c0886-115">Safe handles</span></span>

<span data-ttu-id="c0886-116">Das Schreiben von Code für den Finalizer eines Objekts ist eine komplexe Aufgabe, die Probleme verursachen kann, wenn sie nicht ordnungsgemäß gelöst wird.</span><span class="sxs-lookup"><span data-stu-id="c0886-116">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="c0886-117">Daher wird empfohlen, <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>-Objekte zu erstellen, anstatt einen Finalizer zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="c0886-117">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>

<span data-ttu-id="c0886-118">Bei einem <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> handelt es sich um einen abstrakten verwalteten Typ, der einen <xref:System.IntPtr?displayProperty=nameWithType> umschließt, der eine nicht verwaltete Ressource identifiziert.</span><span class="sxs-lookup"><span data-stu-id="c0886-118">A <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract managed type that wraps an <xref:System.IntPtr?displayProperty=nameWithType> that identifies an unmanaged resource.</span></span> <span data-ttu-id="c0886-119">Unter Windows könnte er ein Handle unter UNIX identifizieren, einen Dateideskriptor.</span><span class="sxs-lookup"><span data-stu-id="c0886-119">On Windows it might identify a handle while on Unix, a file descriptor.</span></span> <span data-ttu-id="c0886-120">Er bietet sämtliche erforderliche Logik, um sicherzustellen, dass diese Ressource einmalig und nur einmal freigegeben wird, wenn das `SafeHandle` verworfen wird oder alle Verweise auf das `SafeHandle` gelöscht wurden und die `SafeHandle`-Instanz abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="c0886-120">It provides all of the logic necessary to ensure that this resource is released once and only once, when the `SafeHandle` is disposed of or when all references to the `SafeHandle` have been dropped and the `SafeHandle` instance is finalized.</span></span>

<span data-ttu-id="c0886-121"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> ist eine abstrakte Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="c0886-121">The <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract base class.</span></span> <span data-ttu-id="c0886-122">Abgeleitete Klassen stellen bestimmte Instanzen für verschiedene Arten von Handles bereit.</span><span class="sxs-lookup"><span data-stu-id="c0886-122">Derived classes provide specific instances for different kinds of handle.</span></span> <span data-ttu-id="c0886-123">Diese abgeleiteten Klassen überprüfen, welche Werte für den <xref:System.IntPtr?displayProperty=nameWithType> als ungültig angesehen werden, und wie das Handle tatsächlich freigegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="c0886-123">These derived classes validate what values for the <xref:System.IntPtr?displayProperty=nameWithType> are considered invalid and how to actually free the handle.</span></span> <span data-ttu-id="c0886-124"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> wird z. B. von `SafeHandle` abgeleitet, um `IntPtrs` zu umschließen, die geöffnete Dateihandles/Deskriptoren identifizieren, und überschreibt die <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType>-Methode, um sie zu schließen (über die `close`-Funktion unter UNIX oder `CloseHandle`-Funktion unter Windows).</span><span class="sxs-lookup"><span data-stu-id="c0886-124">For example, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> derives from `SafeHandle` to wrap `IntPtrs` that identify open file handles/descriptors, and overrides its <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method to close it (via the `close` function on Unix or `CloseHandle` function on Windows).</span></span> <span data-ttu-id="c0886-125">Die meisten APIs in .NET-Bibliotheken, die eine nicht verwaltete Ressource erstellen, umschließen sie in einem `SafeHandle` und geben dieses `SafeHandle` bei Bedarf zurück, anstatt den Rohzeiger zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="c0886-125">Most APIs in .NET libraries that create an unmanaged resource will wrap it in a `SafeHandle` and return that `SafeHandle` to you as needed, rather than handing back the raw pointer.</span></span> <span data-ttu-id="c0886-126">In Situationen, in denen Sie mit einer nicht verwalteten Komponente interagieren und einen `IntPtr` für eine nicht verwaltete Ressource erhalten, können Sie einen eigenen `SafeHandle`-Typ erstellen, um sie zu umschließen.</span><span class="sxs-lookup"><span data-stu-id="c0886-126">In situations where you interact with an unmanaged component and get an `IntPtr` for an unmanaged resource, you can create your own `SafeHandle` type to wrap it.</span></span> <span data-ttu-id="c0886-127">Daher müssen nur wenige Nicht-`SafeHandle`-Typen Finalizer implementieren. Die meisten Implementierungen von Dispose-Mustern schließen nur andere verwaltete Ressourcen ein, von denen einige möglicherweise `SafeHandle`s sind.</span><span class="sxs-lookup"><span data-stu-id="c0886-127">As a result, few non-`SafeHandle` types need to implement finalizers; most disposable pattern implementations only end up wrapping other managed resources, some of which may be `SafeHandle`s.</span></span>

<span data-ttu-id="c0886-128">Die folgenden abgeleiteten Klassen im <xref:Microsoft.Win32.SafeHandles>-Namespace stellen SafeHandles bereit:</span><span class="sxs-lookup"><span data-stu-id="c0886-128">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>

- <span data-ttu-id="c0886-129">Die Klasse <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> und <xref:Microsoft.Win32.SafeHandles.SafePipeHandle>, für Dateien, Speicherabbilddateien und Pipes.</span><span class="sxs-lookup"><span data-stu-id="c0886-129">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>
- <span data-ttu-id="c0886-130">Die <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle>-Klasse, für Speicheransichten.</span><span class="sxs-lookup"><span data-stu-id="c0886-130">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>
- <span data-ttu-id="c0886-131">Die Klassen <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> und <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle>, für Kryptografiekonstrukte.</span><span class="sxs-lookup"><span data-stu-id="c0886-131">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>
- <span data-ttu-id="c0886-132">Die <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>-Klasse, für Registrierungsschlüssel.</span><span class="sxs-lookup"><span data-stu-id="c0886-132">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>
- <span data-ttu-id="c0886-133">Die <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>-Klasse, für Wait-Handles.</span><span class="sxs-lookup"><span data-stu-id="c0886-133">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>

## <a name="dispose-and-disposebool"></a><span data-ttu-id="c0886-134">Dispose() und Dispose(bool)</span><span class="sxs-lookup"><span data-stu-id="c0886-134">Dispose() and Dispose(bool)</span></span>

<span data-ttu-id="c0886-135">Die <xref:System.IDisposable>-Schnittstelle erfordert die Implementierung einer einzelnen parameterlosen Methode, <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0886-135">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="c0886-136">Außerdem sollte jede nicht versiegelte Klasse über eine zusätzliche `Dispose(bool)`-Überladungsmethode verfügen, die implementiert werden soll:</span><span class="sxs-lookup"><span data-stu-id="c0886-136">Also, any non-sealed class should have an additional `Dispose(bool)` overload method to be implemented:</span></span>

- <span data-ttu-id="c0886-137">Eine nicht virtuelle `public`-<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-Implementierung (`NonInheritable` in Visual Basic), die keine Parameter aufweist.</span><span class="sxs-lookup"><span data-stu-id="c0886-137">A `public` non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>

- <span data-ttu-id="c0886-138">Eine `protected virtual`-`Dispose`-Methode (`Overridable` in Visual Basic) mit der folgenden Signatur:</span><span class="sxs-lookup"><span data-stu-id="c0886-138">A `protected virtual` (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>

  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]

  > [!IMPORTANT]
  > <span data-ttu-id="c0886-139">Der `disposing`-Parameter sollte `false` sein, wenn er von einem Finalizer aufgerufen wird, und `true`, wenn er von der <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="c0886-139">The `disposing` parameter should be `false` when called from a finalizer, and `true` when called from the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c0886-140">Dies bedeutet, dass er `true` ist, wenn er deterministisch aufgerufen wird, und `false`, wenn er nicht deterministisch aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="c0886-140">In other words, it is `true` when deterministically called and `false` when non-deterministically called.</span></span>

### <a name="the-dispose-method"></a><span data-ttu-id="c0886-141">Die Dispose()-Methode</span><span class="sxs-lookup"><span data-stu-id="c0886-141">The Dispose() method</span></span>

<span data-ttu-id="c0886-142">Da die nicht virtuelle, parameterlose `public`-`Dispose`-Methode (`NonInheritable` in Visual Basic) von einem Consumer des Typs aufgerufen wird, hat sie den Zweck, nicht verwaltete Ressourcen freizugeben, eine generelle Bereinigung durchzuführen und anzugeben, dass der Finalizer, sofern vorhanden, nicht ausgeführt werden muss.</span><span class="sxs-lookup"><span data-stu-id="c0886-142">Because the `public`, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources, perform general cleanup, and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="c0886-143">Das Freigeben des tatsächlichen Speichers, der einem verwalteten Objekt zugeordnet ist, ist immer die Domäne des [Garbage Collectors](index.md).</span><span class="sxs-lookup"><span data-stu-id="c0886-143">Freeing the actual memory associated with a managed object is always the domain of the [garbage collector](index.md).</span></span> <span data-ttu-id="c0886-144">Daher weist sie eine Standardimplementierung auf:</span><span class="sxs-lookup"><span data-stu-id="c0886-144">Because of this, it has a standard implementation:</span></span>

[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]

<span data-ttu-id="c0886-145">Die `Dispose`-Methode führt die Bereinigung aller Objekte aus, damit der Garbage Collector nicht mehr die <xref:System.Object.Finalize%2A?displayProperty=nameWithType>-Überschreibung der Objekte aufrufen muss.</span><span class="sxs-lookup"><span data-stu-id="c0886-145">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="c0886-146">Daher verhindert der Aufruf der <xref:System.GC.SuppressFinalize%2A>-Methode, dass der Garbage Collector den Finalizer ausführt.</span><span class="sxs-lookup"><span data-stu-id="c0886-146">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="c0886-147">Wenn der Typ keinen Finalizer aufweist, bleibt der Aufruf von <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> ohne Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="c0886-147">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="c0886-148">Beachten Sie, dass die tatsächliche Bereinigung durch die `Dispose(bool)`-Methodenüberladung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="c0886-148">Note that the actual cleanup is performed by the `Dispose(bool)` method overload.</span></span>

### <a name="the-disposebool-method-overload"></a><span data-ttu-id="c0886-149">Die Dispose(bool)-Methodenüberladung</span><span class="sxs-lookup"><span data-stu-id="c0886-149">The Dispose(bool) method overload</span></span>

<span data-ttu-id="c0886-150">In der Überladung ist der `disposing`-Parameter ein <xref:System.Boolean>-Wert, der angibt, ob der Methodenaufruf von einer <xref:System.IDisposable.Dispose%2A>-Methode (deren Wert `true` ist) oder einem Finalizer (dessen Wert `false` ist) stammt.</span><span class="sxs-lookup"><span data-stu-id="c0886-150">In the overload, the `disposing` parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>

<span data-ttu-id="c0886-151">Der Text der Methode besteht aus zwei Codeblöcken:</span><span class="sxs-lookup"><span data-stu-id="c0886-151">The body of the method consists of two blocks of code:</span></span>

- <span data-ttu-id="c0886-152">Ein Block, der nicht verwaltete Ressourcen freigibt.</span><span class="sxs-lookup"><span data-stu-id="c0886-152">A block that frees unmanaged resources.</span></span> <span data-ttu-id="c0886-153">Dieser Block wird unabhängig vom Wert des `disposing`-Parameters ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="c0886-153">This block executes regardless of the value of the `disposing` parameter.</span></span>
- <span data-ttu-id="c0886-154">Ein bedingter Block, der verwaltete Ressourcen freigibt.</span><span class="sxs-lookup"><span data-stu-id="c0886-154">A conditional block that frees managed resources.</span></span> <span data-ttu-id="c0886-155">Dieser Block wird ausgeführt, wenn der Wert von `disposing` gleich `true` ist.</span><span class="sxs-lookup"><span data-stu-id="c0886-155">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="c0886-156">Die verwalteten Ressourcen, die freigegeben werden, können Folgendes umfassen:</span><span class="sxs-lookup"><span data-stu-id="c0886-156">The managed resources that it frees can include:</span></span>

  - <span data-ttu-id="c0886-157">**Verwaltete Objekte, die <xref:System.IDisposable> implementieren.**</span><span class="sxs-lookup"><span data-stu-id="c0886-157">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="c0886-158">Der bedingte Block kann verwendet werden, um deren <xref:System.IDisposable.Dispose%2A>-Implementierung aufzurufen (Weitergeben von Dispose-Aufrufen).</span><span class="sxs-lookup"><span data-stu-id="c0886-158">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation (cascade dispose).</span></span> <span data-ttu-id="c0886-159">Wenn Sie eine abgeleitete Klasse von <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> verwendet haben, um die nicht verwaltete Ressource zu umschließen, sollten Sie hier die <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType>-Implementierung aufrufen.</span><span class="sxs-lookup"><span data-stu-id="c0886-159">If you have used a derived class of <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementation here.</span></span>

  - <span data-ttu-id="c0886-160">**Verwaltete Objekte, die viel Arbeitsspeicher belegen oder knappe Ressourcen nutzen.**</span><span class="sxs-lookup"><span data-stu-id="c0886-160">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="c0886-161">Weisen Sie `null` Verweise auf große verwaltete Objekte zu, damit sie eher unerreichbar sind.</span><span class="sxs-lookup"><span data-stu-id="c0886-161">Assign large managed object references to `null` to make them more likely to be unreachable.</span></span> <span data-ttu-id="c0886-162">Dadurch werden sie schneller freigegeben als bei einer nicht deterministischen Freigabe. Dieser Vorgang erfolgt in der Regel außerhalb des bedingten Blocks.</span><span class="sxs-lookup"><span data-stu-id="c0886-162">This releases them faster than if they were reclaimed non-deterministically, and this is usually done outside of the conditional block.</span></span>

<span data-ttu-id="c0886-163">Wenn der Methodenaufruf von einem Finalizer stammt, wird nur der Code ausgeführt, der nicht verwaltete Ressourcen freigibt.</span><span class="sxs-lookup"><span data-stu-id="c0886-163">If the method call comes from a finalizer, only the code that frees unmanaged resources should execute.</span></span> <span data-ttu-id="c0886-164">Der Implementierer ist dafür verantwortlich, sicherzustellen, dass der falsche Pfad nicht mit verwalteten Objekten interagiert, die möglicherweise freigegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="c0886-164">The implementer is responsible for ensuring that the false path doesn't interact with managed objects that may have been reclaimed.</span></span> <span data-ttu-id="c0886-165">Dies ist wichtig, da die Reihenfolge, in der der Garbage Collector verwaltete Objekte während der Finalisierung zerstört, nicht deterministisch ist.</span><span class="sxs-lookup"><span data-stu-id="c0886-165">This is important because the order in which the garbage collector destroys managed objects during finalization is non-deterministic.</span></span>

## <a name="cascade-dispose-calls"></a><span data-ttu-id="c0886-166">Weitergeben von Dispose-Aufrufen</span><span class="sxs-lookup"><span data-stu-id="c0886-166">Cascade dispose calls</span></span>

<span data-ttu-id="c0886-167">Wenn die Klasse ein Feld oder eine Eigenschaft besitzt und dessen/deren Typ <xref:System.IDisposable> implementiert, sollte die enthaltende Klasse auch <xref:System.IDisposable> implementieren.</span><span class="sxs-lookup"><span data-stu-id="c0886-167">If your class owns a field or property, and its type implements <xref:System.IDisposable>, the containing class itself should also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="c0886-168">Eine Klasse, die eine <xref:System.IDisposable>-Implementierung instanziiert und als Instanzmember speichert, ist auch für die Bereinigung verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="c0886-168">A class that instantiates an <xref:System.IDisposable> implementation and storing it as an instance member, is also responsible for its cleanup.</span></span> <span data-ttu-id="c0886-169">Dadurch wird sichergestellt, dass die verwerfbaren Typen, auf die verwiesen wird, die Möglichkeit erhalten, eine Bereinigung deterministisch mit der <xref:System.IDisposable.Dispose%2A>-Methode auszuführen.</span><span class="sxs-lookup"><span data-stu-id="c0886-169">This is to help ensure that the referenced disposable types are given the opportunity to deterministically perform clean up through the <xref:System.IDisposable.Dispose%2A> method.</span></span> <span data-ttu-id="c0886-170">In diesem Beispiel ist die Klasse `sealed` (oder `NotInheritable` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="c0886-170">In this example, the class is `sealed` (or `NotInheritable` in Visual Basic).</span></span>

[!code-csharp[Conceptual.Disposable#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/disposable1.cs#1)]
[!code-vb[Conceptual.Disposable#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/disposable1.vb#1)]

## <a name="implement-the-dispose-pattern"></a><span data-ttu-id="c0886-171">Implementieren des Dispose-Musters</span><span class="sxs-lookup"><span data-stu-id="c0886-171">Implement the dispose pattern</span></span>

<span data-ttu-id="c0886-172">Alle nicht versiegelten Klassen (oder nicht als `NotInheritable` geänderten Visual Basic-Klassen) sollten als potenzielle Basisklasse angesehen werden, da sie geerbt werden könnten.</span><span class="sxs-lookup"><span data-stu-id="c0886-172">All non-sealed classes or (Visual Basic classes not modified as `NotInheritable`) should be considered a potential base class, because they could be inherited.</span></span> <span data-ttu-id="c0886-173">Wenn Sie das Dispose-Muster für eine potenzielle Basisklasse implementieren, müssen Sie Folgendes bereitstellen:</span><span class="sxs-lookup"><span data-stu-id="c0886-173">If you implement the dispose pattern for any potential base class, you must provide the following:</span></span>

- <span data-ttu-id="c0886-174">Eine <xref:System.IDisposable.Dispose%2A>-Implementierung, die die `Dispose(bool)`-Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="c0886-174">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(bool)` method.</span></span>
- <span data-ttu-id="c0886-175">Eine `Dispose(bool)`-Methode, die die eigentliche Bereinigung ausführt.</span><span class="sxs-lookup"><span data-stu-id="c0886-175">A `Dispose(bool)` method that performs the actual cleanup.</span></span>
- <span data-ttu-id="c0886-176">Entweder eine von <xref:System.Runtime.InteropServices.SafeHandle> abgeleitete Klasse, die die nicht verwaltete Ressource einschließt (empfohlen) oder eine Überschreibung der <xref:System.Object.Finalize%2A?displayProperty=nameWithType>-Methode.</span><span class="sxs-lookup"><span data-stu-id="c0886-176">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c0886-177">Die <xref:System.Runtime.InteropServices.SafeHandle>-Klasse stellt einen Finalizer bereit, sodass Sie ihn nicht selbst schreiben müssen.</span><span class="sxs-lookup"><span data-stu-id="c0886-177">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer, so you do not have to write one yourself.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c0886-178">Es ist möglich, dass eine Basisklasse nur auf verwaltete Objekte verweist und das Dispose-Muster implementiert.</span><span class="sxs-lookup"><span data-stu-id="c0886-178">It is possible for a base class to only reference managed objects, and implement the dispose pattern.</span></span> <span data-ttu-id="c0886-179">In diesen Fällen ist ein Finalizer unnötig.</span><span class="sxs-lookup"><span data-stu-id="c0886-179">In these cases, a finalizer is unnecessary.</span></span> <span data-ttu-id="c0886-180">Ein Finalizer ist nur erforderlich, wenn Sie direkt auf nicht verwaltete Ressourcen verweisen.</span><span class="sxs-lookup"><span data-stu-id="c0886-180">A finalizer is only required if you directly reference unmanaged resources.</span></span>

<span data-ttu-id="c0886-181">Im Folgenden finden Sie das allgemeine Muster für die Implementierung des Dispose-Musters für eine Basisklasse, die ein SafeHandle verwendet.</span><span class="sxs-lookup"><span data-stu-id="c0886-181">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>

[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]

> [!NOTE]
> <span data-ttu-id="c0886-182">Im vorherigen Beispiel wird ein <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>-Objekt zum Veranschaulichen des Musters verwendet; stattdessen kann auch ein beliebiges anderes von <xref:System.Runtime.InteropServices.SafeHandle> abgeleitetes Objekt verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c0886-182">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="c0886-183">Beachten Sie, dass im Beispiel das <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>-Objekt nicht ordnungsgemäß instanziiert wird.</span><span class="sxs-lookup"><span data-stu-id="c0886-183">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="c0886-184">Im Folgenden finden Sie das allgemeine Muster für die Implementierung des Dispose-Musters für eine Basisklasse, die <xref:System.Object.Finalize%2A?displayProperty=nameWithType> überschreibt.</span><span class="sxs-lookup"><span data-stu-id="c0886-184">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>

[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]

> [!TIP]
> <span data-ttu-id="c0886-185">In C# erstellen Sie einen [Finalizer](../../csharp/programming-guide/classes-and-structs/destructors.md), indem Sie <xref:System.Object.Finalize%2A?displayProperty=nameWithType> überschreiben.</span><span class="sxs-lookup"><span data-stu-id="c0886-185">In C#, you create a [finalizer](../../csharp/programming-guide/classes-and-structs/destructors.md) by overriding <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c0886-186">In Visual Basic erfolgt dies mit `Protected Overrides Sub Finalize()`.</span><span class="sxs-lookup"><span data-stu-id="c0886-186">In Visual Basic, this is done with `Protected Overrides Sub Finalize()`.</span></span>

## <a name="implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="c0886-187">Implementieren des Dispose-Musters für eine abgeleitete Klasse</span><span class="sxs-lookup"><span data-stu-id="c0886-187">Implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="c0886-188">Eine Klasse, die von einer Klasse abgeleitet ist, die die <xref:System.IDisposable>-Schnittstelle implementiert, sollte <xref:System.IDisposable> nicht implementieren, da die Basisklassenimplementierung von <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> von den abgeleiteten Klassen geerbt wird.</span><span class="sxs-lookup"><span data-stu-id="c0886-188">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="c0886-189">Zum Bereinigen einer abgeleiteten Klasse stellen Sie stattdessen Folgendes bereit:</span><span class="sxs-lookup"><span data-stu-id="c0886-189">Instead, to cleanup a derived class, you provide the following:</span></span>

- <span data-ttu-id="c0886-190">Eine `protected override void Dispose(bool)`-Methode, die die Basisklassenmethode überschreibt und die eigentliche Bereinigung der abgeleiteten Klasse durchführt.</span><span class="sxs-lookup"><span data-stu-id="c0886-190">A `protected override void Dispose(bool)` method that overrides the base class method and performs the actual cleanup of the derived class.</span></span> <span data-ttu-id="c0886-191">Diese Methode muss auch die `base.Dispose(bool)`-Methode (`MyBase.Dispose(bool)` in Visual Basic) der Basisklasse aufrufen und ihren disposing-Status für das Argument übergeben.</span><span class="sxs-lookup"><span data-stu-id="c0886-191">This method must also call the `base.Dispose(bool)` (`MyBase.Dispose(bool)` in Visual Basic) method of the base class and pass its disposing status for the argument.</span></span>
- <span data-ttu-id="c0886-192">Entweder eine von <xref:System.Runtime.InteropServices.SafeHandle> abgeleitete Klasse, die die nicht verwaltete Ressource einschließt (empfohlen) oder eine Überschreibung der <xref:System.Object.Finalize%2A?displayProperty=nameWithType>-Methode.</span><span class="sxs-lookup"><span data-stu-id="c0886-192">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c0886-193">Die <xref:System.Runtime.InteropServices.SafeHandle>-Klasse stellt einen Finalizer bereit, wodurch Sie keinen programmieren müssen.</span><span class="sxs-lookup"><span data-stu-id="c0886-193">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="c0886-194">Wenn Sie einen Finalizer bereitstellen, muss er die `Dispose(bool)`-Überladung mit einem `disposing`-Argument mit dem Wert `false` aufrufen.</span><span class="sxs-lookup"><span data-stu-id="c0886-194">If you do provide a finalizer, it must call the `Dispose(bool)` overload with a `disposing` argument of `false`.</span></span>

<span data-ttu-id="c0886-195">Im Folgenden finden Sie das allgemeine Muster für das Implementieren des Dispose-Musters für eine abgeleitete Klasse, die ein SafeHandle verwendet:</span><span class="sxs-lookup"><span data-stu-id="c0886-195">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>

[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]

> [!NOTE]
> <span data-ttu-id="c0886-196">Im vorherigen Beispiel wird ein <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>-Objekt zum Veranschaulichen des Musters verwendet; stattdessen kann auch ein beliebiges anderes von <xref:System.Runtime.InteropServices.SafeHandle> abgeleitetes Objekt verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c0886-196">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="c0886-197">Beachten Sie, dass im Beispiel das <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>-Objekt nicht ordnungsgemäß instanziiert wird.</span><span class="sxs-lookup"><span data-stu-id="c0886-197">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="c0886-198">Im Folgenden finden Sie das allgemeine Muster für das Implementieren des Dispose-Musters für eine abgeleitete Klasse, die <xref:System.Object.Finalize%2A?displayProperty=nameWithType> überschreibt:</span><span class="sxs-lookup"><span data-stu-id="c0886-198">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>

[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]

## <a name="implement-the-dispose-pattern-with-safe-handles"></a><span data-ttu-id="c0886-199">Implementieren des Dispose-Musters mit sicheren Handles</span><span class="sxs-lookup"><span data-stu-id="c0886-199">Implement the dispose pattern with safe handles</span></span>

<span data-ttu-id="c0886-200">Das folgende Beispiel zeigt das Dispose-Muster für eine Basisklasse, `DisposableStreamResource`, die ein SafeHandle verwendet, um nicht verwaltete Ressourcen zu kapseln.</span><span class="sxs-lookup"><span data-stu-id="c0886-200">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="c0886-201">Es definiert eine `DisposableStreamResource`-Klasse, die ein <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> verwendet, um ein <xref:System.IO.Stream>-Objekt zu umschließen, das eine offene Datei darstellt.</span><span class="sxs-lookup"><span data-stu-id="c0886-201">It defines a `DisposableStreamResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="c0886-202">Die Klasse enthält auch eine einzelne Eigenschaft, `Size`, die die Gesamtzahl von Bytes im Dateistream zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="c0886-202">The class also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>

[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]

## <a name="implement-the-dispose-pattern-for-a-derived-class-with-safe-handles"></a><span data-ttu-id="c0886-203">Implementieren des Dispose-Musters für eine abgeleitete Klasse mit sicheren Handles</span><span class="sxs-lookup"><span data-stu-id="c0886-203">Implement the dispose pattern for a derived class with safe handles</span></span>

<span data-ttu-id="c0886-204">Das folgende Beispiel zeigt das Dispose-Muster für eine abgeleitete Klasse, `DisposableStreamResource2`, die von der `DisposableStreamResource`-Klasse erbt, die im vorherigen Beispiel dargestellt wurde.</span><span class="sxs-lookup"><span data-stu-id="c0886-204">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="c0886-205">Die Klasse fügt eine zusätzliche Methode, `WriteFileInfo`, hinzu und verwendet ein <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>-Objekt, um das Handle der überschreibbaren Datei zu umschließen.</span><span class="sxs-lookup"><span data-stu-id="c0886-205">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>

[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]

## <a name="see-also"></a><span data-ttu-id="c0886-206">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="c0886-206">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="c0886-207">Definieren und Nutzen von Klassen und Strukturen (C++/CLI)</span><span class="sxs-lookup"><span data-stu-id="c0886-207">Define and consume classes and structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
