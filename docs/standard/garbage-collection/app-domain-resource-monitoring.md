---
title: Überwachung von Anwendungsdomänenressourcen
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- monitoring managed memory use by application domain
- application domains, memory use
- memory use, monitoring
- application domains, resource monitoring
ms.assetid: 318bedf8-7f35-4f00-b34a-2b7b8e3fa315
ms.openlocfilehash: 54e300bef1818fd08f27d7920eec68ee1f2c45bb
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/15/2020
ms.locfileid: "73141384"
---
# <a name="application-domain-resource-monitoring"></a><span data-ttu-id="64130-102">Überwachung von Anwendungsdomänenressourcen</span><span class="sxs-lookup"><span data-stu-id="64130-102">Application Domain Resource Monitoring</span></span>

<span data-ttu-id="64130-103">Hosts mit der Ressourcenüberwachung für die Anwendungsdomäne (ARM) können die CPU- und Speicherauslastung pro Anwendungsdomäne überwachen.</span><span class="sxs-lookup"><span data-stu-id="64130-103">Application domain resource monitoring (ARM) enables hosts to monitor CPU and memory usage by application domain.</span></span> <span data-ttu-id="64130-104">Dies ist nützlich für Hosts wie ASP.NET, die eine Vielzahl von Anwendungsdomänen in einem Prozess mit langer Ausführungsdauer verwenden.</span><span class="sxs-lookup"><span data-stu-id="64130-104">This is useful for hosts such as ASP.NET that use many application domains in a long-running process.</span></span> <span data-ttu-id="64130-105">Der Host kann die Anwendungsdomäne einer Anwendung entladen, die sich negativ auf die Leistung des gesamten Prozesses auswirkt, jedoch nur, wenn er die problematische Anwendung ermitteln kann.</span><span class="sxs-lookup"><span data-stu-id="64130-105">The host can unload the application domain of an application that is adversely affecting the performance of the entire process, but only if it can identify the problematic application.</span></span> <span data-ttu-id="64130-106">Die ARM stellt Informationen bereit, die als Unterstützung bei solchen Entscheidungen herangezogen werden können.</span><span class="sxs-lookup"><span data-stu-id="64130-106">ARM provides information that can be used to assist in making such decisions.</span></span>

<span data-ttu-id="64130-107">In einem Hostingdienst werden möglicherweise viele Anwendungen auf einem ASP.NET-Server ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="64130-107">For example, a hosting service might have many applications running on an ASP.NET server.</span></span> <span data-ttu-id="64130-108">Wenn eine Anwendung im Prozess zu viele Speicherressourcen verbraucht oder zu viel Prozessorzeit in Anspruch nimmt, kann der Hostingdienst mithilfe der ARM die Anwendungsdomäne ermitteln, die das Problem verursacht.</span><span class="sxs-lookup"><span data-stu-id="64130-108">If one application in the process begins consuming too much memory or too much processor time, the hosting service can use ARM to identify the application domain that is causing the problem.</span></span>

<span data-ttu-id="64130-109">Die ARM ist für den Einsatz bei aktiven Anwendungen entsprechend einfach konzipiert.</span><span class="sxs-lookup"><span data-stu-id="64130-109">ARM is sufficiently lightweight to use in live applications.</span></span> <span data-ttu-id="64130-110">Sie können mithilfe der Ereignisablaufverfolgung für Windows (ETW) oder direkt über verwaltete oder native APIs auf die Informationen zugreifen.</span><span class="sxs-lookup"><span data-stu-id="64130-110">You can access the information by using event tracing for Windows (ETW) or directly through managed or native APIs.</span></span>

## <a name="enabling-resource-monitoring"></a><span data-ttu-id="64130-111">Aktivieren der Ressourcenüberwachung</span><span class="sxs-lookup"><span data-stu-id="64130-111">Enabling Resource Monitoring</span></span>

<span data-ttu-id="64130-112">Die ARM kann auf vier Arten aktiviert werden: Durch Bereitstellen einer Konfigurationsdatei beim Starten der Common Language Runtime (CLR), durch eine nicht verwaltete Hosting-API, durch verwalteten Code oder durch Lauschen auf ARM-ETW-Ereignisse.</span><span class="sxs-lookup"><span data-stu-id="64130-112">ARM can be enabled in four ways: by supplying a configuration file when the common language runtime (CLR) is started, by using an unmanaged hosting API, by using managed code, or by listening to ARM ETW events.</span></span>

<span data-ttu-id="64130-113">Sobald die ARM aktiviert ist, beginnt diese mit der Sammlung von Daten für alle Anwendungsdomänen im Prozess. Wenn vor der Aktivierung der ARM eine Anwendungsdomäne erstellt wurde, wird bei der Aktivierung der ARM (nicht bei der Erstellung der Anwendungsdomäne) die Sammlung kumulativer Daten gestartet. Sobald diese aktiviert ist, kann die ARM nicht deaktiviert werden.</span><span class="sxs-lookup"><span data-stu-id="64130-113">As soon as ARM is enabled, it begins collecting data on all application domains in the process.If an application domain was created before ARM is enabled, cumulative data starts when ARM is enabled, not when the application domain was created.Once it is enabled, ARM cannot be disabled.</span></span>

- <span data-ttu-id="64130-114">Sie können die ARM beim Start der CLR aktivieren, indem Sie das [\<appDomainResourceMonitoring>](../../../docs/framework/configure-apps/file-schema/runtime/appdomainresourcemonitoring-element.md)-Element zur Konfigurationsdatei hinzufügen und das `enabled`-Attribut auf `true` festlegen.</span><span class="sxs-lookup"><span data-stu-id="64130-114">You can enable ARM at CLR startup by adding the [\<appDomainResourceMonitoring>](../../../docs/framework/configure-apps/file-schema/runtime/appdomainresourcemonitoring-element.md) element to the configuration file, and setting the `enabled` attribute to `true`.</span></span> <span data-ttu-id="64130-115">Der Wert `false` (Standardeinstellung) gibt lediglich an, dass die ARM beim Start nicht aktiviert wurde. Sie können sie später durch eine der anderen Aktivierungsmethoden aktivieren.</span><span class="sxs-lookup"><span data-stu-id="64130-115">A value of `false` (the default) means only that ARM is not enabled at startup; you can activate it later by using one of the other activation mechanisms.</span></span>

- <span data-ttu-id="64130-116">Der Host kann die ARM durch Anfordern der Hostingschnittstelle [ICLRAppDomainResourceMonitor](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-interface.md) aktivieren.</span><span class="sxs-lookup"><span data-stu-id="64130-116">The host can enable ARM by requesting the [ICLRAppDomainResourceMonitor](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-interface.md) hosting interface.</span></span> <span data-ttu-id="64130-117">Sobald diese Schnittstelle erfolgreich abgerufen wurde, wird die ARM aktiviert.</span><span class="sxs-lookup"><span data-stu-id="64130-117">Once this interface is successfully obtained, ARM is enabled.</span></span>

- <span data-ttu-id="64130-118">Verwalteter Code kann die ARM aktivieren, indem die statische (`Shared` in Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled%2A?displayProperty=nameWithType>-Eigenschaft auf `true` festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="64130-118">Managed code can enable ARM by setting the static (`Shared` in Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled%2A?displayProperty=nameWithType> property to `true`.</span></span> <span data-ttu-id="64130-119">Sobald die Eigenschaft festgelegt ist, wird die ARM aktiviert.</span><span class="sxs-lookup"><span data-stu-id="64130-119">As soon as the property is set, ARM is enabled.</span></span>

- <span data-ttu-id="64130-120">Sie können die ARM nach dem Start durch Lauschen auf ETW-Ereignisse aktivieren.</span><span class="sxs-lookup"><span data-stu-id="64130-120">You can enable ARM after startup by listening to ETW events.</span></span> <span data-ttu-id="64130-121">Wenn Sie den öffentlichen Anbieter `Microsoft-Windows-DotNETRuntime` mit dem Schlüsselwort `AppDomainResourceManagementKeyword` aktivieren, wird die ARM aktiviert, und sie beginnt mit dem Auslösen von Ereignissen für alle Anwendungsdomänen.</span><span class="sxs-lookup"><span data-stu-id="64130-121">ARM is enabled and begins raising events for all application domains when you enable the public provider `Microsoft-Windows-DotNETRuntime` by using the `AppDomainResourceManagementKeyword` keyword.</span></span> <span data-ttu-id="64130-122">Um Daten mit Anwendungsdomänen und -threads zu korrelieren, müssen Sie auch den Anbieter `Microsoft-Windows-DotNETRuntimeRundown` mit dem Schlüsselwort `ThreadingKeyword` aktivieren.</span><span class="sxs-lookup"><span data-stu-id="64130-122">To correlate data with application domains and threads, you must also enable the `Microsoft-Windows-DotNETRuntimeRundown` provider with the `ThreadingKeyword` keyword.</span></span>

## <a name="using-arm"></a><span data-ttu-id="64130-123">Verwenden der ARM</span><span class="sxs-lookup"><span data-stu-id="64130-123">Using ARM</span></span>

<span data-ttu-id="64130-124">Die ARM stellt die gesamte von einer Anwendungsdomäne in Anspruch genommene Prozessorzeit sowie drei Arten von Informationen zur Speicherauslastung bereit.</span><span class="sxs-lookup"><span data-stu-id="64130-124">ARM provides the total processor time that is used by an application domain and three kinds of information about memory use.</span></span>

- <span data-ttu-id="64130-125">**Gesamtprozessorzeit für eine Anwendungsdomäne in Sekunden:** Diese wird durch Addieren der Threadzeiten berechnet, die vom Betriebssystem für alle Threads gemeldet werden, die während ihrer Lebensdauer Zeit für die Ausführung in der Anwendungsdomäne aufgewendet haben.</span><span class="sxs-lookup"><span data-stu-id="64130-125">**Total processor time for an application domain, in seconds**: This is calculated by adding up the thread times reported by the operating system for all threads that spent time executing in the application domain during its lifetime.</span></span> <span data-ttu-id="64130-126">Blockierte Threads oder Threads im Ruhezustand nehmen keine Prozessorzeit in Anspruch.</span><span class="sxs-lookup"><span data-stu-id="64130-126">Blocked or sleeping threads do not use processor time.</span></span> <span data-ttu-id="64130-127">Wenn ein Thread nativen Code aufruft, ist die vom Thread für nativen Code aufgewendete Zeit im Wert für die Anwendungsdomäne enthalten, in der der Aufruf erfolgt ist.</span><span class="sxs-lookup"><span data-stu-id="64130-127">When a thread calls into native code, the time that the thread spends in native code is included in the count for the application domain where the call was made.</span></span>

  - <span data-ttu-id="64130-128">Verwaltete API: Eigenschaft <xref:System.AppDomain.MonitoringTotalProcessorTime%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="64130-128">Managed API: <xref:System.AppDomain.MonitoringTotalProcessorTime%2A?displayProperty=nameWithType> property.</span></span>

  - <span data-ttu-id="64130-129">Hosting-API: [ICLRAppDomainResourceMonitor::GetCurrentCpuTime](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentcputime-method.md)-Methode</span><span class="sxs-lookup"><span data-stu-id="64130-129">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentCpuTime](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentcputime-method.md) method.</span></span>

  - <span data-ttu-id="64130-130">ETW-Ereignisse: Ereignisse `ThreadCreated`, `ThreadAppDomainEnter` und `ThreadTerminated`.</span><span class="sxs-lookup"><span data-stu-id="64130-130">ETW events: `ThreadCreated`, `ThreadAppDomainEnter`, and `ThreadTerminated` events.</span></span> <span data-ttu-id="64130-131">Informationen zu Anbietern und Schlüsselwörtern finden Sie im Artikel [CLR-ETW-Ereignisse](../../../docs/framework/performance/clr-etw-events.md) unter „ETW-Ereignisse der Anwendungsdomänen-Ressourcenüberwachung“.</span><span class="sxs-lookup"><span data-stu-id="64130-131">For information about providers and keywords, see "AppDomain Resource Monitoring Events" in [CLR ETW Events](../../../docs/framework/performance/clr-etw-events.md).</span></span>

- <span data-ttu-id="64130-132">**Gesamtanzahl der durch eine Anwendungsdomäne während ihrer Lebensdauer vorgenommenen verwalteten Zuordnungen in Byte:** Die Gesamtanzahl der Zuordnungen spiegelt nicht immer die Speicherauslastung einer Anwendungsdomäne wider, da die zugeordneten Objekte kurzlebig sein können.</span><span class="sxs-lookup"><span data-stu-id="64130-132">**Total managed allocations made by an application domain during its lifetime, in bytes**: Total allocations do not always reflect memory use by an application domain, because the allocated objects might be short-lived.</span></span> <span data-ttu-id="64130-133">Wenn eine Anwendung eine große Anzahl von Objekten zuordnet und freigibt, können die Kosten für die Zuordnungen beträchtlich sein.</span><span class="sxs-lookup"><span data-stu-id="64130-133">However, if an application allocates and frees huge numbers of objects, the cost of the allocations could be significant.</span></span>

  - <span data-ttu-id="64130-134">Verwaltete API: Eigenschaft <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="64130-134">Managed API: <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A?displayProperty=nameWithType> property.</span></span>

  - <span data-ttu-id="64130-135">Hosting-API: [ICLRAppDomainResourceMonitor::GetCurrentAllocated](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentallocated-method.md)-Methode</span><span class="sxs-lookup"><span data-stu-id="64130-135">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentAllocated](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentallocated-method.md) method.</span></span>

  - <span data-ttu-id="64130-136">ETW-Ereignisse: Ereignis `AppDomainMemAllocated`, Feld `Allocated`</span><span class="sxs-lookup"><span data-stu-id="64130-136">ETW events: `AppDomainMemAllocated` event, `Allocated` field.</span></span>

- <span data-ttu-id="64130-137">**Verwalteter Speicher in Byte, auf den durch eine Anwendungsdomäne verwiesen wird und der bei der letzten vollständigen blockierenden Collection beibehalten wurde:** Dieser Wert ist erst nach einer vollständigen blockierenden Collection präzise.</span><span class="sxs-lookup"><span data-stu-id="64130-137">**Managed memory, in bytes, that is referenced by an application domain and that survived the most recent full, blocking collection**: This number is accurate only after a full, blocking collection.</span></span> <span data-ttu-id="64130-138">(Dieser Vorgang stellt das Gegenteil zu gleichzeitigen Auflistungen dar, die im Hintergrund ausgeführt werden und die Anwendung nicht blockieren.) Die Methodenüberladung <xref:System.GC.Collect?displayProperty=nameWithType> führt beispielsweise zu einer vollständigen blockierenden Auflistung.</span><span class="sxs-lookup"><span data-stu-id="64130-138">(This is in contrast to concurrent collections, which occur in the background and do not block the application.) For example, the <xref:System.GC.Collect?displayProperty=nameWithType> method overload causes a full, blocking collection.</span></span>

  - <span data-ttu-id="64130-139">Verwaltete API: Eigenschaft <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="64130-139">Managed API: <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A?displayProperty=nameWithType> property.</span></span>

  - <span data-ttu-id="64130-140">Hosting-API: [ICLRAppDomainResourceMonitor::GetCurrentSurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md)-Methode mit dem Parameter `pAppDomainBytesSurvived`</span><span class="sxs-lookup"><span data-stu-id="64130-140">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentSurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) method, `pAppDomainBytesSurvived` parameter.</span></span>

  - <span data-ttu-id="64130-141">ETW-Ereignisse: Ereignis `AppDomainMemSurvived`, Feld `Survived`</span><span class="sxs-lookup"><span data-stu-id="64130-141">ETW events: `AppDomainMemSurvived` event, `Survived` field.</span></span>

- <span data-ttu-id="64130-142">**Gesamter verwalteter Speicher in Byte, auf den vom Prozess verwiesen wird und der bei der letzten vollständigen blockierenden Collection beibehalten wurde:** Der Speicher, der für einzelne Anwendungsdomänen beibehalten wird, kann mit dieser Zahl verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="64130-142">**Total managed memory, in bytes, that is referenced by the process and that survived the most recent full, blocking collection**: The survived memory for individual application domains can be compared to this number.</span></span>

  - <span data-ttu-id="64130-143">Verwaltete API: Eigenschaft <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="64130-143">Managed API: <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A?displayProperty=nameWithType> property.</span></span>

  - <span data-ttu-id="64130-144">Hosting-API: [ICLRAppDomainResourceMonitor::GetCurrentSurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md)-Methode mit dem Parameter `pTotalBytesSurvived`</span><span class="sxs-lookup"><span data-stu-id="64130-144">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentSurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) method, `pTotalBytesSurvived` parameter.</span></span>

  - <span data-ttu-id="64130-145">ETW-Ereignisse: Ereignis `AppDomainMemSurvived`, Feld `ProcessSurvived`</span><span class="sxs-lookup"><span data-stu-id="64130-145">ETW events: `AppDomainMemSurvived` event, `ProcessSurvived` field.</span></span>

### <a name="determining-when-a-full-blocking-collection-occurs"></a><span data-ttu-id="64130-146">Ermittlung des Zeitpunkts, an dem eine vollständige blockierende Auflistung auftritt</span><span class="sxs-lookup"><span data-stu-id="64130-146">Determining When a Full, Blocking Collection Occurs</span></span>

<span data-ttu-id="64130-147">Um zu ermitteln, wann die Menge des beibehaltenen Speichers genau ist, müssen Sie wissen, wann soeben eine vollständige blockierende Auflistung aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="64130-147">To determine when counts of survived memory are accurate, you need to know when a full, blocking collection has just occurred.</span></span> <span data-ttu-id="64130-148">Die hierbei angewendete Methode hängt von der API ab, die Sie zum Untersuchen der ARM-Statistik verwenden.</span><span class="sxs-lookup"><span data-stu-id="64130-148">The method for doing this depends on the API you use to examine ARM statistics.</span></span>

#### <a name="managed-api"></a><span data-ttu-id="64130-149">Verwaltete API</span><span class="sxs-lookup"><span data-stu-id="64130-149">Managed API</span></span>

<span data-ttu-id="64130-150">Wenn Sie die Eigenschaften der <xref:System.AppDomain>-Klasse verwenden, können Sie sich mithilfe der <xref:System.GC.RegisterForFullGCNotification%2A?displayProperty=nameWithType>-Methode für Benachrichtigungen über vollständige Auflistungen registrieren.</span><span class="sxs-lookup"><span data-stu-id="64130-150">If you use the properties of the <xref:System.AppDomain> class, you can use the <xref:System.GC.RegisterForFullGCNotification%2A?displayProperty=nameWithType> method to register for notification of full collections.</span></span> <span data-ttu-id="64130-151">Der von Ihnen verwendete Schwellenwert ist nicht von Bedeutung, da Sie auf den Abschluss einer Auflistung warten, nicht auf den Ansatz einer Auflistung.</span><span class="sxs-lookup"><span data-stu-id="64130-151">The threshold you use is not important, because you are waiting for the completion of a collection rather than the approach of a collection.</span></span> <span data-ttu-id="64130-152">Sie können dann die Methode <xref:System.GC.WaitForFullGCComplete%2A?displayProperty=nameWithType> aufrufen, die bis zum Abschluss einer vollständigen Auflistung blockiert ist.</span><span class="sxs-lookup"><span data-stu-id="64130-152">You can then call the <xref:System.GC.WaitForFullGCComplete%2A?displayProperty=nameWithType> method, which blocks until a full collection has completed.</span></span> <span data-ttu-id="64130-153">Sie können einen Thread erstellen, der die Methode in einer Schleife aufruft und bei der Rückgabe der Methode alle erforderlichen Analysen durchführt.</span><span class="sxs-lookup"><span data-stu-id="64130-153">You can create a thread that calls the method in a loop and does any necessary analysis whenever the method returns.</span></span>

<span data-ttu-id="64130-154">Alternativ können Sie in regelmäßigen Abständen die <xref:System.GC.CollectionCount%2A?displayProperty=nameWithType>-Methode aufrufen, um festzustellen, ob sich die Anzahl der Auflistungen der Generation 2 erhöht hat.</span><span class="sxs-lookup"><span data-stu-id="64130-154">Alternatively, you can call the <xref:System.GC.CollectionCount%2A?displayProperty=nameWithType> method periodically to see if the count of generation 2 collections has increased.</span></span> <span data-ttu-id="64130-155">Dieses Verfahren kann abhängig von der Abrufhäufigkeit möglicherweise keine genauen Angaben zum Auftreten einer vollständigen Auflistung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="64130-155">Depending on the polling frequency, this technique might not provide as accurate an indication of the occurrence of a full collection.</span></span>

#### <a name="hosting-api"></a><span data-ttu-id="64130-156">Hosting-API</span><span class="sxs-lookup"><span data-stu-id="64130-156">Hosting API</span></span>

<span data-ttu-id="64130-157">Wenn Sie die nicht verwaltete Hosting-API verwenden, muss Ihr Host der CLR eine Implementierung der [IHostGCManager](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-interface.md)-Schnittstelle übergeben.</span><span class="sxs-lookup"><span data-stu-id="64130-157">If you use the unmanaged hosting API, your host must pass the CLR an implementation of the [IHostGCManager](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-interface.md) interface.</span></span> <span data-ttu-id="64130-158">Die CLR ruft die Methode [IHostGCManager::SuspensionEnding](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) auf, wenn bei der Ausführung einer Auflistung die Ausführung der angehaltenen Threads fortgesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="64130-158">The CLR calls the [IHostGCManager::SuspensionEnding](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) method when it resumes execution of threads that have been suspended while a collection occurs.</span></span> <span data-ttu-id="64130-159">Die CLR übergibt die Erzeugung der abgeschlossenen Auflistung als Parameter der Methode, damit der Host ermitteln kann, ob die Auflistung vollständig oder teilweise ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="64130-159">The CLR passes the generation of the completed collection as a parameter of the method, so the host can determine whether the collection was full or partial.</span></span> <span data-ttu-id="64130-160">Ihre Implementierung der [IHostGCManager::SuspensionEnding](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md)-Methode kann den beibehaltenen Speicher abfragen, um sicherzustellen, dass die Werte direkt nach ihrer Aktualisierung abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="64130-160">Your implementation of the [IHostGCManager::SuspensionEnding](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) method can query for survived memory, to ensure that the counts are retrieved as soon as they are updated.</span></span>

## <a name="see-also"></a><span data-ttu-id="64130-161">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="64130-161">See also</span></span>

- <xref:System.AppDomain.MonitoringIsEnabled%2A?displayProperty=nameWithType>
- [<span data-ttu-id="64130-162">ICLRAppDomainResourceMonitor-Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="64130-162">ICLRAppDomainResourceMonitor Interface</span></span>](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-interface.md)
- [<span data-ttu-id="64130-163">\<appDomainResourceMonitoring></span><span class="sxs-lookup"><span data-stu-id="64130-163">\<appDomainResourceMonitoring></span></span>](../../../docs/framework/configure-apps/file-schema/runtime/appdomainresourcemonitoring-element.md)
- [<span data-ttu-id="64130-164">CLR-ETW-Ereignisse</span><span class="sxs-lookup"><span data-stu-id="64130-164">CLR ETW Events</span></span>](../../../docs/framework/performance/clr-etw-events.md)
