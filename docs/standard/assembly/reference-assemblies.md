---
title: Verweisassemblys
description: Erfahren Sie mehr über Verweisassemblys, eine spezielle Art von Assemblys in .NET, die nur die öffentliche API-Oberfläche der Bibliothek enthalten.
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.technology: dotnet-standard
ms.openlocfilehash: 938942caf81c54a8aa9207dbe87559438ffb252e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/15/2020
ms.locfileid: "79141067"
---
# <a name="reference-assemblies"></a><span data-ttu-id="ca704-103">Verweisassemblys</span><span class="sxs-lookup"><span data-stu-id="ca704-103">Reference assemblies</span></span>

<span data-ttu-id="ca704-104">*Verweisassemblys*  sind eine besondere Art von Assembly, die nur die Mindestmenge an Metadaten enthalten, die zum Darstellen der öffentlichen API-Oberfläche der Bibliothek erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="ca704-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="ca704-105">Sie beinhalten Deklarationen für alle Member, die beim Verweis auf eine Assembly in Buildtools von Bedeutung sind, schließen aber alle Memberimplementierungen und Deklarationen privater Member aus, die keine beobachtbaren Auswirkungen auf ihren API-Vertrag haben.</span><span class="sxs-lookup"><span data-stu-id="ca704-105">They include declarations for all members that are significant when referencing an assembly in build tools, but exclude all member implementations and declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="ca704-106">Im Gegensatz dazu werden reguläre Assemblys als *Implementierungsassemblys* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="ca704-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span>

<span data-ttu-id="ca704-107">Referenzassemblys können nicht zur Ausführung geladen werden, sie können jedoch auf die gleiche Weise wie Implementierungsassemblys als Compilereingaben übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="ca704-107">Reference assemblies can't be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="ca704-108">Referenzassemblys werden in der Regel mit dem Software Development Kit (SDK) einer bestimmten Plattform oder Bibliothek verteilt.</span><span class="sxs-lookup"><span data-stu-id="ca704-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library.</span></span>

<span data-ttu-id="ca704-109">Die Verwendung einer Verweisassembly ermöglicht Entwicklern das Erstellen von Programmen für eine bestimmte Bibliotheksversion, ohne dass die vollständige Implementierungsassembly für diese Version vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="ca704-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="ca704-110">Angenommen, Sie haben nur die neueste Version einer Bibliothek auf Ihrem Computer, aber Sie möchten ein Programm erstellen, das auf eine frühere Version dieser Bibliothek abzielt.</span><span class="sxs-lookup"><span data-stu-id="ca704-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets an earlier version of that library.</span></span> <span data-ttu-id="ca704-111">Wenn Sie direkt mit der Implementierungsassembly kompilieren, verwenden Sie möglicherweise versehentlich API-Member, die in der früheren Version nicht verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="ca704-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version.</span></span> <span data-ttu-id="ca704-112">Sie finden diesen Fehler nur, wenn Sie das Programm auf dem Zielcomputer testen.</span><span class="sxs-lookup"><span data-stu-id="ca704-112">You'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="ca704-113">Wenn Sie eine Kompilierung mit der Verweisassembly für die frühere Version ausführen, erhalten Sie sofort einen Kompilierzeitfehler.</span><span class="sxs-lookup"><span data-stu-id="ca704-113">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="ca704-114">Darüber hinaus kann eine Referenzassembly einen Vertrag darstellen, d.h. einen Satz von APIs, der nicht der konkreten Implementierungsassembly entspricht.</span><span class="sxs-lookup"><span data-stu-id="ca704-114">A reference assembly can also represent a contract, that is, a set of APIs that don't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="ca704-115">Solche Referenzassemblys, die als *Vertragsassemblys* bezeichnet werden, können verwendet werden, um mehrere Plattformen als Ziel festzulegen, die denselben Satz von APIs unterstützen.</span><span class="sxs-lookup"><span data-stu-id="ca704-115">Such reference assemblies, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="ca704-116">.NET Standard stellt z.B. die Vertragsassembly *netstandard.dll* bereit, die den Satz allgemeiner APIs darstellt, die von verschiedenen .NET-Plattformen gemeinsam verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ca704-116">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="ca704-117">Die Implementierungen dieser APIs sind in verschiedenen Assemblys auf unterschiedlichen Plattformen enthalten, z.B. *mscorlib.dll* für .NET Framework oder *System.Private.CoreLib.dll* für .NET Core.</span><span class="sxs-lookup"><span data-stu-id="ca704-117">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="ca704-118">Eine Bibliothek für .NET Standard kann auf allen Plattformen ausgeführt werden, die .NET Standard unterstützen.</span><span class="sxs-lookup"><span data-stu-id="ca704-118">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span>

## <a name="using-reference-assemblies"></a><span data-ttu-id="ca704-119">Verwenden von Verweisassemblys</span><span class="sxs-lookup"><span data-stu-id="ca704-119">Using reference assemblies</span></span>

<span data-ttu-id="ca704-120">Um bestimmte APIs aus Ihrem Projekt zu verwenden, müssen Sie Verweise auf deren Assemblys hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="ca704-120">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="ca704-121">Sie können Verweise sowohl zu Implementierungsassemblys als auch zu Referenzassemblys hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="ca704-121">You can add references to either implementation assemblies or to reference assemblies.</span></span> <span data-ttu-id="ca704-122">Die Verwendung von Referenzassemblys wird immer empfohlen, wenn sie zur Verfügung stehen.</span><span class="sxs-lookup"><span data-stu-id="ca704-122">It's recommended you use reference assemblies whenever they're available.</span></span> <span data-ttu-id="ca704-123">Dadurch können Sie sicherstellen, dass Sie nur die unterstützten API-Mitglieder in der Zielversion verwenden, deren Verwendung von den API-Entwicklern geplant ist.</span><span class="sxs-lookup"><span data-stu-id="ca704-123">Doing so ensures that you're using only the supported API members in the target version, meant to be used by API designers.</span></span> <span data-ttu-id="ca704-124">Das Verwenden der Referenzassembly stellt sicher, dass Sie keine Abhängigkeit in Implementierungsdetails einbringen.</span><span class="sxs-lookup"><span data-stu-id="ca704-124">Using the reference assembly ensures you're not taking a dependency on implementation details.</span></span>

<span data-ttu-id="ca704-125">Verweisassemblys für .NET Framework-Bibliotheken werden mit Zielpaketen verteilt.</span><span class="sxs-lookup"><span data-stu-id="ca704-125">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="ca704-126">Sie können sie abrufen, indem Sie einen eigenständigen Installer herunterladen oder eine Komponente im Visual Studio-Installer auswählen.</span><span class="sxs-lookup"><span data-stu-id="ca704-126">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="ca704-127">Weitere Informationen finden Sie unter [Installieren von .NET Framework für Entwickler](../../framework/install/guide-for-developers.md).</span><span class="sxs-lookup"><span data-stu-id="ca704-127">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="ca704-128">Für .NET Core und .NET Standard werden Verweisassemblys nach Bedarf automatisch heruntergeladen (über NuGet), und es wird darauf verwiesen.</span><span class="sxs-lookup"><span data-stu-id="ca704-128">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="ca704-129">Für .NET Core 3.0 und höher befinden sich die Verweisassemblys für das Kernframework im Paket [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) (das Paket [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) wird stattdessen für Versionen vor 3.0 verwendet).</span><span class="sxs-lookup"><span data-stu-id="ca704-129">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span> <span data-ttu-id="ca704-130">Weitere Informationen finden Sie unter [Pakete, Metapakete und Frameworks](../../core/packages.md) im .NET Core-Leitfaden.</span><span class="sxs-lookup"><span data-stu-id="ca704-130">For more information, see [Packages, metapackages, and frameworks](../../core/packages.md) in the .NET Core Guide.</span></span>

<span data-ttu-id="ca704-131">Wenn Sie in Visual Studio über das Dialogfeld **Verweis hinzufügen** Verweise auf .NET-Framework-Assemblys hinzufügen, wählen Sie eine Assembly aus der Liste aus, und Visual Studio ermittelt automatisch Verweisassemblys, die der in Ihrem Projekt ausgewählten Zielframeworkversion entsprechen.</span><span class="sxs-lookup"><span data-stu-id="ca704-131">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="ca704-132">Dasselbe gilt für das direkte Hinzufügen von Verweisen im MSBuild-Projekt mit dem Projektelement [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference): Sie müssen nur den Assemblynamen angeben, nicht den vollständigen Dateipfad.</span><span class="sxs-lookup"><span data-stu-id="ca704-132">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="ca704-133">Wenn Sie in der Befehlszeile Verweise auf diese Assemblys mit der Compileroption `-reference` ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) und [in Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) oder mit der Methode <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> in der Roslyn-API hinzufügen, müssen Sie manuell Verweisassemblydateien für die richtige Zielplattformversion angeben.</span><span class="sxs-lookup"><span data-stu-id="ca704-133">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="ca704-134">.NET Framework-Verweisassemblydateien befinden sich im Verzeichnis *%ProgramFiles (x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework*.</span><span class="sxs-lookup"><span data-stu-id="ca704-134">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="ca704-135">Für .NET Core können Sie erzwingen, dass der Veröffentlichungsvorgang Verweisassemblys für Ihre Zielplattform in das Unterverzeichnis *publish/refs* des Ausgabeverzeichnisses kopiert, indem Sie die `PreserveCompilationContext`-Projekteigenschaft auf `true` festlegen.</span><span class="sxs-lookup"><span data-stu-id="ca704-135">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="ca704-136">Anschließend können Sie diese Verweisassemblydateien an den Compiler übergeben.</span><span class="sxs-lookup"><span data-stu-id="ca704-136">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="ca704-137">Die Verwendung von `DependencyContext` aus dem Paket [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) kann helfen, ihre Pfade zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="ca704-137">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="ca704-138">Da sie keine Implementierung enthalten, können Referenzassemblys nicht zur Ausführung geladen werden.</span><span class="sxs-lookup"><span data-stu-id="ca704-138">Because they contain no implementation, reference assemblies can't be loaded for execution.</span></span> <span data-ttu-id="ca704-139">Der Versuch, sie zu laden, führt zu <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ca704-139">Trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ca704-140">Wenn Sie den Inhalt einer Verweisassembly untersuchen möchten, können Sie diese in den auf Reflexion beschränkten Kontext im .NET Framework (mit der <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>-Methode) oder in <xref:System.Reflection.MetadataLoadContext> in .NET Core laden.</span><span class="sxs-lookup"><span data-stu-id="ca704-140">If you want to examine the contents of a reference assembly, you can load it into the reflection-only context in .NET Framework (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method) or into the <xref:System.Reflection.MetadataLoadContext> in .NET Core.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="ca704-141">Generieren von Verweisassemblys</span><span class="sxs-lookup"><span data-stu-id="ca704-141">Generating reference assemblies</span></span>

<span data-ttu-id="ca704-142">Das Generieren von Referenzassemblys für Ihre Bibliotheken kann nützlich sein, wenn Ihre Bibliotheksconsumer ihre Programme mit vielen verschiedenen Versionen der Bibliothek erstellen müssen.</span><span class="sxs-lookup"><span data-stu-id="ca704-142">Generating reference assemblies for your libraries can be useful when your library consumers need to build their programs against many different versions of the library.</span></span> <span data-ttu-id="ca704-143">Die Verteilung von Implementierungsassemblys für alle diese Versionen ist aufgrund ihrer Größe möglicherweise nicht praktikabel.</span><span class="sxs-lookup"><span data-stu-id="ca704-143">Distributing implementation assemblies for all these versions might be impractical because of their large size.</span></span> <span data-ttu-id="ca704-144">Referenzassemblys sind kleiner, sodass die Verteilung als Teil des SDK Ihrer Bibliothek die Downloadgröße verringert und Speicherplatz spart.</span><span class="sxs-lookup"><span data-stu-id="ca704-144">Reference assemblies are smaller in size, and distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="ca704-145">IDEs und Buildtools können ebenfalls Verweisassemblys nutzen, um Buildzeiten bei umfangreichen Lösungen zu reduzieren, die aus mehreren Klassenbibliotheken bestehen.</span><span class="sxs-lookup"><span data-stu-id="ca704-145">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="ca704-146">Normalerweise wird ein Projekt in inkrementellen Buildszenarien neu erstellt, wenn eine seiner Eingabedateien geändert wird, einschließlich der Assemblys, von denen es abhängt.</span><span class="sxs-lookup"><span data-stu-id="ca704-146">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="ca704-147">Die Implementierungsassembly ändert sich immer dann, wenn der Programmierer die Implementierung eines beliebigen Members ändert.</span><span class="sxs-lookup"><span data-stu-id="ca704-147">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="ca704-148">Die Verweisassembly ändert sich nur, wenn ihre öffentliche API betroffen ist.</span><span class="sxs-lookup"><span data-stu-id="ca704-148">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="ca704-149">Daher ermöglicht die Verwendung der Referenzassembly als Eingabedatei anstelle der Implementierungsassembly in einigen Fällen das Überspringen des Buildvorgangs des abhängigen Projekts.</span><span class="sxs-lookup"><span data-stu-id="ca704-149">So, using the reference assembly as an input file instead of the implementation assembly allows skipping the build of the dependent project in some cases.</span></span>

<span data-ttu-id="ca704-150">Sie können Verweisassemblys folgendermaßen generieren:</span><span class="sxs-lookup"><span data-stu-id="ca704-150">You can generate reference assemblies:</span></span>

- <span data-ttu-id="ca704-151">In einem MSBuild-Projekt mithilfe der [`ProduceReferenceAssembly`-Projekteigenschaft](/visualstudio/msbuild/common-msbuild-project-properties).</span><span class="sxs-lookup"><span data-stu-id="ca704-151">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="ca704-152">Beim Kompilieren von Programmen über die Befehlszeile, indem Sie die Compileroptionen `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md)) oder `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) angeben.</span><span class="sxs-lookup"><span data-stu-id="ca704-152">When compiling program from command line, by specifiying `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="ca704-153">Wenn Sie die Roslyn-API verwenden, legen Sie <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> auf `true` fest, und <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> auf `false` in einem Objekt, das an die <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType>-Methode übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="ca704-153">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="ca704-154">Wenn Sie Verweisassemblys mit NuGet-Paketen verteilen möchten, müssen Sie sie in das Unterverzeichnis *ref\\* unter dem Paketverzeichnis anstatt im das Unterverzeichnis *lib\\* einbinden, das für die Implementierungsassemblys verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="ca704-154">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="ca704-155">Struktur von Verweisassemblys</span><span class="sxs-lookup"><span data-stu-id="ca704-155">Reference assemblies structure</span></span>

<span data-ttu-id="ca704-156">Verweisassemblys sind eine Erweiterung des verwandten Konzepts der *auf Metadaten beschränkten Assemblys*.</span><span class="sxs-lookup"><span data-stu-id="ca704-156">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="ca704-157">Bei auf Metadaten beschränkten Assemblys werden die Methodentexte durch einen einzigen `throw null`-Text ersetzt, sie enthalten jedoch alle Member außer anonymen Typen.</span><span class="sxs-lookup"><span data-stu-id="ca704-157">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="ca704-158">Der Grund für die Verwendung von `throw null`-Text (im Gegensatz zu keinem Text) besteht darin, dass **PEVerify** erfolgreich ausgeführt und übergeben werden kann (und damit die Vollständigkeit der Metadaten überprüft).</span><span class="sxs-lookup"><span data-stu-id="ca704-158">The reason for using `throw null` bodies (as opposed to no bodies) is so that **PEVerify** can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="ca704-159">Verweisassemblys entfernen außerdem Metadaten (private Member) aus auf Metadaten beschränkten Assemblys:</span><span class="sxs-lookup"><span data-stu-id="ca704-159">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="ca704-160">Eine Verweisassembly verfügt nur über die Verweise, die es in der API-Oberfläche benötigt.</span><span class="sxs-lookup"><span data-stu-id="ca704-160">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="ca704-161">Die echte Assembly kann über zusätzliche Verweise verfügen, die sich auf bestimmte Implementierungen beziehen.</span><span class="sxs-lookup"><span data-stu-id="ca704-161">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="ca704-162">Bei Instanzen verweist die Referenzassembly für `class C { private void M() { dynamic d = 1; ... } }` nicht auf Typen, die für `dynamic` erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="ca704-162">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` doesn't reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="ca704-163">Private Funktionsmember (Methoden, Eigenschaften und Ereignisse) werden in den Fällen entfernt, in denen ihre Entfernung sich nicht erkennbar auf die Kompilierung auswirkt.</span><span class="sxs-lookup"><span data-stu-id="ca704-163">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="ca704-164">Wenn keine [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute)-Attribute vorhanden sind, werden interne Funktionsmember ebenfalls entfernt.</span><span class="sxs-lookup"><span data-stu-id="ca704-164">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="ca704-165">Die Metadaten in Referenzassemblys behalten die folgenden Informationen bei:</span><span class="sxs-lookup"><span data-stu-id="ca704-165">The metadata in reference assemblies continues to keep the following information:</span></span>

- <span data-ttu-id="ca704-166">Alle Typen, einschließlich privater und geschachtelter Typen.</span><span class="sxs-lookup"><span data-stu-id="ca704-166">All types, including private and nested types.</span></span>
- <span data-ttu-id="ca704-167">Alle Attribute, selbst interne.</span><span class="sxs-lookup"><span data-stu-id="ca704-167">All attributes, even internal ones.</span></span>
- <span data-ttu-id="ca704-168">Alle virtuellen Methoden.</span><span class="sxs-lookup"><span data-stu-id="ca704-168">All virtual methods.</span></span>
- <span data-ttu-id="ca704-169">Explizite Schnittstellenimplementierungen.</span><span class="sxs-lookup"><span data-stu-id="ca704-169">Explicit interface implementations.</span></span>
- <span data-ttu-id="ca704-170">Explizit implementierte Eigenschaften und Ereignisse, weil ihre Accessoren virtuell sind.</span><span class="sxs-lookup"><span data-stu-id="ca704-170">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="ca704-171">Alle Felder von Strukturen.</span><span class="sxs-lookup"><span data-stu-id="ca704-171">All fields of structures.</span></span>

<span data-ttu-id="ca704-172">Verweisassemblys enthalten ein [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute)-Attribut auf Assemblyebene.</span><span class="sxs-lookup"><span data-stu-id="ca704-172">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="ca704-173">Dieses Attribut kann in der Quelle angegeben werden (dann muss der Compiler es nicht synthetisch erstellen).</span><span class="sxs-lookup"><span data-stu-id="ca704-173">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="ca704-174">Aufgrund dieses Attribut verweigern Runtimes das Laden von Referenzassemblys für die Ausführung (sie können aber im reflektionsbezogenen Modus geladen werden).</span><span class="sxs-lookup"><span data-stu-id="ca704-174">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can be loaded in reflection-only mode).</span></span>

<span data-ttu-id="ca704-175">Genaue Details der Verweisassemblystruktur hängen von der Compilerversion ab.</span><span class="sxs-lookup"><span data-stu-id="ca704-175">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="ca704-176">Neuere Versionen können weitere Metadaten ausschließen, wenn festgestellt wird, dass sie sich nicht auf die öffentliche API-Oberfläche auswirken.</span><span class="sxs-lookup"><span data-stu-id="ca704-176">Newer versions may choose to exclude more metadata if it's determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="ca704-177">Die Informationen in diesem Abschnitt gelten nur für Verweisassemblys, die von Roslyn-Compilern ab C# Version 7.1 oder Visual Basic Version 15.3 generiert werden.</span><span class="sxs-lookup"><span data-stu-id="ca704-177">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="ca704-178">Die Struktur von Verweisassemblys für .NET Framework- und .NET Core-Bibliotheken kann sich in einigen Details unterscheiden, da sie ihren eigenen Mechanismus zum Generieren von Verweisassemblys verwenden.</span><span class="sxs-lookup"><span data-stu-id="ca704-178">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="ca704-179">Sie verfügen z.B. möglicherweise über vollständig leere Methodenkörper anstelle des `throw null`-Texts.</span><span class="sxs-lookup"><span data-stu-id="ca704-179">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="ca704-180">Das allgemeine Prinzip gilt jedoch weiterhin: Sie verfügen nicht über verwendbare Methodenimplementierungen und enthalten Metadaten nur für Member, die eine sichtbare Auswirkung aus der Perspektive einer öffentlichen API besitzen.</span><span class="sxs-lookup"><span data-stu-id="ca704-180">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="ca704-181">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="ca704-181">See also</span></span>

- [<span data-ttu-id="ca704-182">Assemblys in .NET</span><span class="sxs-lookup"><span data-stu-id="ca704-182">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="ca704-183">Übersicht über Frameworkziele</span><span class="sxs-lookup"><span data-stu-id="ca704-183">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="ca704-184">How to: Hinzufügen oder Entfernen von Verweisen mit dem Verweis-Manager</span><span class="sxs-lookup"><span data-stu-id="ca704-184">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
