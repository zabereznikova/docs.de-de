---
title: Benutzerdefinierte Partitionierer für PLINQ und TPL
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
ms.openlocfilehash: 2268df2eb5cae4dcd7adde491b42c86c546aa1fc
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/18/2020
ms.locfileid: "94829231"
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="3d72f-102">Benutzerdefinierte Partitionierer für PLINQ und TPL</span><span class="sxs-lookup"><span data-stu-id="3d72f-102">Custom Partitioners for PLINQ and TPL</span></span>

<span data-ttu-id="3d72f-103">Einer der wesentlichen Schritte, um einen Vorgang für eine Datenquelle zu parallelisieren, ist das *Partitionieren* der Quelle in mehrere Abschnitte, auf die mehrere Threads gleichzeitig zugreifen können.</span><span class="sxs-lookup"><span data-stu-id="3d72f-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="3d72f-104">PLINQ und die Task Parallel Library (TPL) stellen standardmäßige Partitionierer bereit, die transparent arbeiten, wenn Sie eine parallele Abfrage oder <xref:System.Threading.Tasks.Parallel.ForEach%2A>-Schleife schreiben.</span><span class="sxs-lookup"><span data-stu-id="3d72f-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="3d72f-105">Für erweiterte Szenarien können Sie Ihren eigenen Partitionierer einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>

## <a name="kinds-of-partitioning"></a><span data-ttu-id="3d72f-106">Arten der Partitionierung</span><span class="sxs-lookup"><span data-stu-id="3d72f-106">Kinds of Partitioning</span></span>

<span data-ttu-id="3d72f-107">Es gibt viele Möglichkeiten, eine Datenquelle zu partitionieren.</span><span class="sxs-lookup"><span data-stu-id="3d72f-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="3d72f-108">Bei den effizientesten Ansätzen wird die Quelle nicht physisch in mehrere Untersequenzen unterteilt, sondern mehrere Threads kooperieren beim Verarbeiten der ursprünglichen Quellsequenz.</span><span class="sxs-lookup"><span data-stu-id="3d72f-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="3d72f-109">Für Arrays und andere indizierte Quellen wie <xref:System.Collections.IList>-Sammlungen, bei denen die Länge im Voraus bekannt ist, ist die *Bereichspartitionierung* die einfachste Art der Partitionierung.</span><span class="sxs-lookup"><span data-stu-id="3d72f-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="3d72f-110">Jeder Thread empfängt eindeutige Indizes für Anfang und Ende, sodass er seinen Bereich der Quelle verarbeiten kann, ohne einen anderen Thread zu überschreiben oder selbst überschrieben zu werden.</span><span class="sxs-lookup"><span data-stu-id="3d72f-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="3d72f-111">Der einzige Mehraufwand bei der Bereichspartitionierung ist die ursprüngliche Erstellung von Bereichen; danach ist keine zusätzliche Synchronisierung erforderlich.</span><span class="sxs-lookup"><span data-stu-id="3d72f-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="3d72f-112">Aus diesem Grund liefert sie gute Leistung, solange die Arbeitsauslastung gleichmäßig verteilt wird.</span><span class="sxs-lookup"><span data-stu-id="3d72f-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="3d72f-113">Ein Nachteil der Bereichspartitionierung ist, dass ein Thread, der seine Arbeit frühzeitig beendet, den anderen Threads keine Arbeit abnehmen kann.</span><span class="sxs-lookup"><span data-stu-id="3d72f-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>

<span data-ttu-id="3d72f-114">Für verknüpfte Listen oder andere Sammlungen, deren Länge nicht bekannt ist, können Sie die *Blockpartitionierung* verwenden.</span><span class="sxs-lookup"><span data-stu-id="3d72f-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="3d72f-115">Bei der Blockpartitionierung nutzt jeder Thread oder jede Aufgabe in einer parallelen Schleife oder Abfrage eine Anzahl von Quellelementen in einem Block, verarbeitet sie und kehrt dann zurück, um zusätzliche Elemente abzurufen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="3d72f-116">Mit dem Partitionierer wird sichergestellt, dass alle Elemente verteilt werden und keine Duplikate vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="3d72f-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="3d72f-117">Ein Block kann eine beliebige Größe haben.</span><span class="sxs-lookup"><span data-stu-id="3d72f-117">A chunk may be any size.</span></span> <span data-ttu-id="3d72f-118">Der in [Gewusst wie: Implementieren von dynamischen Partitionen](how-to-implement-dynamic-partitions.md) gezeigte Partitionierer erstellt z.B. Blöcke, die nur ein Element enthalten.</span><span class="sxs-lookup"><span data-stu-id="3d72f-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="3d72f-119">Solange die Blöcke nicht zu groß sind, bewirkt diese Art der Partitionierung auch grundsätzlich einen Lastenausgleich, da die Zuweisung von Elementen zu Threads nicht vorgegeben ist.</span><span class="sxs-lookup"><span data-stu-id="3d72f-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="3d72f-120">Allerdings macht sich der Synchronisierungsmehraufwand für den Partitionierer immer dann bemerkbar, wenn der Thread einen anderen Block abrufen muss.</span><span class="sxs-lookup"><span data-stu-id="3d72f-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="3d72f-121">Das Ausmaß der Synchronisierung ist in diesen Fällen umgekehrt proportional zur Größe der Blöcke.</span><span class="sxs-lookup"><span data-stu-id="3d72f-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>

<span data-ttu-id="3d72f-122">Im Allgemeinen ist die Bereichspartitionierung nur schneller, wenn die Ausführungszeit des Delegaten kurz bis mäßig ist, die Quelle über eine große Anzahl von Elementen verfügt und die gesamte Arbeit in jeder Partition ungefähr gleich ist.</span><span class="sxs-lookup"><span data-stu-id="3d72f-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="3d72f-123">Die Blockpartitionierung ist daher im Allgemeinen in den meisten Fällen schneller.</span><span class="sxs-lookup"><span data-stu-id="3d72f-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="3d72f-124">Bei Datenquellen mit einer kleinen Anzahl von Elementen oder längeren Ausführungszeiten für den Delegaten sind Leistung des Blocks und Bereichspartitionierung ungefähr gleich.</span><span class="sxs-lookup"><span data-stu-id="3d72f-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>

<span data-ttu-id="3d72f-125">Die TPL-Partitionierer unterstützen auch eine dynamische Anzahl von Partitionen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="3d72f-126">Dies bedeutet, dass sie Partitionen während des Betriebs erstellen können, z.B. wenn die <xref:System.Threading.Tasks.Parallel.ForEach%2A>-Schleife eine neue Aufgabe erzeugt.</span><span class="sxs-lookup"><span data-stu-id="3d72f-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="3d72f-127">Dieses Feature ermöglicht dem Partitionierer, zusammen mit der Schleife selbst zu skalieren.</span><span class="sxs-lookup"><span data-stu-id="3d72f-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="3d72f-128">Dynamische Partitionierer bewirken auch grundsätzlich einen Lastenausgleich.</span><span class="sxs-lookup"><span data-stu-id="3d72f-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="3d72f-129">Wenn Sie einen benutzerdefinierten Partitionierer erstellen, müssen Sie die Nutzung der dynamischen Partitionierung von einer <xref:System.Threading.Tasks.Parallel.ForEach%2A>-Schleife aus unterstützen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>

### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="3d72f-130">Konfigurieren von Lastenausgleichspartitionierern für PLINQ</span><span class="sxs-lookup"><span data-stu-id="3d72f-130">Configuring Load Balancing Partitioners for PLINQ</span></span>

<span data-ttu-id="3d72f-131">Mit einigen Überladungen der <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType>-Methode können Sie einen Partitionierer für ein Array oder eine <xref:System.Collections.IList>-Datenquelle erstellen und festlegen, ob er versuchen soll, die Arbeitsauslastung zwischen den Threads auszugleichen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="3d72f-132">Wenn der Partitionierer für den Lastenausgleich konfiguriert ist, wird die Blockpartitionierung verwendet, und die Elemente werden bei Anforderung jeder Partition in kleinen Blöcken übergeben.</span><span class="sxs-lookup"><span data-stu-id="3d72f-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="3d72f-133">Dieser Ansatz stellt sicher, dass alle Partitionen über zu verarbeitende Elemente verfügen, bis die gesamte Schleife oder Abfrage abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="3d72f-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="3d72f-134">Eine weitere Überladung kann zur Lastenausgleichspartitionierung einer beliebigen <xref:System.Collections.IEnumerable>-Quelle dienen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>

<span data-ttu-id="3d72f-135">Lastenausgleich erfordert im Allgemeinen, dass die Partitionen relativ häufig Elemente vom Partitionierer anfordern.</span><span class="sxs-lookup"><span data-stu-id="3d72f-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="3d72f-136">Dagegen kann ein Partitionierer, der statische Partitionierung durchführt, mithilfe der Bereichs- oder Blockpartitionierung alle Elemente jedem Partitionierer gleichzeitig zuweisen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="3d72f-137">Dies erfordert weniger Mehraufwand als der Lastenausgleich, aber die Ausführung dauert möglicherweise länger, wenn ein Thread am Ende deutlich mehr Arbeit bewältigen muss als die anderen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="3d72f-138">Wenn PLINQ eine IList oder ein Array übergeben wird, verwendet PLINQ standardmäßig immer die Bereichspartitionierung ohne Lastenausgleich.</span><span class="sxs-lookup"><span data-stu-id="3d72f-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="3d72f-139">Um den Lastenausgleich für PLINQ zu aktivieren, verwenden Sie die `Partitioner.Create`-Methode, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="3d72f-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>

[!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
[!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]

<span data-ttu-id="3d72f-140">Ob in einem gegebenen Szenario der Lastenausgleich verwendet werden sollte, bestimmen Sie am besten, indem Sie durch Experimentieren und Messen feststellen, wie lange die Ausführung von Vorgängen unter repräsentativen Lasten und Computerkonfigurationen dauert.</span><span class="sxs-lookup"><span data-stu-id="3d72f-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="3d72f-141">Die statische Partitionierung könnte z.B. möglicherweise auf einem Mehrkerncomputer mit nur wenigen Kernen für erhebliche Beschleunigung sorgen, doch bei Computern mit relativ vielen Kernen zu Verlangsamungen führen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>

<span data-ttu-id="3d72f-142">In der folgenden Tabelle sind die verfügbaren Optionen der <xref:System.Collections.Concurrent.Partitioner.Create%2A>-Methode aufgelistet.</span><span class="sxs-lookup"><span data-stu-id="3d72f-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="3d72f-143">Diese Partitionierer sind nicht auf die Verwendung mit PLINQ oder <xref:System.Threading.Tasks.Task> beschränkt.</span><span class="sxs-lookup"><span data-stu-id="3d72f-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="3d72f-144">Sie können auch mit jedem benutzerdefinierten parallelen Konstrukt verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3d72f-144">They can also be used with any custom parallel construct.</span></span>

|<span data-ttu-id="3d72f-145">Überladung</span><span class="sxs-lookup"><span data-stu-id="3d72f-145">Overload</span></span>|<span data-ttu-id="3d72f-146">Verwendet Lastenausgleich</span><span class="sxs-lookup"><span data-stu-id="3d72f-146">Uses load balancing</span></span>|
|--------------|-------------------------|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="3d72f-147">Always</span><span class="sxs-lookup"><span data-stu-id="3d72f-147">Always</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="3d72f-148">Wenn das boolesche Argument als „true“ angegeben wird</span><span class="sxs-lookup"><span data-stu-id="3d72f-148">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="3d72f-149">Wenn das boolesche Argument als „true“ angegeben wird</span><span class="sxs-lookup"><span data-stu-id="3d72f-149">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="3d72f-150">Nie</span><span class="sxs-lookup"><span data-stu-id="3d72f-150">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="3d72f-151">Nie</span><span class="sxs-lookup"><span data-stu-id="3d72f-151">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="3d72f-152">Nie</span><span class="sxs-lookup"><span data-stu-id="3d72f-152">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="3d72f-153">Nie</span><span class="sxs-lookup"><span data-stu-id="3d72f-153">Never</span></span>|

### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="3d72f-154">Konfigurieren von statischen Bereichspartitionierern für Parallel.ForEach</span><span class="sxs-lookup"><span data-stu-id="3d72f-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>

<span data-ttu-id="3d72f-155">In einer <xref:System.Threading.Tasks.Parallel.For%2A>-Schleife wird der Inhalt der Schleife der Methode als Delegat bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="3d72f-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="3d72f-156">Der Aufwand für den Aufruf dieses Delegaten ist mit dem des Aufrufs einer virtuellen Methode identisch.</span><span class="sxs-lookup"><span data-stu-id="3d72f-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="3d72f-157">In einigen Szenarien könnte der Inhalt einer parallelen Schleife so klein sein, dass der Aufwand des Delegatenaufrufs in jeder Schleifeniteration signifikant wird.</span><span class="sxs-lookup"><span data-stu-id="3d72f-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="3d72f-158">In solchen Situationen können Sie mithilfe einer der <xref:System.Collections.Concurrent.Partitioner.Create%2A>-Überladungen eine <xref:System.Collections.Generic.IEnumerable%601>-Schnittstelle von Bereichspartitionen über die Quellelemente erstellen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="3d72f-159">Dann übergeben Sie diese Sammlung von Bereichen an eine <xref:System.Threading.Tasks.Parallel.ForEach%2A>-Methode, deren Inhalt aus einer regulären `for`-Schleife besteht.</span><span class="sxs-lookup"><span data-stu-id="3d72f-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="3d72f-160">Dieser Ansatz hat den Vorteil, dass der Aufwand für den Delegatenaufruf nur einmal pro Bereich und nicht einmal pro Element anfällt.</span><span class="sxs-lookup"><span data-stu-id="3d72f-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="3d72f-161">Das Grundmuster wird im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="3d72f-161">The following example demonstrates the basic pattern.</span></span>

[!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
[!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]

<span data-ttu-id="3d72f-162">Jeder Thread in der Schleife empfängt ein eigenes <xref:System.Tuple%602>, das Start- und Endindexwerte im angegebenen untergeordneten Bereich enthält.</span><span class="sxs-lookup"><span data-stu-id="3d72f-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="3d72f-163">Die innere `for`-Schleife verwendet die `fromInclusive`- und `toExclusive`-Werte für einen direkten Schleifendurchlauf über das Array oder <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="3d72f-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>

<span data-ttu-id="3d72f-164">Mit einer der <xref:System.Collections.Concurrent.Partitioner.Create%2A>-Überladungen können Sie Größe und Anzahl der Partitionen angeben.</span><span class="sxs-lookup"><span data-stu-id="3d72f-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="3d72f-165">Diese Überladung kann in Szenarien verwendet, wo die Arbeit pro Element so gering ist, dass auch ein einziger Aufruf einer virtuellen Methode pro Element eine merkliche Auswirkung auf die Leistung hat.</span><span class="sxs-lookup"><span data-stu-id="3d72f-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>

## <a name="custom-partitioners"></a><span data-ttu-id="3d72f-166">Benutzerdefinierte Partitionierer</span><span class="sxs-lookup"><span data-stu-id="3d72f-166">Custom Partitioners</span></span>

<span data-ttu-id="3d72f-167">In einigen Szenarien kann es empfehlenswert oder sogar erforderlich sein, dass Sie Ihren eigenen Partitionierer implementieren.</span><span class="sxs-lookup"><span data-stu-id="3d72f-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="3d72f-168">Beispielsweise könnten Sie über eine benutzerdefinierte Auflistungsklasse verfügen, die Sie basierend auf Ihren Kenntnissen der internen Struktur der Klasse effizienter partitionieren können als der Standardpartitionierer.</span><span class="sxs-lookup"><span data-stu-id="3d72f-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="3d72f-169">Vielleicht möchten Sie auch Bereichspartitionen mit unterschiedlichen Größen basierend auf Ihrer Kenntnis der Dauer der Verarbeitung von Elementen an verschiedenen Positionen in der Quellsammlung erstellen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>

<span data-ttu-id="3d72f-170">Leiten Sie zum Erstellen eines einfachen benutzerdefinierten Partitionierers eine Klasse von <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> ab, und überschreiben Sie die virtuellen Methoden, wie in der folgenden Tabelle beschrieben.</span><span class="sxs-lookup"><span data-stu-id="3d72f-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="3d72f-171">Diese Methode wird einmal vom Hauptthread aufgerufen und gibt eine IList(IEnumerator(TSource)) zurück.</span><span class="sxs-lookup"><span data-stu-id="3d72f-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="3d72f-172">Jeder Arbeitsthread in der Schleife oder Abfrage kann `GetEnumerator` in der Liste zum Abrufen eines <xref:System.Collections.Generic.IEnumerator%601> über eine unterschiedliche Partition aufrufen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="3d72f-173">Geben Sie `true` zurück, wenn Sie <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A> implementieren, andernfalls `false`.</span><span class="sxs-lookup"><span data-stu-id="3d72f-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="3d72f-174">Wenn <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>`true` ist, kann diese Methode optional anstelle von <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="3d72f-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="3d72f-175">Wenn die Ergebnisse sortierbar sein müssen, oder Sie indizierten Zugriff auf die Elemente benötigen, leiten Sie von <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> ab, und überschreiben Sie dessen virtuelle Methoden wie in der folgenden Tabelle beschrieben.</span><span class="sxs-lookup"><span data-stu-id="3d72f-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="3d72f-176">Diese Methode wird einmal vom Hauptthread aufgerufen und gibt eine `IList(IEnumerator(TSource))` zurück.</span><span class="sxs-lookup"><span data-stu-id="3d72f-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="3d72f-177">Jeder Arbeitsthread in der Schleife oder Abfrage kann `GetEnumerator` in der Liste zum Abrufen eines <xref:System.Collections.Generic.IEnumerator%601> über eine unterschiedliche Partition aufrufen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="3d72f-178">Geben Sie `true` zurück, wenn Sie <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A> implementieren; andernfalls „false“.</span><span class="sxs-lookup"><span data-stu-id="3d72f-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="3d72f-179">In der Regel wird hiermit <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="3d72f-180">Wenn <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>`true` ist, kann diese Methode optional anstelle von <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="3d72f-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="3d72f-181">Die folgende Tabelle enthält weitere Details zur Implementierung der <xref:System.Collections.Concurrent.OrderablePartitioner%601>-Klasse durch die drei Arten von Lastenausgleichspartitionierern.</span><span class="sxs-lookup"><span data-stu-id="3d72f-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>

|<span data-ttu-id="3d72f-182">Methode/Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="3d72f-182">Method/Property</span></span>|<span data-ttu-id="3d72f-183">IList/Array ohne Lastenausgleich</span><span class="sxs-lookup"><span data-stu-id="3d72f-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="3d72f-184">IList/Array mit Lastenausgleich</span><span class="sxs-lookup"><span data-stu-id="3d72f-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="3d72f-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="3d72f-185">IEnumerable</span></span>|
|----------------------|-------------------------------------------|----------------------------------------|-----------------|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="3d72f-186">Verwendet Bereichspartitionierung</span><span class="sxs-lookup"><span data-stu-id="3d72f-186">Uses range partitioning</span></span>|<span data-ttu-id="3d72f-187">Verwendet optimierte Blockpartitionierung für Listen für die angegebene partitionCount</span><span class="sxs-lookup"><span data-stu-id="3d72f-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="3d72f-188">Verwendet Blockpartitionierung durch Erstellen einer statischen Anzahl von Partitionen</span><span class="sxs-lookup"><span data-stu-id="3d72f-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="3d72f-189">Löst nicht unterstützte Ausnahme aus</span><span class="sxs-lookup"><span data-stu-id="3d72f-189">Throws not-supported exception</span></span>|<span data-ttu-id="3d72f-190">Verwendet optimierte Blockpartitionierung für Listen und dynamische Partitionen</span><span class="sxs-lookup"><span data-stu-id="3d72f-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="3d72f-191">Verwendet Blockpartitionierung durch Erstellen einer dynamischen Anzahl von Partitionen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="3d72f-192">Gibt `true` zurück.</span><span class="sxs-lookup"><span data-stu-id="3d72f-192">Returns `true`</span></span>|<span data-ttu-id="3d72f-193">Gibt `true` zurück.</span><span class="sxs-lookup"><span data-stu-id="3d72f-193">Returns `true`</span></span>|<span data-ttu-id="3d72f-194">Gibt `true` zurück.</span><span class="sxs-lookup"><span data-stu-id="3d72f-194">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="3d72f-195">Gibt `true` zurück.</span><span class="sxs-lookup"><span data-stu-id="3d72f-195">Returns `true`</span></span>|<span data-ttu-id="3d72f-196">Gibt `false` zurück.</span><span class="sxs-lookup"><span data-stu-id="3d72f-196">Returns `false`</span></span>|<span data-ttu-id="3d72f-197">Gibt `false` zurück.</span><span class="sxs-lookup"><span data-stu-id="3d72f-197">Returns `false`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="3d72f-198">Gibt `true` zurück.</span><span class="sxs-lookup"><span data-stu-id="3d72f-198">Returns `true`</span></span>|<span data-ttu-id="3d72f-199">Gibt `true` zurück.</span><span class="sxs-lookup"><span data-stu-id="3d72f-199">Returns `true`</span></span>|<span data-ttu-id="3d72f-200">Gibt `true` zurück.</span><span class="sxs-lookup"><span data-stu-id="3d72f-200">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="3d72f-201">Gibt `false` zurück.</span><span class="sxs-lookup"><span data-stu-id="3d72f-201">Returns `false`</span></span>|<span data-ttu-id="3d72f-202">Gibt `true` zurück.</span><span class="sxs-lookup"><span data-stu-id="3d72f-202">Returns `true`</span></span>|<span data-ttu-id="3d72f-203">Gibt `true` zurück.</span><span class="sxs-lookup"><span data-stu-id="3d72f-203">Returns `true`</span></span>|

### <a name="dynamic-partitions"></a><span data-ttu-id="3d72f-204">Dynamische Partitionen</span><span class="sxs-lookup"><span data-stu-id="3d72f-204">Dynamic Partitions</span></span>

<span data-ttu-id="3d72f-205">Wenn Sie beabsichtigen, den Partitionierer in einer <xref:System.Threading.Tasks.Parallel.ForEach%2A>-Methode zu verwenden, müssen Sie eine dynamische Anzahl von Partitionen zurückgeben können.</span><span class="sxs-lookup"><span data-stu-id="3d72f-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="3d72f-206">Dies bedeutet, dass der Partitionierer bei Bedarf jederzeit während der Schleifenausführung einen Enumerator für eine neue Partition bereitstellen kann.</span><span class="sxs-lookup"><span data-stu-id="3d72f-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="3d72f-207">Im Wesentlichen wird immer dann, wenn die Schleife eine neue parallele Aufgabe hinzufügt, eine neue Partition für diese Aufgabe angefordert.</span><span class="sxs-lookup"><span data-stu-id="3d72f-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="3d72f-208">Wenn die Daten sortierbar sein müssen, leiten Sie von <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> ab, sodass jedem Element in jeder Partition ein eindeutiger Index zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="3d72f-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>

<span data-ttu-id="3d72f-209">Weitere Informationen und ein Beispiel finden Sie unter [Gewusst wie: Implementieren von dynamischen Partitionen](how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="3d72f-209">For more information, and an example, see [How to: Implement Dynamic Partitions](how-to-implement-dynamic-partitions.md).</span></span>

### <a name="contract-for-partitioners"></a><span data-ttu-id="3d72f-210">Vertrag für Partitionierer</span><span class="sxs-lookup"><span data-stu-id="3d72f-210">Contract for Partitioners</span></span>

<span data-ttu-id="3d72f-211">Wenn Sie einen benutzerdefinierten Partitionierer implementieren, befolgen Sie diese Richtlinien, um ordnungsgemäße Interaktion mit PLINQ und <xref:System.Threading.Tasks.Parallel.ForEach%2A> in der TPL sicherzustellen:</span><span class="sxs-lookup"><span data-stu-id="3d72f-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>

- <span data-ttu-id="3d72f-212">Wenn <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> mit einem Argument von 0 (null) oder weniger für `partitionsCount` aufgerufen wird, soll <xref:System.ArgumentOutOfRangeException> ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="3d72f-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="3d72f-213">Obwohl PLINQ und TPL niemals eine `partitionCount` gleich 0 übergeben werden, sollten Sie dennoch einen Schutz vor dieser Möglichkeit einbauen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>

- <span data-ttu-id="3d72f-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> und <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> sollten stets eine `partitionsCount` Anzahl von Partitionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="3d72f-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="3d72f-215">Wenn dem Partitionierer keine Daten mehr zur Verfügung stehen, sodass er nicht mehr so viele Partitionen wie angefordert erstellen kann, sollte die Methode für jede der verbleibenden Partitionen einen leeren Enumerator zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="3d72f-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="3d72f-216">Andernfalls löst sowohl PLINQ als auch TPL eine <xref:System.InvalidOperationException> aus.</span><span class="sxs-lookup"><span data-stu-id="3d72f-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="3d72f-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A> und <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> sollten niemals `null` (`Nothing` in Visual Basic) zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="3d72f-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="3d72f-218">Wenn dies doch der Fall ist, lösen PLINQ/TPL eine <xref:System.InvalidOperationException> aus.</span><span class="sxs-lookup"><span data-stu-id="3d72f-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="3d72f-219">Partitionen zurückgebende Methoden sollten immer Partitionen zurückgeben, die die Datenquelle vollständig und eindeutig aufzählen können.</span><span class="sxs-lookup"><span data-stu-id="3d72f-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="3d72f-220">Sofern nicht ausdrücklich vom Entwurf des Partitionierers gefordert, dürfen in der Datenquelle keine Duplikate oder übersprungenen Elemente enthalten sein.</span><span class="sxs-lookup"><span data-stu-id="3d72f-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="3d72f-221">Wenn diese Regel nicht befolgt wird, kann die Ausgabereihenfolge durcheinander geraten.</span><span class="sxs-lookup"><span data-stu-id="3d72f-221">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="3d72f-222">Die folgenden booleschen Getter müssen immer genau die folgenden Werte zurückgeben, damit die Reihenfolge der Ausgabe nicht durcheinander gerät:</span><span class="sxs-lookup"><span data-stu-id="3d72f-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>

  - <span data-ttu-id="3d72f-223">`KeysOrderedInEachPartition`: Jede Partition gibt Elemente mit zunehmenden Schlüsselindizes zurück.</span><span class="sxs-lookup"><span data-stu-id="3d72f-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>

  - <span data-ttu-id="3d72f-224">`KeysOrderedAcrossPartitions`: Für alle zurückgegebenen Partitionen sind die Schlüsselindizes in Partition *i* höher als diejenigen in Partition *i*-1.</span><span class="sxs-lookup"><span data-stu-id="3d72f-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>

  - <span data-ttu-id="3d72f-225">`KeysNormalized`: Alle Schlüsselindizes nehmen beginnend mit 0 (null) ohne Lücken monoton zu.</span><span class="sxs-lookup"><span data-stu-id="3d72f-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>

- <span data-ttu-id="3d72f-226">Alle Indizes müssen eindeutig sein.</span><span class="sxs-lookup"><span data-stu-id="3d72f-226">All indices must be unique.</span></span> <span data-ttu-id="3d72f-227">Es darf keine doppelten Indizes geben.</span><span class="sxs-lookup"><span data-stu-id="3d72f-227">There may not be duplicate indices.</span></span> <span data-ttu-id="3d72f-228">Wenn diese Regel nicht befolgt wird, kann die Ausgabereihenfolge durcheinander geraten.</span><span class="sxs-lookup"><span data-stu-id="3d72f-228">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="3d72f-229">Alle Indizes dürfen nicht negativ sein.</span><span class="sxs-lookup"><span data-stu-id="3d72f-229">All indices must be nonnegative.</span></span> <span data-ttu-id="3d72f-230">Wenn diese Regel nicht befolgt wird, kann PLINQ/TPL Ausnahmen auslösen.</span><span class="sxs-lookup"><span data-stu-id="3d72f-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>

## <a name="see-also"></a><span data-ttu-id="3d72f-231">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="3d72f-231">See also</span></span>

- [<span data-ttu-id="3d72f-232">Parallele Programmierung</span><span class="sxs-lookup"><span data-stu-id="3d72f-232">Parallel Programming</span></span>](index.md)
- [<span data-ttu-id="3d72f-233">Gewusst wie: Implementieren von dynamischen Partitionen</span><span class="sxs-lookup"><span data-stu-id="3d72f-233">How to: Implement Dynamic Partitions</span></span>](how-to-implement-dynamic-partitions.md)
- [<span data-ttu-id="3d72f-234">Gewusst wie: Implementieren eines Partitionierers für statisches Partitionieren</span><span class="sxs-lookup"><span data-stu-id="3d72f-234">How to: Implement a Partitioner for Static Partitioning</span></span>](how-to-implement-a-partitioner-for-static-partitioning.md)
