---
title: Potenzielle Fehler bei Daten- und Aufgabenparallelität
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- parallel programming, pitfalls
ms.assetid: 1e357177-e699-4b8f-9e49-56d3513ed128
ms.openlocfilehash: ff6ac9e8c41ee203ae72e1b28c088f462ddf6a54
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/15/2020
ms.locfileid: "73140021"
---
# <a name="potential-pitfalls-in-data-and-task-parallelism"></a><span data-ttu-id="10c9d-102">Potenzielle Fehler bei Daten- und Aufgabenparallelität</span><span class="sxs-lookup"><span data-stu-id="10c9d-102">Potential Pitfalls in Data and Task Parallelism</span></span>
<span data-ttu-id="10c9d-103">In vielen Fällen können <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> und <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> erhebliche Leistungssteigerungen gegenüber gewöhnlichen sequenziellen Schleifen bieten.</span><span class="sxs-lookup"><span data-stu-id="10c9d-103">In many cases, <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> can provide significant performance improvements over ordinary sequential loops.</span></span> <span data-ttu-id="10c9d-104">Die Parallelisierung der Schleife erhöht jedoch die Komplexität des Vorgangs, was Probleme nach sich ziehen kann, die in sequenziellem Code weniger häufig oder gar nicht vorkommen.</span><span class="sxs-lookup"><span data-stu-id="10c9d-104">However, the work of parallelizing the loop introduces complexity that can lead to problems that, in sequential code, are not as common or are not encountered at all.</span></span> <span data-ttu-id="10c9d-105">In diesem Thema sind bestimmte Fehlerquellen aufgeführt, die beim Schreiben von parallelen Schleifen vermieden werden sollten.</span><span class="sxs-lookup"><span data-stu-id="10c9d-105">This topic lists some practices to avoid when you write parallel loops.</span></span>  
  
## <a name="do-not-assume-that-parallel-is-always-faster"></a><span data-ttu-id="10c9d-106">Gehen Sie nicht davon aus, dass eine parallele Ausführung immer schneller ist.</span><span class="sxs-lookup"><span data-stu-id="10c9d-106">Do Not Assume That Parallel Is Always Faster</span></span>  
 <span data-ttu-id="10c9d-107">In bestimmten Fällen kann eine parallele Schleife langsamer als deren sequenzielle Entsprechung ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="10c9d-107">In certain cases a parallel loop might run slower than its sequential equivalent.</span></span> <span data-ttu-id="10c9d-108">Eine Faustregel besagt, dass die Geschwindigkeit von parallelen Schleifen mit wenigen Iterationen und schnellen Benutzerdelegaten wahrscheinlich kaum zunimmt.</span><span class="sxs-lookup"><span data-stu-id="10c9d-108">The basic rule of thumb is that parallel loops that have few iterations and fast user delegates are unlikely to speedup much.</span></span> <span data-ttu-id="10c9d-109">Da jedoch viele Faktoren Einfluss auf die Leistung haben, wird empfohlen, immer die tatsächlichen Ergebnisse zu messen.</span><span class="sxs-lookup"><span data-stu-id="10c9d-109">However, because many factors are involved in performance, we recommend that you always measure actual results.</span></span>  
  
## <a name="avoid-writing-to-shared-memory-locations"></a><span data-ttu-id="10c9d-110">Vermeiden Sie es, in gemeinsam genutzte Speicherpositionen zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="10c9d-110">Avoid Writing to Shared Memory Locations</span></span>  
 <span data-ttu-id="10c9d-111">Bei sequenziellem Code wird regelmäßig aus statischen Variablen oder Klassenfeldern gelesen bzw. in diese geschrieben.</span><span class="sxs-lookup"><span data-stu-id="10c9d-111">In sequential code, it is not uncommon to read from or write to static variables or class fields.</span></span> <span data-ttu-id="10c9d-112">Wenn jedoch mehrere Threads gleichzeitig auf diese Variablen zugreifen, besteht eine hohe Wahrscheinlichkeit für Racebedingungen.</span><span class="sxs-lookup"><span data-stu-id="10c9d-112">However, whenever multiple threads are accessing such variables concurrently, there is a big potential for race conditions.</span></span> <span data-ttu-id="10c9d-113">Sie können den Zugriff auf die Variable mithilfe von Sperren zwar synchronisieren, die Synchronisierung geht jedoch zu Lasten der Leistung.</span><span class="sxs-lookup"><span data-stu-id="10c9d-113">Even though you can use locks to synchronize access to the variable, the cost of synchronization can hurt performance.</span></span> <span data-ttu-id="10c9d-114">Es empfiehlt sich daher, den Zugriff auf den Freigabezustand in einer parallelen Schleife zu vermeiden oder so weit wie möglich einzuschränken.</span><span class="sxs-lookup"><span data-stu-id="10c9d-114">Therefore, we recommend that you avoid, or at least limit, access to shared state in a parallel loop as much as possible.</span></span> <span data-ttu-id="10c9d-115">Dies geschieht am besten durch Verwendung der Überladungen von <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> und <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>, die eine <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>-Variable zum Speichern des threadlokalen Zustands während der Schleifenausführung verwenden.</span><span class="sxs-lookup"><span data-stu-id="10c9d-115">The best way to do this is to use the overloads of <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> that use a <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> variable to store thread-local state during loop execution.</span></span> <span data-ttu-id="10c9d-116">Weitere Informationen finden Sie unter [Vorgehensweise: Schreiben einer Parallel.For-Schleife mit threadlokalen Variablen](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) und [Vorgehensweise: Schreiben einer Parallel.ForEach-Schleife mit partitionslokalen Variablen](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="10c9d-116">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="avoid-over-parallelization"></a><span data-ttu-id="10c9d-117">Vermeiden Sie eine zu starke Parallelisierung.</span><span class="sxs-lookup"><span data-stu-id="10c9d-117">Avoid Over-Parallelization</span></span>  
 <span data-ttu-id="10c9d-118">Mithilfe von parallelen Schleifen übernehmen Sie die Mehrkosten für das Partitionieren der Quellauflistung und das Synchronisieren der Arbeitsthreads.</span><span class="sxs-lookup"><span data-stu-id="10c9d-118">By using parallel loops, you incur the overhead costs of partitioning the source collection and synchronizing the worker threads.</span></span> <span data-ttu-id="10c9d-119">Die Vorteile der Parallelisierung werden zudem durch die Anzahl der Prozessoren auf dem Computer beschränkt.</span><span class="sxs-lookup"><span data-stu-id="10c9d-119">The benefits of parallelization are further limited by the number of processors on the computer.</span></span> <span data-ttu-id="10c9d-120">Die Ausführung von mehreren rechnergebundenen Threads auf nur einem Prozessor ermöglicht keine Geschwindigkeitssteigerung.</span><span class="sxs-lookup"><span data-stu-id="10c9d-120">There is no speedup to be gained by running multiple compute-bound threads on just one processor.</span></span> <span data-ttu-id="10c9d-121">Achten Sie daher darauf, dass Sie eine Schleife nicht zu stark parallelisieren.</span><span class="sxs-lookup"><span data-stu-id="10c9d-121">Therefore, you must be careful not to over-parallelize a loop.</span></span>  
  
 <span data-ttu-id="10c9d-122">Eine zu starke Parallelisierung tritt vor allem in geschachtelten Schleifen auf, wie im folgenden Ausschnitt gezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="10c9d-122">The most common scenario in which over-parallelization can occur is in nested loops.</span></span> <span data-ttu-id="10c9d-123">In den meisten Fällen sollte idealerweise nur die äußere Schleife parallelisiert werden, sofern nicht eine oder mehrere der folgenden Bedingungen erfüllt sind:</span><span class="sxs-lookup"><span data-stu-id="10c9d-123">In most cases, it is best to parallelize only the outer loop unless one or more of the following conditions apply:</span></span>  
  
- <span data-ttu-id="10c9d-124">Die innere Schleife ist bekanntermaßen sehr lang.</span><span class="sxs-lookup"><span data-stu-id="10c9d-124">The inner loop is known to be very long.</span></span>  
  
- <span data-ttu-id="10c9d-125">Sie führen für jede Bestellung eine umfangreiche Berechnung aus.</span><span class="sxs-lookup"><span data-stu-id="10c9d-125">You are performing an expensive computation on each order.</span></span> <span data-ttu-id="10c9d-126">(Der im Beispiel gezeigte Vorgang ist nicht sehr rechenintensiv.)</span><span class="sxs-lookup"><span data-stu-id="10c9d-126">(The operation shown in the example is not expensive.)</span></span>  
  
- <span data-ttu-id="10c9d-127">Das Zielsystem verfügt über genug Prozessoren für die Verarbeitung der Anzahl von Threads, die durch die Parallelisierung der Abfrage von `cust.Orders` erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="10c9d-127">The target system is known to have enough processors to handle the number of threads that will be produced by parallelizing the query on `cust.Orders`.</span></span>  
  
 <span data-ttu-id="10c9d-128">In allen diesen Fällen empfiehlt es sich, die optimale Abfrageform mithilfe von Tests und Messungen zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="10c9d-128">In all cases, the best way to determine the optimum query shape is to test and measure.</span></span>  
  
## <a name="avoid-calls-to-non-thread-safe-methods"></a><span data-ttu-id="10c9d-129">Vermeiden Sie den Aufruf nicht threadsicherer Methoden.</span><span class="sxs-lookup"><span data-stu-id="10c9d-129">Avoid Calls to Non-Thread-Safe Methods</span></span>  
 <span data-ttu-id="10c9d-130">Das Schreiben in nicht threadsichere Instanzmethoden von einer parallelen Schleife aus kann zu Datenbeschädigungen führen, die im Programm möglicherweise unerkannt bleiben.</span><span class="sxs-lookup"><span data-stu-id="10c9d-130">Writing to non-thread-safe instance methods from a parallel loop can lead to data corruption which may or may not go undetected in your program.</span></span> <span data-ttu-id="10c9d-131">Dies kann auch zu Ausnahmen führen.</span><span class="sxs-lookup"><span data-stu-id="10c9d-131">It can also lead to exceptions.</span></span> <span data-ttu-id="10c9d-132">Im folgenden Beispiel würden mehrere Threads gleichzeitig versuchen, die <xref:System.IO.FileStream.WriteByte%2A?displayProperty=nameWithType>-Methode aufzurufen, was von der Klasse nicht unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="10c9d-132">In the following example, multiple threads would be attempting to call the <xref:System.IO.FileStream.WriteByte%2A?displayProperty=nameWithType> method simultaneously, which is not supported by the class.</span></span>  
  
 [!code-csharp[TPL_Pitfalls#04](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#04)]
 [!code-vb[TPL_Pitfalls#04](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#04)]  
  
## <a name="limit-calls-to-thread-safe-methods"></a><span data-ttu-id="10c9d-133">Beschränken Sie Aufrufe auf threadsichere Methoden.</span><span class="sxs-lookup"><span data-stu-id="10c9d-133">Limit Calls to Thread-Safe Methods</span></span>  
 <span data-ttu-id="10c9d-134">Die meisten statischen Methoden in .NET Framework sind threadsicher und können von mehreren Threads gleichzeitig aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="10c9d-134">Most static methods in the .NET Framework are thread-safe and can be called from multiple threads concurrently.</span></span> <span data-ttu-id="10c9d-135">Die damit verbundene Synchronisierung kann jedoch auch in diesen Fällen zu einer erheblichen Verlangsamung der Abfrage führen.</span><span class="sxs-lookup"><span data-stu-id="10c9d-135">However, even in these cases, the synchronization involved can lead to significant slowdown in the query.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="10c9d-136">Sie können dies testen, indem Sie in Ihre Abfragen Aufrufe von <xref:System.Console.WriteLine%2A> einfügen.</span><span class="sxs-lookup"><span data-stu-id="10c9d-136">You can test for this yourself by inserting some calls to <xref:System.Console.WriteLine%2A> in your queries.</span></span> <span data-ttu-id="10c9d-137">Diese Methode wird jedoch nur in den Dokumentationsbeispielen zu Demonstrationszwecken verwendet. Nutzen Sie sie nur in parallelen Schleifen, wenn dies erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="10c9d-137">Although this method is used in the documentation examples for demonstration purposes, do not use it in parallel loops unless necessary.</span></span>  
  
## <a name="be-aware-of-thread-affinity-issues"></a><span data-ttu-id="10c9d-138">Beachten Sie Threadaffinitätsprobleme.</span><span class="sxs-lookup"><span data-stu-id="10c9d-138">Be Aware of Thread Affinity Issues</span></span>  
 <span data-ttu-id="10c9d-139">Einige Technologien, z. B. COM-Interoperabilität für STA-Komponenten (Singlethread-Apartment), Windows Forms und Windows Presentation Foundation (WPF), erzeugen Threadaffinitätseinschränkungen, aufgrund derer Code in einem bestimmten Thread ausgeführt werden muss.</span><span class="sxs-lookup"><span data-stu-id="10c9d-139">Some technologies, for example, COM interoperability for Single-Threaded Apartment (STA) components, Windows Forms, and Windows Presentation Foundation (WPF), impose thread affinity restrictions that require code to run on a specific thread.</span></span> <span data-ttu-id="10c9d-140">Beispielsweise kann sowohl in Windows Forms als auch in WPF nur in einem Thread auf ein Steuerelement zugegriffen werden, in dem es erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="10c9d-140">For example, in both Windows Forms and WPF, a control can only be accessed on the thread on which it was created.</span></span> <span data-ttu-id="10c9d-141">Dies bedeutet beispielsweise, dass Sie kein Listensteuerelement von einer parallelen Schleife aktualisieren können, außer wenn Sie den Threadplaner konfigurieren, um die Arbeit nur im UI-Thread zu planen.</span><span class="sxs-lookup"><span data-stu-id="10c9d-141">This means, for example, that you cannot update a list control from a parallel loop unless you configure the thread scheduler to schedule work only on the UI thread.</span></span> <span data-ttu-id="10c9d-142">Weitere Informationen finden Sie unter [Angeben eines Synchronisierungskontexts](xref:System.Threading.Tasks.TaskScheduler#specifying-a-synchronization-context).</span><span class="sxs-lookup"><span data-stu-id="10c9d-142">For more information, see [Specifying a synchronization context](xref:System.Threading.Tasks.TaskScheduler#specifying-a-synchronization-context).</span></span>  
  
## <a name="use-caution-when-waiting-in-delegates-that-are-called-by-parallelinvoke"></a><span data-ttu-id="10c9d-143">Seien Sie vorsichtig, wenn Sie in Delegaten warten, die von Parallel.Invoke aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="10c9d-143">Use Caution When Waiting in Delegates That Are Called by Parallel.Invoke</span></span>  
 <span data-ttu-id="10c9d-144">Unter bestimmten Umständen wird ein Task von der Task Parallel Library inline ausgeführt, d.h. die Ausführung erfolgt im derzeit ausgeführten Thread.</span><span class="sxs-lookup"><span data-stu-id="10c9d-144">In certain circumstances, the Task Parallel Library will inline a task, which means it runs on the task on the currently executing thread.</span></span> <span data-ttu-id="10c9d-145">(Weitere Informationen finden Sie unter [TaskScheduler-Klasse](xref:System.Threading.Tasks.TaskScheduler).) Diese Leistungsoptimierung kann in bestimmten Fällen einen Deadlock zur Folge haben.</span><span class="sxs-lookup"><span data-stu-id="10c9d-145">(For more information, see [Task Schedulers](xref:System.Threading.Tasks.TaskScheduler).) This performance optimization can lead to deadlock in certain cases.</span></span> <span data-ttu-id="10c9d-146">Beispiel: Bei zwei Tasks wird möglicherweise der gleiche Delegatcode ausgeführt, der signalisiert, wenn ein Ereignis auftritt und anschließend auf die Signalisierung des anderen Tasks wartet.</span><span class="sxs-lookup"><span data-stu-id="10c9d-146">For example, two tasks might run the same delegate code, which signals when an event occurs, and then waits for the other task to signal.</span></span> <span data-ttu-id="10c9d-147">Wenn der zweite Task im gleichen Thread wie der erste Task inline ausgeführt wird und der erste Task in einen Wartezustand versetzt wird, kann der zweite Task das Ereignis niemals signalisieren.</span><span class="sxs-lookup"><span data-stu-id="10c9d-147">If the second task is inlined on the same thread as the first, and the first goes into a Wait state, the second task will never be able to signal its event.</span></span> <span data-ttu-id="10c9d-148">Um dies zu vermeiden, können Sie für den Wartevorgang ein Timeout angeben oder explizite Threadkonstruktoren verwenden, um sicherzustellen, dass ein Task nicht den anderen blockieren kann.</span><span class="sxs-lookup"><span data-stu-id="10c9d-148">To avoid such an occurrence, you can specify a timeout on the Wait operation, or use explicit thread constructors to help ensure that one task cannot block the other.</span></span>  
  
## <a name="do-not-assume-that-iterations-of-foreach-for-and-forall-always-execute-in-parallel"></a><span data-ttu-id="10c9d-149">Gehen Sie nicht davon aus, dass Iterationen von „ForEach“, „For“ und „ForAll“ immer parallel ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="10c9d-149">Do Not Assume that Iterations of ForEach, For and ForAll Always Execute in Parallel</span></span>  
 <span data-ttu-id="10c9d-150">Beachten Sie unbedingt, dass einzelne Iterationen in einer <xref:System.Threading.Tasks.Parallel.For%2A>-, <xref:System.Threading.Tasks.Parallel.ForEach%2A>- oder <xref:System.Linq.ParallelEnumerable.ForAll%2A>-Schleife parallel ausgeführt werden können, jedoch nicht parallel ausgeführt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="10c9d-150">It is important to keep in mind that individual iterations in a <xref:System.Threading.Tasks.Parallel.For%2A>, <xref:System.Threading.Tasks.Parallel.ForEach%2A> or <xref:System.Linq.ParallelEnumerable.ForAll%2A> loop may but do not have to execute in parallel.</span></span> <span data-ttu-id="10c9d-151">Schreiben Sie daher nach Möglichkeit keinen Code, dessen Korrektheit von der parallelen Ausführung von Iterationen oder der Ausführung von Iterationen in einer bestimmten Reihenfolge abhängig ist.</span><span class="sxs-lookup"><span data-stu-id="10c9d-151">Therefore, you should avoid writing any code that depends for correctness on parallel execution of iterations or on the execution of iterations in any particular order.</span></span> <span data-ttu-id="10c9d-152">Beim folgenden Code ist z. B. ein Deadlock wahrscheinlich:</span><span class="sxs-lookup"><span data-stu-id="10c9d-152">For example, this code is likely to deadlock:</span></span>  
  
 [!code-csharp[TPL_Pitfalls#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#01)]
 [!code-vb[TPL_Pitfalls#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#01)]  
  
 <span data-ttu-id="10c9d-153">In diesem Beispiel wird durch eine Iteration ein Ereignis festgelegt, und alle anderen Iterationen warten auf das Ereignis.</span><span class="sxs-lookup"><span data-stu-id="10c9d-153">In this example, one iteration sets an event, and all other iterations wait on the event.</span></span> <span data-ttu-id="10c9d-154">Die wartenden Iterationen können erst nach Abschluss der ereignisauslösenden Iteration abgeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="10c9d-154">None of the waiting iterations can complete until the event-setting iteration has completed.</span></span> <span data-ttu-id="10c9d-155">Es ist jedoch möglich, dass die wartenden Iterationen alle Threads blockieren, die zur Ausführung der parallelen Schleife verwendet werden, bevor die ereignisauslösende Iteration überhaupt ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="10c9d-155">However, it is possible that the waiting iterations block all threads that are used to execute the parallel loop, before the event-setting iteration has had a chance to execute.</span></span> <span data-ttu-id="10c9d-156">Dies führt zu einem Deadlock. Die ereignisauslösende Iteration wird niemals ausgeführt, und die wartenden Iterationen werden zu keinem Zeitpunkt aktiviert.</span><span class="sxs-lookup"><span data-stu-id="10c9d-156">This results in a deadlock – the event-setting iteration will never execute, and the waiting iterations will never wake up.</span></span>  
  
 <span data-ttu-id="10c9d-157">Insbesondere sollte eine Iteration einer parallelen Schleife nie auf den Fortschritt einer anderen Iteration der Schleife warten.</span><span class="sxs-lookup"><span data-stu-id="10c9d-157">In particular, one iteration of a parallel loop should never wait on another iteration of the loop to make progress.</span></span> <span data-ttu-id="10c9d-158">Wenn von der parallelen Schleife entschieden wird, die Iterationen sequenziell zu planen, jedoch in der entgegengesetzten Reihenfolge, tritt ein Deadlock auf.</span><span class="sxs-lookup"><span data-stu-id="10c9d-158">If the parallel loop decides to schedule the iterations sequentially but in the opposite order, a deadlock will occur.</span></span>  
  
## <a name="avoid-executing-parallel-loops-on-the-ui-thread"></a><span data-ttu-id="10c9d-159">Vermeiden Sie die Ausführung paralleler Schleifen im UI-Thread.</span><span class="sxs-lookup"><span data-stu-id="10c9d-159">Avoid Executing Parallel Loops on the UI Thread</span></span>  
 <span data-ttu-id="10c9d-160">Es ist wichtig, die Reaktionsfähigkeit der Benutzeroberfläche der Anwendung zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="10c9d-160">It is important to keep your application's user interface (UI) responsive.</span></span> <span data-ttu-id="10c9d-161">Wenn ein Vorgang genug Arbeit enthält, um Parallelisierung zu garantieren, darf der Vorgang wahrscheinlich nicht im UI-Thread ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="10c9d-161">If an operation contains enough work to warrant parallelization, then it likely should not be run that operation on the UI thread.</span></span>  <span data-ttu-id="10c9d-162">Stattdessen sollte der Vorgang abgeladen werden, um eine Ausführung als Hintergrundthread zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="10c9d-162">Instead, it should offload that operation to be run on a background thread.</span></span> <span data-ttu-id="10c9d-163">Wenn Sie z.B. eine parallele Schleife verwenden möchten, um einige Daten zu berechnen, die dann in ein UI-Steuerelement gerendert werden sollen, führen Sie die Schleife ggf. innerhalb einer Aufgabeninstanz und nicht direkt in einem UI-Ereignishandler aus.</span><span class="sxs-lookup"><span data-stu-id="10c9d-163">For example, if you want to use a parallel loop to compute some data that should then be rendered into a UI control, you should consider executing the loop within a task instance rather than directly in a UI event handler.</span></span>  <span data-ttu-id="10c9d-164">Erst nach der Kernberechnung können Sie die Aktualisierung der Benutzeroberfläche zurück zum UI-Thread marshallen.</span><span class="sxs-lookup"><span data-stu-id="10c9d-164">Only when the core computation has completed should you then marshal the UI update back to the UI thread.</span></span>  
  
 <span data-ttu-id="10c9d-165">Wenn Sie parallele Schleifen im UI-Thread ausführen, aktualisieren Sie innerhalb der Schleife keine Benutzeroberflächenelemente.</span><span class="sxs-lookup"><span data-stu-id="10c9d-165">If you do run parallel loops on the UI thread, be careful to avoid updating UI controls from within the loop.</span></span> <span data-ttu-id="10c9d-166">Der Versuch, UI-Steuerelemente innerhalb einer parallelen Schleife zu aktualisieren, die im UI-Thread ausgeführt wird, kann zu Zustandsbeschädigung, Ausnahmen, verzögerten Updates und sogar Deadlocks führen, und zwar abhängig davon, wie das Update der Benutzeroberfläche aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="10c9d-166">Attempting to update UI controls from within a parallel loop that is executing on the UI thread can lead to state corruption, exceptions, delayed updates, and even deadlocks, depending on how the UI update is invoked.</span></span> <span data-ttu-id="10c9d-167">Im folgenden Beispiel blockiert die parallele Schleife den UI-Thread, in dem sie ausgeführt wird, bis alle Iterationen abgeschlossen wurden.</span><span class="sxs-lookup"><span data-stu-id="10c9d-167">In the following example, the parallel loop blocks the UI thread on which it’s executing until all iterations are complete.</span></span> <span data-ttu-id="10c9d-168">Wenn eine Iteration der Schleife jedoch in einem Hintergrundthread ausgeführt wird (möglicherweise wie bei <xref:System.Threading.Tasks.Parallel.For%2A>), verursacht der Aufruf von „Invoke“ die Übermittlung einer Meldung an den UI-Thread, und er blockiert das Warten auf die Verarbeitung der Nachricht.</span><span class="sxs-lookup"><span data-stu-id="10c9d-168">However, if an iteration of the loop is running on a background thread (as <xref:System.Threading.Tasks.Parallel.For%2A> may do), the call to Invoke causes a message to be submitted to the UI thread and blocks waiting for that message to be processed.</span></span> <span data-ttu-id="10c9d-169">Da der UI-Thread, in dem <xref:System.Threading.Tasks.Parallel.For%2A> ausgeführt wird, blockiert ist, kann die Nachricht nie verarbeitet werden, und im UI-Thread kommt es zu einem Deadlock.</span><span class="sxs-lookup"><span data-stu-id="10c9d-169">Since the UI thread is blocked running the <xref:System.Threading.Tasks.Parallel.For%2A>, the message can never be processed, and the UI thread deadlocks.</span></span>  
  
 [!code-csharp[TPL_Pitfalls#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#02)]
 [!code-vb[TPL_Pitfalls#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#02)]  
  
 <span data-ttu-id="10c9d-170">Im folgenden Beispiel wird gezeigt, wie der Deadlock vermieden wird, indem die Schleife in einer Aufgabeninstanz ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="10c9d-170">The following example shows how to avoid the deadlock, by running the loop inside a task instance.</span></span> <span data-ttu-id="10c9d-171">Der UI-Thread wird nicht von der Schleife blockiert, und die Meldung kann verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="10c9d-171">The UI thread is not blocked by the loop, and the message can be processed.</span></span>  
  
 [!code-csharp[TPL_Pitfalls#03](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#03)]
 [!code-vb[TPL_Pitfalls#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#03)]  
  
## <a name="see-also"></a><span data-ttu-id="10c9d-172">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="10c9d-172">See also</span></span>

- [<span data-ttu-id="10c9d-173">Parallele Programmierung</span><span class="sxs-lookup"><span data-stu-id="10c9d-173">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
- [<span data-ttu-id="10c9d-174">Potential Pitfalls with PLINQ (Potenzielle Fehler bei PLINQ)</span><span class="sxs-lookup"><span data-stu-id="10c9d-174">Potential Pitfalls with PLINQ</span></span>](../../../docs/standard/parallel-programming/potential-pitfalls-with-plinq.md)
- [<span data-ttu-id="10c9d-175">Patterns for Parallel Programming: Understanding and Applying Parallel Patterns with the .NET Framework 4 (Muster für die parallele Programmierung: Verstehen und Anwenden von parallelen Mustern mit .NET Framework 4)</span><span class="sxs-lookup"><span data-stu-id="10c9d-175">Patterns for Parallel Programming: Understanding and Applying Parallel Patterns with the .NET Framework 4</span></span>](https://www.microsoft.com/download/details.aspx?id=19222)
