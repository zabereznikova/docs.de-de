---
title: Grundlagen zur Beschleunigung in PLINQ
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
ms.openlocfilehash: 64eb346ba57e9af9f5be0cc1b42398c4f539d4d4
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/24/2020
ms.locfileid: "95689900"
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="ecae0-102">Grundlagen zur Beschleunigung in PLINQ</span><span class="sxs-lookup"><span data-stu-id="ecae0-102">Understanding Speedup in PLINQ</span></span>

<span data-ttu-id="ecae0-103">Der primäre Zweck von PLINQ ist die Beschleunigung der Ausführung von LINQ to Objects-Abfragen durch paralleles Ausführen der Abfragedelegaten auf Computern mit mehreren Kernen.</span><span class="sxs-lookup"><span data-stu-id="ecae0-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="ecae0-104">PLINQ zeigt die beste Leistung, wenn die Verarbeitung der einzelnen Elemente in einer Quellsammlung unabhängig erfolgt, ohne gemeinsamen Zustand der einzelnen Delegaten.</span><span class="sxs-lookup"><span data-stu-id="ecae0-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="ecae0-105">Solche Vorgänge sind häufig in LINQ to Objects und PLINQ und werden oft als „*optimal parallel*“ bezeichnet, da sie gut auf mehrere Threads verteilt werden können.</span><span class="sxs-lookup"><span data-stu-id="ecae0-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="ecae0-106">Nicht alle Abfragen bestehen jedoch vollständig aus optimal parallel verarbeitbaren Vorgängen; in den meisten Fällen umfasst eine Abfrage einige Operatoren, die entweder nicht parallelisiert werden können oder die parallele Ausführung verlangsamen.</span><span class="sxs-lookup"><span data-stu-id="ecae0-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="ecae0-107">Und auch bei optimal parallel verarbeitbaren Abfragen muss PLINQ noch die Datenquelle partitionieren, die Arbeit auf die Threads aufteilen und in der Regel die Ergebnisse zusammenführen, wenn die Abfrage abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ecae0-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="ecae0-108">Alle diese Vorgänge tragen zum Rechenaufwand für die Parallelisierung bei; dieser Aufwand zum Hinzufügen der Parallelisierung wird als *Mehraufwand* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="ecae0-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="ecae0-109">Um optimale Leistung in einer PLINQ-Abfrage zu erzielen, besteht das Ziel darin, optimal parallel verarbeitbare Teile zu maximieren und Teile, die Mehraufwand erfordern, zu minimieren.</span><span class="sxs-lookup"><span data-stu-id="ecae0-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="ecae0-110">Dieser Artikel enthält Informationen, mit deren Hilfe Sie PLINQ-Abfragen schreiben können, die so effizient wie möglich sind und nichtsdestoweniger richtige Ergebnisse liefern.</span><span class="sxs-lookup"><span data-stu-id="ecae0-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="ecae0-111">Faktoren, die sich auf die PLINQ-Abfrageleistung auswirken</span><span class="sxs-lookup"><span data-stu-id="ecae0-111">Factors that Impact PLINQ Query Performance</span></span>  

 <span data-ttu-id="ecae0-112">In den folgenden Abschnitten werden einige der wichtigsten Faktoren aufgeführt, die sich auf die Leistung der parallelen Abfrage auswirken.</span><span class="sxs-lookup"><span data-stu-id="ecae0-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="ecae0-113">Hierbei handelt es sich um allgemeine Aussagen, die für sich allein nicht ausreichen, um die Abfrageleistung in allen Fällen vorherzusagen.</span><span class="sxs-lookup"><span data-stu-id="ecae0-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="ecae0-114">Wie immer ist es wichtig, die tatsächliche Leistung bei bestimmten Abfragen auf Computern mit einer Reihe von repräsentativen Konfigurationen und Lasten zu messen.</span><span class="sxs-lookup"><span data-stu-id="ecae0-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1. <span data-ttu-id="ecae0-115">Rechenaufwand für die gesamte Arbeit.</span><span class="sxs-lookup"><span data-stu-id="ecae0-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="ecae0-116">Um die Beschleunigung zu erreichen, muss eine PLINQ-Abfrage zum Ausgleich des Mehraufwands in ausreichendem Maße optimal parallel verarbeitbar sein.</span><span class="sxs-lookup"><span data-stu-id="ecae0-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="ecae0-117">Die Arbeit kann als Rechenaufwand für jeden Delegaten multipliziert mit der Anzahl der Elemente in der Quellsammlung ausgedrückt werden.</span><span class="sxs-lookup"><span data-stu-id="ecae0-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="ecae0-118">Unter der Voraussetzung, dass ein Vorgang parallelisiert werden kann, ist die Gelegenheit zur Beschleunigung umso größer, je höher der Rechenaufwand für ihn ist.</span><span class="sxs-lookup"><span data-stu-id="ecae0-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="ecae0-119">Wenn z.B. die Ausführung einer Funktion eine Millisekunde dauert, dauert die Anwendung dieser Funktion bei einer sequenziellen Abfrage von 1.000 Elementen eine Sekunde, bei einer parallelen Abfrage auf einem Computer mit vier Kernen vielleicht nur 250 Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="ecae0-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="ecae0-120">Dies ergibt eine Beschleunigung von 750 Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="ecae0-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="ecae0-121">Wenn die Ausführung der Funktion für jedes Element eine Sekunde beanspruchen würde, betrüge die Beschleunigung 750 Sekunden.</span><span class="sxs-lookup"><span data-stu-id="ecae0-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="ecae0-122">Wenn der Delegat sehr aufwändig ist, könnte PLINQ mit nur wenigen Elementen in der Quellsammlung eine erhebliche Beschleunigung bieten.</span><span class="sxs-lookup"><span data-stu-id="ecae0-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="ecae0-123">Im Gegensatz dazu eignen sich kleine Quellsammlungen mit trivialen Delegaten im Allgemeinen nicht gut für PLINQ.</span><span class="sxs-lookup"><span data-stu-id="ecae0-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="ecae0-124">Im folgenden Beispiel ist queryA wahrscheinlich ein guter Kandidat für PLINQ, vorausgesetzt, dass die Select-Funktion mit einer Menge Arbeit verbunden ist.</span><span class="sxs-lookup"><span data-stu-id="ecae0-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="ecae0-125">Wahrscheinlich ist queryB kein guter Kandidat, weil die Select-Funktion nicht mit genügend Arbeit verbunden ist, und der Mehraufwand der Parallelisierung den Vorteil der Beschleunigung mindestens überwiegend, wenn nicht vollständig aufhebt.</span><span class="sxs-lookup"><span data-stu-id="ecae0-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2. <span data-ttu-id="ecae0-126">Die Anzahl der logischen Kerne im System (Grad an Parallelität).</span><span class="sxs-lookup"><span data-stu-id="ecae0-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="ecae0-127">Dieser Punkt ist eine offensichtliche logische Konsequenz des vorherigen Abschnitts; optimal parallel verarbeitbare Abfragen werden auf Computern mit mehr Kernen schneller ausgeführt, da die Arbeit auf mehrere parallele Threads aufgeteilt werden kann.</span><span class="sxs-lookup"><span data-stu-id="ecae0-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="ecae0-128">Die Gesamtbeschleunigung hängt davon ab, welcher Prozentsatz der gesamten Abfragearbeit parallelisierbar ist.</span><span class="sxs-lookup"><span data-stu-id="ecae0-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="ecae0-129">Gehen Sie jedoch nicht davon aus, dass alle Abfragen auf einem Computer mit acht Kernen doppelt so schnell ausgeführt werden wie auf einem Computer mit vier Kernen.</span><span class="sxs-lookup"><span data-stu-id="ecae0-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="ecae0-130">Bei der Leistungsoptimierung von Abfragen kommt es darauf an, die tatsächlichen Ergebnisse auf Computern mit unterschiedlicher Anzahl von Kernen zu messen.</span><span class="sxs-lookup"><span data-stu-id="ecae0-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="ecae0-131">Dieser Punkt steht im Zusammenhang mit Punkt 1: Zur Nutzung größerer Computeressourcen sind größere Datasets erforderlich.</span><span class="sxs-lookup"><span data-stu-id="ecae0-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3. <span data-ttu-id="ecae0-132">Anzahl und Art der Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="ecae0-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="ecae0-133">PLINQ stellt den AsOrdered-Operator für Situationen bereit, in denen die Reihenfolge der Elemente in der Quellsequenz beibehalten werden muss.</span><span class="sxs-lookup"><span data-stu-id="ecae0-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="ecae0-134">Mit der Sortierung ist ein gewisser Aufwand verbunden, aber dieser Nachteil ist in der Regel sehr gering.</span><span class="sxs-lookup"><span data-stu-id="ecae0-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="ecae0-135">GroupBy- und Join-Vorgänge verursachen ebenso einen Mehraufwand.</span><span class="sxs-lookup"><span data-stu-id="ecae0-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="ecae0-136">PLINQ bringt die beste Leistung, wenn Elemente in der Quellsammlung in beliebiger Reihenfolge verarbeitet und – sobald sie dazu bereit sind – an den nächsten Operator übergeben werden können.</span><span class="sxs-lookup"><span data-stu-id="ecae0-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="ecae0-137">Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](order-preservation-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="ecae0-137">For more information, see [Order Preservation in PLINQ](order-preservation-in-plinq.md).</span></span>  
  
4. <span data-ttu-id="ecae0-138">Die Form der Abfrageausführung.</span><span class="sxs-lookup"><span data-stu-id="ecae0-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="ecae0-139">Wenn Sie die Ergebnisse einer Abfrage durch Aufrufen von ToArray oder ToList speichern, müssen die Ergebnisse von allen parallelen Threads in der einzelnen Datenstruktur zusammengeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ecae0-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="ecae0-140">Dies ist mit unvermeidbarem Rechenaufwand verbunden.</span><span class="sxs-lookup"><span data-stu-id="ecae0-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="ecae0-141">Ebenso müssen die Ergebnisse von den Arbeitsthreads auf den Enumeratorthread serialisiert werden, wenn Sie die Iteration über die Ergebnisse mithilfe einer foreach-Schleife („For Each“ in Visual Basic) durchführen.</span><span class="sxs-lookup"><span data-stu-id="ecae0-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="ecae0-142">Aber wenn Sie eine Aktion einfach basierend auf dem Ergebnis jedes Threads ausführen möchten, können Sie diese Aufgabe mit der ForAll-Methode auf mehreren Threads durchführen.</span><span class="sxs-lookup"><span data-stu-id="ecae0-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5. <span data-ttu-id="ecae0-143">Der Typ der Mergeoptionen.</span><span class="sxs-lookup"><span data-stu-id="ecae0-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="ecae0-144">PLINQ kann entweder so konfiguriert werden, dass die Ausgabe gepuffert und nach dem Erzeugen des gesamten Resultsets in Blöcken oder im Ganzen bereitgestellt wird, oder dass einzelne Ergebnisse nach dem Erzeugen im Datenstrom bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="ecae0-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="ecae0-145">Im ersten Fall wird die Gesamtausführungszeit verkürzt und im zweiten Fall die Latenzzeit zwischen den bereitgestellten Elementen.</span><span class="sxs-lookup"><span data-stu-id="ecae0-145">The former results in decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="ecae0-146">Mergeoptionen haben zwar nicht immer erhebliche Auswirkungen auf die gesamte Abfrageleistung, können sich jedoch auf die wahrgenommene Leistung auswirken, da sie steuern, wie lange ein Benutzer warten muss, um Ergebnisse zu sehen.</span><span class="sxs-lookup"><span data-stu-id="ecae0-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="ecae0-147">Weitere Informationen finden Sie unter [Merge Options in PLINQ (Zusammenführungsoptionen in PLINQ)](merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="ecae0-147">For more information, see [Merge Options in PLINQ](merge-options-in-plinq.md).</span></span>  
  
6. <span data-ttu-id="ecae0-148">Die Art der Partitionierung.</span><span class="sxs-lookup"><span data-stu-id="ecae0-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="ecae0-149">In einigen Fällen kann eine PLINQ-Abfrage einer indizierbaren Quellsammlung zu einer unausgeglichenen Arbeitslast führen.</span><span class="sxs-lookup"><span data-stu-id="ecae0-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="ecae0-150">In diesem Fall können Sie die Abfrageleistung vielleicht erhöhen, indem Sie einen benutzerdefinierten Partitionierer erstellen.</span><span class="sxs-lookup"><span data-stu-id="ecae0-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="ecae0-151">Weitere Informationen finden Sie unter [Custom Partitioners for PLINQ and TPL (Benutzerdefinierte Partitionierer für PLINQ und TPL)](custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="ecae0-151">For more information, see [Custom Partitioners for PLINQ and TPL](custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="ecae0-152">Wenn PLINQ den sequenziellen Modus auswählt</span><span class="sxs-lookup"><span data-stu-id="ecae0-152">When PLINQ Chooses Sequential Mode</span></span>  

 <span data-ttu-id="ecae0-153">PLINQ versucht immer, eine Abfrage mindestens so schnell auszuführen, als würde die Abfrage sequenziell ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="ecae0-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="ecae0-154">PLINQ beachtet zwar weder den Rechenaufwand der Benutzerdelegaten noch die Größe der Eingabequelle, sucht jedoch nach bestimmten „Abfrageformen“.</span><span class="sxs-lookup"><span data-stu-id="ecae0-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="ecae0-155">Insbesondere wird nach Abfrageoperatoren oder Kombinationen aus Operatoren gesucht, die in der Regel die Ausführung einer Abfrage im parallelen Modus verlangsamen.</span><span class="sxs-lookup"><span data-stu-id="ecae0-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="ecae0-156">Wenn solche Formen gefunden werden, fällt PLINQ standardmäßig auf den sequenziellen Modus zurück.</span><span class="sxs-lookup"><span data-stu-id="ecae0-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="ecae0-157">Vielleicht stellen Sie jedoch nach dem Messen der Leistung für eine bestimmte Abfrage fest, dass sie im parallelen Modus tatsächlich schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="ecae0-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="ecae0-158">In solchen Fällen können Sie das <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType>-Flag mithilfe der <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A>-Methode verwenden, um PLINQ anzuweisen, die Abfrage zu parallelisieren.</span><span class="sxs-lookup"><span data-stu-id="ecae0-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="ecae0-159">Weitere Informationen finden Sie unter [Vorgehensweise: Angeben des Ausführungsmodus in PLINQ](how-to-specify-the-execution-mode-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="ecae0-159">For more information, see [How to: Specify the Execution Mode in PLINQ](how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="ecae0-160">Die folgende Liste beschreibt die Abfrageformen, die PLINQ standardmäßig im sequenziellen Modus ausführt:</span><span class="sxs-lookup"><span data-stu-id="ecae0-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
- <span data-ttu-id="ecae0-161">Abfragen, die eine Select-, indizierte Where-, indizierte SelectMany- oder ElementAt-Klausel nach einem Sortierungs- oder Filterungsoperator enthalten, der ursprüngliche Indizes entfernt oder angeordnet hat.</span><span class="sxs-lookup"><span data-stu-id="ecae0-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
- <span data-ttu-id="ecae0-162">Abfragen, die einen Take-, TakeWhile-, Skip- und SkipWhile-Operator enthalten, und bei denen sich Indizes in der Quellsequenz nicht in der ursprünglichen Reihenfolge befinden.</span><span class="sxs-lookup"><span data-stu-id="ecae0-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
- <span data-ttu-id="ecae0-163">Abfragen, die Zip oder SequenceEquals enthalten, es sei denn, eine der Datenquellen enthält einen ursprünglich geordneten Index, und die andere Datenquelle ist indizierbar – d.h. Array oder IList(T).</span><span class="sxs-lookup"><span data-stu-id="ecae0-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
- <span data-ttu-id="ecae0-164">Abfragen, die Concat enthalten, sofern nicht auf indizierbare Datenquellen angewendet.</span><span class="sxs-lookup"><span data-stu-id="ecae0-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
- <span data-ttu-id="ecae0-165">Abfragen, die Reverse enthalten, sofern nicht auf eine indizierbare Datenquelle angewendet.</span><span class="sxs-lookup"><span data-stu-id="ecae0-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ecae0-166">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="ecae0-166">See also</span></span>

- [<span data-ttu-id="ecae0-167">Parallel LINQ (PLINQ) (Paralleles LINQ (PLINQ))</span><span class="sxs-lookup"><span data-stu-id="ecae0-167">Parallel LINQ (PLINQ)</span></span>](introduction-to-plinq.md)
