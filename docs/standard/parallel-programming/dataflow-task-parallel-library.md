---
title: Datenfluss (Task Parallel Library)
description: Erfahren Sie, wie Sie Datenflusskomponenten aus der Task Parallel Library (TPL) verwenden, um die Stabilität von nebenläufigkeitsfähigen Anwendungen zu verbessern.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
ms.openlocfilehash: 67b5cfaa987b3f37d68597d22ad5f87e8d1bd018
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/24/2020
ms.locfileid: "95728692"
---
# <a name="dataflow-task-parallel-library"></a>Datenfluss (Task Parallel Library)

Die Task Parallel Library (TPL) stellt Datenflusskomponenten bereit, um die Stabilität von nebenläufigkeitsfähigen Anwendungen zu erhöhen. Diese Datenflusskomponenten werden zusammen als *TPL-Datenflussbibliothek* bezeichnet. Dieses Datenflussmodell begünstigt die akteurbasierte Programmierung durch eine prozessinterne Nachrichtenübergabe für simple Datenfluss- und Pipelineaufgaben. Die Datenflusskomponenten basieren auf den Typen und der Planungsinfrastruktur der TPL und sind in die C#-, Visual Basic- und F#-Sprachunterstützung für asynchrone Programmierung integriert. Diese Datenflusskomponenten sind hilfreich, wenn mehrere Vorgänge vorliegen, die asynchron miteinander kommunizieren müssen, oder wenn Sie Daten verarbeiten möchten, die gerade verfügbar werden. Denken Sie beispielsweise an eine Anwendung, die Bilddaten von einer Webcam verarbeitet. Durch das Datenflussmodell kann die Anwendung Bildframes verarbeiten, sobald diese verfügbar sind. Wenn die Anwendung Bildframes beispielsweise durch Lichtkorrektur oder Rote-Augen-Reduktion aufbessert, können Sie eine *Pipeline* von Datenflusskomponenten erstellen. Jede Phase der Pipeline kann grober strukturierte Parallelitätsfunktionen verwenden, wie z. B. die von der TPL bereitgestellten Funktionen zum Transformieren des Bilds.  
  
 Dieses Dokument enthält eine Übersicht über die TPL-Datenflussbibliothek. Es bietet Informationen über das Programmiermodell, die vordefinierten Datenflussblocktypen sowie die Konfiguration der Datenflussblöcke für die speziellen Anforderungen Ihrer Anwendungen.  

[!INCLUDE [tpl-install-instructions](../../../includes/tpl-install-instructions.md)]

## <a name="programming-model"></a>Programmiermodell

 Die TPL-Datenflussbibliothek bietet eine Grundlage für die Nachrichtenübergabe und die Parallelisierung CPU-intensiver und E/A-intensiver Anwendungen mit hohem Durchsatz und niedriger Latenz. Außerdem erhalten Sie damit explizite Kontrolle darüber, wie Daten gepuffert und im System übermittelt werden. Stellen Sie sich zum besseren Verständnis des Datenflussprogrammiermodells eine Anwendung vor, die Bilder asynchron vom Datenträger lädt und ein Kompositum dieser Bilder erstellt. Herkömmliche Programmiermodelle erfordern in der Regel die Verwendung von Rückrufen und Synchronisierungsobjekten wie Sperren, um Aufgaben und den Zugriff auf freigegebene Daten zu koordinieren. Mit dem Datenflussprogrammiermodell können Sie Datenflussobjekte erstellen, die Bilder beim Lesen vom Datenträger verarbeiten. Unter dem Datenflussmodell deklarieren Sie, wie Daten behandelt werden, sobald diese verfügbar werden, und legen außerdem Abhängigkeiten zwischen Daten fest. Da die Laufzeit Abhängigkeiten zwischen Daten verwaltet, können Sie häufig die Anforderung vermeiden, Zugriff auf freigegebene Daten synchronisieren zu müssen. Da die Arbeit von der Laufzeit basierend auf dem asynchronen Eintreffen von Daten geplant wird, können Reaktionsgeschwindigkeit und Durchsatz des Datenflusses verbessert werden, indem die zugrunde liegenden Threads effizient verwaltet werden. Ein Beispiel, bei dem mit dem Datenflussprogrammiermodell eine Bildverarbeitung in einer Windows Forms-Anwendung implementiert wird, finden Sie unter [Walkthrough: Using Dataflow in a Windows Forms Application (Exemplarische Vorgehensweise: Verwenden von Datenflüssen in einer Windows Forms-Anwendung)](walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Quellen und Ziele  

 Die TPL-Datenflussbibliothek besteht aus *Datenflussblöcken*, bei denen es sich um Datenstrukturen handelt, die Daten puffern und verarbeiten. Die TPL definiert drei Arten von Datenflussblöcken: *Quellblöcke*, *Zielblöcke* und *Weitergabeblöcke*. Ein Quellblock fungiert als Datenquelle, aus der gelesen werden kann. Ein Zielblock fungiert als Datenempfänger, in den geschrieben werden kann. Ein Weitergabeblock fungiert als Quellblock und als Zielblock, aus dem gelesen und in den geschrieben werden kann. Die TPL definiert die <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType>-Schnittstelle, um Quellen darzustellen, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType>, um Ziele darzustellen, und <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType>, um Weitergaben darzustellen. <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> erbt von <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> und <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Die TPL-Datenflussbibliothek enthält mehrere vordefinierte Datenflussblocktypen, die die Schnittstellen <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> und <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> implementieren. Diese Datenflussblocktypen werden in diesem Dokument im Abschnitt [Vordefinierte Datenflussblocktypen](#predefined-dataflow-block-types) beschrieben.  
  
### <a name="connecting-blocks"></a>Verbinden von Blöcken  

 Sie können Datenflussblöcke mit *Formularpipelines* (lineare Sequenzen von Datenflussblöcken) oder *Netzwerken* (Diagramme von Datenflussblöcken) verbinden. Eine Pipeline ist eine Form von Netzwerk. In einer Pipeline oder einem Netzwerk geben Quellen asynchron Daten an Ziele weiter, sobald diese Daten verfügbar werden. Die <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType>-Methode verknüpft einen Quelldatenflussblock mit einem Zielblock. Eine Quelle kann mit null oder mehr Zielen verknüpft werden. Ziele können mit null oder mehr Quellen verknüpft werden. Sie können Datenflussblöcke in einer Pipeline oder einem Netzwerk gleichzeitig hinzufügen oder entfernen. Die vordefinierten Datenflussblocktypen behandeln alle Threadsicherheitsaspekte bezüglich Verknüpfungen und des Lösens von Verknüpfungen.  
  
 Ein Beispiel für die Verbindung von Datenflussblöcken zum Erstellen einer einfachen Pipeline finden Sie unter [Walkthrough: Creating a Dataflow Pipeline (Exemplarische Vorgehensweise: Erstellen einer Datenflusspipeline)](walkthrough-creating-a-dataflow-pipeline.md). Ein Beispiel für die Verbindung von Datenflussblöcken zum Erstellen eines komplexeren Netzwerks finden Sie unter [Walkthrough: Using Dataflow in a Windows Forms Application (Exemplarische Vorgehensweise: Verwenden von Datenflüssen in einer Windows Forms-Anwendung)](walkthrough-using-dataflow-in-a-windows-forms-application.md). Ein Beispiel, bei dem die Verknüpfung eines Ziels mit einer Quelle gelöst wird, nachdem die Quelle dem Ziel eine Nachricht anbietet, finden Sie unter [Vorgehensweise: Aufheben der Verknüpfungen von Datenflussblöcken](how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Filtern  

 Wenn Sie die <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType>-Methode aufrufen, um eine Quelle mit einem Ziel zu verknüpfen, können Sie einen Delegaten bereitstellen, der anhand des Werts einer Nachricht bestimmt, ob der Zielblock die Nachricht annimmt oder ablehnt. Dieser Filtermechanismus ist eine hilfreiche Möglichkeit, um sicherzustellen, dass nur bestimmte Werte von einem Datenflussblock empfangen werden. Für die meisten der vordefinierten Datenflussblocktypen gilt, dass eine Nachricht von der Quelle dem nächsten Ziel angeboten wird, wenn ein Quellblock mit mehreren Zielblöcken verbunden ist und ein Zielblock die Nachricht ablehnt. Die Reihenfolge, in der Nachrichten von einer Quelle Zielen angeboten werden, wird durch die Quelle definiert und kann je nach Typ der Quelle variieren. Die meisten Quellblocktypen bieten eine Nachricht nicht weiter an, nachdem diese von einem Ziel akzeptiert wurde. Eine Ausnahme dieser Regel ist die <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>-Klasse, die jede Nachricht allen Zielen anbietet, auch wenn einige Ziele die Nachricht ablehnen. Ein Beispiel, bei dem durch Filterung nur bestimmte Nachrichten verarbeitet werden, finden Sie unter [Walkthrough: Using Dataflow in a Windows Forms Application (Exemplarische Vorgehensweise: Verwenden von Datenflüssen in einer Windows Forms-Anwendung)](walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
> Da jeder vordefinierte Quelldatenflussblocktyp sicherstellt, dass Nachrichten in der Reihenfolge weitergegeben werden, in der sie empfangen werden, muss jede Nachricht vom Quellblock gelesen werden, bevor der Quellblock die nächste Nachricht verarbeiten kann. Wenn Sie daher Filter verwenden, um mehrere Ziele mit einer Quelle zu verbinden, sollten Sie sicherstellen, dass jede Nachricht von mindestens einem Zielblock empfangen wird. Andernfalls kann bei der Anwendung ein Deadlock auftreten.  
  
### <a name="message-passing"></a>Nachrichtenübergabe  

 Das Datenflussprogrammiermodell bezieht sich auf das Konzept der *Nachrichtenübergabe*, bei dem unabhängige Komponenten eines Programms miteinander kommunizieren, indem sie Nachrichten senden. Eine Möglichkeit, Nachrichten zwischen Anwendungskomponenten weiterzugeben, besteht darin, die <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A>- und die <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType>-Methode aufzurufen, um Nachrichten an Zieldatenflussblöcke zu senden (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> agiert synchron, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> agiert asynchron), und die <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>-, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>- und <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A>-Methoden aufzurufen, um Nachrichten von Quellblöcken zu empfangen. Sie können diese Methoden mit Datenflusspipelines oder -netzwerken kombinieren, indem Sie Eingabedaten an den Hauptknoten (ein Zielblock) senden und Ausgabedaten vom Terminalknoten der Pipeline bzw. von den Terminalknoten des Netzwerks (ein oder mehrere Quellblöcke) empfangen. Sie können auch die <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A>-Methode verwenden, um aus der ersten der bereitgestellten Quellen zu lesen, die Daten zur Verfügung stellt, und Aktionen für diese Daten ausführen.  
  
 Quellblöcke bieten Zielblöcken Daten an, indem die <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType>-Methode aufgerufen wird. Der Zielblock reagiert auf eine angebotene Nachricht auf eine von drei Arten: Er kann die Nachricht akzeptieren, ablehnen oder zurückstellen. Wenn das Ziel die Nachricht akzeptiert, gibt die <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A>-Methode <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted> zurück. Wenn das Ziel die Nachricht ablehnt, gibt die <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A>-Methode <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined> zurück. Wenn das Ziel erfordert, dass es keine weiteren Nachrichten mehr von der Quelle empfängt, gibt die <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A>-Methode <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently> zurück. Die vordefinierten Quellblocktypen bieten verknüpften Zielen keine Nachrichten an, nachdem ein solcher Rückgabewert empfangen wird, und die Verknüpfung zu solchen Zielen wird automatisch gelöst.  
  
 Wenn ein Zielblock die Nachricht für die spätere Verwendung zurückstellt, gibt die <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A>-Methode <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed> zurück. Ein Zielblock, der eine Nachricht zurückstellt, kann später die Methode <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType> aufrufen, um zu versuchen, die angebotene Nachricht zu reservieren. In diesem Moment ist die Nachricht entweder weiterhin verfügbar und kann vom Zielblock verwendet werden, oder die Nachricht wurde von einem anderen Ziel angenommen. Wenn der Zielblock die Nachricht später benötigt oder die Nachricht nicht mehr benötigt, wird die <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType>- bzw. die <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A>-Methode aufgerufen. Nachrichtenreservierung wird in der Regel von Datenflussblocktypen verwendet, die sich im nicht gierigen Modus befinden. "Nicht gieriger Modus" wird weiter unten in diesem Dokument erläutert. Anstatt eine zurückgestellte Nachricht zu reservieren, kann ein Zielblock auch die <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType>-Methode verwenden, um zu versuchen, die zurückgestellte Nachricht direkt zu verarbeiten.  
  
### <a name="dataflow-block-completion"></a>Abschluss von Datenflussblöcken  

 Datenflussblöcke unterstützen auch das Konzept des *Abschlusses*. Ein Datenflussblock, der sich im abgeschlossenen Zustand befindet, führt keine weitere Arbeit mehr aus. Jeder Datenflussblock verfügt über ein zugehöriges <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>-Objekt, das als *Abschlussaufgabe* bezeichnet wird und den Abschlusszustand des Blocks darstellt. Da Sie mithilfe von Abschlussaufgaben darauf warten können, dass ein <xref:System.Threading.Tasks.Task>-Objekt abgeschlossen wird, können Sie auf den Abschluss von einem oder mehreren Terminalknoten eines Datenflussnetzwerks warten. Die <xref:System.Threading.Tasks.Dataflow.IDataflowBlock>-Schnittstelle definiert die <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A>-Methode, die den Datenflussblock über eine abzuschließende Anforderung informiert, sowie die <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A>-Eigenschaft, die die Abschlussaufgabe für den Datenflussblock zurückgibt. <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> und <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> erben beide von der <xref:System.Threading.Tasks.Dataflow.IDataflowBlock>-Schnittstelle.  
  
 Es gibt zwei Möglichkeiten, um zu bestimmen, ob ein Datenflussblock ohne Fehler abgeschlossen wurde, ob mindestens ein Fehler aufgetreten ist oder ob er abgebrochen wurde. Die erste Möglichkeit besteht darin, die <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>-Methode für die Abschlussaufgabe in einem `try`---Block (`catch``Try``Catch` in Visual Basic) aufzurufen. Im folgenden Beispiel wird ein <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>-Objekt erstellt, das <xref:System.ArgumentOutOfRangeException> auslöst, wenn der Eingabewert kleiner als null ist. <xref:System.AggregateException> wird ausgelöst, wenn in diesem Beispiel <xref:System.Threading.Tasks.Task.Wait%2A> für die Abschlussaufgabe aufgerufen wird. Der Zugriff auf <xref:System.ArgumentOutOfRangeException> erfolgt über die <xref:System.AggregateException.InnerExceptions%2A>-Eigenschaft des <xref:System.AggregateException>-Objekts.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 In diesem Beispiel wird der Fall erläutert, in dem eine Ausnahme im Delegaten eines Ausführungsdatenflussblocks unbehandelt bleibt. Es wird empfohlen, Ausnahmen in den Codetexten solcher Blöcke zu behandeln. Wenn dies jedoch nicht möglich ist, verhält sich der Block, als ob er abgebrochen wurde, und verarbeitet keine eingehenden Nachrichten.  
  
 Wenn ein Datenflussblock explizit abgebrochen wird, enthält das <xref:System.AggregateException>-Objekt <xref:System.OperationCanceledException> in der <xref:System.AggregateException.InnerExceptions%2A>-Eigenschaft. Weitere Informationen zum Abbrechen von Datenflüssen finden Sie im Abschnitt [Aktivieren des Abbruchs](#enabling-cancellation).  
  
 Die zweite Möglichkeit, den Abschlussstatus eines Datenflussblocks zu bestimmen, ist die Verwendung einer Fortsetzung außerhalb der Abschlussaufgabe oder die Verwendung der asynchronen Sprachfunktionen von C# und Visual Basic, um auf die Abschlussaufgabe asynchron zu warten. Der Delegat, den Sie für die <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType>-Methode bereitstellen, nimmt ein <xref:System.Threading.Tasks.Task>-Objekt an, das die vorangehende Aufgabe darstellt. Im Fall der <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A>-Eigenschaft nimmt der Delegat für die Fortsetzung die Abschlussaufgabe selbst an. Das folgende Beispiel ähnelt dem vorherigen, es wird jedoch auch die <xref:System.Threading.Tasks.Task.ContinueWith%2A>-Methode verwendet, um eine Abschlussaufgabe zu erstellen, die den Status des gesamten Datenflussvorgangs ausgibt.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 Sie können auch Eigenschaften wie <xref:System.Threading.Tasks.Task.IsCanceled%2A> im Codetext der Fortsetzungsaufgabe verwenden, um zusätzliche Informationen über den Abschlussstatus eines Datenflussblocks zu ermitteln. Weitere Informationen zu Fortsetzungsaufgaben und deren Beziehung zum Abbruch und zur Fehlerbehandlung finden Sie unter [Verketten von Aufgaben durch Fortsetzungsaufgaben](chaining-tasks-by-using-continuation-tasks.md), [Aufgabenabbruch](task-cancellation.md) und [Ausnahmebehandlung](exception-handling-task-parallel-library.md).  

## <a name="predefined-dataflow-block-types"></a>Vordefinierte Datenflussblocktypen  

 Die TPL-Datenflussbibliothek enthält mehrere vordefinierte Datenflussblocktypen. Diese Typen sind in drei Kategorien unterteilt: *Pufferblöcke*, *Ausführungsblöcke* und *Gruppierungsblöcke*. In den folgenden Abschnitten werden die Blocktypen dieser Kategorien beschrieben.  
  
### <a name="buffering-blocks"></a>Pufferblöcke  

 Pufferblöcke enthalten Daten zur Verwendung durch Datenconsumer. Die TPL-Datenflussbibliothek enthält drei Pufferblocktypen: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType> und <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.  
  
#### <a name="bufferblockt"></a>BufferBlock(T)  

 Die <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>-Klasse stellt eine allgemeine asynchrone Nachrichtenstruktur dar. Diese Klasse speichert eine FIFO-Nachrichtenwarteschlange (First In, First Out), in die mehrere Quellen Nachrichten schreiben oder aus der mehrere Ziele Nachrichten auslesen können. Wenn ein Ziel eine Nachricht von einem <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>-Objekt empfängt, wird diese Nachricht aus der Nachrichtenwarteschlange entfernt. Daher können die einzelnen Nachrichten nur von einem Ziel empfangen werden, obwohl ein <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>-Objekt mehrere Ziele haben kann. Die <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>-Klasse ist hilfreich, wenn Sie mehrere Nachrichten an eine andere Komponente übergeben möchten und diese Komponente alle Nachrichten empfangen muss.  
  
 Im folgenden grundlegenden Beispiel werden mehrere <xref:System.Int32>-Werte an ein <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>-Objekt gesendet und anschließend wieder aus dem Objekt gelesen.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Ein vollständiges Beispiel zur Veranschaulichung, wie Nachrichten in ein <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>-Objekt geschrieben oder daraus gelesen werden, finden Sie unter [Vorgehensweise: Schreiben und Lesen von Nachrichten in einem Datenflussblock](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  

 Die <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>-Klasse ist hilfreich, wenn mehrere Nachrichten an eine andere Komponente übergeben werden müssen, diese Komponente jedoch nur den letzten Wert benötigt. Diese Klasse ist darüber hinaus auch hilfreich, wenn Sie eine Nachricht an mehreren Komponenten übertragen möchten.  
  
 Im folgenden grundlegenden Beispiel wird ein <xref:System.Double>-Wert an ein <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>-Objekt gesendet und dann mehrmals aus dem Objekt gelesen. Da Werte nicht aus <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>-Objekten entfernt werden, nachdem sie gelesen wurden, ist der gleiche Wert jedes Mal verfügbar.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Ein vollständiges Beispiel zur Veranschaulichung, wie eine Nachricht mit <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> an mehrere Zielblöcke gesendet wird, finden Sie unter [Vorgehensweise: Angeben eines Taskplaners in einem Datenflussblock](how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  

 Die <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>-Klasse ähnelt der <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>-Klasse, ein <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>-Objekt kann jedoch nur einmal hineingeschrieben werden. <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> ähnelt dem [readonly](../../csharp/language-reference/keywords/readonly.md)-Schlüsselwort in C# ([ReadOnly](../../visual-basic/language-reference/modifiers/readonly.md) in Visual Basic), ein <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>-Objekt wird jedoch unveränderlich, nachdem es einen Wert anstatt einer Konstruktion empfängt. Wenn ein Ziel eine Nachricht von einem <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>-Objekt empfängt, wird diese Nachricht wie bei der <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>-Klasse nicht aus diesem Objekt entfernt. Daher empfangen mehrere Ziele eine Kopie der Nachricht. Die <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>-Klasse ist hilfreich, wenn Sie nur die erste von mehreren Nachrichten weitergeben möchten.  
  
 Im folgenden Beispiel werden mehrere <xref:System.String>-Werte an ein <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>-Objekt gesendet. Anschließend wird der Wert aus dem Objekt gelesen. Da in ein <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>-Objekt nur einmal geschrieben werden kann, nachdem ein <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>-Objekt eine Nachricht empfängt, werden nachfolgende Nachrichten verworfen.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Ein vollständiges Beispiel zur Veranschaulichung, wie mit <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> der Wert des ersten abgeschlossenen Vorgangs empfangen wird, finden Sie unter [Vorgehensweise: Aufheben der Verknüpfungen von Datenflussblöcken](how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Ausführungsblöcke  

 Ausführungsblöcke rufen einen vom Benutzer bereitgestellten Delegaten für jedes Element empfangener Daten auf. Die TPL-Datenflussbibliothek enthält drei Typen von Ausführungsblöcken: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType> und <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>.  
  
#### <a name="actionblockt"></a>ActionBlock(T)  

 Die <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>-Klasse ist ein Zielblock, der einen Delegaten aufruft, wenn er Daten empfängt. Stellen Sie sich ein <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>-Objekt als Delegaten vor, der asynchron ausgeführt wird, wenn Daten verfügbar werden. Der Delegat, den Sie für ein <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>-Objekt bereitstellen, kann vom Typ <xref:System.Action%601> oder vom Typ `System.Func<TInput, Task>` sein. Wenn Sie ein <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>-Objekt mit <xref:System.Action%601> verwenden, wird die Verarbeitung jedes Eingabeelements als abgeschlossen betrachtet, wenn der Delegat zurückgegeben wird. Wenn Sie ein <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>-Objekt mit `System.Func<TInput, Task>` verwenden, wird die Verarbeitung jedes Eingabeelements nur dann als abgeschlossen betrachtet, wenn das zurückgegebene <xref:System.Threading.Tasks.Task>-Objekt abgeschlossen ist. Mit diesen beiden Mechanismen können Sie <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> zur synchronen und asynchronen Verarbeitung der einzelnen Eingabeelemente verwenden.  
  
 Im folgenden grundlegenden Beispiel werden mehrere <xref:System.Int32>-Werte an ein <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>-Objekt gesendet. Das <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>-Objekt gibt diese Werte in der Konsole aus. Im Beispiel wird der Block dann in den abgeschlossenen Zustand versetzt, und es wird gewartet, bis alle Datenflussaufgaben abgeschlossen sind.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Ausführliche Beispiele für die Verwendung von Delegaten mit der <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>-Klasse finden Sie unter [Vorgehensweise: Ausführen einer Aktion, wenn ein Datenflussblock Daten empfängt](how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  

 Die <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>-Klasse ähnelt der <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>-Klasse, sie fungiert jedoch als Quelle und als Ziel. Der Delegat, den Sie an ein <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>-Objekt übergeben, gibt einen Wert vom Typ `TOutput` zurück. Der Delegat, den Sie für ein <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>-Objekt bereitstellen, kann vom Typ `System.Func<TInput, TOutput>` oder vom Typ `System.Func<TInput, Task<TOutput>>` sein. Wenn Sie ein <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>-Objekt mit `System.Func<TInput, TOutput>` verwenden, wird die Verarbeitung jedes Eingabeelements als abgeschlossen betrachtet, wenn der Delegat zurückgegeben wird. Wenn Sie ein <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>-Objekt mit `System.Func<TInput, Task<TOutput>>` verwenden, wird die Verarbeitung jedes Eingabeelements nur dann als abgeschlossen betrachtet, wenn das zurückgegebene <xref:System.Threading.Tasks.Task%601>-Objekt abgeschlossen ist. Wie bei <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> können Sie mit diesen beiden Mechanismen <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> zur synchronen und asynchronen Verarbeitung der einzelnen Eingabeelemente verwenden.  
  
 Im folgenden grundlegenden Beispiel wird ein <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>-Objekt erstellt, das die Quadratwurzel seiner Eingabe berechnet. Das <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>-Objekt nimmt <xref:System.Int32>-Werte als Eingabe an und erzeugt <xref:System.Double>-Werte als Ausgabe.  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Ausführliche Beispiele für die Verwendung von <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> in einem Netzwerk von Datenflussblöcken, das eine Bildverarbeitung in einer Windows Forms-Anwendung ausführt, finden Sie unter [Walkthrough: Using Dataflow in a Windows Forms Application (Exemplarische Vorgehensweise: Verwenden von Datenflüssen in einer Windows Forms-Anwendung)](walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  

 Die <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>-Klasse ähnelt der <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>-Klasse, außer dass <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> null oder mehr Ausgabewerte für jeden Eingabewert erzeugt, anstatt nur eines Ausgabewerts für jeden Eingabewert. Der Delegat, den Sie für ein <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>-Objekt bereitstellen, kann vom Typ `System.Func<TInput, IEnumerable<TOutput>>` oder vom Typ `System.Func<TInput, Task<IEnumerable<TOutput>>>` sein. Wenn Sie ein <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>-Objekt mit `System.Func<TInput, IEnumerable<TOutput>>` verwenden, wird die Verarbeitung jedes Eingabeelements als abgeschlossen betrachtet, wenn der Delegat zurückgegeben wird. Wenn Sie ein <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>-Objekt mit `System.Func<TInput, Task<IEnumerable<TOutput>>>` verwenden, wird die Verarbeitung jedes Eingabeelements nur dann als abgeschlossen betrachtet, wenn das zurückgegebene `System.Threading.Tasks.Task<IEnumerable<TOutput>>`-Objekt abgeschlossen ist.  
  
 Im folgenden grundlegenden Beispiel wird ein <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>-Objekt erstellt, das Zeichenfolgen in ihre einzelnen Zeichensequenzen aufteilt. Das <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>-Objekt nimmt <xref:System.String>-Werte als Eingabe an und erzeugt <xref:System.Char>-Werte als Ausgabe.  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Ausführliche Beispiele, bei denen mit <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> mehrere unabhängige Ausgaben für jede Eingabe in einer Datenflusspipeline erzeugt werden, finden Sie unter [Walkthrough: Creating a Dataflow Pipeline (Exemplarische Vorgehensweise: Erstellen einer Datenflusspipeline)](walkthrough-creating-a-dataflow-pipeline.md).  
  
#### <a name="degree-of-parallelism"></a>Grad der Parallelität  

 Jedes <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>-, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>- und <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>-Objekt puffert eingehende Nachrichten, bis der Block bereit für die Verarbeitung ist. In der Standardeinstellung verarbeiten diese Klassen Nachrichten nacheinander in der Reihenfolge, in der sie empfangen werden. Sie können auch den Grad der Parallelität angeben, sodass <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>-, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>- und <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>-Objekte mehrere Nachrichten gleichzeitig verarbeiten können. Weitere Informationen über die gleichzeitige Ausführung finden Sie im Abschnitt "Festlegen des Grads der Parallelität" weiter unten in diesem Dokument. Ein Beispiel, bei dem der Grad der Parallelität so festgelegt wird, dass ein Ausführungsdatenflussblock mehrere Nachrichten gleichzeitig verarbeiten kann, finden Sie unter [Vorgehensweise: Festlegen des Parallelitätsgrads in einem Datenflussblock](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Übersicht über Delegattypen  

 In der folgenden Tabelle sind die Delegattypen zusammengefasst, die Sie für <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>-, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>- und <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>-Objekte bereitstellen können. In dieser Tabelle wird auch angegeben, ob der Delegattyp synchron oder asynchron arbeitet.  
  
|Typ|Synchroner Delegattyp|Asynchroner Delegattyp|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func<TInput, TOutput>`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 Sie können auch Lambda-Ausdrücke verwenden, wenn Sie mit Ausführungsblocktypen arbeiten. Ein Beispiel für die Verwendung eines Lambda-Ausdrucks mit einem Ausführungsblock finden Sie unter [Vorgehensweise: Ausführen einer Aktion, wenn ein Datenflussblock Daten empfängt](how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Gruppierungsblöcke  

 Gruppierungsblöcke kombinieren Daten aus einer oder mehreren Quellen und unter verschiedenen Einschränkungen. Die TPL-Datenflussbibliothek enthält drei Typen von Gruppierungsblöcken: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> und <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.  
  
#### <a name="batchblockt"></a>BatchBlock(T)  

 Die <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>-Klasse kombiniert Sätze von Eingabedaten, die als Batches bezeichnet werden, in Arrays von Ausgabedaten. Beim Erstellen eines <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>-Objekts geben Sie die Größe von jedem Batch an. Wenn das <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>-Objekt die angegebene Anzahl von Eingabeelementen empfängt, wird ein Array mit diesen Elementen asynchron weitergegeben. Wenn ein <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>-Objekt in den abgeschlossenen Zustand versetzt wird, jedoch nicht genügend Elemente zum Bilden eines Batches enthält, wird ein abschließendes Array mit den restlichen Eingabeelementen weitergegeben.  
  
 Die <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>-Klasse arbeitet entweder im *gierigen* oder im *nicht gierigen* Modus. Im gierigen Modus (Standard) nimmt ein <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>-Objekt jede Nachricht an, die angeboten wird, und gibt ein Array weiter, nachdem die angegebene Anzahl von Elementen empfangen wurde. Im nicht gierigen Modus stellt ein <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>-Objekt alle eingehenden Nachrichten zurück, bis dem Block genügend Nachrichten von Quellen angeboten wurden, um einen Batch zu bilden. Der gierige Modus erzielt in der Regel eine bessere Leistung als der nicht gierige Modus, da er weniger Verarbeitungsaufwand erfordert. Sie können den nicht gierigen Modus jedoch verwenden, wenn Sie die Nutzung von mehreren Quellen auf atomische Weise koordinieren müssen. Legen Sie den nicht gierigen Modus fest, indem Sie <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> auf `False` im `dataflowBlockOptions` Parameter im <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A>-Konstruktor festlegen.  
  
 Im folgenden grundlegenden Beispiel werden mehrere <xref:System.Int32>-Werte an ein <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>-Objekt gesendet, das zehn Elemente in einem Batch enthält. Um sicherzustellen, dass alle Werte aus <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> weitergegeben werden, wird in diesem Beispiel die <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A>-Methode aufgerufen. Die <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A>-Methode legt das <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>-Objekt auf den abgeschlossenen Zustand fest. Daher werden vom <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>-Objekt alle verbleibenden Elemente in einem abschließenden Batch weitergegeben.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Ein vollständiges Beispiel für die Verwendung von <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> zur Verbesserung der Effizienz von Datenbankeinfügevorgängen finden Sie unter [Exemplarische Vorgehensweise: Effizienzverbesserung durch Verwendung von BatchBlock und BatchedJoinBlock](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>JoinBlock(T1, T2, ...)  

 Die <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>- und die <xref:System.Threading.Tasks.Dataflow.JoinBlock%603>-Klasse sammeln Eingabeelemente und geben <xref:System.Tuple%602?displayProperty=nameWithType>- oder <xref:System.Tuple%603?displayProperty=nameWithType>-Objekte weiter, die diese Elemente enthalten. Die <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>- und die <xref:System.Threading.Tasks.Dataflow.JoinBlock%603>-Klasse erben nicht von <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Stattdessen stellen sie die Eigenschaften <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A> und <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A> bereit, die <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> implementieren.  
  
 Wie <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> arbeiten auch <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> und <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> entweder im gierigen oder im nicht gierigen Modus. Im gierigen Modus (Standard) nimmt ein <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>- oder <xref:System.Threading.Tasks.Dataflow.JoinBlock%603>-Objekt jede Nachricht an, die angeboten wird, und gibt ein Tupel weiter, nachdem jedes der zugehörigen Ziele mindestens eine Nachricht empfangen hat. Im nicht gierigen Modus stellt ein <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>- oder <xref:System.Threading.Tasks.Dataflow.JoinBlock%603>-Objekt alle eingehenden Nachrichten zurück, bis allen Zielen die Daten angeboten wurden, die zum Erstellen eines Tupels erforderlich sind. An diesem Punkt initiiert der Block ein Zweiphasencommit-Protokoll, um alle erforderlichen Elemente aus den Quellen atomar abzurufen. Durch diese Zurückstellung ist es möglich, dass eine andere Entität die Daten in der Zwischenzeit nutzt, sodass das gesamte System mit der Verarbeitung fortschreitet.  
  
 Das folgende grundlegende Beispiel zeigt einen Fall, in dem ein <xref:System.Threading.Tasks.Dataflow.JoinBlock%603>-Objekt mehrere Daten benötigt, einen Wert zu berechnen. In diesem Beispiel wird ein <xref:System.Threading.Tasks.Dataflow.JoinBlock%603>-Objekt erstellt, das zwei <xref:System.Int32>-Werte und einen <xref:System.Char>-Wert erfordert, um eine arithmetische Operation durchzuführen.  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Ein vollständiges Beispiel für die Verwendung von <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>-Objekten im nicht gierigen Modus zur kooperativen Nutzung einer Ressource finden Sie unter [Vorgehensweise: Verwenden von JoinBlock zum Lesen aus mehreren Quellen](how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock(T1, T2, ...)  

 Die <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>- und die <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603>-Klasse sammeln Batches von Eingabeelementen und geben `System.Tuple(IList(T1), IList(T2))`- oder `System.Tuple(IList(T1), IList(T2), IList(T3))`-Objekte weiter, die diese Elemente enthalten. Stellen Sie sich <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> als eine Kombination aus <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> und <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> vor. Beim Erstellen eines <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>-Objekts geben Sie die Größe von jedem Batch an. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> stellt außerdem die Eigenschaften <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> und <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> bereit, die <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> implementieren. Wenn die angegebene Anzahl von Eingabeelementen auf allen Zielen empfangen wurde, gibt das <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>-Objekt ein `System.Tuple(IList(T1), IList(T2))`-Objekt asynchron weiter, das die Elemente enthält.  
  
 Im folgenden grundlegenden Beispiel wird ein <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>-Objekt erstellt, das Ergebnisse, <xref:System.Int32>-Werte und Fehler enthält, bei denen es sich um <xref:System.Exception>-Objekte handelt. In diesem Beispiel werden mehrere Vorgänge durchgeführt. Ergebnisse werden in die <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A>-Eigenschaft und Fehler in die <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>-Eigenschaft des <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>-Objekts geschrieben. Da die Anzahl der erfolgreichen und fehlgeschlagenen Vorgänge im Voraus unbekannt ist, ermöglichen die <xref:System.Collections.Generic.IList%601>-Objekte, dass jedes Ziel null oder mehr Werte empfängt.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Ein vollständiges Beispiel, bei dem mit <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> die Ergebnisse und Ausnahmen erfasst werden, die beim Lesen des Programms aus einer Datenbank auftreten, finden Sie unter [Exemplarische Vorgehensweise: Effizienzverbesserung durch Verwendung von BatchBlock und BatchedJoinBlock](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  

## <a name="configuring-dataflow--block-behavior"></a>Konfigurieren des Datenflussblockverhaltens  

 Sie können zusätzliche Optionen aktivieren, indem Sie ein <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>-Objekt für den Konstruktor von Datenflussblocktypen bereitstellen. Diese Optionen steuern das Verhalten wie z. B. den Planer, der die zugrunde liegende Aufgabe und den Grad der Parallelität verwaltet. <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> verfügt außerdem über abgeleitete Typen, die das Verhalten für bestimmte Datenflussblocktypen festlegen. In der folgenden Tabelle ist zusammengefasst, welcher Optionstyp den einzelnen Datenflussblocktypen zugeordnet ist.  
  
|Datenflussblocktyp|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>-Typ|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 Die folgenden Abschnitte enthalten zusätzliche Informationen über die wichtigen Arten von Optionen für Datenflussblöcke, die durch die Klassen <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType> und <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType> zur Verfügung stehen.  
  
### <a name="specifying-the-task-scheduler"></a>Festlegen des Aufgabenplaners  

 Jeder vordefinierte Datenflussblock verwendet den TPL-Aufgabenplanungsmechanismus zum Durchführen von Aktivitäten, wie das Weitergeben von Daten an ein Ziel, das Empfangen von Daten aus einer Quelle und das Ausführen benutzerdefinierter Delegate, wenn Daten verfügbar werden. <xref:System.Threading.Tasks.TaskScheduler> ist eine abstrakte Klasse, die einen Aufgabenplaner darstellt, der Aufgaben in Warteschlangen für Threads stellt. Der Standardtaskplaner <xref:System.Threading.Tasks.TaskScheduler.Default%2A> verwendet die <xref:System.Threading.ThreadPool>-Klasse, um Arbeit in die Warteschlange zu stellen und auszuführen. Sie können den Standardtaskplaner überschreiben, indem Sie die <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A>-Eigenschaft festlegen, wenn Sie ein Datenflussblockobjekt erstellen.  
  
 Wenn der gleiche Aufgabenplaner mehrere Datenflussblöcke verwaltet, kann er Richtlinien für sie erzwingen. Wenn beispielsweise für mehrere Datenflussblöcke jeweils der exklusive Planer des gleichen <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair>-Objekts als Ziel konfiguriert ist, wird die gesamte Arbeit serialisiert, die auf diesen Blöcken ausgeführt wird. Wenn für diese Blöcke der parallele Planer des gleichen <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair>-Objekts als Ziel konfiguriert wird und dieser Planer für die maximale Nebenläufigkeitsebene konfiguriert ist, wird die gesamte Arbeit von diesen Blöcken auf diese Anzahl paralleler Vorgänge beschränkt. Ein Beispiel, bei dem mithilfe der <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair>-Klasse Lesevorgänge parallel ausgeführt werden, Schreibvorgänge jedoch exklusiv von allen anderen Vorgängen erfolgen, finden Sie unter [Vorgehensweise: Angeben eines Taskplaners in einem Datenflussblock](how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Weitere Informationen zum Taskplaner in der TPL finden Sie im Thema zur <xref:System.Threading.Tasks.TaskScheduler>-Klasse.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Festlegen des Grads der Parallelität  

 In der Standardeinstellung verarbeitet die drei Ausführungsblocktypen, die die TPL-Datenflussbibliothek bereitstellt, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> und <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, jeweils nur eine Nachricht. Diese Datenflussblocktypen verarbeiten Nachrichten ebenfalls in der Reihenfolge, in der sie empfangen werden. Damit diese Datenflussblöcke Nachrichten gleichzeitig verarbeiten können, muss die <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType>-Eigenschaft beim Erstellen des Datenflussblockobjekts festgelegt werden.  
  
 Der Standardwert von <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> ist 1. Dadurch wird gewährleistet, dass der Datenflussblock jeweils nur eine Nachricht verarbeitet. Durch das Festlegen dieser Eigenschaft auf einen Wert, der größer als 1 ist, kann der Datenflussblock mehrere Nachrichten gleichzeitig verarbeiten. Durch das Festlegen dieser Eigenschaft auf <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> kann der zugrunde liegende Aufgabenplaner den maximalen Grad von Nebenläufigkeit verwalten.  
  
> [!IMPORTANT]
> Wenn Sie einen maximalen Grad an Parallelität angeben, der größer als 1 ist, werden mehrere Nachrichten gleichzeitig verarbeitet. Daher werden Nachrichten möglicherweise nicht in der Reihenfolge verarbeitet, in der sie empfangen werden. Die Reihenfolge, in der die Nachrichten aus dem Block ausgegeben werden, ist jedoch mit der Reihenfolge identisch, in der sie empfangen werden.  
  
 Da die <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A>-Eigenschaft den maximalen Grad an Parallelität darstellt, wird der Datenflussblock u. U. mit einem geringeren Grad an Parallelität ausgeführt als angegeben. Der Datenflussblock kann zum Erfüllen seiner Funktionsanforderungen oder aufgrund eines Mangels an verfügbaren Systemressourcen einen geringeren Grad an Parallelität verwenden. Ein Datenflussblock wird nie mit mehr Parallelität ausgeführt als Sie angeben.  
  
 Der Wert der <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A>-Eigenschaft ist exklusiv für jedes Datenflussblockobjekt. Wenn beispielsweise für vier Datenflussblockobjekte als maximaler Grad an Parallelität jeweils 1 angegeben wird, können u. U. alle vier Datenflussblockobjekte parallel ausgeführt werden.  
  
 Ein Beispiel, bei dem der maximale Grad an Parallelität so festgelegt wird, dass lang andauernde Operationen parallel ausgeführt werden können, finden Sie unter [Vorgehensweise: Festlegen des Parallelitätsgrads in einem Datenflussblock](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Festlegen der Anzahl von Nachrichten pro Aufgabe  

 Die vordefinierten Datenflussblocktypen verwenden Aufgaben, um mehrere Eingabeelemente zu verarbeiten. Dadurch kann die Anzahl der zum Verarbeiten von Daten erforderlichen Aufgabenobjekte minimiert werden, sodass Anwendungen effizienter ausgeführt werden können. Wenn Daten von den Aufgaben aus einem Satz von Datenflussblöcken verarbeitet werden, müssen die Aufgaben von anderen Datenflussblöcken jedoch möglicherweise auf Verarbeitungszeit warten, indem Nachrichten in die Warteschlange gestellt werden. Legen Sie die Eigenschaft <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> fest, um eine bessere Ausgewogenheit zwischen Datenflussaufgaben zu ermöglichen. Wenn <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> auf <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> (Standard) festgelegt ist, verarbeitet die von einem Datenflussblock verwendete Aufgabe alle verfügbaren Nachrichten. Wenn <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> auf einen anderen Wert als <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded> festgelegt wird, verarbeitet der Datenflussblock höchstens diese Anzahl an Nachrichten pro <xref:System.Threading.Tasks.Task>-Objekt. Obwohl das Festlegen der <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A>-Eigenschaft die Ausgewogenheit zwischen Aufgaben erhöhen kann, werden vom System u. U. mehr Aufgaben als notwendig erstellt, sodass die Leistung beeinträchtigt wird.  
  
### <a name="enabling-cancellation"></a>Aktivieren des Abbruchs  

 Die TPL bietet einen Mechanismus, durch den Aufgaben Abbrüche kooperative koordinieren können. Legen Sie die <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A>-Eigenschaft fest, damit Datenflussblöcke diesen Abbruchmechanismus nutzen. Wenn dieses <xref:System.Threading.CancellationToken>-Objekt in den abgebrochenen Zustand versetzt wird, beenden alle Datenflussblöcke, die dieses Token überwachen, die Ausführung ihres aktuellen Elements, beginnen jedoch nicht mit der Verarbeitung nachfolgender Elemente. Diese Datenflussblöcke löschen außerdem alle gepufferten Nachrichten, geben Verbindungen zu allen Quell- und Zielblöcken frei und wechseln in den abgebrochenen Zustand. Durch den Übergang in den abgebrochenen Zustand, wird die <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A>-Eigenschaft der <xref:System.Threading.Tasks.Task.Status%2A>-Eigenschaft auf <xref:System.Threading.Tasks.TaskStatus.Canceled> festgelegt, wenn während der Verarbeitung keine Aufnahme aufgetreten ist. In diesem Fall wird <xref:System.Threading.Tasks.Task.Status%2A> auf <xref:System.Threading.Tasks.TaskStatus.Faulted> festgelegt.  
  
 Ein Beispiel für die Verwendung eines Abbruchs in einer Windows Forms-Anwendung finden Sie unter [Vorgehensweise: Abbrechen eines Datenflussblocks](how-to-cancel-a-dataflow-block.md). Weitere Informationen über Abbrüche in der TPL finden Sie unter [Aufgabenabbruch](task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Festlegen von gierigem Verhalten im Vergleich zu nicht gierigem Verhalten  

 Mehrere Gruppierungsdatenflussblock-Typen können im *gierigen* oder im *nicht gierigen* Modus arbeiten. In der Standardeinstellung arbeiten die vordefinierten Datenflussblocktypen im gierigen Modus.  
  
 Bei Gruppierungsblocktypen wie <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> bedeutet der gierige Modus, dass Daten vom Block sofort angenommen werden, auch wenn die entsprechenden Daten, mit denen eine gemeinsame Gruppierung erfolgt, noch nicht verfügbar sind. Nicht gieriger Modus bedeutet, dass der Block alle eingehenden Nachrichten zurückstellt, bis eine Nachricht an jedem der zugehörigen Ziele verfügbar ist, um die Gruppierung zu vervollständigen. Wenn eine der zurückgestellten Nachrichten nicht mehr verfügbar ist, gibt der Gruppierungsblock alle zurückgestellten Nachrichten frei und startet den Prozess neu. Bei der <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>-Klasse ist das gierige und das nicht gierige Verhalten ähnlich, außer dass ein <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>-Objekt im nicht gierigen Modus alle eingehenden Nachrichten zurückstellt, bis genügend Nachrichten aus verschiedenen Quellen verfügbar sind, um einen Batch zu vervollständigen.  
  
 Legen Sie <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> auf `False` fest, um den nicht gierigen Modus für einen Datenflussblock festzulegen. Ein Beispiel für die Verwendung des nicht gierigen Modus, sodass mehrere Gruppierungsblöcke eine Datenquelle effizienter gemeinsam verwenden können, finden Sie unter [Vorgehensweise: Verwenden von JoinBlock zum Lesen aus mehreren Quellen](how-to-use-joinblock-to-read-data-from-multiple-sources.md).

## <a name="custom-dataflow-blocks"></a>Benutzerdefinierte Datenflussblöcke  

 Obwohl die TPL-Datenflussbibliothek viele vordefinierte Blocktypen bereitstellt, können Sie zusätzliche Blockstypen mit einem benutzerdefinierten Verhalten erstellen. Implementieren Sie direkt die <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>- oder die <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>-Schnittstelle, oder verwenden Sie die <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A>-Methode, um einen komplexen Block zu erstellen, der das Verhalten vorhandener Blocktypen kapselt. Beispiele für die Implementierung benutzerdefinierter Datenflussblock-Funktionen finden Sie unter [Exemplarische Vorgehensweise: Erstellen eines Datenflussblocktyps](walkthrough-creating-a-custom-dataflow-block-type.md).

## <a name="related-topics"></a>Verwandte Themen  
  
|Titel|Beschreibung|  
|-----------|-----------------|  
|[How to: Schreiben und Lesen von Nachrichten in einem Datenflussblock](how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Veranschaulicht, wie Nachrichten in ein <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>-Objekt geschrieben und daraus gelesen werden.|  
|[How to: Implementieren eines Producer-Consumer-Musters](how-to-implement-a-producer-consumer-dataflow-pattern.md)|Beschreibt, wie mit dem Datenflussmodell ein Producer-Consumer-Muster implementiert wird, bei dem der Producer Nachrichten an einen Datenflussblock sendet und der Consumer Nachrichten aus diesem Block liest.|  
|[How to: Ausführen einer Aktion, wenn ein Datenflussblock Daten empfängt](how-to-perform-action-when-a-dataflow-block-receives-data.md)|Beschreibt, wie Delegaten für die Ausführungsdatenflussblocktypen <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> und <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> bereitgestellt werden.|  
|[Exemplarische Vorgehensweise: Erstellen einer Datenflusspipeline](walkthrough-creating-a-dataflow-pipeline.md)|Beschreibt, wie eine Datenflusspipeline erstellt wird, die Text aus dem Web herunterlädt und Vorgänge für diesen Text ausführt.|  
|[How to: Aufheben der Verknüpfungen von Datenflussblöcken](how-to-unlink-dataflow-blocks.md)|Veranschaulicht, wie mit der <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A>-Methode die Verknüpfung zwischen einem Zielblock und der zugehörigen Quelle aufgelöst wird, nachdem die Quelle dem Ziel eine Nachricht anbietet.|  
|[Exemplarische Vorgehensweise: Verwenden von Dataflow in einer Windows Forms-Anwendung](walkthrough-using-dataflow-in-a-windows-forms-application.md)|Veranschaulicht, wie ein Netzwerk von Datenflussblöcken erstellt wird, die eine Bildverarbeitung in einer Windows Forms-Anwendung durchführen.|  
|[How to: Abbrechen eines Datenflussblocks](how-to-cancel-a-dataflow-block.md)|Veranschaulicht die Verwendung von Abbrüchen in einer Windows Forms-Anwendung.|  
|[How to: Verwenden von JoinBlock zum Lesen aus mehreren Quellen](how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Erläutert die Verwendung der <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>-Klasse, um einen Vorgang durchzuführen, wenn Daten aus mehreren Quellen zur Verfügung stehen, sowie die Verwendung des nicht gierigen Modus, sodass mehrere Gruppierungsblöcke eine Datenquelle effizienter gemeinsam verwenden können.|  
|[How to: Festlegen des Parallelitätsgrads in einem Datenflussblock](how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Beschreibt, wie die <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A>-Eigenschaft festgelegt wird, damit ein Ausführungsdatenflussblock mehrere Nachrichten gleichzeitig verarbeiten kann.|  
|[How to: Angeben eines Taskplaners in einem Datenflussblock](how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Veranschaulicht, wie ein bestimmter Aufgabenplaner zugeordnet wird, wenn Sie Datenfluss in Ihrer Anwendung verwenden.|  
|[Exemplarische Vorgehensweise: Effizienzverbesserung durch Verwendung von BatchBlock und BatchedJoinBlock](walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Beschreibt, wie mit der <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>-Klasse die Effizienz von Datenbankeinfügevorgängen verbessert wird und wie mit der <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>-Klasse sowohl die Ergebnisse als auch Ausnahmen erfasst werden, die auftreten, während das Programm aus einer Datenbank liest.|  
|[Exemplarische Vorgehensweise: Erstellen eines Datenflussblocktyps](walkthrough-creating-a-custom-dataflow-block-type.md)|Veranschaulicht zwei Möglichkeiten, einen Datenflussblocktyp zu erstellen, der benutzerdefiniertes Verhalten implementiert.|  
|[Task Parallel Library (TPL)](task-parallel-library-tpl.md)|Stellt die TPL vor, eine Bibliothek, die die parallele Programmierung in .NET Framework-Anwendungen vereinfacht.|
