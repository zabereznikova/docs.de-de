---
title: Zuverlässigkeits Regeln (Code Analyse)
description: Erfahren Sie mehr über die Zuverlässigkeits Regeln für die Code Analyse.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.reliabilityrules
helpviewer_keywords:
- rules, reliability
- reliability rules
- managed code analysis rules, reliability rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: a747dd4dcda351a1ddb0f3d069bb7bac895c32f8
ms.sourcegitcommit: 636af37170ae75a11c4f7d1ecd770820e7dfe7bd
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/07/2020
ms.locfileid: "96591773"
---
# <a name="reliability-rules"></a><span data-ttu-id="9515f-103">Zuverlässigkeitsregeln</span><span class="sxs-lookup"><span data-stu-id="9515f-103">Reliability rules</span></span>

<span data-ttu-id="9515f-104">Zuverlässigkeits Regeln unterstützen die Zuverlässigkeit von Bibliotheken und Anwendungen, z. b. die korrekte Arbeitsspeicher-und Thread Verwendung</span><span class="sxs-lookup"><span data-stu-id="9515f-104">Reliability rules support library and application reliability, such as correct memory and thread usage.</span></span> <span data-ttu-id="9515f-105">Die Zuverlässigkeits Regeln umfassen Folgendes:</span><span class="sxs-lookup"><span data-stu-id="9515f-105">The reliability rules include:</span></span>

|<span data-ttu-id="9515f-106">Regel</span><span class="sxs-lookup"><span data-stu-id="9515f-106">Rule</span></span>|<span data-ttu-id="9515f-107">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="9515f-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="9515f-108">CA2000: Objekte verwerfen, bevor Bereich verloren geht.</span><span class="sxs-lookup"><span data-stu-id="9515f-108">CA2000: Dispose objects before losing scope</span></span>](ca2000.md)|<span data-ttu-id="9515f-109">Da eine Ausnahme auftreten kann, durch die die Ausführung eines Objektfinalizers verhindert wird, sollte das Objekt explizit verworfen werden, bevor sich sämtliche Verweise auf dieses außerhalb des Bereichs befinden.</span><span class="sxs-lookup"><span data-stu-id="9515f-109">Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope.</span></span>|
|[<span data-ttu-id="9515f-110">CA2002: Auf Objekten mit schwacher Identität nicht sperren.</span><span class="sxs-lookup"><span data-stu-id="9515f-110">CA2002: Do not lock on objects with weak identity</span></span>](ca2002.md)|<span data-ttu-id="9515f-111">Ein Objekt hat eine schwache Identität, wenn ein Zugriff darauf über Grenzen von Anwendungsdomänen hinweg möglich ist.</span><span class="sxs-lookup"><span data-stu-id="9515f-111">An object is said to have a weak identity when it can be directly accessed across application domain boundaries.</span></span> <span data-ttu-id="9515f-112">Ein Thread, der eine Sperre für ein Objekt zu erhalten versucht, das über eine schwache Identität verfügt, kann durch einen zweiten Thread in einer anderen Anwendungsdomäne blockiert werden, der eine Sperre für das gleiche Objekt besitzt.</span><span class="sxs-lookup"><span data-stu-id="9515f-112">A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</span></span>|
|[<span data-ttu-id="9515f-113">CA2007: Eine Aufgabe nicht direkt abwarten</span><span class="sxs-lookup"><span data-stu-id="9515f-113">CA2007: Do not directly await a Task</span></span>](ca2007.md)|<span data-ttu-id="9515f-114">Eine asynchrone Methode [erwartet](../../../csharp/language-reference/operators/await.md) <xref:System.Threading.Tasks.Task> direkt ein.</span><span class="sxs-lookup"><span data-stu-id="9515f-114">An asynchronous method [awaits](../../../csharp/language-reference/operators/await.md) a <xref:System.Threading.Tasks.Task> directly.</span></span>|
|[<span data-ttu-id="9515f-115">CA2008: Keine Tasks ohne Übergabe eines TaskSchedulers erstellen</span><span class="sxs-lookup"><span data-stu-id="9515f-115">CA2008: Do not create tasks without passing a TaskScheduler</span></span>](ca2008.md)|<span data-ttu-id="9515f-116">Ein Task Erstellungs-oder Fortsetzungs Vorgang verwendet eine Methoden Überladung, die keinen <xref:System.Threading.Tasks.TaskScheduler> Parameter angibt.</span><span class="sxs-lookup"><span data-stu-id="9515f-116">A task creation or continuation operation uses a method overload that does not specify a <xref:System.Threading.Tasks.TaskScheduler> parameter.</span></span>|
|[<span data-ttu-id="9515f-117">CA2009: „ToImmutableCollection“ nicht für einen ImmutableCollection-Wert aufrufen.</span><span class="sxs-lookup"><span data-stu-id="9515f-117">CA2009: Do not call ToImmutableCollection on an ImmutableCollection value</span></span>](ca2009.md)|<span data-ttu-id="9515f-118">`ToImmutable` die Methode wurde für eine unveränderliche Auflistung aus dem <xref:System.Collections.Immutable> Namespace unnötig aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="9515f-118">`ToImmutable` method was unnecessarily called on an immutable collection from <xref:System.Collections.Immutable> namespace.</span></span>|
|[<span data-ttu-id="9515f-119">CA2011: Eigenschaft nicht innerhalb ihres Setters zuweisen</span><span class="sxs-lookup"><span data-stu-id="9515f-119">CA2011: Do not assign property within its setter</span></span>](ca2011.md) | <span data-ttu-id="9515f-120">Einer Eigenschaft wurde versehentlich ein Wert innerhalb ihrer eigenen [Set-Zugriffs](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor)Methode zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="9515f-120">A property was accidentally assigned a value within its own [set accessor](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span></span> |
|[<span data-ttu-id="9515f-121">CA2012: Verwenden Sie ValueTasks ordnungsgemäß.</span><span class="sxs-lookup"><span data-stu-id="9515f-121">CA2012: Use ValueTasks correctly</span></span>](ca2012.md) | <span data-ttu-id="9515f-122">Valuetasks, die von Element aufrufen zurückgegeben wurden, sollen direkt gewartet werden.</span><span class="sxs-lookup"><span data-stu-id="9515f-122">ValueTasks returned from member invocations are intended to be directly awaited.</span></span>  <span data-ttu-id="9515f-123">Versucht, eine valuetask mehrmals zu verwenden oder direkt auf das Ergebnis zuzugreifen, bevor es als abgeschlossen bezeichnet wird, kann zu einer Ausnahme oder Beschädigung führen.</span><span class="sxs-lookup"><span data-stu-id="9515f-123">Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.</span></span>  <span data-ttu-id="9515f-124">Das ignorieren einer solchen valuetask ist wahrscheinlich ein Hinweis auf einen Funktionsfehler und kann die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="9515f-124">Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</span></span> |
|[<span data-ttu-id="9515f-125">CA2013: Verwenden Sie ReferenceEquals nicht mit Werttypen.</span><span class="sxs-lookup"><span data-stu-id="9515f-125">CA2013: Do not use ReferenceEquals with value types</span></span>](ca2013.md) | <span data-ttu-id="9515f-126">Beim Vergleichen von Werten mit werden bei <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> objA und objB Werttypen verwendet, bevor Sie an die-Methode übermittelt werden <xref:System.Object.ReferenceEquals%2A> .</span><span class="sxs-lookup"><span data-stu-id="9515f-126">When comparing values using <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>, if objA and objB are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="9515f-127">Dies bedeutet, dass auch dann, wenn objA und objB dieselbe Instanz eines Werttyps darstellen, die <xref:System.Object.ReferenceEquals%2A> Methode trotzdem false zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="9515f-127">This means that even if both objA and objB represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns false.</span></span> |
|[<span data-ttu-id="9515f-128">CA2014: Verwenden Sie stackzuweisung nicht in Schleifen.</span><span class="sxs-lookup"><span data-stu-id="9515f-128">CA2014: Do not use stackalloc in loops.</span></span>](ca2014.md) | <span data-ttu-id="9515f-129">Der von stackzugewiesc zugewiesene Stapel Speicher wird nur am Ende des Aufruf der aktuellen Methode freigegeben.</span><span class="sxs-lookup"><span data-stu-id="9515f-129">Stack space allocated by a stackalloc is only released at the end of the current method's invocation.</span></span>  <span data-ttu-id="9515f-130">Die Verwendung in einer-Schleife kann zu unbegrenzten Stapel Vergrößerung und letztlichen Stapelüberlauf Bedingungen führen.</span><span class="sxs-lookup"><span data-stu-id="9515f-130">Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</span></span> |
|[<span data-ttu-id="9515f-131">CA2015: Finalizer nicht für Typen definieren, die von memorymanager &lt; T abgeleitet sind&gt;</span><span class="sxs-lookup"><span data-stu-id="9515f-131">CA2015: Do not define finalizers for types derived from MemoryManager&lt;T&gt;</span></span>](ca2015.md) | <span data-ttu-id="9515f-132">Durch das Hinzufügen eines Finalizers zu einem von abgeleiteten Typ <xref:System.Buffers.MemoryManager%601> kann der Speicher freigegeben werden, während er noch von einem verwendet wird <xref:System.Span%601> .</span><span class="sxs-lookup"><span data-stu-id="9515f-132">Adding a finalizer to a type derived from <xref:System.Buffers.MemoryManager%601> may permit memory to be freed while it is still in use by a <xref:System.Span%601>.</span></span> |
|[<span data-ttu-id="9515f-133">CA2016: Parameter "CancellationToken" an Methoden weiterleiten, die diesen Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="9515f-133">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>](ca2016.md) | <span data-ttu-id="9515f-134">Leiten Sie den- `CancellationToken` Parameter an Methoden weiter, die einen annehmen, um sicherzustellen, dass die Vorgangs Abbruch Benachrichtigungen ordnungsgemäß weitergegeben werden, oder übergeben Sie `CancellationToken.None` explizit, um anzugeben, dass das Token absichtlich nicht</span><span class="sxs-lookup"><span data-stu-id="9515f-134">Forward the `CancellationToken` parameter to methods that take one to ensure the operation cancellation notifications gets properly propagated, or pass in `CancellationToken.None` explicitly to indicate intentionally not propagating the token.</span></span> |
