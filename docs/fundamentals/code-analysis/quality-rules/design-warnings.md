---
title: Entwurfs Regeln (Code Analyse)
description: Erfahren Sie mehr über die Entwurfs Regeln für die Code Analyse.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 7b49403b1aa3d48008e6f7448ab0ed5a84468373
ms.sourcegitcommit: 45c7148f2483db2501c1aa696ab6ed2ed8cb71b2
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 12/08/2020
ms.locfileid: "96851528"
---
# <a name="design-rules"></a>Entwurfsregeln

Entwurfs Regeln unterstützen die Einhaltung der [.NET Framework Entwurfs Richtlinien](../../../standard/design-guidelines/index.md).

## <a name="in-this-section"></a>In diesem Abschnitt

| Regel | Beschreibung |
| - | - |
| [CA1000: Statische Member nicht in generischen Typen deklarieren.](ca1000.md) | Wenn ein statischer Member eines generischen Typs aufgerufen wird, muss das Typargument für den Typ angegeben werden. Wenn ein generischer Instanzmember, der keine Unterstützung für Rückschlüsse bietet, aufgerufen wird, muss das Typargument für den Member angegeben werden. In diesen beiden Fällen ist die Syntax zum Angeben des Typarguments unterschiedlich und leicht zu verwechseln. |
| [CA1001: Typen, die löschbare Felder besitzen, müssen gelöscht werden können.](ca1001.md) | Eine Klasse deklariert und implementiert ein Instanzfeld, das ein System. iverwerfbarer Typ ist, und die Klasse implementiert iverwerfnicht. Eine Klasse, die ein IDisposable-Feld deklariert, besitzt indirekt eine nicht verwaltete Ressource und sollte die IDisposable-Schnittstelle implementieren. |
| [CA1002: Generische Listen nicht verfügbar machen.](ca1002.md) | System. Collections. Generic. List< (of \<(T> ) >) ist eine generische Sammlung, die für Leistung und nicht Vererbung konzipiert ist. Daher enthält List keine virtuellen Member. Stattdessen sollten die generischen Auflistungen, die im Hinblick auf die Vererbung entworfen wurden, verfügbar gemacht werden. |
| [CA1003: Generische Ereignishandlerinstanzen verwenden.](ca1003.md) | Ein Typ enthält einen Delegaten, der "void" zurückgibt, dessen Signatur zwei Parameter enthält (das erste Objekt und das zweite einen Typ, der EventArgs zugewiesen werden kann), und die enthaltende Assembly ist .NET Framework 2,0. |
| [CA1005: Übermäßige Anzahl von Parametern in generischen Typen vermeiden.](ca1005.md) | Je mehr Typparameter ein generischer Typ enthält, desto schwieriger ist es, zu wissen und zu behalten, was die einzelnen Typparameter darstellen. Es ist in der Regel offensichtlich mit einem Typparameter, wie in der Liste \<T> , und in bestimmten Fällen mit zwei Typparametern, wie im Wörterbuch \<TKey, TValue> . Mehr als zwei Typparameter hingegen bereiten den meisten Benutzern Schwierigkeiten. |
| [CA1008: Enumerationen müssen einen Wert von 0 (null) aufweisen.](ca1008.md) | Der Standardwert einer nicht initialisierten Enumeration ist ebenso wie der anderer Werttypen 0 (null). Eine nicht-Flags-Enumeration sollte einen Member mit dem Wert 0 (null) definieren, sodass der Standardwert ein gültiger Wert der-Enumeration ist. Wenn eine Enumeration, auf die FlagsAttribute angewendet wird, einen Member mit dem Wert 0 (null) definiert, sollte dieser den Namen "None" haben, um anzugeben, dass in der Enumeration keine Werte festgelegt wurden. |
| [CA1010: Sammlungen müssen eine generische Schnittstelle implementieren.](ca1010.md) | Um die Verwendbarkeit einer Auflistung zu erweitern, implementieren Sie eine der generischen Auflistungsschnittstellen. Anschließend kann die Auflistung zum Auffüllen generischer Auflistungstypen verwendet werden. |
| [CA1012: Abstrakte Typen dürfen keine Konstruktoren aufweisen.](ca1012.md) | Konstruktoren von abstrakten Datentypen können nur von abgeleiteten Typen aufgerufen werden. Da öffentliche Konstruktoren Instanzen eines Typs erstellen und Sie keine Instanzen eines abstrakten Datentyps erstellen können, ist ein abstrakter Datentyp mit einem öffentlichen Konstruktor fehlerhaft konzipiert. |
| [CA1014: Assemblys mit CLSCompliantAttribute markieren.](ca1014.md) | In der Common Language Specification (CLS) sind Benennungseinschränkungen, Datentypen und Regeln definiert, denen Assemblys entsprechen müssen, wenn sie in verschiedenen Programmiersprachen verwendet werden sollen. Ein guter Entwurf bedeutet, dass alle Assemblys mit CLSCompliantAttribute explizit die CLS-Konformität angeben. Wenn das Attribut in einer Assembly nicht vorhanden ist, ist die Assembly nicht kompatibel. |
| [CA1016: Assemblys mit AssemblyVersionAttribute markieren.](ca1016.md) | .NET verwendet die Versionsnummer zur eindeutigen Identifizierung einer Assembly und zum Binden an Typen in Assemblys mit starkem Namen. Die Versionsnummer wird zusammen mit der Versions- und Herausgeberrichtlinie verwendet. Standardmäßig werden Anwendungen nur mit der Assemblyversion ausgeführt, mit der sie erstellt wurden. |
| [CA1017: Assemblys mit ComVisibleAttribute markieren.](ca1017.md) | Das ComVisibleAttribute-Attribut bestimmt, wie COM-Clients auf verwalteten Code zugreifen. Gute Entwurfsprinzipien verlangen, dass die COM-Sichtbarkeit durch Assemblys explizit angegeben wird. Die COM-Sichtbarkeit kann für die gesamte Assembly festgelegt und anschließend für einzelne Typen und Typmember überschrieben werden. Wenn das Attribut fehlt, ist der Inhalt der Assembly für COM-Clients sichtbar. |
| [CA1018: Attribute mit AttributeUsageAttribute markieren.](ca1018.md) | Wenn Sie ein benutzerdefiniertes Attribut definieren, markieren Sie es mithilfe von AttributeUsageAttribute, um anzugeben, an welcher Stelle im Quellcode das benutzerdefinierte Attribut angewendet werden kann. Die Bedeutung und die beabsichtigte Verwendung eines Attributs bestimmen die gültigen Positionen des Attributs im Code. |
| [CA1019: Accessoren für Attributargumente definieren.](ca1019.md) | Attribute können obligatorische Argumente definieren, die angegeben werden müssen, wenn das Attribut auf ein Ziel angewendet wird. Diese Argumente werden auch als positionelle Argumente bezeichnet, da sie bei Attributkonstruktoren als positionelle Parameter angegeben werden. Für jedes obligatorische Argument muss das Attribut außerdem eine entsprechende schreibgeschützte Eigenschaft enthalten, damit der Wert des Arguments zur Ausführungszeit abgerufen werden kann. Attribute können auch optionale Argumente definieren, die auch als benannte Argumente bezeichnet werden. Diese Argumente werden bei Attributkonstruktoren über ihren Namen angegeben und sollten über eine entsprechende Lese-Schreib-Eigenschaft verfügen. |
| [CA1021: out-Parameter vermeiden.](ca1021.md) | Die Übergabe von Typen als Verweis (mit out oder ref) erfordert Erfahrung im Umgang mit Zeigern, Kenntnisse der Unterschiede zwischen Wert- und Verweistypen und Erfahrung im Umgang mit Methoden mit mehreren Rückgabewerten. Außerdem ist der Unterschied zwischen dem out-Parameter und dem ref-Parametern oft unklar. |
| [CA1024: Nach Möglichkeit Eigenschaften verwenden.](ca1024.md) | Eine öffentliche oder geschützte Methode hat einen Namen, der mit "Get" beginnt. Sie nimmt keine Parameter an und gibt einen Wert zurück, bei dem es sich nicht um ein Array handelt. Die Methode ist möglicherweise als Eigenschaft geeignet. |
| [CA1027: Enumerationen mit FlagsAttribute markieren.](ca1027.md) | Eine Enumeration ist ein Werttyp, der einen Satz verwandter benannter Konstanten definiert. Wenden Sie FlagsAttribute auf eine Enumeration an, wenn deren benannte Konstanten sinnvoll kombiniert werden können. |
| [CA1028: Der Enumerationsspeicher sollte Int32 sein.](ca1028.md) | Eine Enumeration ist ein Werttyp, der einen Satz verwandter benannter Konstanten definiert. Standardmäßig wird zum Speichern des konstanten Werts der System.Int32-Datentyp verwendet. Obwohl Sie diesen zugrunde liegenden Typ ändern können, ist er in den meisten Szenarien nicht erforderlich oder nicht empfehlenswert. |
| [CA1030: Nach Möglichkeit Ereignisse verwenden.](ca1030.md) | Diese Regel erkennt Methoden, deren Namen normalerweise für Ereignisse verwendet würden. Wenn eine Methode auf eine klar definierte Zustandsänderung hin aufgerufen wird, sollte die Methode von einem Ereignishandler aufgerufen werden. Objekte, die die Methode aufrufen, sollten Ereignisse auslösen, statt die Methode direkt aufzurufen. |
| [CA1031: Allgemeine Ausnahmetypen nicht auffangen.](ca1031.md) | Allgemeine Ausnahmen sollten nicht abgefangen werden. Fangen Sie eine spezifischere Ausnahme ab, oder lösen Sie die allgemeine Ausnahme erneut als letzte Anweisung im catch-Block aus. |
| [CA1032: Standardausnahmekonstruktoren implementieren.](ca1032.md) | Falls nicht der vollständige Satz von Konstruktoren angegeben wird, wird eine ordnungsgemäße Behandlung von Ausnahmen unter Umständen erschwert. |
| [CA1033: Schnittstellenmethoden sollten von untergeordneten Typen aufgerufen werden können.](ca1033.md) | Ein unversiegelter, extern sichtbarer Typ gibt eine explizite Methodenimplementierung einer öffentlichen Schnittstelle an und gibt keine alternative extern sichtbare Methode mit dem gleichen Namen an. |
| [CA1034: Geschachtelte Typen sollten nicht sichtbar sein.](ca1034.md) | Ein geschachtelter Typ ist ein Typ, der innerhalb des Gültigkeitsbereichs eines anderen Typs deklariert ist. Geschachtelte Typen eignen sich für die Kapselung privater Implementierungsdetails der enthaltenden Typen. Bei dieser Verwendungsart sollten geschachtelte Typen nicht extern sichtbar sein. |
| [CA1036: Methoden bei vergleichbaren Typen überschreiben.](ca1036.md) | Ein öffentlicher oder geschützter Typ implementiert die System.IComparable-Schnittstelle. Er überschreibt Object.Equals nicht und überlädt auch nicht den sprachspezifischen Operator für gleich, ungleich, kleiner als und größer als. |
| [CA1040: Leere Schnittstellen vermeiden.](ca1040.md) | Schnittstellen definieren Member, die ein Verhalten oder einen Verwendungsvertrag bereitstellen. Die durch die Schnittstelle beschriebene Funktionalität kann von jedem Typ übernommen werden, unabhängig davon, an welcher Stelle der Typ in der Vererbungshierarchie steht. Ein Typ implementiert eine Schnittstelle, indem er Implementierungen für die Member der Schnittstelle bereitstellt. Eine leere Schnittstelle definiert keine Member. Daher definiert sie keinen Vertrag, der implementiert werden kann. |
| [CA1041: ObsoleteAttribute-Meldung bereitstellen.](ca1041.md) | Ein Typ oder Member wird mit einem System.ObsoleteAttribute-Attribut markiert, dessen ObsoleteAttribute.Message-Eigenschaft nicht angegeben wurde. Wenn ein Typ oder Member, der mithilfe von ObsoleteAttribute markiert ist, kompiliert wird, wird die Message-Eigenschaft des Attributs angezeigt, die dem Benutzerinformationen über den veralteten Typ oder Member übergibt. |
| [CA1043: Ganzzahliges Argument oder Zeichenfolgenargument für Indexer verwenden.](ca1043.md) | Indexer (d. h. indizierte Eigenschaften) sollten ganzzahlige Typen oder Zeichenfolgentypen für den Index verwenden. Diese Typen werden i. d. R. zum Indizieren von Datenstrukturen verwendet und erweitern den Einsatzbereich der Bibliothek. Die Verwendung des Object-Typs sollte auf die Fälle beschränkt werden, in denen der spezielle integrale oder Zeichenfolgentyp zur Entwurfszeit nicht angegeben werden kann. |
| [CA1044: Eigenschaften sollten nicht lesegeschützt sein.](ca1044.md) | Obwohl eine schreibgeschützte Eigenschaft akzeptabel und oft erforderlich ist, verhindern die Entwurfsrichtlinien die Verwendung von Eigenschaften, die nur geschrieben werden können. Wenn ein Benutzer einen Wert festlegen kann, bietet es keinerlei Sicherheitsvorteile, das Lesen und Anzeigen des Werts durch den Benutzer zu sperren. Außerdem kann der Zustand freigegebener Objekte ohne Lesezugriff nicht angezeigt werden, wodurch ihre Nützlichkeit eingeschränkt wird. |
| [CA1045: Typen nicht als Verweis übergeben.](ca1045.md) | Die Übergabe von Typen als Verweis (mit out oder ref) erfordert Erfahrung im Umgang mit Zeigern, Kenntnisse der Unterschiede zwischen Wert- und Verweistypen und Erfahrung im Umgang mit Methoden mit mehreren Rückgabewerten. Entwickler von Bibliotheken für eine breite Zielgruppe sollten nicht davon ausgehen, dass die Benutzer den out-Parameter oder den ref-Parameter richtig verwenden können. |
| [CA1046: Gleichheitsoperator für Referenztypen nicht überladen.](ca1046.md) | Für Verweistypen ist die Standardimplementierung des Gleichheitsoperators fast immer zutreffend. Standardmäßig sind zwei Verweise nur dann gleich, wenn sie auf dasselbe Objekt zeigen. |
| [CA1047: Geschützte Member in versiegelten Typen nicht deklarieren.](ca1047.md) | Typen deklarieren geschützte Member, damit erbende Typen auf den Member zugreifen oder diesen überschreiben können. Per Definition kann von versiegelten Typen nicht geerbt werden. Dies bedeutet, dass geschützte Methoden für versiegelte Typen nicht aufgerufen werden können. |
| [CA1050: Typen in Namespaces deklarieren.](ca1050.md) | Typen werden in Namespaces deklariert, um Namenskonflikte zu verhindern und um verwandte Typen in einer Objekthierarchie zu organisieren. |
| [CA1051: Sichtbare Instanzfelder nicht deklarieren.](ca1051.md) | Ein Feld sollte primär als Implementierungsdetail verwendet werden. Felder sollten privat oder intern sein und durch die Verwendung von Eigenschaften verfügbar gemacht werden. |
| [CA1052: Statische Haltertypen sollten versiegelt sein.](ca1052.md) | Ein öffentlicher oder geschützter Typ enthält nur statische Member und wird nicht mit dem sealed (c#)-oder notvererable (Visual Basic)-Modifizierer deklariert. Ein Typ, der nicht geerbt werden soll, sollte mit dem sealed-Modifizierer markiert werden, um seine Verwendung als Basistyp zu verhindern. |
| [CA1053: Statische Haltertypen sollten keine Konstruktoren aufweisen.](ca1053.md) | Ein öffentlicher oder verschachtelter öffentlicher Typ deklariert nur statische Member und verfügt über einen öffentlichen oder geschützten Standardkonstruktor. Der Konstruktor ist überflüssig, da zum Aufrufen statischer Member keine Instanz des Typs erforderlich ist. Die Zeichenfolgenüberladung sollte die URI-Überladung aus Sicherheitsgründen mit dem Zeichenfolgenargument aufrufen. |
| [CA1054: URI-Parameter dürfen keine Zeichenfolgen sein.](ca1054.md) | Wenn eine Methode eine Zeichenfolgendarstellung eines URIs annimmt, sollte eine entsprechende Überladung angegeben werden, die eine Instanz der URI-Klasse annimmt, die diese Dienste auf sichere Weise bereitstellt. |
| [CA1055: URI-Rückgabewerte dürfen keine Zeichenfolgen sein.](ca1055.md) | Diese Regel geht davon aus, dass die Methode einen URI zurückgibt. Eine Zeichenfolgendarstellung eines URIs ist anfällig für Analyse- und Codierungsfehler und kann zu Sicherheitsmängeln führen. Die System.Uri-Klasse stellt diese Dienste auf sichere Weise bereit. |
| [CA1056: URI-Eigenschaften dürfen keine Zeichenfolgen sein.](ca1056.md) | Diese Regel setzt voraus, dass die-Eigenschaft einen URI darstellt. Eine Zeichenfolgendarstellung eines URIs ist anfällig für Analyse- und Codierungsfehler und kann zu Sicherheitsmängeln führen. Die System.Uri-Klasse stellt diese Dienste auf sichere Weise bereit. |
| [CA1058: Typen sollten bestimmte Basistypen nicht erweitern.](ca1058.md) | Ein extern sichtbarer Typ erweitert bestimmte Basistypen. Verwenden Sie eine der Alternativen. |
| [CA1060: P/Aufrufe in die NativeMethods-Klasse verschieben](ca1060.md) | Platt Form Aufruf Methoden, z. b. diejenigen, die mit der-Methode oder der-Methode gekennzeichnet sind <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> , die mit dem Declare-Schlüsselwort in Visual Basic definiert ist, greifen Diese Methoden sollten der Klasse NativeMethods, SafeNativeMethods oder UnsafeNativeMethods angehören. |
| [CA1061: Basisklassenmethoden nicht ausblenden.](ca1061.md) | Eine Methode in einem Basistyp wird durch eine Methode mit identischem Namen in einem abgeleiteten Typ verdeckt, wenn die Parametersignatur der abgeleiteten Methode sich nur hinsichtlich der Typen unterscheidet, die schwächer abgeleitet sind als die entsprechenden Typen in der Parametersignatur der Basismethode. |
| [CA1062: Argumente von öffentlichen Methoden validieren.](ca1062.md) | Alle an extern sichtbare Methoden übergebenen Verweisargumente sollten auf NULL überprüft werden. |
| [CA1063: IDisposable korrekt implementieren.](ca1063.md) | Alle IDisposable-Typen müssen das Dispose-Muster korrekt implementieren. |
| [CA1064: Ausnahmen sollten öffentlich sein.](ca1064.md) | Eine interne Ausnahme ist nur innerhalb ihres eigenen internen Bereichs sichtbar. Nachdem die Ausnahme den internen Bereich verlassen hat, kann nur die Basisausnahme zum Abfangen der Ausnahme verwendet werden. Wenn die interne Ausnahme von <xref:System.Exception?displayProperty=fullName> , oder geerbt wird <xref:System.SystemException?displayProperty=fullName> <xref:System.ApplicationException?displayProperty=fullName> , verfügt der externe Code nicht über genügend Informationen, um zu wissen, was mit der Ausnahme zu tun ist. |
| [CA1065: Keine Ausnahmen an unerwarteten Speicherorten auslösen.](ca1065.md) | Eine Methode, von der das Auslösen von Ausnahmen nicht erwartet wird, löst eine Ausnahme aus. |
| [CA1066: „IEquatable“ beim Außerkraftsetzen von „Equals“ implementieren](ca1066.md) | Ein Werttyp überschreibt die- <xref:System.Object.Equals%2A> Methode, implementiert jedoch nicht <xref:System.IEquatable%601> . |
| [CA1067: „Object.Equals(object)“ bei Implementierung von „IEquatable“ außer Kraft setzen](ca1067.md) | Ein Typ implementiert <xref:System.IEquatable%601> , aber überschreibt die- <xref:System.Object.Equals%2A> Methode nicht. |
| [CA1068: CancellationToken-Parameter müssen zuletzt aufgeführt werden.](ca1068.md) | Eine Methode verfügt über einen CancellationToken-Parameter, der nicht der letzte Parameter ist. |
| [CA1069: Enumerationen dürfen keine doppelten Werte aufweisen.](ca1069.md) | Eine Enumeration verfügt über mehrere Member, denen explizit derselbe Konstante Wert zugewiesen wird. |
| [CA1070: Ereignisfelder dürfen nicht als virtuell deklariert werden.](ca1070.md) | Ein [Feld ähnliches Ereignis](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) wurde als virtuell deklariert. |
| [CA1071: Basis überschreiben. Ist beim Implementieren von IEquatable.](ca1071.md) | Ein abgeleiteter Typ implementiert <xref:System.IEquatable%601> , aber überschreibt die Basisklassen <xref:System.IEquatable%601.Equals%2A> Methode nicht. |
