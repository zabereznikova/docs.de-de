---
title: Entwurfs Regeln (Code Analyse)
description: Erfahren Sie mehr über die Entwurfs Regeln für die Code Analyse.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 7b49403b1aa3d48008e6f7448ab0ed5a84468373
ms.sourcegitcommit: 45c7148f2483db2501c1aa696ab6ed2ed8cb71b2
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 12/08/2020
ms.locfileid: "96851528"
---
# <a name="design-rules"></a><span data-ttu-id="f4702-103">Entwurfsregeln</span><span class="sxs-lookup"><span data-stu-id="f4702-103">Design rules</span></span>

<span data-ttu-id="f4702-104">Entwurfs Regeln unterstützen die Einhaltung der [.NET Framework Entwurfs Richtlinien](../../../standard/design-guidelines/index.md).</span><span class="sxs-lookup"><span data-stu-id="f4702-104">Design rules support adherence to the [.NET Framework Design Guidelines](../../../standard/design-guidelines/index.md).</span></span>

## <a name="in-this-section"></a><span data-ttu-id="f4702-105">In diesem Abschnitt</span><span class="sxs-lookup"><span data-stu-id="f4702-105">In this section</span></span>

| <span data-ttu-id="f4702-106">Regel</span><span class="sxs-lookup"><span data-stu-id="f4702-106">Rule</span></span> | <span data-ttu-id="f4702-107">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="f4702-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="f4702-108">CA1000: Statische Member nicht in generischen Typen deklarieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-108">CA1000: Do not declare static members on generic types</span></span>](ca1000.md) | <span data-ttu-id="f4702-109">Wenn ein statischer Member eines generischen Typs aufgerufen wird, muss das Typargument für den Typ angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-109">When a static member of a generic type is called, the type argument must be specified for the type.</span></span> <span data-ttu-id="f4702-110">Wenn ein generischer Instanzmember, der keine Unterstützung für Rückschlüsse bietet, aufgerufen wird, muss das Typargument für den Member angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-110">When a generic instance member that does not support inference is called, the type argument must be specified for the member.</span></span> <span data-ttu-id="f4702-111">In diesen beiden Fällen ist die Syntax zum Angeben des Typarguments unterschiedlich und leicht zu verwechseln.</span><span class="sxs-lookup"><span data-stu-id="f4702-111">In these two cases, the syntax for specifying the type argument is different and easily confused.</span></span> |
| [<span data-ttu-id="f4702-112">CA1001: Typen, die löschbare Felder besitzen, müssen gelöscht werden können.</span><span class="sxs-lookup"><span data-stu-id="f4702-112">CA1001: Types that own disposable fields should be disposable</span></span>](ca1001.md) | <span data-ttu-id="f4702-113">Eine Klasse deklariert und implementiert ein Instanzfeld, das ein System. iverwerfbarer Typ ist, und die Klasse implementiert iverwerfnicht.</span><span class="sxs-lookup"><span data-stu-id="f4702-113">A class declares and implements an instance field that is a System.IDisposable type and the class does not implement IDisposable.</span></span> <span data-ttu-id="f4702-114">Eine Klasse, die ein IDisposable-Feld deklariert, besitzt indirekt eine nicht verwaltete Ressource und sollte die IDisposable-Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-114">A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</span></span> |
| [<span data-ttu-id="f4702-115">CA1002: Generische Listen nicht verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="f4702-115">CA1002: Do not expose generic lists</span></span>](ca1002.md) | <span data-ttu-id="f4702-116">System. Collections. Generic. List< (of \<(T> ) >) ist eine generische Sammlung, die für Leistung und nicht Vererbung konzipiert ist.</span><span class="sxs-lookup"><span data-stu-id="f4702-116">System.Collections.Generic.List<(Of \<(T>)>) is a generic collection that is designed for performance, not inheritance.</span></span> <span data-ttu-id="f4702-117">Daher enthält List keine virtuellen Member.</span><span class="sxs-lookup"><span data-stu-id="f4702-117">Therefore, List does not contain any virtual members.</span></span> <span data-ttu-id="f4702-118">Stattdessen sollten die generischen Auflistungen, die im Hinblick auf die Vererbung entworfen wurden, verfügbar gemacht werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-118">The generic collections that are designed for inheritance should be exposed instead.</span></span> |
| [<span data-ttu-id="f4702-119">CA1003: Generische Ereignishandlerinstanzen verwenden.</span><span class="sxs-lookup"><span data-stu-id="f4702-119">CA1003: Use generic event handler instances</span></span>](ca1003.md) | <span data-ttu-id="f4702-120">Ein Typ enthält einen Delegaten, der "void" zurückgibt, dessen Signatur zwei Parameter enthält (das erste Objekt und das zweite einen Typ, der EventArgs zugewiesen werden kann), und die enthaltende Assembly ist .NET Framework 2,0.</span><span class="sxs-lookup"><span data-stu-id="f4702-120">A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets .NET Framework 2.0.</span></span> |
| [<span data-ttu-id="f4702-121">CA1005: Übermäßige Anzahl von Parametern in generischen Typen vermeiden.</span><span class="sxs-lookup"><span data-stu-id="f4702-121">CA1005: Avoid excessive parameters on generic types</span></span>](ca1005.md) | <span data-ttu-id="f4702-122">Je mehr Typparameter ein generischer Typ enthält, desto schwieriger ist es, zu wissen und zu behalten, was die einzelnen Typparameter darstellen.</span><span class="sxs-lookup"><span data-stu-id="f4702-122">The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents.</span></span> <span data-ttu-id="f4702-123">Es ist in der Regel offensichtlich mit einem Typparameter, wie in der Liste \<T> , und in bestimmten Fällen mit zwei Typparametern, wie im Wörterbuch \<TKey, TValue> .</span><span class="sxs-lookup"><span data-stu-id="f4702-123">It is usually obvious with one type parameter, as in List\<T>, and in certain cases with two type parameters, as in Dictionary\<TKey, TValue>.</span></span> <span data-ttu-id="f4702-124">Mehr als zwei Typparameter hingegen bereiten den meisten Benutzern Schwierigkeiten.</span><span class="sxs-lookup"><span data-stu-id="f4702-124">However, if more than two type parameters exist, the difficulty becomes too great for most users.</span></span> |
| [<span data-ttu-id="f4702-125">CA1008: Enumerationen müssen einen Wert von 0 (null) aufweisen.</span><span class="sxs-lookup"><span data-stu-id="f4702-125">CA1008: Enums should have zero value</span></span>](ca1008.md) | <span data-ttu-id="f4702-126">Der Standardwert einer nicht initialisierten Enumeration ist ebenso wie der anderer Werttypen 0 (null).</span><span class="sxs-lookup"><span data-stu-id="f4702-126">The default value of an uninitialized enumeration, just as other value types, is zero.</span></span> <span data-ttu-id="f4702-127">Eine nicht-Flags-Enumeration sollte einen Member mit dem Wert 0 (null) definieren, sodass der Standardwert ein gültiger Wert der-Enumeration ist.</span><span class="sxs-lookup"><span data-stu-id="f4702-127">A nonflags attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration.</span></span> <span data-ttu-id="f4702-128">Wenn eine Enumeration, auf die FlagsAttribute angewendet wird, einen Member mit dem Wert 0 (null) definiert, sollte dieser den Namen "None" haben, um anzugeben, dass in der Enumeration keine Werte festgelegt wurden.</span><span class="sxs-lookup"><span data-stu-id="f4702-128">If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration.</span></span> |
| [<span data-ttu-id="f4702-129">CA1010: Sammlungen müssen eine generische Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-129">CA1010: Collections should implement generic interface</span></span>](ca1010.md) | <span data-ttu-id="f4702-130">Um die Verwendbarkeit einer Auflistung zu erweitern, implementieren Sie eine der generischen Auflistungsschnittstellen.</span><span class="sxs-lookup"><span data-stu-id="f4702-130">To broaden the usability of a collection, implement one of the generic collection interfaces.</span></span> <span data-ttu-id="f4702-131">Anschließend kann die Auflistung zum Auffüllen generischer Auflistungstypen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-131">Then the collection can be used to populate generic collection types.</span></span> |
| [<span data-ttu-id="f4702-132">CA1012: Abstrakte Typen dürfen keine Konstruktoren aufweisen.</span><span class="sxs-lookup"><span data-stu-id="f4702-132">CA1012: Abstract types should not have constructors</span></span>](ca1012.md) | <span data-ttu-id="f4702-133">Konstruktoren von abstrakten Datentypen können nur von abgeleiteten Typen aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-133">Constructors on abstract types can be called only by derived types.</span></span> <span data-ttu-id="f4702-134">Da öffentliche Konstruktoren Instanzen eines Typs erstellen und Sie keine Instanzen eines abstrakten Datentyps erstellen können, ist ein abstrakter Datentyp mit einem öffentlichen Konstruktor fehlerhaft konzipiert.</span><span class="sxs-lookup"><span data-stu-id="f4702-134">Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</span></span> |
| [<span data-ttu-id="f4702-135">CA1014: Assemblys mit CLSCompliantAttribute markieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-135">CA1014: Mark assemblies with CLSCompliantAttribute</span></span>](ca1014.md) | <span data-ttu-id="f4702-136">In der Common Language Specification (CLS) sind Benennungseinschränkungen, Datentypen und Regeln definiert, denen Assemblys entsprechen müssen, wenn sie in verschiedenen Programmiersprachen verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="f4702-136">The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages.</span></span> <span data-ttu-id="f4702-137">Ein guter Entwurf bedeutet, dass alle Assemblys mit CLSCompliantAttribute explizit die CLS-Konformität angeben.</span><span class="sxs-lookup"><span data-stu-id="f4702-137">Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute.</span></span> <span data-ttu-id="f4702-138">Wenn das Attribut in einer Assembly nicht vorhanden ist, ist die Assembly nicht kompatibel.</span><span class="sxs-lookup"><span data-stu-id="f4702-138">If this attribute is not present on an assembly, the assembly is not compliant.</span></span> |
| [<span data-ttu-id="f4702-139">CA1016: Assemblys mit AssemblyVersionAttribute markieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-139">CA1016: Mark assemblies with AssemblyVersionAttribute</span></span>](ca1016.md) | <span data-ttu-id="f4702-140">.NET verwendet die Versionsnummer zur eindeutigen Identifizierung einer Assembly und zum Binden an Typen in Assemblys mit starkem Namen.</span><span class="sxs-lookup"><span data-stu-id="f4702-140">.NET uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies.</span></span> <span data-ttu-id="f4702-141">Die Versionsnummer wird zusammen mit der Versions- und Herausgeberrichtlinie verwendet.</span><span class="sxs-lookup"><span data-stu-id="f4702-141">The version number is used together with version and publisher policy.</span></span> <span data-ttu-id="f4702-142">Standardmäßig werden Anwendungen nur mit der Assemblyversion ausgeführt, mit der sie erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="f4702-142">By default, applications run only with the assembly version with which they were built.</span></span> |
| [<span data-ttu-id="f4702-143">CA1017: Assemblys mit ComVisibleAttribute markieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-143">CA1017: Mark assemblies with ComVisibleAttribute</span></span>](ca1017.md) | <span data-ttu-id="f4702-144">Das ComVisibleAttribute-Attribut bestimmt, wie COM-Clients auf verwalteten Code zugreifen.</span><span class="sxs-lookup"><span data-stu-id="f4702-144">ComVisibleAttribute determines how COM clients access managed code.</span></span> <span data-ttu-id="f4702-145">Gute Entwurfsprinzipien verlangen, dass die COM-Sichtbarkeit durch Assemblys explizit angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f4702-145">Good design dictates that assemblies explicitly indicate COM visibility.</span></span> <span data-ttu-id="f4702-146">Die COM-Sichtbarkeit kann für die gesamte Assembly festgelegt und anschließend für einzelne Typen und Typmember überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-146">COM visibility can be set for the whole assembly and then overridden for individual types and type members.</span></span> <span data-ttu-id="f4702-147">Wenn das Attribut fehlt, ist der Inhalt der Assembly für COM-Clients sichtbar.</span><span class="sxs-lookup"><span data-stu-id="f4702-147">If this attribute is not present, the contents of the assembly are visible to COM clients.</span></span> |
| [<span data-ttu-id="f4702-148">CA1018: Attribute mit AttributeUsageAttribute markieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-148">CA1018: Mark attributes with AttributeUsageAttribute</span></span>](ca1018.md) | <span data-ttu-id="f4702-149">Wenn Sie ein benutzerdefiniertes Attribut definieren, markieren Sie es mithilfe von AttributeUsageAttribute, um anzugeben, an welcher Stelle im Quellcode das benutzerdefinierte Attribut angewendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="f4702-149">When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied.</span></span> <span data-ttu-id="f4702-150">Die Bedeutung und die beabsichtigte Verwendung eines Attributs bestimmen die gültigen Positionen des Attributs im Code.</span><span class="sxs-lookup"><span data-stu-id="f4702-150">The meaning and intended usage of an attribute will determine its valid locations in code.</span></span> |
| [<span data-ttu-id="f4702-151">CA1019: Accessoren für Attributargumente definieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-151">CA1019: Define accessors for attribute arguments</span></span>](ca1019.md) | <span data-ttu-id="f4702-152">Attribute können obligatorische Argumente definieren, die angegeben werden müssen, wenn das Attribut auf ein Ziel angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="f4702-152">Attributes can define mandatory arguments that must be specified when you apply the attribute to a target.</span></span> <span data-ttu-id="f4702-153">Diese Argumente werden auch als positionelle Argumente bezeichnet, da sie bei Attributkonstruktoren als positionelle Parameter angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-153">These are also known as positional arguments because they are supplied to attribute constructors as positional parameters.</span></span> <span data-ttu-id="f4702-154">Für jedes obligatorische Argument muss das Attribut außerdem eine entsprechende schreibgeschützte Eigenschaft enthalten, damit der Wert des Arguments zur Ausführungszeit abgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="f4702-154">For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time.</span></span> <span data-ttu-id="f4702-155">Attribute können auch optionale Argumente definieren, die auch als benannte Argumente bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-155">Attributes can also define optional arguments, which are also known as named arguments.</span></span> <span data-ttu-id="f4702-156">Diese Argumente werden bei Attributkonstruktoren über ihren Namen angegeben und sollten über eine entsprechende Lese-Schreib-Eigenschaft verfügen.</span><span class="sxs-lookup"><span data-stu-id="f4702-156">These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</span></span> |
| [<span data-ttu-id="f4702-157">CA1021: out-Parameter vermeiden.</span><span class="sxs-lookup"><span data-stu-id="f4702-157">CA1021: Avoid out parameters</span></span>](ca1021.md) | <span data-ttu-id="f4702-158">Die Übergabe von Typen als Verweis (mit out oder ref) erfordert Erfahrung im Umgang mit Zeigern, Kenntnisse der Unterschiede zwischen Wert- und Verweistypen und Erfahrung im Umgang mit Methoden mit mehreren Rückgabewerten.</span><span class="sxs-lookup"><span data-stu-id="f4702-158">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="f4702-159">Außerdem ist der Unterschied zwischen dem out-Parameter und dem ref-Parametern oft unklar.</span><span class="sxs-lookup"><span data-stu-id="f4702-159">Also, the difference between out and ref parameters is not widely understood.</span></span> |
| [<span data-ttu-id="f4702-160">CA1024: Nach Möglichkeit Eigenschaften verwenden.</span><span class="sxs-lookup"><span data-stu-id="f4702-160">CA1024: Use properties where appropriate</span></span>](ca1024.md) | <span data-ttu-id="f4702-161">Eine öffentliche oder geschützte Methode hat einen Namen, der mit "Get" beginnt. Sie nimmt keine Parameter an und gibt einen Wert zurück, bei dem es sich nicht um ein Array handelt.</span><span class="sxs-lookup"><span data-stu-id="f4702-161">A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array.</span></span> <span data-ttu-id="f4702-162">Die Methode ist möglicherweise als Eigenschaft geeignet.</span><span class="sxs-lookup"><span data-stu-id="f4702-162">The method might be a good candidate to become a property.</span></span> |
| [<span data-ttu-id="f4702-163">CA1027: Enumerationen mit FlagsAttribute markieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-163">CA1027: Mark enums with FlagsAttribute</span></span>](ca1027.md) | <span data-ttu-id="f4702-164">Eine Enumeration ist ein Werttyp, der einen Satz verwandter benannter Konstanten definiert.</span><span class="sxs-lookup"><span data-stu-id="f4702-164">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="f4702-165">Wenden Sie FlagsAttribute auf eine Enumeration an, wenn deren benannte Konstanten sinnvoll kombiniert werden können.</span><span class="sxs-lookup"><span data-stu-id="f4702-165">Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</span></span> |
| [<span data-ttu-id="f4702-166">CA1028: Der Enumerationsspeicher sollte Int32 sein.</span><span class="sxs-lookup"><span data-stu-id="f4702-166">CA1028: Enum storage should be Int32</span></span>](ca1028.md) | <span data-ttu-id="f4702-167">Eine Enumeration ist ein Werttyp, der einen Satz verwandter benannter Konstanten definiert.</span><span class="sxs-lookup"><span data-stu-id="f4702-167">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="f4702-168">Standardmäßig wird zum Speichern des konstanten Werts der System.Int32-Datentyp verwendet.</span><span class="sxs-lookup"><span data-stu-id="f4702-168">By default, the System.Int32 data type is used to store the constant value.</span></span> <span data-ttu-id="f4702-169">Obwohl Sie diesen zugrunde liegenden Typ ändern können, ist er in den meisten Szenarien nicht erforderlich oder nicht empfehlenswert.</span><span class="sxs-lookup"><span data-stu-id="f4702-169">Even though you can change this underlying type, it is not required or recommended for most scenarios.</span></span> |
| [<span data-ttu-id="f4702-170">CA1030: Nach Möglichkeit Ereignisse verwenden.</span><span class="sxs-lookup"><span data-stu-id="f4702-170">CA1030: Use events where appropriate</span></span>](ca1030.md) | <span data-ttu-id="f4702-171">Diese Regel erkennt Methoden, deren Namen normalerweise für Ereignisse verwendet würden.</span><span class="sxs-lookup"><span data-stu-id="f4702-171">This rule detects methods that have names that ordinarily would be used for events.</span></span> <span data-ttu-id="f4702-172">Wenn eine Methode auf eine klar definierte Zustandsänderung hin aufgerufen wird, sollte die Methode von einem Ereignishandler aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-172">If a method is called in response to a clearly defined state change, the method should be invoked by an event handler.</span></span> <span data-ttu-id="f4702-173">Objekte, die die Methode aufrufen, sollten Ereignisse auslösen, statt die Methode direkt aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="f4702-173">Objects that call the method should raise events instead of calling the method directly.</span></span> |
| [<span data-ttu-id="f4702-174">CA1031: Allgemeine Ausnahmetypen nicht auffangen.</span><span class="sxs-lookup"><span data-stu-id="f4702-174">CA1031: Do not catch general exception types</span></span>](ca1031.md) | <span data-ttu-id="f4702-175">Allgemeine Ausnahmen sollten nicht abgefangen werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-175">General exceptions should not be caught.</span></span> <span data-ttu-id="f4702-176">Fangen Sie eine spezifischere Ausnahme ab, oder lösen Sie die allgemeine Ausnahme erneut als letzte Anweisung im catch-Block aus.</span><span class="sxs-lookup"><span data-stu-id="f4702-176">Catch a more-specific exception, or rethrow the general exception as the last statement in the catch block.</span></span> |
| [<span data-ttu-id="f4702-177">CA1032: Standardausnahmekonstruktoren implementieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-177">CA1032: Implement standard exception constructors</span></span>](ca1032.md) | <span data-ttu-id="f4702-178">Falls nicht der vollständige Satz von Konstruktoren angegeben wird, wird eine ordnungsgemäße Behandlung von Ausnahmen unter Umständen erschwert.</span><span class="sxs-lookup"><span data-stu-id="f4702-178">Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</span></span> |
| [<span data-ttu-id="f4702-179">CA1033: Schnittstellenmethoden sollten von untergeordneten Typen aufgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="f4702-179">CA1033: Interface methods should be callable by child types</span></span>](ca1033.md) | <span data-ttu-id="f4702-180">Ein unversiegelter, extern sichtbarer Typ gibt eine explizite Methodenimplementierung einer öffentlichen Schnittstelle an und gibt keine alternative extern sichtbare Methode mit dem gleichen Namen an.</span><span class="sxs-lookup"><span data-stu-id="f4702-180">An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</span></span> |
| [<span data-ttu-id="f4702-181">CA1034: Geschachtelte Typen sollten nicht sichtbar sein.</span><span class="sxs-lookup"><span data-stu-id="f4702-181">CA1034: Nested types should not be visible</span></span>](ca1034.md) | <span data-ttu-id="f4702-182">Ein geschachtelter Typ ist ein Typ, der innerhalb des Gültigkeitsbereichs eines anderen Typs deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="f4702-182">A nested type is a type that is declared in the scope of another type.</span></span> <span data-ttu-id="f4702-183">Geschachtelte Typen eignen sich für die Kapselung privater Implementierungsdetails der enthaltenden Typen.</span><span class="sxs-lookup"><span data-stu-id="f4702-183">Nested types are useful to encapsulate private implementation details of the containing type.</span></span> <span data-ttu-id="f4702-184">Bei dieser Verwendungsart sollten geschachtelte Typen nicht extern sichtbar sein.</span><span class="sxs-lookup"><span data-stu-id="f4702-184">Used for this purpose, nested types should not be externally visible.</span></span> |
| [<span data-ttu-id="f4702-185">CA1036: Methoden bei vergleichbaren Typen überschreiben.</span><span class="sxs-lookup"><span data-stu-id="f4702-185">CA1036: Override methods on comparable types</span></span>](ca1036.md) | <span data-ttu-id="f4702-186">Ein öffentlicher oder geschützter Typ implementiert die System.IComparable-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="f4702-186">A public or protected type implements the System.IComparable interface.</span></span> <span data-ttu-id="f4702-187">Er überschreibt Object.Equals nicht und überlädt auch nicht den sprachspezifischen Operator für gleich, ungleich, kleiner als und größer als.</span><span class="sxs-lookup"><span data-stu-id="f4702-187">It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than.</span></span> |
| [<span data-ttu-id="f4702-188">CA1040: Leere Schnittstellen vermeiden.</span><span class="sxs-lookup"><span data-stu-id="f4702-188">CA1040: Avoid empty interfaces</span></span>](ca1040.md) | <span data-ttu-id="f4702-189">Schnittstellen definieren Member, die ein Verhalten oder einen Verwendungsvertrag bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="f4702-189">Interfaces define members that provide a behavior or usage contract.</span></span> <span data-ttu-id="f4702-190">Die durch die Schnittstelle beschriebene Funktionalität kann von jedem Typ übernommen werden, unabhängig davon, an welcher Stelle der Typ in der Vererbungshierarchie steht.</span><span class="sxs-lookup"><span data-stu-id="f4702-190">The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy.</span></span> <span data-ttu-id="f4702-191">Ein Typ implementiert eine Schnittstelle, indem er Implementierungen für die Member der Schnittstelle bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="f4702-191">A type implements an interface by providing implementations for the members of the interface.</span></span> <span data-ttu-id="f4702-192">Eine leere Schnittstelle definiert keine Member. Daher definiert sie keinen Vertrag, der implementiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="f4702-192">An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</span></span> |
| [<span data-ttu-id="f4702-193">CA1041: ObsoleteAttribute-Meldung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="f4702-193">CA1041: Provide ObsoleteAttribute message</span></span>](ca1041.md) | <span data-ttu-id="f4702-194">Ein Typ oder Member wird mit einem System.ObsoleteAttribute-Attribut markiert, dessen ObsoleteAttribute.Message-Eigenschaft nicht angegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="f4702-194">A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified.</span></span> <span data-ttu-id="f4702-195">Wenn ein Typ oder Member, der mithilfe von ObsoleteAttribute markiert ist, kompiliert wird, wird die Message-Eigenschaft des Attributs angezeigt, die dem Benutzerinformationen über den veralteten Typ oder Member übergibt.</span><span class="sxs-lookup"><span data-stu-id="f4702-195">When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed, which gives the user information about the obsolete type or member.</span></span> |
| [<span data-ttu-id="f4702-196">CA1043: Ganzzahliges Argument oder Zeichenfolgenargument für Indexer verwenden.</span><span class="sxs-lookup"><span data-stu-id="f4702-196">CA1043: Use integral or string argument for indexers</span></span>](ca1043.md) | <span data-ttu-id="f4702-197">Indexer (d. h. indizierte Eigenschaften) sollten ganzzahlige Typen oder Zeichenfolgentypen für den Index verwenden.</span><span class="sxs-lookup"><span data-stu-id="f4702-197">Indexers (that is, indexed properties) should use integral or string types for the index.</span></span> <span data-ttu-id="f4702-198">Diese Typen werden i. d. R. zum Indizieren von Datenstrukturen verwendet und erweitern den Einsatzbereich der Bibliothek.</span><span class="sxs-lookup"><span data-stu-id="f4702-198">These types are typically used for indexing data structures and they increase the usability of the library.</span></span> <span data-ttu-id="f4702-199">Die Verwendung des Object-Typs sollte auf die Fälle beschränkt werden, in denen der spezielle integrale oder Zeichenfolgentyp zur Entwurfszeit nicht angegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="f4702-199">Use of the Object type should be restricted to those cases where the specific integral or string type cannot be specified at design time.</span></span> |
| [<span data-ttu-id="f4702-200">CA1044: Eigenschaften sollten nicht lesegeschützt sein.</span><span class="sxs-lookup"><span data-stu-id="f4702-200">CA1044: Properties should not be write only</span></span>](ca1044.md) | <span data-ttu-id="f4702-201">Obwohl eine schreibgeschützte Eigenschaft akzeptabel und oft erforderlich ist, verhindern die Entwurfsrichtlinien die Verwendung von Eigenschaften, die nur geschrieben werden können.</span><span class="sxs-lookup"><span data-stu-id="f4702-201">Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties.</span></span> <span data-ttu-id="f4702-202">Wenn ein Benutzer einen Wert festlegen kann, bietet es keinerlei Sicherheitsvorteile, das Lesen und Anzeigen des Werts durch den Benutzer zu sperren.</span><span class="sxs-lookup"><span data-stu-id="f4702-202">This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security.</span></span> <span data-ttu-id="f4702-203">Außerdem kann der Zustand freigegebener Objekte ohne Lesezugriff nicht angezeigt werden, wodurch ihre Nützlichkeit eingeschränkt wird.</span><span class="sxs-lookup"><span data-stu-id="f4702-203">Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</span></span> |
| [<span data-ttu-id="f4702-204">CA1045: Typen nicht als Verweis übergeben.</span><span class="sxs-lookup"><span data-stu-id="f4702-204">CA1045: Do not pass types by reference</span></span>](ca1045.md) | <span data-ttu-id="f4702-205">Die Übergabe von Typen als Verweis (mit out oder ref) erfordert Erfahrung im Umgang mit Zeigern, Kenntnisse der Unterschiede zwischen Wert- und Verweistypen und Erfahrung im Umgang mit Methoden mit mehreren Rückgabewerten.</span><span class="sxs-lookup"><span data-stu-id="f4702-205">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="f4702-206">Entwickler von Bibliotheken für eine breite Zielgruppe sollten nicht davon ausgehen, dass die Benutzer den out-Parameter oder den ref-Parameter richtig verwenden können.</span><span class="sxs-lookup"><span data-stu-id="f4702-206">Library architects who design for a general audience should not expect users to master working with out or ref parameters.</span></span> |
| [<span data-ttu-id="f4702-207">CA1046: Gleichheitsoperator für Referenztypen nicht überladen.</span><span class="sxs-lookup"><span data-stu-id="f4702-207">CA1046: Do not overload operator equals on reference types</span></span>](ca1046.md) | <span data-ttu-id="f4702-208">Für Verweistypen ist die Standardimplementierung des Gleichheitsoperators fast immer zutreffend.</span><span class="sxs-lookup"><span data-stu-id="f4702-208">For reference types, the default implementation of the equality operator is almost always correct.</span></span> <span data-ttu-id="f4702-209">Standardmäßig sind zwei Verweise nur dann gleich, wenn sie auf dasselbe Objekt zeigen.</span><span class="sxs-lookup"><span data-stu-id="f4702-209">By default, two references are equal only if they point to the same object.</span></span> |
| [<span data-ttu-id="f4702-210">CA1047: Geschützte Member in versiegelten Typen nicht deklarieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-210">CA1047: Do not declare protected members in sealed types</span></span>](ca1047.md) | <span data-ttu-id="f4702-211">Typen deklarieren geschützte Member, damit erbende Typen auf den Member zugreifen oder diesen überschreiben können.</span><span class="sxs-lookup"><span data-stu-id="f4702-211">Types declare protected members so that inheriting types can access or override the member.</span></span> <span data-ttu-id="f4702-212">Per Definition kann von versiegelten Typen nicht geerbt werden. Dies bedeutet, dass geschützte Methoden für versiegelte Typen nicht aufgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="f4702-212">By definition, sealed types cannot be inherited, which means that protected methods on sealed types cannot be called.</span></span> |
| [<span data-ttu-id="f4702-213">CA1050: Typen in Namespaces deklarieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-213">CA1050: Declare types in namespaces</span></span>](ca1050.md) | <span data-ttu-id="f4702-214">Typen werden in Namespaces deklariert, um Namenskonflikte zu verhindern und um verwandte Typen in einer Objekthierarchie zu organisieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-214">Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</span></span> |
| [<span data-ttu-id="f4702-215">CA1051: Sichtbare Instanzfelder nicht deklarieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-215">CA1051: Do not declare visible instance fields</span></span>](ca1051.md) | <span data-ttu-id="f4702-216">Ein Feld sollte primär als Implementierungsdetail verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-216">The primary use of a field should be as an implementation detail.</span></span> <span data-ttu-id="f4702-217">Felder sollten privat oder intern sein und durch die Verwendung von Eigenschaften verfügbar gemacht werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-217">Fields should be private or internal and should be exposed by using properties.</span></span> |
| [<span data-ttu-id="f4702-218">CA1052: Statische Haltertypen sollten versiegelt sein.</span><span class="sxs-lookup"><span data-stu-id="f4702-218">CA1052: Static holder types should be sealed</span></span>](ca1052.md) | <span data-ttu-id="f4702-219">Ein öffentlicher oder geschützter Typ enthält nur statische Member und wird nicht mit dem sealed (c#)-oder notvererable (Visual Basic)-Modifizierer deklariert.</span><span class="sxs-lookup"><span data-stu-id="f4702-219">A public or protected type contains only static members and is not declared by using the sealed (C#) or NotInheritable (Visual Basic) modifier.</span></span> <span data-ttu-id="f4702-220">Ein Typ, der nicht geerbt werden soll, sollte mit dem sealed-Modifizierer markiert werden, um seine Verwendung als Basistyp zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="f4702-220">A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type.</span></span> |
| [<span data-ttu-id="f4702-221">CA1053: Statische Haltertypen sollten keine Konstruktoren aufweisen.</span><span class="sxs-lookup"><span data-stu-id="f4702-221">CA1053: Static holder types should not have constructors</span></span>](ca1053.md) | <span data-ttu-id="f4702-222">Ein öffentlicher oder verschachtelter öffentlicher Typ deklariert nur statische Member und verfügt über einen öffentlichen oder geschützten Standardkonstruktor.</span><span class="sxs-lookup"><span data-stu-id="f4702-222">A public or nested public type declares only static members and has a public or protected default constructor.</span></span> <span data-ttu-id="f4702-223">Der Konstruktor ist überflüssig, da zum Aufrufen statischer Member keine Instanz des Typs erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="f4702-223">The constructor is unnecessary because calling static members does not require an instance of the type.</span></span> <span data-ttu-id="f4702-224">Die Zeichenfolgenüberladung sollte die URI-Überladung aus Sicherheitsgründen mit dem Zeichenfolgenargument aufrufen.</span><span class="sxs-lookup"><span data-stu-id="f4702-224">The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security.</span></span> |
| [<span data-ttu-id="f4702-225">CA1054: URI-Parameter dürfen keine Zeichenfolgen sein.</span><span class="sxs-lookup"><span data-stu-id="f4702-225">CA1054: URI parameters should not be strings</span></span>](ca1054.md) | <span data-ttu-id="f4702-226">Wenn eine Methode eine Zeichenfolgendarstellung eines URIs annimmt, sollte eine entsprechende Überladung angegeben werden, die eine Instanz der URI-Klasse annimmt, die diese Dienste auf sichere Weise bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="f4702-226">If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="f4702-227">CA1055: URI-Rückgabewerte dürfen keine Zeichenfolgen sein.</span><span class="sxs-lookup"><span data-stu-id="f4702-227">CA1055: URI return values should not be strings</span></span>](ca1055.md) | <span data-ttu-id="f4702-228">Diese Regel geht davon aus, dass die Methode einen URI zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="f4702-228">This rule assumes that the method returns a URI.</span></span> <span data-ttu-id="f4702-229">Eine Zeichenfolgendarstellung eines URIs ist anfällig für Analyse- und Codierungsfehler und kann zu Sicherheitsmängeln führen.</span><span class="sxs-lookup"><span data-stu-id="f4702-229">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="f4702-230">Die System.Uri-Klasse stellt diese Dienste auf sichere Weise bereit.</span><span class="sxs-lookup"><span data-stu-id="f4702-230">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="f4702-231">CA1056: URI-Eigenschaften dürfen keine Zeichenfolgen sein.</span><span class="sxs-lookup"><span data-stu-id="f4702-231">CA1056: URI properties should not be strings</span></span>](ca1056.md) | <span data-ttu-id="f4702-232">Diese Regel setzt voraus, dass die-Eigenschaft einen URI darstellt.</span><span class="sxs-lookup"><span data-stu-id="f4702-232">This rule assumes that the property represents a URI.</span></span> <span data-ttu-id="f4702-233">Eine Zeichenfolgendarstellung eines URIs ist anfällig für Analyse- und Codierungsfehler und kann zu Sicherheitsmängeln führen.</span><span class="sxs-lookup"><span data-stu-id="f4702-233">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="f4702-234">Die System.Uri-Klasse stellt diese Dienste auf sichere Weise bereit.</span><span class="sxs-lookup"><span data-stu-id="f4702-234">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="f4702-235">CA1058: Typen sollten bestimmte Basistypen nicht erweitern.</span><span class="sxs-lookup"><span data-stu-id="f4702-235">CA1058: Types should not extend certain base types</span></span>](ca1058.md) | <span data-ttu-id="f4702-236">Ein extern sichtbarer Typ erweitert bestimmte Basistypen.</span><span class="sxs-lookup"><span data-stu-id="f4702-236">An externally visible type extends certain base types.</span></span> <span data-ttu-id="f4702-237">Verwenden Sie eine der Alternativen.</span><span class="sxs-lookup"><span data-stu-id="f4702-237">Use one of the alternatives.</span></span> |
| [<span data-ttu-id="f4702-238">CA1060: P/Aufrufe in die NativeMethods-Klasse verschieben</span><span class="sxs-lookup"><span data-stu-id="f4702-238">CA1060: Move P/Invokes to NativeMethods class</span></span>](ca1060.md) | <span data-ttu-id="f4702-239">Platt Form Aufruf Methoden, z. b. diejenigen, die mit der-Methode oder der-Methode gekennzeichnet sind <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> , die mit dem Declare-Schlüsselwort in Visual Basic definiert ist, greifen</span><span class="sxs-lookup"><span data-stu-id="f4702-239">Platform Invocation methods, such as those marked with the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> or methods defined by using the Declare keyword in Visual Basic, access unmanaged code.</span></span> <span data-ttu-id="f4702-240">Diese Methoden sollten der Klasse NativeMethods, SafeNativeMethods oder UnsafeNativeMethods angehören.</span><span class="sxs-lookup"><span data-stu-id="f4702-240">These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</span></span> |
| [<span data-ttu-id="f4702-241">CA1061: Basisklassenmethoden nicht ausblenden.</span><span class="sxs-lookup"><span data-stu-id="f4702-241">CA1061: Do not hide base class methods</span></span>](ca1061.md) | <span data-ttu-id="f4702-242">Eine Methode in einem Basistyp wird durch eine Methode mit identischem Namen in einem abgeleiteten Typ verdeckt, wenn die Parametersignatur der abgeleiteten Methode sich nur hinsichtlich der Typen unterscheidet, die schwächer abgeleitet sind als die entsprechenden Typen in der Parametersignatur der Basismethode.</span><span class="sxs-lookup"><span data-stu-id="f4702-242">A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</span></span> |
| [<span data-ttu-id="f4702-243">CA1062: Argumente von öffentlichen Methoden validieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-243">CA1062: Validate arguments of public methods</span></span>](ca1062.md) | <span data-ttu-id="f4702-244">Alle an extern sichtbare Methoden übergebenen Verweisargumente sollten auf NULL überprüft werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-244">All reference arguments that are passed to externally visible methods should be checked against null.</span></span> |
| [<span data-ttu-id="f4702-245">CA1063: IDisposable korrekt implementieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-245">CA1063: Implement IDisposable correctly</span></span>](ca1063.md) | <span data-ttu-id="f4702-246">Alle IDisposable-Typen müssen das Dispose-Muster korrekt implementieren.</span><span class="sxs-lookup"><span data-stu-id="f4702-246">All IDisposable types should implement the Dispose pattern correctly.</span></span> |
| [<span data-ttu-id="f4702-247">CA1064: Ausnahmen sollten öffentlich sein.</span><span class="sxs-lookup"><span data-stu-id="f4702-247">CA1064: Exceptions should be public</span></span>](ca1064.md) | <span data-ttu-id="f4702-248">Eine interne Ausnahme ist nur innerhalb ihres eigenen internen Bereichs sichtbar.</span><span class="sxs-lookup"><span data-stu-id="f4702-248">An internal exception is visible only inside its own internal scope.</span></span> <span data-ttu-id="f4702-249">Nachdem die Ausnahme den internen Bereich verlassen hat, kann nur die Basisausnahme zum Abfangen der Ausnahme verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-249">After the exception falls outside the internal scope, only the base exception can be used to catch the exception.</span></span> <span data-ttu-id="f4702-250">Wenn die interne Ausnahme von <xref:System.Exception?displayProperty=fullName> , oder geerbt wird <xref:System.SystemException?displayProperty=fullName> <xref:System.ApplicationException?displayProperty=fullName> , verfügt der externe Code nicht über genügend Informationen, um zu wissen, was mit der Ausnahme zu tun ist.</span><span class="sxs-lookup"><span data-stu-id="f4702-250">If the internal exception is inherited from <xref:System.Exception?displayProperty=fullName>, <xref:System.SystemException?displayProperty=fullName>, or <xref:System.ApplicationException?displayProperty=fullName>, the external code will not have sufficient information to know what to do with the exception.</span></span> |
| [<span data-ttu-id="f4702-251">CA1065: Keine Ausnahmen an unerwarteten Speicherorten auslösen.</span><span class="sxs-lookup"><span data-stu-id="f4702-251">CA1065: Do not raise exceptions in unexpected locations</span></span>](ca1065.md) | <span data-ttu-id="f4702-252">Eine Methode, von der das Auslösen von Ausnahmen nicht erwartet wird, löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="f4702-252">A method that is not expected to throw exceptions throws an exception.</span></span> |
| [<span data-ttu-id="f4702-253">CA1066: „IEquatable“ beim Außerkraftsetzen von „Equals“ implementieren</span><span class="sxs-lookup"><span data-stu-id="f4702-253">CA1066: Implement IEquatable when overriding Equals</span></span>](ca1066.md) | <span data-ttu-id="f4702-254">Ein Werttyp überschreibt die- <xref:System.Object.Equals%2A> Methode, implementiert jedoch nicht <xref:System.IEquatable%601> .</span><span class="sxs-lookup"><span data-stu-id="f4702-254">A value type overrides <xref:System.Object.Equals%2A> method, but does not implement <xref:System.IEquatable%601>.</span></span> |
| [<span data-ttu-id="f4702-255">CA1067: „Object.Equals(object)“ bei Implementierung von „IEquatable“ außer Kraft setzen</span><span class="sxs-lookup"><span data-stu-id="f4702-255">CA1067: Override Equals when implementing IEquatable</span></span>](ca1067.md) | <span data-ttu-id="f4702-256">Ein Typ implementiert <xref:System.IEquatable%601> , aber überschreibt die- <xref:System.Object.Equals%2A> Methode nicht.</span><span class="sxs-lookup"><span data-stu-id="f4702-256">A type implements <xref:System.IEquatable%601>, but does not override <xref:System.Object.Equals%2A> method.</span></span> |
| [<span data-ttu-id="f4702-257">CA1068: CancellationToken-Parameter müssen zuletzt aufgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-257">CA1068: CancellationToken parameters must come last</span></span>](ca1068.md) | <span data-ttu-id="f4702-258">Eine Methode verfügt über einen CancellationToken-Parameter, der nicht der letzte Parameter ist.</span><span class="sxs-lookup"><span data-stu-id="f4702-258">A method has a CancellationToken parameter that is not the last parameter.</span></span> |
| [<span data-ttu-id="f4702-259">CA1069: Enumerationen dürfen keine doppelten Werte aufweisen.</span><span class="sxs-lookup"><span data-stu-id="f4702-259">CA1069: Enums should not have duplicate values</span></span>](ca1069.md) | <span data-ttu-id="f4702-260">Eine Enumeration verfügt über mehrere Member, denen explizit derselbe Konstante Wert zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="f4702-260">An enumeration has multiple members which are explicitly assigned the same constant value.</span></span> |
| [<span data-ttu-id="f4702-261">CA1070: Ereignisfelder dürfen nicht als virtuell deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="f4702-261">CA1070: Do not declare event fields as virtual</span></span>](ca1070.md) | <span data-ttu-id="f4702-262">Ein [Feld ähnliches Ereignis](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) wurde als virtuell deklariert.</span><span class="sxs-lookup"><span data-stu-id="f4702-262">A [field-like event](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) was declared as virtual.</span></span> |
| [<span data-ttu-id="f4702-263">CA1071: Basis überschreiben. Ist beim Implementieren von IEquatable.</span><span class="sxs-lookup"><span data-stu-id="f4702-263">CA1071: Override base.Equals when implementing IEquatable</span></span>](ca1071.md) | <span data-ttu-id="f4702-264">Ein abgeleiteter Typ implementiert <xref:System.IEquatable%601> , aber überschreibt die Basisklassen <xref:System.IEquatable%601.Equals%2A> Methode nicht.</span><span class="sxs-lookup"><span data-stu-id="f4702-264">A derived type implements <xref:System.IEquatable%601>, but does not override the base class <xref:System.IEquatable%601.Equals%2A> method.</span></span> |
