---
title: 'CA2009: "deimmutablecollection" nicht für einen "immutablecollection"-Wert (Code Analyse) aufzurufen.'
description: 'Weitere Informationen zur Code Analyse Regel CA2009: Verwenden Sie nicht "deimmutablecollection" für einen "immutablecollection"-Wert.'
ms.date: 04/29/2020
ms.topic: reference
f1_keywords:
- CA2009
- DoNotCallToImmutableCollectionOnAnImmutableCollectionValueAnalyzer
helpviewer_keywords:
- CA2009
author: mavasani
ms.author: mavasani
ms.openlocfilehash: 0fbb265e2a1c02d7413639f074a0a37790cfe4c2
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/25/2020
ms.locfileid: "96590707"
---
# <a name="ca2009-do-not-call-toimmutablecollection-on-an-immutablecollection-value"></a>CA2009: „ToImmutableCollection“ nicht für einen ImmutableCollection-Wert aufrufen.

| | Wert |
|-|-|
| **Regel-ID** |CA2009|
| **Kategorie** |Microsoft.Reliability|
| **Behebung ist unterbrechend oder nicht unterbrechend** |Nicht unterbrechend|

## <a name="cause"></a>Ursache

`ToImmutable` die Methode wurde für eine unveränderliche Auflistung aus dem <xref:System.Collections.Immutable> Namespace unnötig aufgerufen.

## <a name="rule-description"></a>Regelbeschreibung

<xref:System.Collections.Immutable> der-Namespace enthält Typen, die unveränderliche Auflistungen definieren. Diese Regel analysiert die folgenden unveränderlichen Auflistungs Typen:

- <xref:System.Collections.Immutable.ImmutableArray%601?displayProperty=fullName>
- <xref:System.Collections.Immutable.ImmutableList%601?displayProperty=fullName>
- <xref:System.Collections.Immutable.ImmutableHashSet%601?displayProperty=fullName>
- <xref:System.Collections.Immutable.ImmutableSortedSet%601?displayProperty=fullName>
- <xref:System.Collections.Immutable.ImmutableDictionary%602?displayProperty=fullName>
- <xref:System.Collections.Immutable.ImmutableSortedDictionary%602?displayProperty=fullName>

Diese Typen definieren Erweiterungs Methoden, die eine neue unveränderliche Auflistung aus einer vorhandenen <xref:System.Collections.Generic.IEnumerable%601> Sammlung erstellen.

- <xref:System.Collections.Immutable.ImmutableArray%601> definiert <xref:System.Collections.Immutable.ImmutableArray.ToImmutableArray%2A> .
- <xref:System.Collections.Immutable.ImmutableList%601> definiert <xref:System.Collections.Immutable.ImmutableList.ToImmutableList%2A> .
- <xref:System.Collections.Immutable.ImmutableHashSet%601> definiert <xref:System.Collections.Immutable.ImmutableHashSet.ToImmutableHashSet%2A> .
- <xref:System.Collections.Immutable.ImmutableSortedSet%601> definiert <xref:System.Collections.Immutable.ImmutableSortedSet.ToImmutableSortedSet%2A> .
- <xref:System.Collections.Immutable.ImmutableDictionary%602> definiert <xref:System.Collections.Immutable.ImmutableDictionary.ToImmutableDictionary%2A> .
- <xref:System.Collections.Immutable.ImmutableSortedDictionary%602> definiert <xref:System.Collections.Immutable.ImmutableSortedDictionary.ToImmutableSortedDictionary%2A> .

Diese Erweiterungs Methoden sind so konzipiert, dass eine änderbare Auflistung in eine unveränderliche Auflistung konvertiert wird. Allerdings kann der Aufrufer versehentlich eine unveränderliche Auflistung als Eingabe an diese Methoden übergeben. Dies kann ein Leistungs-und/oder ein funktionales Problem darstellen.

- Leistungsproblem: unnötige Erstellung einer duplizierbaren Auflistung. Die ursprüngliche Auflistung war bereits unveränderlich und kann direkt verwendet werden.
- Potenzielles Funktionsprobleme: der Aufrufer hat eine änderbare Auflistung angenommen, als er tatsächlich eine unveränderliche Auflistung besaß.

## <a name="how-to-fix-violations"></a>Behandeln von Verstößen

Entfernen Sie den redundanten- `ToImmutable` Rückruf für eine unveränderliche Auflistung, um Verstöße zu beheben. Die folgenden beiden Code Ausschnitte zeigen z. b. einen Verstoß gegen die Regel und wie Sie behoben werden:

```csharp
using System;
using System.Collections.Generic;
using System.Collections.Immutable;

public class C
{
    public void M(IEnumerable<int> collection, ImmutableArray<int> immutableArray)
    {
        // This is fine.
        M2(collection.ToImmutableArray());

        // This leads to CA2009.
        M2(immutableArray.ToImmutableArray());
    }

    private void M2(ImmutableArray<int> immutableArray)
    {
        Console.WriteLine(immutableArray.Length);
    }
}
```

```csharp
using System;
using System.Collections.Generic;
using System.Collections.Immutable;

public class C
{
    public void M(IEnumerable<int> collection, ImmutableArray<int> immutableArray)
    {
        // This is fine.
        M2(collection.ToImmutableArray());

        // This is now fine.
        M2(immutableArray);
    }

    private void M2(ImmutableArray<int> immutableArray)
    {
        Console.WriteLine(immutableArray.Length);
    }
}
```

> [!TIP]
> Eine Code Korrektur ist für diese Regel in Visual Studio verfügbar. Positionieren Sie den Cursor bei der Verletzung, und drücken Sie **STRG**, um ihn zu verwenden + **.** (Punkt). Wählen Sie in der Liste der angezeigten Optionen **redundante Aufrufe entfernen** aus.
>
> ![Code Korrektur für CA2009: "deimmutablecollection" kann nicht für einen immutablecollection-Wert aufgerufen werden.](media/ca2009-codefix.png)

## <a name="when-to-suppress-warnings"></a>Wann sollten Warnungen unterdrückt werden?

Unterdrücken Sie keine Verstöße gegen diese Regel, es sei denn, Sie haben keine Auswirkungen auf die Auswirkungen auf die Leistung durch unnötige Zuordnungen unveränderlicher Sammlungen.

## <a name="see-also"></a>Siehe auch

- [Zuverlässigkeitsregeln](reliability-warnings.md)
- [Leistungsregeln](performance-warnings.md)
