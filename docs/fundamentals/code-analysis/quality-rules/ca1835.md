---
title: 'CA1835: bevorzugen der Speicher basierten über Ladungen von "Read Async"-und "Write-Async"-Methoden in streambasierten Klassen (Code Analyse)'
description: 'Informationen zur Code Analyse Regel CA1835: bevorzugen Sie die Speicher basierten über Ladungen von "Read Async"/"Write-Async"-Methoden in streambasierten Klassen'
ms.date: 05/11/2020
ms.topic: reference
f1_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
helpviewer_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
author: carlossanlop
ms.author: calope
dev_langs:
- CSharp
- VB
ms.openlocfilehash: a3730f911f55af27f75ca41a8a9427a29efd0a18
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/25/2020
ms.locfileid: "96590790"
---
# <a name="ca1835-prefer-the-memory-based-overloads-of-readasyncwriteasync-methods-in-stream-based-classes"></a><span data-ttu-id="3fe23-103">CA1835: bevorzugen der Speicher basierten über Ladungen von "Read Async"-und "Write-Async"-Methoden in streambasierten Klassen</span><span class="sxs-lookup"><span data-stu-id="3fe23-103">CA1835: Prefer the memory-based overloads of ReadAsync/WriteAsync methods in stream-based classes</span></span>

| | <span data-ttu-id="3fe23-104">Wert</span><span class="sxs-lookup"><span data-stu-id="3fe23-104">Value</span></span> |
|-|-|
|<span data-ttu-id="3fe23-105">TypName</span><span class="sxs-lookup"><span data-stu-id="3fe23-105">TypeName</span></span>|<span data-ttu-id="3fe23-106">Preferstreamasyncmemoryoverlodas</span><span class="sxs-lookup"><span data-stu-id="3fe23-106">PreferStreamAsyncMemoryOverlodas</span></span>|
| <span data-ttu-id="3fe23-107">**Regel-ID**</span><span class="sxs-lookup"><span data-stu-id="3fe23-107">**Rule ID**</span></span> |<span data-ttu-id="3fe23-108">CA1835</span><span class="sxs-lookup"><span data-stu-id="3fe23-108">CA1835</span></span>|
| <span data-ttu-id="3fe23-109">**Kategorie**</span><span class="sxs-lookup"><span data-stu-id="3fe23-109">**Category**</span></span> |<span data-ttu-id="3fe23-110">Microsoft. Performance</span><span class="sxs-lookup"><span data-stu-id="3fe23-110">Microsoft.Performance</span></span>|
| <span data-ttu-id="3fe23-111">**Behebung ist unterbrechend oder nicht unterbrechend**</span><span class="sxs-lookup"><span data-stu-id="3fe23-111">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="3fe23-112">Nicht unterbrechend</span><span class="sxs-lookup"><span data-stu-id="3fe23-112">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="3fe23-113">Ursache</span><span class="sxs-lookup"><span data-stu-id="3fe23-113">Cause</span></span>

<span data-ttu-id="3fe23-114">Diese Regel sucht nach erwarteten Aufrufen der Byte-Array-basierten Methoden Überladungen für `ReadAsync` und `WriteAsync` und schlägt vor, stattdessen die Speicher basierten Methoden Überladungen zu verwenden, da Sie effizienter sind.</span><span class="sxs-lookup"><span data-stu-id="3fe23-114">This rule locates awaited invocations of the byte-array-based method overloads for `ReadAsync` and `WriteAsync`, and suggests using the memory-based method overloads instead, because they are more efficient.</span></span>

## <a name="rule-description"></a><span data-ttu-id="3fe23-115">Regelbeschreibung</span><span class="sxs-lookup"><span data-stu-id="3fe23-115">Rule description</span></span>

<span data-ttu-id="3fe23-116">Die Speicher basierten Methoden Überladungen haben eine effizientere Speicherauslastung als die Byte Array basierten.</span><span class="sxs-lookup"><span data-stu-id="3fe23-116">The memory-based method overloads have a more efficient memory usage than the byte array-based ones.</span></span>

<span data-ttu-id="3fe23-117">Die Regel funktioniert für `ReadAsync` -und- `WriteAsync` Aufrufe einer beliebigen Klasse, die von erbt <xref:System.IO.Stream> .</span><span class="sxs-lookup"><span data-stu-id="3fe23-117">The rule works on `ReadAsync` and `WriteAsync` invocations of any class that inherits from <xref:System.IO.Stream>.</span></span>

<span data-ttu-id="3fe23-118">Die Regel funktioniert nur, wenn der-Methode das- `await` Schlüsselwort vorangestellt ist.</span><span class="sxs-lookup"><span data-stu-id="3fe23-118">The rule only works when the method is preceded by the `await` keyword.</span></span>

|<span data-ttu-id="3fe23-119">Erkannte Methode</span><span class="sxs-lookup"><span data-stu-id="3fe23-119">Detected method</span></span>|<span data-ttu-id="3fe23-120">Vorgeschlagene Methode</span><span class="sxs-lookup"><span data-stu-id="3fe23-120">Suggested method</span></span>|
|-|-|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)>|<span data-ttu-id="3fe23-121"><xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)>`CancellationToken` `default` , wenn in c# auf festgelegt ist, oder `Nothing` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="3fe23-121"><xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<span data-ttu-id="3fe23-122"><xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)>`CancellationToken` `default` , wenn in c# auf festgelegt ist, oder `Nothing` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="3fe23-122"><xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|

> [!IMPORTANT]
> <span data-ttu-id="3fe23-123">Stellen Sie sicher, dass das `offset` -Argument und das- `count` ganzzahlige Argument an die erstellten- `Memory` `ReadOnlyMemory` Instanzen</span><span class="sxs-lookup"><span data-stu-id="3fe23-123">Make sure to pass the `offset` and `count` integer arguments to the created `Memory` or `ReadOnlyMemory` instances.</span></span>

> [!NOTE]
> <span data-ttu-id="3fe23-124">Die Regel CA1835 ist in allen .NET-Versionen verfügbar, in denen die Speicher basierten über Ladungen verfügbar sind:</span><span class="sxs-lookup"><span data-stu-id="3fe23-124">Rule CA1835 is available in all .NET versions where the memory-based overloads are available:</span></span>
>
> - <span data-ttu-id="3fe23-125">.NET Standard 2,1 und höher.</span><span class="sxs-lookup"><span data-stu-id="3fe23-125">.NET Standard 2.1 and above.</span></span>
> - <span data-ttu-id="3fe23-126">.Net Core 2,1 und höher.</span><span class="sxs-lookup"><span data-stu-id="3fe23-126">.NET Core 2.1 and above.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="3fe23-127">Behandeln von Verstößen</span><span class="sxs-lookup"><span data-stu-id="3fe23-127">How to fix violations</span></span>

<span data-ttu-id="3fe23-128">Sie können Sie entweder manuell beheben, oder Sie können sich dafür entscheiden, Visual Studio für Sie zu verwenden, indem Sie auf die Glühbirne zeigen, die neben dem Methodenaufruf angezeigt wird, und die vorgeschlagene Änderung auswählen.</span><span class="sxs-lookup"><span data-stu-id="3fe23-128">You can either fix them manually, or you can opt to let Visual Studio do it for you, by hovering over the light bulb that shows up next to the method invocation, and selecting the suggested change.</span></span> <span data-ttu-id="3fe23-129">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="3fe23-129">Example:</span></span>

![Code Korrektur für CA1835: bevorzugt die Speicher basierten über Ladungen von "Read Async"/"Write-Async"-Methoden in streambasierten Klassen](media/ca1835-codefix.png)

<span data-ttu-id="3fe23-131">Die Regel kann eine Vielzahl von Verstößen gegen die `ReadAsync` -Methode und die- `WriteAsync` Methode erkennen.</span><span class="sxs-lookup"><span data-stu-id="3fe23-131">The rule can detect a variety of violations for the `ReadAsync` and `WriteAsync` methods.</span></span> <span data-ttu-id="3fe23-132">Im folgenden finden Sie Beispiele für die Fälle, die die Regel erkennen kann:</span><span class="sxs-lookup"><span data-stu-id="3fe23-132">Here are examples of the cases that the rule can detect:</span></span>

### <a name="example-1"></a><span data-ttu-id="3fe23-133">Beispiel 1</span><span class="sxs-lookup"><span data-stu-id="3fe23-133">Example 1</span></span>

<span data-ttu-id="3fe23-134">Aufrufe von `ReadAsync` ohne und mit einem- `CancellationToken` Argument:</span><span class="sxs-lookup"><span data-stu-id="3fe23-134">Invocations of `ReadAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer, 0, buffer.Length);
            await s.ReadAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="3fe23-135">Behebung:</span><span class="sxs-lookup"><span data-stu-id="3fe23-135">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length));
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-2"></a><span data-ttu-id="3fe23-136">Beispiel 2</span><span class="sxs-lookup"><span data-stu-id="3fe23-136">Example 2</span></span>

<span data-ttu-id="3fe23-137">Aufrufe von `WriteAsync` ohne und mit einem- `CancellationToken` Argument:</span><span class="sxs-lookup"><span data-stu-id="3fe23-137">Invocations of `WriteAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer, 0, buffer.Length);
            await s.WriteAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="3fe23-138">Behebung:</span><span class="sxs-lookup"><span data-stu-id="3fe23-138">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length));
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-3"></a><span data-ttu-id="3fe23-139">Beispiel 3</span><span class="sxs-lookup"><span data-stu-id="3fe23-139">Example 3</span></span>

<span data-ttu-id="3fe23-140">Aufrufe mit `ConfigureAwait` :</span><span class="sxs-lookup"><span data-stu-id="3fe23-140">Invocations with `ConfigureAwait`:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1, 0, buffer1.Length).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2, 0, buffer2.Length).ConfigureAwait(true);
        }
    }
}
```

<span data-ttu-id="3fe23-141">Behebung:</span><span class="sxs-lookup"><span data-stu-id="3fe23-141">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1.AsMemory(0, buffer1.Length)).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2.AsMemory(0, buffer.Length)).ConfigureAwait(true);
        }
    }
}
```

## <a name="non-violations"></a><span data-ttu-id="3fe23-142">Nicht Verstöße</span><span class="sxs-lookup"><span data-stu-id="3fe23-142">Non-violations</span></span>

<span data-ttu-id="3fe23-143">Im folgenden finden Sie einige Beispiele für Aufrufe, bei denen die Regel **nicht** ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="3fe23-143">Following are some examples of invocations where the rule will **not** be fired.</span></span>

<span data-ttu-id="3fe23-144">Der Rückgabewert wird in einer `Task` Variablen gespeichert, anstatt gewartet zu haben:</span><span class="sxs-lookup"><span data-stu-id="3fe23-144">The return value is saved in a `Task` variable instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            Task t = s.WriteAsync(buffer, 0, buffer.Length);
        }
    }
}
```

<span data-ttu-id="3fe23-145">Der Rückgabewert wird von der Wrapping Methode zurückgegeben, anstatt gewartet zu haben:</span><span class="sxs-lookup"><span data-stu-id="3fe23-145">The return value is returned by the wrapping method instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public Task MyMethod(FileStream s, byte[] buffer)
    {
        return s.WriteAsync(buffer, 0, buffer.Length);
    }
}
```

<span data-ttu-id="3fe23-146">Der Rückgabewert wird verwendet, um aufzurufen `ContinueWith` , wobei es sich um die erwartete Methode handelt:</span><span class="sxs-lookup"><span data-stu-id="3fe23-146">The return value is used to call `ContinueWith`, which is the method being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            await s.WriteAsync(buffer, 0, buffer.Length).ContinueWith(c => { /* ... */ });
        }
    }
}
```

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="3fe23-147">Wann sollten Warnungen unterdrückt werden?</span><span class="sxs-lookup"><span data-stu-id="3fe23-147">When to suppress warnings</span></span>

<span data-ttu-id="3fe23-148">Es ist sicher, einen Verstoß gegen diese Regel zu unterdrücken, wenn Sie sich keine Gedanken über die Verbesserung der Leistung machen, wenn Sie Puffer in streambasierten Klassen lesen oder schreiben.</span><span class="sxs-lookup"><span data-stu-id="3fe23-148">It's safe to suppress a violation of this rule if you're not concerned about improving performance when reading or writing buffers in stream-based classes.</span></span>

## <a name="see-also"></a><span data-ttu-id="3fe23-149">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="3fe23-149">See also</span></span>

- [<span data-ttu-id="3fe23-150">Leistungsregeln</span><span class="sxs-lookup"><span data-stu-id="3fe23-150">Performance rules</span></span>](performance-warnings.md)
