---
title: Leistungs Regeln (Code Analyse)
description: Erfahren Sie mehr über die Leistungs Regeln für die Code Analyse.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.performancerules
helpviewer_keywords:
- rules, performance
- performance rules
- performance, rules
- managed code analysis rules, performance rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 4409cc46eb73f13f8e59d7a51899da27035bb6af
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/25/2020
ms.locfileid: "96590680"
---
# <a name="performance-rules"></a><span data-ttu-id="c8ee5-103">Leistungsregeln</span><span class="sxs-lookup"><span data-stu-id="c8ee5-103">Performance rules</span></span>

<span data-ttu-id="c8ee5-104">Leistungs Regeln unterstützen Hochleistungs Bibliotheken und-Anwendungen.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-104">Performance rules support high-performance libraries and applications.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="c8ee5-105">In diesem Abschnitt</span><span class="sxs-lookup"><span data-stu-id="c8ee5-105">In this section</span></span>

| <span data-ttu-id="c8ee5-106">Regel</span><span class="sxs-lookup"><span data-stu-id="c8ee5-106">Rule</span></span> | <span data-ttu-id="c8ee5-107">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="c8ee5-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="c8ee5-108">CA1802: Nach Möglichkeit Literale verwenden.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-108">CA1802: Use Literals Where Appropriate</span></span>](ca1802.md) | <span data-ttu-id="c8ee5-109">Ein Feld wird als statisch und schreibgeschützt deklariert (in Visual Basic freigegeben und schreibgeschützt) und mit einem Wert initialisiert, der zur Kompilierzeit berechnet werden kann.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-109">A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized with a value that is computable at compile time.</span></span> <span data-ttu-id="c8ee5-110">Da der Wert, der dem Zielfeld zugewiesen ist, zur Kompilierzeit komprimiert werden kann, ändern Sie die Deklaration in ein Konstantenfeld (Konstantenin Visual Basic), sodass der Wert zur Kompilierzeit anstelle der Laufzeit berechnet wird.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-110">Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run time.</span></span> |
| [<span data-ttu-id="c8ee5-111">CA1805: nicht unnötig initialisieren</span><span class="sxs-lookup"><span data-stu-id="c8ee5-111">CA1805: Do not initialize unnecessarily</span></span>](ca1805.md) | <span data-ttu-id="c8ee5-112">Die .NET-Laufzeit initialisiert alle Felder von Verweis Typen mit ihren Standardwerten, bevor der Konstruktor ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-112">The .NET runtime initializes all fields of reference types to their default values before running the constructor.</span></span> <span data-ttu-id="c8ee5-113">In den meisten Fällen ist das explizite Initialisieren eines Felds auf seinen Standardwert redundant, wodurch Wartungskosten erhöht und die Leistung beeinträchtigt werden kann (z. b. mit erhöhter assemblygröße).</span><span class="sxs-lookup"><span data-stu-id="c8ee5-113">In most cases, explicitly initializing a field to its default value is redundant, which adds to maintenance costs and may degrade performance (such as with increased assembly size).</span></span> |
| [<span data-ttu-id="c8ee5-114">CA1806: Methodenergebnisse nicht ignorieren.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-114">CA1806: Do not ignore method results</span></span>](ca1806.md) | <span data-ttu-id="c8ee5-115">Ein neues-Objekt wird erstellt, aber nie verwendet, oder eine Methode, die eine neue Zeichenfolge erstellt und zurückgibt, wird aufgerufen, und die neue Zeichenfolge wird nie verwendet, oder eine Component Object Model (com)-oder P/aufrufen-Methode gibt ein HRESULT oder einen Fehlercode zurück, das nie verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-115">A new object is created but never used, or a method that creates and returns a new string is called and the new string is never used, or a Component Object Model (COM) or P/Invoke method returns an HRESULT or error code that is never used.</span></span> |
| [<span data-ttu-id="c8ee5-116">CA1810: Statische Felder von Referenztypen inline initialisieren.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-116">CA1810: Initialize reference type static fields inline</span></span>](ca1810.md) | <span data-ttu-id="c8ee5-117">Wenn ein Typ einen expliziten statischen Konstruktor deklariert, überprüft der JIT-Compiler (Just in Time) jede statische Methode und jeden Instanzenkonstruktor des Typs. Dadurch wird sichergestellt, dass der statische Konstruktor zuvor aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-117">When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called.</span></span> <span data-ttu-id="c8ee5-118">Durch die Überprüfung statischer Konstruktoren kann die Leistung herabgesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-118">Static constructor checks can decrease performance.</span></span> |
| [<span data-ttu-id="c8ee5-119">CA1812: Nicht instanziierte interne Klassen vermeiden.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-119">CA1812: Avoid uninstantiated internal classes</span></span>](ca1812.md) | <span data-ttu-id="c8ee5-120">Eine Instanz eines Typs auf Assemblyebene wird nicht durch Code in der Assembly erstellt.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-120">An instance of an assembly-level type is not created by code in the assembly.</span></span> |
| [<span data-ttu-id="c8ee5-121">CA1813: Nicht versiegelte Attribute vermeiden.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-121">CA1813: Avoid unsealed attributes</span></span>](ca1813.md) | <span data-ttu-id="c8ee5-122">.NET stellt Methoden zum Abrufen von benutzerdefinierten Attributen bereit.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-122">.NET provides methods for retrieving custom attributes.</span></span> <span data-ttu-id="c8ee5-123">Standardmäßig wird mit diesen Methoden die Attributvererbungshierarchie durchsucht.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-123">By default, these methods search the attribute inheritance hierarchy.</span></span> <span data-ttu-id="c8ee5-124">Durch Verwendung eines versiegelten Attributs wird das Durchsuchen der Vererbungshierarchie unterbunden und die Leistung u. U. verbessert.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-124">Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</span></span> |
| [<span data-ttu-id="c8ee5-125">CA1814: Jagged Arrays mehrdimensionalen Arrays vorziehen.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-125">CA1814: Prefer jagged arrays over multidimensional</span></span>](ca1814.md) | <span data-ttu-id="c8ee5-126">Ein verzweigtes Array ist ein Array, dessen Elemente wiederum Arrays sind.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-126">A jagged array is an array whose elements are arrays.</span></span> <span data-ttu-id="c8ee5-127">Die Arrays, aus denen die Elemente bestehen, können unterschiedlich groß sein, was zu weniger Verlust von Speicherplatz für einige Datenmengen führen kann.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-127">The arrays that make up the elements can be of different sizes, which can result in less wasted space for some sets of data.</span></span> |
| [<span data-ttu-id="c8ee5-128">CA1815: Equals und Gleichheitsoperator für Werttypen überschreiben.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-128">CA1815: Override equals and operator equals on value types</span></span>](ca1815.md) | <span data-ttu-id="c8ee5-129">Bei Werttypen wird die Reflection-Bibliothek von der geerbten Implementierung von Equals verwendet und der Inhalt aller Felder verglichen.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-129">For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields.</span></span> <span data-ttu-id="c8ee5-130">Reflection ist rechenintensiv, und das Überprüfen eines jeden Felds auf Gleichheit ist eventuell unnötig.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-130">Reflection is computationally expensive, and comparing every field for equality might be unnecessary.</span></span> <span data-ttu-id="c8ee5-131">Wenn Sie erwarten, dass die Benutzer Instanzen vergleichen oder sortieren bzw. dass sie die Instanzen als Schlüssel für Hashtabellen verwenden, sollte der Werttyp Equals implementieren.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-131">If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</span></span> |
| [<span data-ttu-id="c8ee5-132">CA1819: Eigenschaften sollten keine Arrays zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-132">CA1819: Properties should not return arrays</span></span>](ca1819.md) | <span data-ttu-id="c8ee5-133">Arrays, die von Eigenschaften zurückgegeben werden, sind nicht schreibgeschützt, auch wenn die Eigenschaft schreibgeschützt ist.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-133">Arrays that are returned by properties are not write-protected, even if the property is read-only.</span></span> <span data-ttu-id="c8ee5-134">Damit das Array gegen Manipulationen geschützt bleibt, muss die Eigenschaft eine Kopie des Arrays zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-134">To keep the array tamper-proof, the property must return a copy of the array.</span></span> <span data-ttu-id="c8ee5-135">Normalerweise verstehen die Benutzer nicht, welche negativen Auswirkungen der Aufruf einer solchen Eigenschaft auf die Leistung hat.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-135">Typically, users will not understand the adverse performance implications of calling such a property.</span></span> |
| [<span data-ttu-id="c8ee5-136">CA1820: Mithilfe der Zeichenfolgenlänge auf leere Zeichenfolgen prüfen.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-136">CA1820: Test for empty strings using string length</span></span>](ca1820.md) | <span data-ttu-id="c8ee5-137">Der Vergleich von Zeichenfolgen mit der String.Length-Eigenschaft oder der String.IsNullOrEmpty-Methode führt erheblich schneller zu Ergebnissen als das Verwenden von Equals.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-137">Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</span></span> |
| [<span data-ttu-id="c8ee5-138">CA1821: Leere Finalizer entfernen.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-138">CA1821: Remove empty finalizers</span></span>](ca1821.md) | <span data-ttu-id="c8ee5-139">Finalizer sollten möglichst vermieden werden, da durch Verfolgung der Objektlebensdauer zusätzliche Leistung beansprucht wird.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-139">Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime.</span></span> <span data-ttu-id="c8ee5-140">Ein leerer Finalizer verursacht zusätzlichen Aufwand ohne jeglichen Vorteil.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-140">An empty finalizer incurs added overhead without any benefit.</span></span> |
| [<span data-ttu-id="c8ee5-141">CA1822: Member als statisch markieren.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-141">CA1822: Mark members as static</span></span>](ca1822.md) | <span data-ttu-id="c8ee5-142">Member, die nicht auf Instanzdaten oder Aufrufen von Instanzmethoden zugreifen, können als statisch gekennzeichnet werden (in Visual Basic freigegeben).</span><span class="sxs-lookup"><span data-stu-id="c8ee5-142">Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic).</span></span> <span data-ttu-id="c8ee5-143">Danach gibt der Compiler nicht virtuelle Aufrufsites an diese Member aus.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-143">After you mark the methods as static, the compiler will emit nonvirtual call sites to these members.</span></span> <span data-ttu-id="c8ee5-144">Dies kann zu einer messbaren Leistungssteigerung für leistungsabhängigen Code führen.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-144">This can give you a measurable performance gain for performance-sensitive code.</span></span> |
| [<span data-ttu-id="c8ee5-145">CA1823: Nicht verwendete private Felder vermeiden.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-145">CA1823: Avoid unused private fields</span></span>](ca1823.md) | <span data-ttu-id="c8ee5-146">Es wurden private Felder erkannt, auf die in der Assembly anscheinend kein Zugriff erfolgt.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-146">Private fields were detected that do not appear to be accessed in the assembly.</span></span> |
| [<span data-ttu-id="c8ee5-147">CA1824: Assemblys mit NeutralResourcesLanguageAttribute markieren.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-147">CA1824: Mark assemblies with NeutralResourcesLanguageAttribute</span></span>](ca1824.md) | <span data-ttu-id="c8ee5-148">Das NeutralResourcesLanguage-Attribut informiert den Ressourcen-Manager der Sprache, die verwendet wurde, um die Ressourcen einer neutralen Kultur für eine Assembly anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-148">The NeutralResourcesLanguage attribute informs the Resource Manager of the language that was used to display the resources of a neutral culture for an assembly.</span></span> <span data-ttu-id="c8ee5-149">Auf diese Weise wird die Suchleistung für die erste zu ladende Ressource verbessert und Ihr Workingset kann sich verkleinern.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-149">This improves lookup performance for the first resource that you load and can reduce your working set.</span></span> |
| [<span data-ttu-id="c8ee5-150">CA1825: Vermeiden Sie Arrayzuteilungen mit einer Länge von 0 (null).</span><span class="sxs-lookup"><span data-stu-id="c8ee5-150">CA1825: Avoid zero-length array allocations</span></span>](ca1825.md) | <span data-ttu-id="c8ee5-151">Die Initialisierung eines Arrays der Länge 0 (null) führt zu einer unnötigen Speicher Belegung.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-151">Initializing a zero-length array leads to unnecessary memory allocation.</span></span> <span data-ttu-id="c8ee5-152">Verwenden Sie stattdessen die statisch zugeordnete leere Array Instanz, indem Sie aufrufen <xref:System.Array.Empty%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="c8ee5-152">Instead, use the statically allocated empty array instance by calling <xref:System.Array.Empty%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c8ee5-153">Die Speicher Belegung wird für alle Aufrufe dieser Methode freigegeben.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-153">The memory allocation is shared across all invocations of this method.</span></span> |
| [<span data-ttu-id="c8ee5-154">CA1826: Eigenschaft anstelle der LINQ-Enumerable-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-154">CA1826: Use property instead of Linq Enumerable method</span></span>](ca1826.md) | <span data-ttu-id="c8ee5-155"><xref:System.Linq.Enumerable> Die LINQ-Methode wurde für einen Typ verwendet, der eine äquivalente, effizientere Eigenschaft unterstützt.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-155"><xref:System.Linq.Enumerable> LINQ method was used on a type that supports an equivalent, more efficient property.</span></span> |
| [<span data-ttu-id="c8ee5-156">CA1827: Count/LongCount nicht verwenden, wenn Any verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-156">CA1827: Do not use Count/LongCount when Any can be used</span></span>](ca1827.md) | <span data-ttu-id="c8ee5-157"><xref:System.Linq.Enumerable.Count%2A> die-Methode oder die- <xref:System.Linq.Enumerable.LongCount%2A> Methode wurde verwendet, wenn die <xref:System.Linq.Enumerable.Any%2A> Methode effizienter wäre.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-157"><xref:System.Linq.Enumerable.Count%2A> or <xref:System.Linq.Enumerable.LongCount%2A> method was used where <xref:System.Linq.Enumerable.Any%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="c8ee5-158">CA1828: CountAsync/LongCountAsync nicht verwenden, wenn AnyAsync verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-158">CA1828: Do not use CountAsync/LongCountAsync when AnyAsync can be used</span></span>](ca1828.md) | <span data-ttu-id="c8ee5-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> die-Methode oder die- <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> Methode wurde verwendet, wenn die <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> Methode effizienter wäre.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> or <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> method was used where <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="c8ee5-160">CA1829: Length/Count-Eigenschaft anstelle der Enumerable.Count-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-160">CA1829: Use Length/Count property instead of Enumerable.Count method</span></span>](ca1829.md) | <span data-ttu-id="c8ee5-161"><xref:System.Linq.Enumerable.Count%2A> Die LINQ-Methode wurde für einen Typ verwendet, der eine äquivalente, effizientere oder-Eigenschaft unterstützt `Length` `Count` .</span><span class="sxs-lookup"><span data-stu-id="c8ee5-161"><xref:System.Linq.Enumerable.Count%2A> LINQ method was used on a type that supports an equivalent, more efficient `Length` or `Count` property.</span></span> |
| [<span data-ttu-id="c8ee5-162">CA1830: Bevorzugen Sie stark typisierte Append- und Insert-Methodenüberladungen für StringBuilder.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-162">CA1830: Prefer strongly-typed Append and Insert method overloads on StringBuilder</span></span>](ca1830.md) | <span data-ttu-id="c8ee5-163"><xref:System.Text.StringBuilder.Append%2A> und <xref:System.Text.StringBuilder.Insert%2A> Stellen über Ladungen für mehrere Typen bereit, die über System. String hinausgehen.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-163"><xref:System.Text.StringBuilder.Append%2A> and <xref:System.Text.StringBuilder.Insert%2A> provide overloads for multiple types beyond System.String.</span></span>  <span data-ttu-id="c8ee5-164">Bevorzugen Sie nach Möglichkeit die stark typisierten über Ladungen über die Verwendung von ToString () und der Zeichen folgen basierten Überladung.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-164">When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</span></span> |
| [<span data-ttu-id="c8ee5-165">CA1831: Verwenden Sie für Zeichenfolgen bei Bedarf anstelle von Range-basierten Indexern „AsSpan“.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-165">CA1831: Use AsSpan instead of Range-based indexers for string when appropriate</span></span>](ca1831.md) | <span data-ttu-id="c8ee5-166">Wenn Sie einen Range-Indexer für eine Zeichenfolge verwenden und den Wert implizit einem "Read onlyspan"- &lt; Char- &gt; Typ zuweisen, wird die-Methode <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> anstelle von verwendet <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , wodurch eine Kopie des angeforderten Teils der Zeichenfolge erzeugt wird.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-166">When using a range-indexer on a string and implicitly assigning the value to a ReadOnlySpan&lt;char&gt; type, the method <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the string.</span></span> |
| [<span data-ttu-id="c8ee5-167">CA1832: Verwenden Sie „AsSpan“ oder „AsMemory“ anstelle von Range-basierten Indexern zum Abrufen eines ReadOnlySpan- oder ReadOnlyMemory-Teils eines Arrays.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-167">CA1832: Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array</span></span>](ca1832.md) | <span data-ttu-id="c8ee5-168">Wenn Sie einen Range-Indexer für ein Array verwenden und den Wert implizit einem- <xref:System.ReadOnlySpan%601> oder- <xref:System.ReadOnlyMemory%601> Typ zuweisen, wird die-Methode <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> anstelle von verwendet <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , wodurch eine Kopie des angeforderten Teils des Arrays erzeugt wird.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-168">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.ReadOnlySpan%601> or <xref:System.ReadOnlyMemory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="c8ee5-169">CA1833: Verwenden Sie „AsSpan“ oder „AsMemory“ anstelle von Range-basierten Indexern zum Abrufen eines Span- oder Memory-Teils eines Arrays.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-169">CA1833: Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array</span></span>](ca1833.md) | <span data-ttu-id="c8ee5-170">Wenn Sie einen Range-Indexer für ein Array verwenden und den Wert implizit einem- <xref:System.Span%601> oder- <xref:System.Memory%601> Typ zuweisen, wird die-Methode <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> anstelle von verwendet <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , wodurch eine Kopie des angeforderten Teils des Arrays erzeugt wird.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-170">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.Span%601> or <xref:System.Memory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="c8ee5-171">CA1834: Verwenden von StringBuilder.Append(char) für Zeichenfolgen mit einem einzelnen Zeichen</span><span class="sxs-lookup"><span data-stu-id="c8ee5-171">CA1834: Use StringBuilder.Append(char) for single character strings</span></span>](ca1834.md) | <span data-ttu-id="c8ee5-172"><xref:System.Text.StringBuilder> verfügt über eine-Überladung `Append` , die einen `char` als sein Argument annimmt.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-172"><xref:System.Text.StringBuilder> has an `Append` overload that takes a `char` as its argument.</span></span> <span data-ttu-id="c8ee5-173">Bevorzugen Sie die `char` Überladung, um die Leistung zu verbessern</span><span class="sxs-lookup"><span data-stu-id="c8ee5-173">Prefer calling the `char` overload to improve performance.</span></span> |
| [<span data-ttu-id="c8ee5-174">CA1835: bevorzugen Sie die "Memory"-basierten über Ladungen für "Read Async" und "schreiteasync".</span><span class="sxs-lookup"><span data-stu-id="c8ee5-174">CA1835: Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</span></span>](ca1835.md) | <span data-ttu-id="c8ee5-175">' Stream ' weist eine ' Schreib async '-Überladung auf, die ein ' Memory &lt; Byte &gt; ' als erstes Argument annimmt, und eine ' schreiteasync '-Überladung, die ein ' Read onlymemory &lt; Byte &gt; ' als erstes Argument annimmt.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-175">'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument.</span></span> <span data-ttu-id="c8ee5-176">Bevorzugen Sie das Aufrufen der Speicher basierten über Ladungen, die effizienter sind.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-176">Prefer calling the memory based overloads, which are more efficient.</span></span> |
| [<span data-ttu-id="c8ee5-177">CA1836: bevorzugen `IsEmpty` , `Count` Wenn verfügbar</span><span class="sxs-lookup"><span data-stu-id="c8ee5-177">CA1836: Prefer `IsEmpty` over `Count` when available</span></span>](ca1836.md) | <span data-ttu-id="c8ee5-178">Bevorzugt eine `IsEmpty` Eigenschaft, die effizienter ist als `Count` , oder, `Length` <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> um zu bestimmen, ob das Objekt Elemente enthält oder nicht.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-178">Prefer `IsEmpty` property that is more efficient than `Count`, `Length`, <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> or <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> to determine whether the object contains or not any items.</span></span> |
| [<span data-ttu-id="c8ee5-179">CA1837: Verwenden Sie `Environment.ProcessId` anstelle von. `Process.GetCurrentProcess().Id`</span><span class="sxs-lookup"><span data-stu-id="c8ee5-179">CA1837: Use `Environment.ProcessId` instead of `Process.GetCurrentProcess().Id`</span></span>](ca1837.md) | <span data-ttu-id="c8ee5-180">`Environment.ProcessId` ist einfacher und schneller als `Process.GetCurrentProcess().Id` .</span><span class="sxs-lookup"><span data-stu-id="c8ee5-180">`Environment.ProcessId` is simpler and faster than `Process.GetCurrentProcess().Id`.</span></span> |
| [<span data-ttu-id="c8ee5-181">CA1838: `StringBuilder` Parameter für P/Aufrufe vermeiden</span><span class="sxs-lookup"><span data-stu-id="c8ee5-181">CA1838: Avoid `StringBuilder` parameters for P/Invokes</span></span>](ca1838.md) | <span data-ttu-id="c8ee5-182">Beim Marshalling von `StringBuilder` wird immer eine native Puffer Kopie erstellt, was zu mehreren Zuordnungen für einen marshallingvorgang führt.</span><span class="sxs-lookup"><span data-stu-id="c8ee5-182">Marshaling of `StringBuilder` always creates a native buffer copy, resulting in multiple allocations for one marshaling operation.</span></span> |
