---
title: 'CA1033: Schnittstellen Methoden sollten von untergeordneten Typen aufgerufen werden können (Code Analyse)'
description: 'Weitere Informationen zur Code Analyse Regel CA1033: Schnittstellen Methoden sollten von untergeordneten Typen aufgerufen werden können'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- InterfaceMethodsShouldBeCallableByChildTypes
- CA1033
helpviewer_keywords:
- CA1033
- InterfaceMethodsShouldBeCallableByChildTypes
author: gewarren
ms.author: gewarren
ms.openlocfilehash: fd9e544f23c7ea437449d0bdf0be1744b1238dbd
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/25/2020
ms.locfileid: "96591534"
---
# <a name="ca1033-interface-methods-should-be-callable-by-child-types"></a><span data-ttu-id="3a683-103">CA1033: Schnittstellenmethoden sollten von untergeordneten Typen aufgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="3a683-103">CA1033: Interface methods should be callable by child types</span></span>

| <span data-ttu-id="3a683-104">Element</span><span class="sxs-lookup"><span data-stu-id="3a683-104">Item</span></span>                                     | <span data-ttu-id="3a683-105">Wert</span><span class="sxs-lookup"><span data-stu-id="3a683-105">Value</span></span>            |
|------------------------------------------|------------------|
| <span data-ttu-id="3a683-106">RuleId</span><span class="sxs-lookup"><span data-stu-id="3a683-106">RuleId</span></span>                                   | <span data-ttu-id="3a683-107">CA1033</span><span class="sxs-lookup"><span data-stu-id="3a683-107">CA1033</span></span>           |
| <span data-ttu-id="3a683-108">Category</span><span class="sxs-lookup"><span data-stu-id="3a683-108">Category</span></span>                                 | <span data-ttu-id="3a683-109">Microsoft. Design</span><span class="sxs-lookup"><span data-stu-id="3a683-109">Microsoft.Design</span></span> |
| <span data-ttu-id="3a683-110">Behebung ist unterbrechend oder nicht unterbrechend</span><span class="sxs-lookup"><span data-stu-id="3a683-110">Fix is breaking or non-breaking</span></span> | <span data-ttu-id="3a683-111">Nicht unterbrechend</span><span class="sxs-lookup"><span data-stu-id="3a683-111">Non-breaking</span></span>     |

## <a name="cause"></a><span data-ttu-id="3a683-112">Ursache</span><span class="sxs-lookup"><span data-stu-id="3a683-112">Cause</span></span>

<span data-ttu-id="3a683-113">Ein unversiegelter, extern sichtbarer Typ gibt eine explizite Methodenimplementierung einer öffentlichen Schnittstelle an und gibt keine alternative extern sichtbare Methode mit dem gleichen Namen an.</span><span class="sxs-lookup"><span data-stu-id="3a683-113">An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</span></span>

## <a name="rule-description"></a><span data-ttu-id="3a683-114">Regelbeschreibung</span><span class="sxs-lookup"><span data-stu-id="3a683-114">Rule description</span></span>

<span data-ttu-id="3a683-115">Beachten Sie einen Basistyp, der eine öffentliche Schnittstellen Methode explizit implementiert.</span><span class="sxs-lookup"><span data-stu-id="3a683-115">Consider a base type that explicitly implements a public interface method.</span></span> <span data-ttu-id="3a683-116">Ein Typ, der vom Basistyp abgeleitet wird, kann nur über einen Verweis auf die aktuelle Instanz (in c#) auf die geerbte Schnittstellen Methode zugreifen `this` , die in die-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="3a683-116">A type that derives from the base type can access the inherited interface method only through a reference to the current instance (`this` in C#) that is cast to the interface.</span></span> <span data-ttu-id="3a683-117">Wenn der abgeleitete Typ die geerbte Schnittstellen Methode (explizit) neu implementiert, kann auf die Basis Implementierung nicht mehr zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="3a683-117">If the derived type reimplements (explicitly) the inherited interface method, the base implementation can no longer be accessed.</span></span> <span data-ttu-id="3a683-118">Durch den Aufruf über den aktuellen Instanzverweis wird die abgeleitete Implementierung aufgerufen. Dies bewirkt eine Rekursion und einen eventuellen Stapelüberlauf.</span><span class="sxs-lookup"><span data-stu-id="3a683-118">The call through the current instance reference will invoke the derived implementation; this causes recursion and an eventual stack overflow.</span></span>

<span data-ttu-id="3a683-119">Diese Regel meldet keine Verstöße gegen eine explizite Implementierung von, <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> Wenn eine extern sichtbare- `Close()` oder- `System.IDisposable.Dispose(Boolean)` Methode bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="3a683-119">This rule does not report a violation for an explicit implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> when an externally visible `Close()` or `System.IDisposable.Dispose(Boolean)` method is provided.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="3a683-120">Behandeln von Verstößen</span><span class="sxs-lookup"><span data-stu-id="3a683-120">How to fix violations</span></span>

<span data-ttu-id="3a683-121">Um einen Verstoß gegen diese Regel zu beheben, implementieren Sie eine neue Methode, die die gleiche Funktionalität verfügbar macht und für abgeleitete Typen sichtbar ist, oder ändern Sie zu einer nicht expliziten Implementierung.</span><span class="sxs-lookup"><span data-stu-id="3a683-121">To fix a violation of this rule, implement a new method that exposes the same functionality and is visible to derived types or change to a nonexplicit implementation.</span></span> <span data-ttu-id="3a683-122">Wenn ein Breaking Change akzeptabel ist, besteht eine Alternative darin, den Typ versiegelt zu machen.</span><span class="sxs-lookup"><span data-stu-id="3a683-122">If a breaking change is acceptable, an alternative is to make the type sealed.</span></span>

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="3a683-123">Wann sollten Warnungen unterdrückt werden?</span><span class="sxs-lookup"><span data-stu-id="3a683-123">When to suppress warnings</span></span>

<span data-ttu-id="3a683-124">Es ist sicher, eine Warnung aus dieser Regel zu unterdrücken, wenn eine extern sichtbare Methode bereitgestellt wird, die über die gleiche Funktionalität, aber einen anderen Namen als die explizit implementierte Methode verfügt.</span><span class="sxs-lookup"><span data-stu-id="3a683-124">It is safe to suppress a warning from this rule if an externally visible method is provided that has the same functionality but a different name than the explicitly implemented method.</span></span>

## <a name="example"></a><span data-ttu-id="3a683-125">Beispiel</span><span class="sxs-lookup"><span data-stu-id="3a683-125">Example</span></span>

<span data-ttu-id="3a683-126">Das folgende Beispiel zeigt einen Typ, `ViolatingBase` , der gegen die Regel verstößt, und einen Typ, `FixedBase` , der eine Korrektur für die Verletzung anzeigt.</span><span class="sxs-lookup"><span data-stu-id="3a683-126">The following example shows a type, `ViolatingBase`, that violates the rule and a type, `FixedBase`, that shows a fix for the violation.</span></span>

:::code language="csharp" source="snippets/csharp/all-rules/ca1033.cs" id="snippet1":::

## <a name="see-also"></a><span data-ttu-id="3a683-127">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="3a683-127">See also</span></span>

- [<span data-ttu-id="3a683-128">Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="3a683-128">Interfaces</span></span>](../../../csharp/programming-guide/interfaces/index.md)
