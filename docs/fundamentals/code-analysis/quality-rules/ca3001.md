---
title: 'CA3001: Überprüfen von Code auf Sicherheitsanfälligkeiten der SQL-Injektion (Code Analyse)'
description: 'Weitere Informationen zur Code Analyse Regel CA3001: Überprüfen von Code auf Sicherheitsanfälligkeiten in SQL'
ms.date: 04/03/2019
ms.topic: reference
author: dotpaul
ms.author: paulming
dev_langs:
- CSharp
- VB
ms.openlocfilehash: 01cafc45e05b809ecc21ebd82ffa0f215e5f1925
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/25/2020
ms.locfileid: "96591509"
---
# <a name="ca3001-review-code-for-sql-injection-vulnerabilities"></a>CA3001: Review code for SQL injection vulnerabilities (Überprüfen von Code auf Sicherheitsrisiken durch Einschleusung von SQL-Befehlen)

| | Wert |
|-|-|
| **Regel-ID** |CA3001|
| **Kategorie** |Microsoft.Security|
| **Behebung ist unterbrechend oder nicht unterbrechend** |Nicht unterbrechend|

## <a name="cause"></a>Ursache

Potenziell nicht vertrauenswürdige HTTP-Anforderungs Eingaben erreichen den Text eines SQL-Befehls.

Standardmäßig analysiert diese Regel die gesamte CodeBase, aber dies ist [konfigurierbar](#configurability).

## <a name="rule-description"></a>Regelbeschreibung

Beachten Sie beim Arbeiten mit nicht vertrauenswürdigen Eingabe-und SQL-Befehlen, dass SQL-Injection-Angriffe berücksichtigt werden. Ein SQL Injection-Angriff kann bösartige SQL-Befehle ausführen und so die Sicherheit und Integrität Ihrer Anwendung beeinträchtigen. Typische Techniken umfassen die Verwendung eines einfachen Anführungs Zeichens oder Apostroph zum Begrenzen von Literalzeichenfolgen, zwei Bindestrichen für einen Kommentar und ein Semikolon für das Ende einer Anweisung. Weitere Informationen finden Sie unter [Einschleusung von SQL-Befehlen](/sql/relational-databases/security/sql-injection).

Diese Regel versucht, Eingaben von HTTP-Anforderungen zu suchen, die den Text eines SQL-Befehls erreichen.

> [!NOTE]
> Diese Regel kann keine Daten über Assemblys hinweg verfolgen. Wenn eine Assembly z. b. die HTTP-Anforderungs Eingabe liest und Sie dann an eine andere Assembly übergibt, die den SQL-Befehl ausführt, erzeugt diese Regel keine Warnung.

> [!NOTE]
> Es gibt eine konfigurierbare Beschränkung, wie tief diese Regel den Datenfluss über Methodenaufrufe hinweg analysieren wird. Weitere Informationen zum Konfigurieren des Limits in einer Editor config-Datei finden Sie unter [Analyse Konfiguration](https://github.com/dotnet/roslyn-analyzers/blob/master/docs/Analyzer%20Configuration.md#dataflow-analysis) .

## <a name="how-to-fix-violations"></a>Behandeln von Verstößen

Verwenden Sie parametrisierte SQL-Befehle oder gespeicherte Prozeduren mit Parametern, die die nicht vertrauenswürdige Eingabe enthalten.

## <a name="when-to-suppress-warnings"></a>Wann sollten Warnungen unterdrückt werden?

Es ist sicher, eine Warnung aus dieser Regel zu unterdrücken, wenn Sie wissen, dass die Eingabe immer anhand eines bekannten sicheren Satzes von Zeichen überprüft wird.

## <a name="configurability"></a>Konfigurierbarkeit

Diese Regel verfügt über die folgenden konfigurierbaren Optionen.

### <a name="excluded-symbol-names"></a>Ausgeschlossene Symbolnamen

Sie können konfigurieren, welche Teile Ihrer Codebasis von der Analyse ausgeschlossen werden sollen. Um z. b. anzugeben, dass die Regel nicht für Code innerhalb von Typen mit dem Namen ausgeführt `MyType` werden soll, fügen Sie das folgende Schlüssel-Wert-Paar in eine *Editor config* -Datei in Ihrem Projekt ein:

```ini
dotnet_code_quality.CA3001.excluded_symbol_names = MyType
```

Zulässige Symbol namens Formate im Optionswert (durch getrennt `|` ):

- Nur Symbol Name (schließt alle Symbole mit dem Namen ein, unabhängig vom enthaltenden Typ oder Namespace)
- Voll qualifizierte Namen im [Dokumentations-ID-Format](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)des Symbols. Jeder Symbol Name erfordert ein Symbolart-Präfix, z. b. "M:"-Präfix für Methoden, `T:` Präfix für Typen, "N:"-Präfix für Namespaces usw.
- `.ctor` für Konstruktoren und `.cctor` für statische Konstruktoren

Beispiele:

| Optionswert | Zusammenfassung |
| --- | --- |
|`dotnet_code_quality.CA3001.excluded_symbol_names = MyType` | Entspricht allen Symbolen mit dem Namen "MyType" in der Kompilierung.
|`dotnet_code_quality.CA3001.excluded_symbol_names = MyType1|MyType2` | Entspricht allen Symbolen mit dem Namen "MyType1" oder "MyType2" in der Kompilierung.
|`dotnet_code_quality.CA3001.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Entspricht der bestimmten Methode "MyMethod" mit der angegebenen voll qualifizierten Signatur.
|`dotnet_code_quality.CA3001.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Entspricht den spezifischen Methoden "MyMethod1" und "MyMethod2" mit der entsprechenden voll qualifizierten Signatur.

Sie können all diese Optionen für diese Regel, für alle Regeln oder für alle Regeln in dieser Kategorie (Sicherheit) konfigurieren. Weitere Informationen finden Sie unter [Konfigurationsoptionen für die Code Qualitäts Regel](../code-quality-rule-options.md).

## <a name="pseudo-code-examples"></a>Pseudo Codebeispiele

### <a name="violation"></a>Verletzung

```csharp
using System;
using System.Data;
using System.Data.SqlClient;

namespace TestNamespace
{
    public partial class WebForm : System.Web.UI.Page
    {
        public static string ConnectionString { get; set; }

        protected void Page_Load(object sender, EventArgs e)
        {
            string name = Request.Form["product_name"];
            using (SqlConnection connection = new SqlConnection(ConnectionString))
            {
                SqlCommand sqlCommand = new SqlCommand()
                {
                    CommandText = "SELECT ProductId FROM Products WHERE ProductName = '" + name + "'",
                    CommandType = CommandType.Text,
                };

                SqlDataReader reader = sqlCommand.ExecuteReader();
            }
        }
    }
}
```

```vb
Imports System
Imports System.Data
Imports System.Data.SqlClient
Imports System.Linq

Namespace VulnerableWebApp
    Partial Public Class WebForm
        Inherits System.Web.UI.Page

        Public Property ConnectionString As String

        Protected Sub Page_Load(sender As Object, e As EventArgs)
            Dim name As String = Me.Request.Form("product_name")
            Using connection As SqlConnection = New SqlConnection(ConnectionString)
                Dim sqlCommand As SqlCommand = New SqlCommand With {.CommandText = "SELECT ProductId FROM Products WHERE ProductName = '" + name + "'",
                                                                    .CommandType = CommandType.Text}
                Dim reader As SqlDataReader = sqlCommand.ExecuteReader()
            End Using
        End Sub
    End Class
End Namespace
```

### <a name="parameterized-solution"></a>Parametrisierte Lösung

```csharp
using System;
using System.Data;
using System.Data.SqlClient;

namespace TestNamespace
{
    public partial class WebForm : System.Web.UI.Page
    {
        public static string ConnectionString { get; set; }

        protected void Page_Load(object sender, EventArgs e)
        {
            string name = Request.Form["product_name"];
            using (SqlConnection connection = new SqlConnection(ConnectionString))
            {
                SqlCommand sqlCommand = new SqlCommand()
                {
                    CommandText = "SELECT ProductId FROM Products WHERE ProductName = @productName",
                    CommandType = CommandType.Text,
                };

                sqlCommand.Parameters.Add("@productName", SqlDbType.NVarChar, 128).Value = name;

                SqlDataReader reader = sqlCommand.ExecuteReader();
            }
        }
    }
}
```

```vb
Imports System
Imports System.Data
Imports System.Data.SqlClient
Imports System.Linq

Namespace VulnerableWebApp
    Partial Public Class WebForm
        Inherits System.Web.UI.Page

        Public Property ConnectionString As String

        Protected Sub Page_Load(sender As Object, e As EventArgs)
            Dim name As String = Me.Request.Form("product_name")
            Using connection As SqlConnection = New SqlConnection(ConnectionString)
                Dim sqlCommand As SqlCommand = New SqlCommand With {.CommandText = "SELECT ProductId FROM Products WHERE ProductName = @productName",
                                                                    .CommandType = CommandType.Text}
                sqlCommand.Parameters.Add("@productName", SqlDbType.NVarChar, 128).Value = name
                Dim reader As SqlDataReader = sqlCommand.ExecuteReader()
            End Using
        End Sub
    End Class
End Namespace
```

### <a name="stored-procedure-solution"></a>Lösung für eine gespeicherte Prozedur

```csharp
using System;
using System.Data;
using System.Data.SqlClient;

namespace TestNamespace
{
    public partial class WebForm : System.Web.UI.Page
    {
        public static string ConnectionString { get; set; }

        protected void Page_Load(object sender, EventArgs e)
        {
            string name = Request.Form["product_name"];
            using (SqlConnection connection = new SqlConnection(ConnectionString))
            {
                SqlCommand sqlCommand = new SqlCommand()
                {
                    CommandText = "sp_GetProductIdFromName",
                    CommandType = CommandType.StoredProcedure,
                };

                sqlCommand.Parameters.Add("@productName", SqlDbType.NVarChar, 128).Value = name;

                SqlDataReader reader = sqlCommand.ExecuteReader();
            }
        }
    }
}
```

```vb
Imports System
Imports System.Data
Imports System.Data.SqlClient
Imports System.Linq

Namespace VulnerableWebApp
    Partial Public Class WebForm
        Inherits System.Web.UI.Page

        Public Property ConnectionString As String

        Protected Sub Page_Load(sender As Object, e As EventArgs)
            Dim name As String = Me.Request.Form("product_name")
            Using connection As SqlConnection = New SqlConnection(ConnectionString)
                Dim sqlCommand As SqlCommand = New SqlCommand With {.CommandText = "sp_GetProductIdFromName",
                                                                    .CommandType = CommandType.StoredProcedure}
                sqlCommand.Parameters.Add("@productName", SqlDbType.NVarChar, 128).Value = name
                Dim reader As SqlDataReader = sqlCommand.ExecuteReader()
            End Using
        End Sub
    End Class
End Namespace
```
