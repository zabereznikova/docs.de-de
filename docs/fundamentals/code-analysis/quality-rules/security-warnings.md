---
title: Sicherheitsregeln (Code Analyse)
description: Erfahren Sie mehr über die Sicherheitsregeln für die Code Analyse.
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security rules
- managed code analysis rules, security rules
- rules, security
author: gewarren
ms.author: gewarren
ms.openlocfilehash: e907905b065d786fc8b3c370fb2d2e2b19e62a2b
ms.sourcegitcommit: 5114e7847e0ff8ddb8c266802d47af78567949cf
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/19/2020
ms.locfileid: "96592095"
---
# <a name="security-rules"></a>Sicherheitsregeln

Sicherheitsregeln unterstützen sicherere Bibliotheken und Anwendungen. Diese Regeln helfen dabei, Sicherheitslücken im Programm zu vermeiden. Wenn Sie diese Regeln deaktivieren, sollten Sie den Grund im Code eindeutig markieren und den designierten Sicherheitsbeauftragten für Ihr Entwicklungsprojekt informieren.

## <a name="in-this-section"></a>In diesem Abschnitt

|Regel|Beschreibung|
|----------|-----------------|
|[CA2100: SQL-Abfragen auf Sicherheitsrisiken überprüfen.](ca2100.md)|Eine Methode legt die System.Data.IDbCommand.CommandText-Eigenschaft mithilfe einer Zeichenfolge fest, die aus einem Zeichenfolgenargument für die Methode erstellt wird. Diese Regel setzt voraus, dass das Zeichenfolgenargument Benutzereingaben enthält. Eine aus Benutzereingaben erstellte SQL-Befehlszeichenfolge ist anfällig für SQL-Injection-Angriffe.|
|[CA2109: Sichtbare Ereignishandler überprüfen.](ca2109.md)|Eine öffentliche oder geschützte Ereignisbehandlungsmethode wurde erkannt. Ereignisbehandlungsmethoden sollten nur dann verfügbar gemacht werden, wenn dies absolut notwendig ist.|
|[CA2119: Methoden versiegeln, die die Bedingungen privater Schnittstellen erfüllen.](ca2119.md)|Ein vererbbarer öffentlicher Typ stellt eine überschreibbare Methodenimplementierung einer internen Schnittstelle (Friend in Visual Basic) bereit. Um einen Verstoß gegen diese Regel zu beheben, verhindern Sie, dass die Methode außerhalb der Assembly überschrieben wird.|
|[CA2153: Verhindern, dass Ausnahmen bei Beschädigungen verarbeitet werden.](ca2153.md)|[Ausnahmen bei Beschädigungen (Corrupted State Exceptions, CSE)](/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) weisen auf eine Speicherbeschädigung innerhalb des Prozesses hin. Diese abzufangen, statt einen Absturz des Prozesses zuzulassen, führt zu Sicherheitsrisiken, falls ein Angreifer einen Exploit in den beschädigten Speicherbereich einschleusen kann.|
|[CA2300: Nicht den unsicheren BinaryFormatter zur Deserialisierung verwenden](ca2300.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2301: BinaryFormatter.Deserialize nicht ohne Festlegung von BinaryFormatter.Binder aufrufen](ca2301.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2302: Festlegung von BinaryFormatter.Binder vor dem Aufruf von BinaryFormatter.Deserialize sicherstellen](ca2302.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2305: Unsicheren Deserialisierer nicht verwenden: LosFormatter](ca2305.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2310: Unsicheren Deserialisierer nicht verwenden: NetDataContractSerializer](ca2310.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2311: Nicht deserialisieren, ohne zuerst NetDataContractSerializer.Binder festzulegen](ca2311.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2312: Vor dem Deserialisieren sicherstellen, dass NetDataContractSerializer.Binder festgelegt ist](ca2312.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2315: Unsicheren Deserialisierer nicht verwenden: ObjectStateFormatter](ca2315.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2321: Nicht mit JavaScriptSerializer und SimpleTypeResolver deserialisieren](ca2321.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2322: Vor dem Deserialisieren sicherstellen, dass JavaScriptSerializer nicht mit SimpleTypeResolver initialisiert ist](ca2322.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2326: Keine anderen TypeNameHandling-Werte als None (Keine) verwenden](ca2326.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2327: Keine unsichere JsonSerializerSettings-Klasse verwenden](ca2327.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2328: Sicherstellen, dass JsonSerializerSettings sicher ist](ca2328.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2329: Nicht mit JsonSerializer mit unsicherer Konfiguration deserialisieren](ca2329.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2330: Sicherstellen, dass JsonSerializer eine sichere Konfiguration bei der Deserialisierung verwendet](ca2330.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2350: Sicherstellen, dass die Eingabe von DataTable.ReadXml() vertrauenswürdig ist](ca2350.md)|Beim Deserialisieren eines <xref:System.Data.DataTable> mit nicht vertrauenswürdiger Eingabe kann ein Angreifer böswillige Eingaben erstellen, um einen Denial-of-Service-Angriff auszuführen. Möglicherweise gibt es unbekannte Sicherheitsrisiken bei der Remote Codeausführung.|
|[CA2351: Sicherstellen, dass die Eingabe von DataSet.ReadXml() vertrauenswürdig ist](ca2351.md)|Beim Deserialisieren eines <xref:System.Data.DataSet> mit nicht vertrauenswürdiger Eingabe kann ein Angreifer böswillige Eingaben erstellen, um einen Denial-of-Service-Angriff auszuführen. Möglicherweise gibt es unbekannte Sicherheitsrisiken bei der Remote Codeausführung.|
|[CA2352: Unsichere DataSet- oder DataTable-Elemente in einem serialisierbaren Typ können anfällig für Angriffe durch Remotecodeausführung sein](ca2352.md)|Eine mit markierte Klasse oder Struktur <xref:System.SerializableAttribute> enthält ein <xref:System.Data.DataSet> <xref:System.Data.DataTable> -oder-Feld oder eine-Eigenschaft und verfügt nicht über eine <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> .|
|[CA2353: Unsichere DataSet- oder DataTable-Elemente in einem serialisierbaren Typ](ca2353.md)|Eine Klasse oder Struktur, die mit einem XML-serialisierungsattribut oder einem Daten Vertrags Attribut gekennzeichnet ist, enthält ein- <xref:System.Data.DataSet> <xref:System.Data.DataTable> Feld oder eine-Eigenschaft.|
|[CA2354: Unsichere DataSet- oder DataTable-Elemente in einem deserialisierten Objektgraph können anfällig für Angriffe durch Remotecodeausführung sein](ca2354.md)|Die Deserialisierung mit einem <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> serialisierten und das Objekt Diagramm des umgewandelt Type kann ein-oder-Objekt enthalten <xref:System.Data.DataSet> <xref:System.Data.DataTable> .|
|[CA2355: Unsichere DataSet- oder DataTable-Elemente in einem deserialisierten Objektgraph](ca2355.md)|Deserialisierung, wenn das Objekt Diagramm des eingefügten oder des angegebenen Typs ein oder ein enthalten kann <xref:System.Data.DataSet> <xref:System.Data.DataTable> .|
|[CA2356: unsicheres DataSet oder Datentabelle im webdeserialisierten Objekt Diagramm](ca2356.md)|Eine Methode mit einem <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> oder <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> weist einen Parameter auf, der auf <xref:System.Data.DataSet> oder verweisen kann <xref:System.Data.DataTable> .|
|[CA2361: Sicherstellen, dass die automatisch generierte Klasse mit DataSet.ReadXml() nicht mit nicht vertrauenswürdigen Daten verwendet wird](ca2361.md)|Beim Deserialisieren eines <xref:System.Data.DataSet> mit nicht vertrauenswürdiger Eingabe kann ein Angreifer böswillige Eingaben erstellen, um einen Denial-of-Service-Angriff auszuführen. Möglicherweise gibt es unbekannte Sicherheitsrisiken bei der Remote Codeausführung.|
|[CA2362: Ein unsicheres DataSet- oder DataTable-Element in einem automatisch generierten, serialisierbaren Typ kann für Angriffe durch Remotecodeausführung anfällig sein](ca2362.md)|Wenn nicht vertrauenswürdige Eingaben mit <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> deserialisiert werden und das deserialisierte Objekt Diagramm ein-oder-Objekt enthält <xref:System.Data.DataSet> <xref:System.Data.DataTable> , kann ein Angreifer eine schädliche Nutzlast erstellen, um einen Remote Code Ausführungs Angriff auszuführen.|
|[CA3001: Review code for SQL injection vulnerabilities (Überprüfen von Code auf Sicherheitsrisiken durch Einschleusung von SQL-Befehlen)](ca3001.md)|Beachten Sie beim Arbeiten mit nicht vertrauenswürdigen Eingabe-und SQL-Befehlen, dass SQL-Injection-Angriffe berücksichtigt werden. Ein SQL Injection-Angriff kann bösartige SQL-Befehle ausführen und so die Sicherheit und Integrität Ihrer Anwendung beeinträchtigen.|
|[CA3002: Review code for XSS vulnerabilities (Überprüfen von Code auf Sicherheitsrisiken durch XSS)](ca3002.md)|Beachten Sie beim Arbeiten mit nicht vertrauenswürdigen Eingaben aus Webanforderungen, dass XSS-Angriffe (Cross-Site Scripting) berücksichtigt werden. Ein XSS-Angriff fügt nicht vertrauenswürdige Eingaben in die unformatierte HTML-Ausgabe ein, sodass der Angreifer bösartige Skripts ausführen oder den Inhalt auf der Webseite in böswilliger Absicht ändern kann.|
|[CA3003: Review code for file path injection vulnerabilities (Überprüfen von Code auf Sicherheitsrisiken durch Einschleusungen über einen Dateipfad)](ca3003.md)|Wenn Sie mit nicht vertrauenswürdigen Eingaben aus Webanforderungen arbeiten, achten Sie darauf, benutzergesteuerte Eingaben beim Angeben von Pfaden zu Dateien zu verwenden.|
|[CA3004: Review code for information disclosure vulnerabilities (Überprüfen von Code auf Sicherheitsrisiken bei der Veröffentlichung von Informationen)](ca3004.md)|Die Offenlegung von Ausnahme Informationen bietet Angreifern Einblicke in die internale Ihrer Anwendung, die Angreifern bei der Suche nach anderen Sicherheitsrisiken helfen können.|
|[CA3006: Review code for process command injection vulnerabilities (Überprüfen von Code auf Sicherheitsrisiken durch Einschleusung von Prozessbefehlen)](ca3006.md)|Beachten Sie bei der Arbeit mit nicht vertrauenswürdigen Eingaben, dass Befehls Injection-Angriffe berücksichtigt werden. Ein Befehl zum Einschleusen von Befehlen kann bösartige Befehle auf dem zugrunde liegenden Betriebssystem ausführen und so die Sicherheit und Integrität des Servers beeinträchtigen.|
|[CA3007: Review code for open redirect vulnerabilities (Überprüfen von Code auf Sicherheitsrisiken durch offene Umleitungen)](ca3007.md)|Beachten Sie bei der Arbeit mit nicht vertrauenswürdigen Eingaben die Sicherheitsrisiken offener Umleitung. Ein Angreifer kann eine offene Umleitungs Anfälligkeit ausnutzen, um die Darstellung einer legitimen URL mithilfe Ihrer Website zu versehen, aber einen nicht ahnenden Besucher an eine phishingwebseite oder eine andere böswillige Webseite umzuleiten.|
|[CA3008: Review code for XPath injection vulnerabilities (Überprüfen von Code auf Sicherheitsrisiken durch Einschleusungen von XPath-Befehlen)](ca3008.md)|Beachten Sie bei der Arbeit mit nicht vertrauenswürdigen Eingaben die XPath-Injection-Angriffe. Das Erstellen von XPath-Abfragen mithilfe nicht vertrauenswürdiger Eingaben kann es einem Angreifer ermöglichen, die Abfrage bösartig zu manipulieren, um ein unbeabsichtigtes Ergebnis zurückzugeben, und möglicherweise den Inhalt der abgefragten XML-Daten offenzulegen.|
|[CA3009: Review code for XML injection vulnerabilities (Überprüfen von Code auf Sicherheitsrisiken durch Einschleusungen von XML-Befehlen)](ca3009.md)|Beachten Sie bei der Arbeit mit nicht vertrauenswürdigen Eingaben, dass XML-Injection-Angriffe berücksichtigt werden.|
|[CA3010: Review code for XAML injection vulnerabilities (Überprüfen von Code auf Sicherheitsrisiken durch Einschleusungen von XAML-Befehlen)](ca3010.md)|Beachten Sie bei der Arbeit mit nicht vertrauenswürdigen Eingaben XAML Injection-Angriffe. XAML ist eine Markupsprache, die Objektinstanziierung und -ausführung direkt darstellt. Dies bedeutet, dass in XAML erstellte Elemente mit Systemressourcen interagieren können (z. b. Netzwerk Zugriff und Dateisystem-e/a).|
|[CA3011: Review code for DLL injection vulnerabilities (Überprüfen von Code auf Sicherheitsrisiken durch Einschleusungen von DLL)](ca3011.md)|Wenn Sie mit nicht vertrauenswürdigen Eingaben arbeiten, achten Sie darauf, nicht vertrauenswürdigen Code zu laden. Wenn Ihre Webanwendung nicht vertrauenswürdigen Code lädt, kann ein Angreifer möglicherweise böswillige DLLs in Ihren Prozess einfügen und bösartigen Code ausführen.|
|[CA3012: Review code for regex injection vulnerabilities (Überprüfen von Code auf Sicherheitsrisiken durch Einschleusungen von RegEx)](ca3012.md)|Beachten Sie bei der Arbeit mit nicht vertrauenswürdigen Eingaben die Regex Injection-Angriffe. Ein Angreifer kann eine Regex-Injektion verwenden, um einen regulären Ausdruck in böswilliger Weise zu ändern, damit der Regex unbeabsichtigte Ergebnisse findet oder der Regex übermäßige CPU beansprucht, was zu einem Denial-of-Service-Angriff führt.|
|[CA3061: Fügen Sie kein Schema nach URL hinzu.](ca3061.md)|Verwenden Sie die unsichere Überladung der Add-Methode nicht, da Sie gefährliche externe Verweise verursachen kann.|
|[CA3075: Unsichere DTD-Verarbeitung.](ca3075.md)|Wenn Sie unsichere DTDProcessing-Instanzen verwenden oder auf externe Entitätsquellen verweisen, kann der Parser unter Umständen nicht vertrauenswürdige Eingaben akzeptieren und Angreifern vertrauliche Informationen offenlegen.|
|[CA3076: Unsichere XSLT-Skriptausführung.](ca3076.md)|Wenn Sie XSLT (Extensible Stylesheet Language Transformations) in .NET-Anwendungen unsicher ausführen, löst der Prozessor möglicherweise nicht vertrauenswürdige URI-Verweise auf, die Angreifern vertrauliche Informationen offenlegen, was zu Denial-of-Service-und Site übergreifenden Angriffen führt.|
|[CA3077: Unsichere Verarbeitung in API-Design, XML-Dokument und XML-Textreader.](ca3077.md)|Beim Entwerfen einer von XMLDocument und XMLTextReader abgeleiteten API sollten Sie DtdProcessing berücksichtigen. Das Verwenden unsicherer DTDProcessing-Instanzen beim Verweisen auf externe Entitätsquellen bzw. bei deren Auflösung oder das Festlegen unsicherer Werte in XML-Code kann zum Offenlegen von Informationen führen.|
|[CA3147: Verbhandler mit ValidateAntiForgeryToken markieren.](ca3147.md)|Achten Sie beim Entwerfen eines ASP.NET-MVC-Controllers auf Site übergreifende Anforderungs Fälschungs Angriffe. Mit einem Website übergreifenden Anforderungs Fälschungs Angriff können böswillige Anforderungen von einem authentifizierten Benutzer an Ihren ASP.NET MVC-Controller gesendet werden.|
|[CA5350: Keine schwachen Kryptografiealgorithmen verwenden.](ca5350.md)|Unsichere Verschlüsselungsalgorithmen und Hashfunktionen werden heute aus verschiedenen Gründen verwendet, sollten jedoch nicht verwendet werden, um die Vertrauenswürdigkeit oder Integrität der Daten, die sie schützen, zu gewährleisten. Dieser Regel wird ausgelöst, wenn im Code TripleDES-, SHA1- oder RIPEMD160-Algorithmen gefunden werden.|
|[CA5351: Verwenden Sie keine unterbrochenen Kryptografiealgorithmen.](ca5351.md)|Unterbrochene kryptografische Algorithmen werden nicht als sicher betrachtet; ihre Verwendung sollte unbedingt unterbunden werden. Diese Regel wird ausgelöst, wenn der MD5-Hash-Algorithmus oder DES- bzw. RC2-Verschlüsselungsalgorithmen im Code gefunden werden.|
|[CA5358: Verwenden Sie keine unsicheren Verschlüsselungsmodi.](ca5358.md)|Verwenden Sie keine unsicheren Verschlüsselungsmodi.|
|[CA5359: Zertifikatüberprüfung nicht deaktivieren](ca5359.md)|Ein Zertifikat kann bei der Authentifizierung der Identität des Servers helfen. Clients sollten das Serverzertifikat überprüfen, um sicherzustellen, dass Anforderungen an den vorgesehenen Server gesendet werden. Wenn servercertifikatevalidationcallback immer zurück `true` gegeben wird, übergibt jedes Zertifikat die Validierung.|
|[CA5360: Keine gefährlichen Methoden bei der Deserialisierung aufrufen.](ca5360.md)|Unsichere Deserialisierung ist ein Sicherheitsrisiko, das auftritt, wenn nicht vertrauenswürdige Daten verwendet werden, um die Logik einer Anwendung zu missbrauchen, einen Denial-of-Service-Angriff (DOS) zu verursachen oder sogar beliebigen Code auszuführen, wenn er deserialisiert wird. Es ist oft möglich, dass böswillige Benutzer diese deserialisierungsfeatures missbrauchen, wenn die Anwendung nicht vertrauenswürdige Daten deserialisiert, die unter ihrer Kontrolle sind. Rufen Sie insbesondere gefährliche Methoden im Prozess der Deserialisierung auf. Erfolgreiche unsichere deserialisierungsangriffe können einem Angreifer ermöglichen, Angriffe wie DOS-Angriffe, Authentifizierungs Umgehungen und Remote Codeausführung auszuführen.|
|[CA5361: die SChannel-Verwendung der starken Kryptografie nicht deaktivieren](ca5361.md)|Durch Festlegen `Switch.System.Net.DontEnableSchUseStrongCrypto` von auf `true` wird die Kryptografie für ausgehende Transport Layer Security Verbindungen (TLS) schwächer. Schwächere Kryptografie kann die Vertraulichkeit der Kommunikation zwischen Ihrer Anwendung und dem Server beeinträchtigen, sodass Angreifer die Möglichkeit erhalten, sensible Daten besser zu löschen.|
|[CA5362: Potenzieller Verweiszyklus in deserialisiertem Objektgraph](ca5362.md)|Wenn nicht vertrauenswürdige Daten deserialisiert werden, muss jeder Code, der das deserialisierte Objekt Diagramm verarbeitet, Verweis Zyklen verarbeiten, ohne in unendliche Schleifen zu wechseln. Dies umfasst sowohl Code, der Teil eines deserialisierungsrückrufs ist, als auch Code, der das Objekt Diagramm nach Abschluss der Deserialisierung verarbeitet. Andernfalls könnte ein Angreifer einen Denial-of-Service-Angriff mit bösartigen Daten durchführen, die einen Verweis-Cycle enthalten.|
|[CA5363: Deaktivieren Sie die Anforderungsüberprüfung nicht.](ca5363.md)|Die Anforderungs Validierung ist eine Funktion in ASP.net, die HTTP-Anforderungen untersucht und bestimmt, ob Sie potenziell gefährlichen Inhalt enthalten, der zu Injection-Angriffen führen kann, einschließlich Website übergreifender Skripts.|
|[CA5364: Verwenden Sie keine veralteten Sicherheitsprotokolle.](ca5364.md)|Transport Layer Security (TLS) sichert die Kommunikation zwischen Computern, in der Regel mit HTTPS (Hypertext Transfer Protocol Secure). Ältere Protokoll Versionen von TLS sind weniger sicher als TLS 1,2 und TLS 1,3 und haben wahrscheinlich neue Sicherheitsrisiken. Vermeiden Sie ältere Protokoll Versionen, um Risiken zu minimieren.|
|[CA5365: Überprüfung von HTTP-Headern nicht deaktivieren](ca5365.md)|Die HTTP-Header Überprüfung ermöglicht das Codieren von Wagen Rücklauf-und Zeilenumbruch Zeichen (\r und \n), die in Antwort Headern gefunden werden. Diese Codierung kann dabei helfen, Injection-Angriffe zu vermeiden, die eine Anwendung ausnutzen, die nicht vertrauenswürdige Daten in der Kopfzeile wieder gibt.|
|[CA5366: XmlReader zum Lesen von DataSet-XML verwenden](ca5366.md)|Wenn Sie ein-Element <xref:System.Data.DataSet> zum Lesen von XML mit nicht vertrauenswürdigen Daten verwenden, werden möglicherweise gefährliche externe Verweise geladen, die mithilfe von <xref:System.Xml.XmlReader> mit einem sicheren Konflikt Löser oder mit deaktivierter DTD-Verarbeitung eingeschränkt werden sollten.|
|[CA5367: Typen mit Zeigerfeldern dürfen nicht serialisiert werden.](ca5367.md)|Diese Regel überprüft, ob eine serialisierbare Klasse mit einem Zeiger Feld oder einer Eigenschaft vorhanden ist. Member, die nicht serialisiert werden können, können ein Zeiger sein, z. b. statische Member oder Felder, die mit gekennzeichnet sind <xref:System.NonSerializedAttribute> .|
|[CA5368: Festlegen von ViewStateUserKey für von der Seite abgeleitete Klassen](ca5368.md)|Das Festlegen der- <xref:System.Web.UI.Page.ViewStateUserKey> Eigenschaft kann Ihnen helfen, Angriffe auf Ihre Anwendung zu verhindern, indem Sie der Ansichts Zustandsvariablen für einzelne Benutzer einen Bezeichner zuweisen können, sodass Angreifer die Variable nicht zum Generieren eines Angriffs verwenden können. Andernfalls gibt es Sicherheitsrisiken für die Website übergreifende Anforderungs Fälschung.|
|[CA5369: Verwenden Sie XmlReader zur Deserialisierung.](ca5369.md)|Die Verarbeitung von nicht vertrauenswürdigen DTD-und XML-Schemas kann das Laden gefährlicher externer Verweise ermöglichen, das durch die Verwendung eines XmlReader mit einem sicheren Konflikt Löser oder durch deaktivierte DTD-und XML-Inline Schema Verarbeitung eingeschränkt werden sollte.|
|[CA5370: Verwenden Sie XmlReader als überprüfenden Reader.](ca5370.md)|Die Verarbeitung von nicht vertrauenswürdigen DTD-und XML-Schemas kann das Laden gefährlicher externer Verweise ermöglichen. Dieses gefährliche laden kann durch die Verwendung eines XmlReader mit einem sicheren Konflikt Löser oder durch deaktivierte DTD-und XML-Inline Schema Verarbeitung eingeschränkt werden.|
|[CA5371: Verwenden Sie XmlReader für Schemalesevorgänge.](ca5371.md)|Die Verarbeitung von nicht vertrauenswürdigen DTD-und XML-Schemas kann das Laden gefährlicher externer Verweise ermöglichen. Dies wird durch die Verwendung eines XmlReader mit einem sicheren Konflikt Löser oder mit deaktivierter DTD-und XML-Inline Schema Verarbeitung eingeschränkt.|
|[CA5372: Verwenden Sie XmlReader für XPathDocument.](ca5372.md)|Beim Verarbeiten von XML aus nicht vertrauenswürdigen Daten können gefährliche externe Verweise geladen werden, die durch die Verwendung eines XmlReader mit einem sicheren Konflikt Löser oder deaktivierter DTD-Verarbeitung eingeschränkt werden können.|
|[CA5373: Verwenden Sie keine veraltete Schlüsselableitungsfunktion.](ca5373.md)|Diese Regel erkennt den Aufruf von schwachen Schlüssel abderivations Methoden <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> und `Rfc2898DeriveBytes.CryptDeriveKey` . <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> ein schwacher Algorithmus PBKDF1 wurde verwendet.|
|[CA5374: Kein XslTransform verwenden](ca5374.md)|Diese Regel überprüft, ob <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> im Code instanziiert wird. <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> ist mittlerweile veraltet und sollte nicht verwendet werden.|
|[CA5375: Shared Access Signature des Kontos nicht verwenden.](ca5375.md)|Eine Konto-SAS kann den Zugriff auf Lese-, Schreib-und Löschvorgänge für BLOB-Container, Tabellen, Warteschlangen und Dateifreigaben delegieren, die mit einer Dienst-SAS nicht zulässig sind. Es unterstützt jedoch keine Richtlinien auf Container Ebene und bietet weniger Flexibilität und Kontrolle über die gewährten Berechtigungen. Wenn böswillige Benutzer diese erhalten haben, wird Ihr Speicherkonto problemlos kompromittiert.|
|[CA5376: SharedAccessProtocol.HttpsOnly verwenden.](ca5376.md)|Bei SAS handelt es sich um sensible Daten, die nicht als Klartext über HTTP übertragen werden können.|
|[CA5377: Zugriffsrichtlinie auf Containerebene verwenden.](ca5377.md)|Eine Zugriffs Richtlinie auf Container Ebene kann jederzeit geändert oder widerrufen werden. Sie bietet mehr Flexibilität und Kontrolle über die gewährten Berechtigungen.|
|[CA5378: Deaktivieren Sie ServicePointManagerSecurityProtocols nicht.](ca5378.md)|Durch das Festlegen `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` von auf werden `true` die (WCF)-Transport Layer Security (WCF)-Verbindungen von Windows Communication Framework auf mithilfe von TLS 1,0 beschränkt. Diese Version von TLS wird als veraltet markiert.|
|[CA5379: sicherstellen, dass der Algorithmus der Schlüssel Ableitung funktioniert](ca5379.md)|Die- <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasse verwendet standardmäßig den- <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> Algorithmus. Sie sollten den Hash Algorithmus angeben, der in einigen über Ladungen des Konstruktors mit oder höher verwendet werden soll <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> . Beachten Sie, dass <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> die-Eigenschaft nur über einen `get` -Accessor verfügt und keinen- `overriden` Modifizierer aufweist.|
|[CA5380: Fügen Sie keine Zertifikate zum Stammspeicher hinzu.](ca5380.md)|Diese Regel erkennt Code, der ein Zertifikat in den Zertifikat Speicher für vertrauenswürdige Stamm Zertifizierungsstellen einfügt. Standardmäßig ist der Zertifikat Speicher für vertrauenswürdige Stamm Zertifizierungsstellen mit einer Gruppe von öffentlichen Zertifizierungsstellen konfiguriert, die die Anforderungen des Microsoft-Programms für Stamm Zertifikate erfüllt haben.|
|[CA5381: Stellen Sie sicher, dass keine Zertifikate zum Stammspeicher hinzugefügt werden.](ca5381.md)|Mit dieser Regel wird Code erkannt, der potenziell ein Zertifikat in den Zertifikat Speicher für vertrauenswürdige Stamm Zertifizierungsstellen einfügt. Standardmäßig ist der Zertifikat Speicher für vertrauenswürdige Stamm Zertifizierungsstellen mit einer Reihe von öffentlichen Zertifizierungsstellen (CAS) konfiguriert, die die Anforderungen des Microsoft-Programms für Stamm Zertifikate erfüllen.|
|[CA5382: Sichere Cookies in ASP.NET Core verwenden](ca5382.md)|Anwendungen, die über HTTPS verfügbar sind, müssen sichere Cookies verwenden, die dem Browser zeigen, dass das Cookie nur mit Transport Layer Security (TLS) übertragen werden soll.|
|[CA5383: Sicherstellen, dass sichere Cookies in ASP.NET Core verwendet werden](ca5383.md)|Anwendungen, die über HTTPS verfügbar sind, müssen sichere Cookies verwenden, die dem Browser zeigen, dass das Cookie nur mit Transport Layer Security (TLS) übertragen werden soll.|
|[CA5384: Digitalen Signaturalgorithmus (DSA) nicht verwenden](ca5384.md)|DSA ist ein schwacher Algorithmus für die asymmetrische Verschlüsselung.|
|[CA5385: RSA-Algorithmus (Rivest – Shamir – Adleman) mit ausreichender Schlüsselgröße verwenden](ca5385.md)|Ein RSA-Schlüssel, der kleiner als 2048 Bits ist, ist anfälliger für Brute-Force-Angriffe.|
|[CA5386: Vermeiden Sie die Hartcodierung des SecurityProtocolType-Werts.](ca5386.md)|Transport Layer Security (TLS) sichert die Kommunikation zwischen Computern, in der Regel mit HTTPS (Hypertext Transfer Protocol Secure). Die Protokoll Versionen TLS 1,0 und TLS 1,1 sind veraltet, TLS 1,2 und TLS 1,3 sind jedoch aktuell. In Zukunft können TLS 1,2 und TLS 1,3 als veraltet eingestuft werden. Um sicherzustellen, dass Ihre Anwendung sicher bleibt, vermeiden Sie das hart codieren einer Protokollversion und das Ziel mindestens .NET Framework v-4.7.1.|
|[CA5387: Schwache Schlüsselableitungsfunktion nicht mit unzureichender Iterationsanzahl verwenden](ca5387.md)|Mit dieser Regel wird überprüft, ob von ein Kryptografieschlüssel <xref:System.Security.Cryptography.Rfc2898DeriveBytes> mit einer Iterations Anzahl von weniger als 100.000 generiert wurde. Eine höhere iterations Anzahl kann bei der Vermeidung von Wörterbuchangriffen helfen, die versuchen, den generierten kryptografischen Schlüssel zu erraten.|
|[CA5388: Sicherstellen einer ausreichenden Iterationsanzahl bei Verwendung einer schwachen Schlüsselableitungsfunktion](ca5388.md)|Mit dieser Regel wird überprüft, ob von ein Kryptografieschlüssel <xref:System.Security.Cryptography.Rfc2898DeriveBytes> mit einer Iterations Anzahl generiert wurde, die möglicherweise kleiner als 100.000 ist. Eine höhere iterations Anzahl kann bei der Vermeidung von Wörterbuchangriffen helfen, die versuchen, den generierten kryptografischen Schlüssel zu erraten.|
|[CA5389: Fügen Sie den Pfad des Archivelements nicht zum Pfad des Zieldateisystems hinzu.](ca5389.md)|Der Dateipfad kann relativ sein und kann dazu führen, dass der Dateisystem Zugriff außerhalb des erwarteten Ziel Pfads für das Dateisystem ist, was zu schädlichen Konfigurationsänderungen und Remote Codeausführung über die Methode "Lay-and-Wait" führt.|
|[CA5390: Keine Hartcodierung von Verschlüsselungsschlüsseln](ca5390.md)|Damit ein symmetrischer Algorithmus erfolgreich ist, muss der geheime Schlüssel nur dem Absender und dem Empfänger bekannt sein. Wenn ein Schlüssel hart codiert ist, kann er leicht erkannt werden. Selbst bei kompilierten Binärdateien ist es für böswillige Benutzer leicht, Sie zu extrahieren. Nachdem der private Schlüssel kompromittiert wurde, kann der Chiffre Text direkt entschlüsselt werden und ist nicht mehr geschützt.|
|[CA5391: Fälschungssicherheitstoken in ASP.NET Core MVC-Controllern verwenden.](ca5391.md)|Das Verarbeiten einer- `POST` ,-,-oder-Anforderung, `PUT` `PATCH` `DELETE` ohne ein antifälschungstoken zu validieren, kann für Website übergreifende Anforderungs Fälschungs Angriffe anfällig sein. Mit einem Website übergreifenden Anforderungs Fälschungs Angriff können böswillige Anforderungen von einem authentifizierten Benutzer an Ihren ASP.net Core MVC-Controller gesendet werden.|
|[CA5392: DefaultDllImportSearchPaths-Attribut für P/Invokes verwenden.](ca5392.md)|Standardmäßig verwenden P/aufrufen Funktionen, indem Sie <xref:System.Runtime.InteropServices.DllImportAttribute> eine Reihe von Verzeichnissen testen, einschließlich des aktuellen Arbeitsverzeichnisses für die zu ladende Bibliothek. Dies kann ein Sicherheitsproblem für bestimmte Anwendungen sein, was zu einer DLL-Hijacking-Aktion führt.|
|[CA5393: Keinen unsicheren DllImportSearchPath-Wert verwenden.](ca5393.md)|In den standardmäßigen dll-Such Verzeichnissen und Assemblyverzeichnissen könnte eine bösartige dll vorhanden sein. Abhängig davon, wo Ihre Anwendung ausgeführt wird, kann es sich auch um eine bösartige dll im Verzeichnis der Anwendung handeln.|
|[CA5394: Keine unsichere Zufälligkeitsstufe verwenden](ca5394.md)|Die Verwendung eines kryptografisch schwachen Pseudozufallszahlen-Generators kann es einem Angreifer ermöglichen, vorherzusagen, welcher sicherheitsrelevante Wert generiert wird.|
|[CA5395: Fehlendes HttpVerb-Attribut für Aktionsmethoden.](ca5395.md)|Alle Aktionsmethoden, die Daten erstellen, bearbeiten, löschen oder anderweitig ändern, müssen durch das antifälschungs Attribut von Website übergreifenden Anforderungs Fälschungs Angriffen geschützt werden. Das Ausführen eines Get-Vorgangs sollte ein sicherer Vorgang sein, der keine Nebeneffekte hat und die beibehaltenen Daten nicht ändert.|
|[CA5396: HttpOnly für HttpCookie auf TRUE festlegen](ca5396.md)|Stellen Sie sicher, dass sicherheitsrelevante http-Cookies als "HttpOnly" gekennzeichnet sind. Dies bedeutet, dass Webbrowser das Zugreifen auf die Cookies durch Skripts nicht zulassen sollten. Injizierte schädliche Skripts sind eine gängige Methode zum stehlen von Cookies.|
|[CA5397: Verwenden Sie keine veralteten SslProtocols-Werte.](ca5397.md)|Transport Layer Security (TLS) sichert die Kommunikation zwischen Computern, in der Regel mit HTTPS (Hypertext Transfer Protocol Secure). Ältere Protokoll Versionen von TLS sind weniger sicher als TLS 1,2 und TLS 1,3 und haben wahrscheinlich neue Sicherheitsrisiken. Vermeiden Sie ältere Protokoll Versionen, um Risiken zu minimieren.|
|[CA5398: Vermeiden Sie hartcodierte SslProtocols-Werte.](ca5398.md)|Transport Layer Security (TLS) sichert die Kommunikation zwischen Computern, in der Regel mit HTTPS (Hypertext Transfer Protocol Secure). Die Protokoll Versionen TLS 1,0 und TLS 1,1 sind veraltet, TLS 1,2 und TLS 1,3 sind jedoch aktuell. In Zukunft können TLS 1,2 und TLS 1,3 als veraltet eingestuft werden. Vermeiden Sie das hart codieren einer Protokollversion, um sicherzustellen, dass Ihre Anwendung sicher bleibt.|
|[CA5399: Überprüfung der HttpClient-Zertifikatsperrliste definitiv deaktivieren](ca5399.md)|Ein gesperrtes Zertifikat ist nicht mehr vertrauenswürdig. Sie kann von Angreifern verwendet werden, die bei der HTTPS-Kommunikation schädliche Daten übergeben oder vertrauliche Daten stehlen.|
|[CA5400: Sicherstellen, dass die Überprüfung der HttpClient-Zertifikatsperrliste nicht deaktiviert ist](ca5400.md)|Ein gesperrtes Zertifikat ist nicht mehr vertrauenswürdig. Sie kann von Angreifern verwendet werden, die bei der HTTPS-Kommunikation schädliche Daten übergeben oder vertrauliche Daten stehlen.|
|[CA5401: CreateEncryptor nicht mit Nicht-Standard-Initialisierungsvektoren verwenden](ca5401.md)|Die symmetrische Verschlüsselung sollte immer einen nicht wiederholbaren Initialisierungs Vektor verwenden, um Wörterbuchangriffe zu verhindern.|
|[CA5402: CreateEncryptor mit Standard-Initialisierungsvektoren verwenden](ca5402.md)|Die symmetrische Verschlüsselung sollte immer einen nicht wiederholbaren Initialisierungs Vektor verwenden, um Wörterbuchangriffe zu verhindern.|
|[CA5403: Keine Hartcodierung von Zertifikaten](ca5403.md)|Der `data` - `rawData` Parameter oder der-Parameter eines- <xref:System.Security.Cryptography.X509Certificates.X509Certificate> oder- <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Konstruktors ist hart codiert.|
