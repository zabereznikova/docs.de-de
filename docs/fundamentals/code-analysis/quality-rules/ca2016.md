---
title: 'CA2016: den CancellationToken-Parameter an Methoden weiterleiten, die eine (Code Analyse) akzeptieren.'
description: 'Weitere Informationen zur Code Analyse Regel CA2016: Weiterleiten des CancellationToken-Parameters an Methoden, die eine'
ms.date: 06/18/2020
ms.topic: reference
f1_keywords:
- ForwardCancellationTokenToInvocations
- CA2016
helpviewer_keywords:
- ForwardCancellationTokenToInvocations
- CA2016
author: carlossanlop
ms.author: calope
dev_langs:
- CSharp
- VB
ms.openlocfilehash: d8d76ca576a4e175528f066741914739a570af41
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/25/2020
ms.locfileid: "96590638"
---
# <a name="ca2016-forward-the-cancellationtoken-parameter-to-methods-that-take-one"></a><span data-ttu-id="8a2d7-103">CA2016: Parameter "CancellationToken" an Methoden weiterleiten, die diesen Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="8a2d7-103">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>

| | <span data-ttu-id="8a2d7-104">Wert</span><span class="sxs-lookup"><span data-stu-id="8a2d7-104">Value</span></span> |
|-|-|
|<span data-ttu-id="8a2d7-105">TypName</span><span class="sxs-lookup"><span data-stu-id="8a2d7-105">TypeName</span></span>|<span data-ttu-id="8a2d7-106">Forwardcancellationzu kentoinvocations</span><span class="sxs-lookup"><span data-stu-id="8a2d7-106">ForwardCancellationTokenToInvocations</span></span>|
| <span data-ttu-id="8a2d7-107">**Regel-ID**</span><span class="sxs-lookup"><span data-stu-id="8a2d7-107">**Rule ID**</span></span> |<span data-ttu-id="8a2d7-108">CA2016</span><span class="sxs-lookup"><span data-stu-id="8a2d7-108">CA2016</span></span>|
| <span data-ttu-id="8a2d7-109">**Kategorie**</span><span class="sxs-lookup"><span data-stu-id="8a2d7-109">**Category**</span></span> |<span data-ttu-id="8a2d7-110">Microsoft. Performance</span><span class="sxs-lookup"><span data-stu-id="8a2d7-110">Microsoft.Performance</span></span>|
| <span data-ttu-id="8a2d7-111">**Behebung ist unterbrechend oder nicht unterbrechend**</span><span class="sxs-lookup"><span data-stu-id="8a2d7-111">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="8a2d7-112">Nicht unterbrechend</span><span class="sxs-lookup"><span data-stu-id="8a2d7-112">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="8a2d7-113">Ursache</span><span class="sxs-lookup"><span data-stu-id="8a2d7-113">Cause</span></span>

<span data-ttu-id="8a2d7-114">Diese Regel sucht Methodenaufrufe, die zwar einen Parameter akzeptieren <xref:System.Threading.CancellationToken> , aber keine übergeben, und schlägt vor, die übergeordneten Methoden an Sie weiterzuleiten `CancellationToken` .</span><span class="sxs-lookup"><span data-stu-id="8a2d7-114">This rule locates method invocations that could accept a <xref:System.Threading.CancellationToken> parameter, but are not passing any, and suggests to forward the parent method's `CancellationToken` to them.</span></span>

## <a name="rule-description"></a><span data-ttu-id="8a2d7-115">Regelbeschreibung</span><span class="sxs-lookup"><span data-stu-id="8a2d7-115">Rule description</span></span>

<span data-ttu-id="8a2d7-116">Diese Regel analysiert Methoden Definitionen, die einen `CancellationToken` als letzten Parameter annehmen, und analysiert dann alle Methoden, die im Textkörper aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="8a2d7-116">This rule analyzes method definitions that take a `CancellationToken` as their last parameter, then analyzes all methods invoked in its body.</span></span> <span data-ttu-id="8a2d7-117">Wenn einer der Methodenaufrufe entweder `CancellationToken` als letzten Parameter akzeptieren oder über eine Überladung verfügen, die `CancellationToken` als letzten Parameter als annimmt, schlägt die Regel die Verwendung dieser Option vor, um sicherzustellen, dass die Abbruch Benachrichtigung an alle Vorgänge weitergegeben wird, die darauf lauschen können.</span><span class="sxs-lookup"><span data-stu-id="8a2d7-117">If any of the method invocations can either accept a `CancellationToken` as the last parameter, or have an overload that takes a `CancellationToken` as the last parameter, then the rule suggests using that option instead to ensure that the cancellation notification gets propagated to all operations that can listen to it.</span></span>

> [!NOTE]
> <span data-ttu-id="8a2d7-118">Die Regel CA2016 ist in allen .NET-Versionen verfügbar, in denen der `CancellationToken` Typ verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="8a2d7-118">Rule CA2016 is available in all .NET versions where the `CancellationToken` type is available.</span></span> <span data-ttu-id="8a2d7-119">Weitere Informationen finden [Sie im Abschnitt CancellationToken "betrifft](/dotnet/api/system.threading.cancellationtoken#moniker-applies-to) ".</span><span class="sxs-lookup"><span data-stu-id="8a2d7-119">See [CancellationToken "Applies to" section](/dotnet/api/system.threading.cancellationtoken#moniker-applies-to)</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="8a2d7-120">Behandeln von Verstößen</span><span class="sxs-lookup"><span data-stu-id="8a2d7-120">How to fix violations</span></span>

<span data-ttu-id="8a2d7-121">Sie können Sie entweder manuell beheben, oder Sie können sich dafür entscheiden, Visual Studio für Sie zu verwenden, indem Sie auf die Glühbirne zeigen, die neben dem Methodenaufruf angezeigt wird, und die vorgeschlagene Änderung auswählen.</span><span class="sxs-lookup"><span data-stu-id="8a2d7-121">You can either fix them manually, or you can opt to let Visual Studio do it for you, by hovering over the light bulb that shows up next to the method invocation, and selecting the suggested change.</span></span>

<span data-ttu-id="8a2d7-122">Das folgende Beispiel zeigt zwei vorgeschlagene Änderungen:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-122">The following example shows two suggested changes:</span></span>

![Rule CA2016: der CancellationToken-Parameter wird an Methoden weiterleiten, die einen Parameter annehmen.](media/ca2016-diagnose.png)

<span data-ttu-id="8a2d7-124">Es ist sicher, einen Verstoß gegen diese Regel zu unterdrücken, wenn Sie sich keine Gedanken darüber machen, wie die abgebrochene Vorgangs Benachrichtigung an niedrigere Methodenaufrufe weitergeleitet werden soll.</span><span class="sxs-lookup"><span data-stu-id="8a2d7-124">It's safe to suppress a violation of this rule if you're not concerned about forwarding the canceled operation notification to lower method invocations.</span></span> <span data-ttu-id="8a2d7-125">Sie können c# auch explizit übergeben `default` ( `Nothing` in Visual Basic) oder <xref:System.Threading.CancellationToken.None> den Regelverstoß unterdrücken.</span><span class="sxs-lookup"><span data-stu-id="8a2d7-125">You can also explicitly pass `default` in C# (`Nothing` in Visual Basic) or <xref:System.Threading.CancellationToken.None> to suppress the rule violation.</span></span>

<span data-ttu-id="8a2d7-126">Die Regel kann eine Vielzahl von Verstößen erkennen.</span><span class="sxs-lookup"><span data-stu-id="8a2d7-126">The rule can detect a variety of violations.</span></span> <span data-ttu-id="8a2d7-127">In den folgenden Beispielen werden Fälle gezeigt, die von der Regel erkannt werden können:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-127">The following examples show cases that the rule can detect:</span></span>

### <a name="example-1"></a><span data-ttu-id="8a2d7-128">Beispiel 1</span><span class="sxs-lookup"><span data-stu-id="8a2d7-128">Example 1</span></span>

<span data-ttu-id="8a2d7-129">Die Regel schlägt `c` vor, den Parameter von `MyMethod` an den Aufruf weiterzuleiten `MyMethodWithDefault` , da die Methode einen optionalen tokenparameter definiert:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-129">The rule will suggest forwarding the `c` parameter from `MyMethod` to the `MyMethodWithDefault` invocation, because the method defines an optional token parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="8a2d7-130">Behebung:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-130">Fix:</span></span>

<span data-ttu-id="8a2d7-131">Leiten Sie den `c` Parameter weiter:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-131">Forward the `c` parameter:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(c);
        }
```

<span data-ttu-id="8a2d7-132">Wenn Sie sich keine Gedanken über das Weiterleiten von Abbruch Benachrichtigungen an niedrigere Aufrufe machen, haben Sie folgende Möglichkeiten:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-132">If you are not concerned about forwarding cancellation notifications to lower invocations, you can either:</span></span>

<span data-ttu-id="8a2d7-133">Explizit übergeben `default` :</span><span class="sxs-lookup"><span data-stu-id="8a2d7-133">Explicitly pass `default`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(default);
        }
```

<span data-ttu-id="8a2d7-134">Oder explizit übergeben `CancellationToken.None` :</span><span class="sxs-lookup"><span data-stu-id="8a2d7-134">Or explicitly pass `CancellationToken.None`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(CancellationToken.None);
        }
```

### <a name="example-2"></a><span data-ttu-id="8a2d7-135">Beispiel 2</span><span class="sxs-lookup"><span data-stu-id="8a2d7-135">Example 2</span></span>

<span data-ttu-id="8a2d7-136">Die Regel schlägt `c` vor, den Parameter von `MyMethod` an den Aufruf weiterzuleiten `MyMethodWithDefault` , da die Methode über eine Überladung verfügt, die einen `CancellationToken` Parameter annimmt:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-136">The rule will suggest forwarding the `c` parameter from `MyMethod` to the `MyMethodWithDefault` invocation, because the method has an overload that takes a `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload()
        {
        }

        public static void MyMethodWithOverload(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```

<span data-ttu-id="8a2d7-137">Behebung:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-137">Fix:</span></span>

<span data-ttu-id="8a2d7-138">Leiten Sie den `c` Parameter weiter:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-138">Forward the `c` parameter:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(c);
        }
```

<span data-ttu-id="8a2d7-139">Wenn Sie sich keine Gedanken über das Weiterleiten von Abbruch Benachrichtigungen an niedrigere Aufrufe machen, haben Sie folgende Möglichkeiten:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-139">If you are not concerned about forwarding cancellation notifications to lower invocations, you can either:</span></span>

<span data-ttu-id="8a2d7-140">Explizit übergeben `default` :</span><span class="sxs-lookup"><span data-stu-id="8a2d7-140">Explicitly pass `default`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(default);
        }
```

<span data-ttu-id="8a2d7-141">Oder explizit übergeben `CancellationToken.None` :</span><span class="sxs-lookup"><span data-stu-id="8a2d7-141">Or explicitly pass `CancellationToken.None`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(CancellationToken.None);
        }
```

## <a name="non-violation-examples"></a><span data-ttu-id="8a2d7-142">Beispiele für Nichtverletzung</span><span class="sxs-lookup"><span data-stu-id="8a2d7-142">Non-violation examples</span></span>

<span data-ttu-id="8a2d7-143">Der- `CancellationToken` Parameter in der übergeordneten-Methode befindet sich nicht in der letzten Position:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-143">The `CancellationToken` parameter in the parent method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c, int lastParameter)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="8a2d7-144">Der- `CancellationToken` Parameter in der Default-Methode befindet sich nicht an der letzten Position:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-144">The `CancellationToken` parameter in the default method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default, int lastParameter = 0)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="8a2d7-145">Der- `CancellationToken` Parameter in der Überladungs Methode befindet sich nicht an der letzten Position:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-145">The `CancellationToken` parameter in the overload method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload(int lastParameter)
        {
        }
        public static void MyMethodWithOverload(CancellationToken ct, int lastParameter)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```

<span data-ttu-id="8a2d7-146">Die übergeordnete Methode definiert mehr als einen `CancellationToken` Parameter:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-146">The parent method defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c1, CancellationToken c2)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="8a2d7-147">Die-Methode mit Standardwerten definiert mehr als einen `CancellationToken` Parameter:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-147">The method with defaults defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken c1 = default, CancellationToken c2 = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="8a2d7-148">Die Methoden Überladung definiert mehr als einen `CancellationToken` Parameter:</span><span class="sxs-lookup"><span data-stu-id="8a2d7-148">The method overload defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload(CancellationToken c1, CancellationToken c2)
        {
        }

        public static void MyMethodWithOverload()
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```
