---
title: Implementieren des Trennschaltermusters
description: Erfahren Sie, wie das Circuit-Breaker-Muster als ergänzendes System zu HTTP-Wiederholungsversuchen implementieren können.
ms.date: 03/03/2020
ms.openlocfilehash: a79c6fcca1e29f3c30d697cb369060d59a72c121
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/14/2020
ms.locfileid: "78847244"
---
# <a name="implement-the-circuit-breaker-pattern"></a><span data-ttu-id="6686a-103">Implementieren des Circuit Breaker-Musters</span><span class="sxs-lookup"><span data-stu-id="6686a-103">Implement the Circuit Breaker pattern</span></span>

<span data-ttu-id="6686a-104">Wie bereits in einem vorherigen Artikel erwähnt wurde, sollten Sie Fehler behandeln, deren Behebung unterschiedlich lange dauern kann. Dies kann beispielsweise der Fall sein, wenn Sie versuchen, sich mit einem Remote-Dienst oder einer Remote-Ressource zu verbinden.</span><span class="sxs-lookup"><span data-stu-id="6686a-104">As noted earlier, you should handle faults that might take a variable amount of time to recover from, as might happen when you try to connect to a remote service or resource.</span></span> <span data-ttu-id="6686a-105">Die Behandlung derartiger Fehler kann die Stabilität und Robustheit einer Anwendung erhöhen.</span><span class="sxs-lookup"><span data-stu-id="6686a-105">Handling this type of fault can improve the stability and resiliency of an application.</span></span>

<span data-ttu-id="6686a-106">In einer verteilten Umgebung können Aufrufe von Remote-Ressourcen und -Diensten fehlschlagen, wenn vorübergehende Fehler wie langsame Netzwerkverbindungen und Timeouts auftreten oder wenn Ressourcen zu langsam reagieren oder vorübergehend nicht verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="6686a-106">In a distributed environment, calls to remote resources and services can fail due to transient faults, such as slow network connections and timeouts, or if resources are responding slowly or are temporarily unavailable.</span></span> <span data-ttu-id="6686a-107">Diese Fehler werden in der Regel nach kurzer Zeit korrigiert, und eine robuste Cloudanwendung sollte diese durch eine Strategie wie das Wiederholungsmuster behandeln können.</span><span class="sxs-lookup"><span data-stu-id="6686a-107">These faults typically correct themselves after a short time, and a robust cloud application should be prepared to handle them by using a strategy like the "Retry pattern".</span></span>

<span data-ttu-id="6686a-108">Es gibt jedoch auch Situationen, in denen Fehler aufgrund unerwarteter Ereignisse auftreten. Die Behebung dieser Fehler kann deutlich mehr Zeit in Anspruch nehmen.</span><span class="sxs-lookup"><span data-stu-id="6686a-108">However, there can also be situations where faults are due to unanticipated events that might take much longer to fix.</span></span> <span data-ttu-id="6686a-109">Zu unterscheiden sind unterschiedliche Schweregrade, die von einem Teilverlust der Konnektivität bis hin zum vollständigen Ausfall des Diensts reichen können.</span><span class="sxs-lookup"><span data-stu-id="6686a-109">These faults can range in severity from a partial loss of connectivity to the complete failure of a service.</span></span> <span data-ttu-id="6686a-110">In diesen Situationen ist es möglicherweise nicht sinnvoll, wenn eine Anwendung einen Vorgang mehrfach wiederholt, der wahrscheinlich nicht erfolgreich ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="6686a-110">In these situations, it might be pointless for an application to continually retry an operation that's unlikely to succeed.</span></span>

<span data-ttu-id="6686a-111">Stattdessen sollte die Anwendung so programmiert sein, dass ein fehlgeschlagener Vorgang akzeptiert und der Fehler entsprechend behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="6686a-111">Instead, the application should be coded to accept that the operation has failed and handle the failure accordingly.</span></span>

<span data-ttu-id="6686a-112">Wenn Sie HTTP-Wiederholungen nicht sorgfältig verwenden, kann dies zu einem Denial-of-Service-Angriff ([DoS](https://en.wikipedia.org/wiki/Denial-of-service_attack)) innerhalb Ihrer eigenen Software führen.</span><span class="sxs-lookup"><span data-stu-id="6686a-112">Using Http retries carelessly could result in creating a Denial of Service ([DoS](https://en.wikipedia.org/wiki/Denial-of-service_attack)) attack within your own software.</span></span> <span data-ttu-id="6686a-113">Wenn ein Microservice fehlschlägt oder langsam ausgeführt wird, wiederholen möglicherweise mehrere Clients fehlgeschlagene Anforderungen.</span><span class="sxs-lookup"><span data-stu-id="6686a-113">As a microservice fails or performs slowly, multiple clients might repeatedly retry failed requests.</span></span> <span data-ttu-id="6686a-114">Dadurch entsteht das Risiko, exponentiell ansteigenden Datenverkehr zu erzeugen, den fehlgeschlagenen Dienst anzielt.</span><span class="sxs-lookup"><span data-stu-id="6686a-114">That creates a dangerous risk of exponentially increasing traffic targeted at the failing service.</span></span>

<span data-ttu-id="6686a-115">Deshalb benötigen Sie eine „Sicherung“, damit übermäßige Anforderungen beendet werden, wenn weitere Versuche überflüssig sind.</span><span class="sxs-lookup"><span data-stu-id="6686a-115">Therefore, you need some kind of defense barrier so that excessive requests stop when it isn't worth to keep trying.</span></span> <span data-ttu-id="6686a-116">Bei dieser Sicherung handelt es sich um den Circuit Breaker.</span><span class="sxs-lookup"><span data-stu-id="6686a-116">That defense barrier is precisely the circuit breaker.</span></span>

<span data-ttu-id="6686a-117">Das Circuit Breaker-Muster hat einen anderen Zweck als das Wiederholungsmuster.</span><span class="sxs-lookup"><span data-stu-id="6686a-117">The Circuit Breaker pattern has a different purpose than the "Retry pattern".</span></span> <span data-ttu-id="6686a-118">Das Wiederholungsmuster ermöglicht es einer Anwendung, einen Vorgang erneut auszuführen, wobei davon ausgegangen wird, dass dieser irgendwann erfolgreich ist.</span><span class="sxs-lookup"><span data-stu-id="6686a-118">The "Retry pattern" enables an application to retry an operation in the expectation that the operation will eventually succeed.</span></span> <span data-ttu-id="6686a-119">Das Circuit Breaker-Muster hindert eine Anwendung daran, einen Vorgang auszuführen, bei dem vermutlich ein Fehler auftreten wird.</span><span class="sxs-lookup"><span data-stu-id="6686a-119">The Circuit Breaker pattern prevents an application from performing an operation that's likely to fail.</span></span> <span data-ttu-id="6686a-120">Eine Anwendung kann diese beiden Muster kombinieren.</span><span class="sxs-lookup"><span data-stu-id="6686a-120">An application can combine these two patterns.</span></span> <span data-ttu-id="6686a-121">Die Wiederholungslogik sollte jedoch Ausnahmen behandeln können, die vom Circuit Breaker zurückgegeben werden, und auf Wiederholungsversuche verzichten, wenn der Circuit Breaker anzeigt, dass ein Fehler nicht temporär ist.</span><span class="sxs-lookup"><span data-stu-id="6686a-121">However, the retry logic should be sensitive to any exception returned by the circuit breaker, and it should abandon retry attempts if the circuit breaker indicates that a fault is not transient.</span></span>

## <a name="implement-circuit-breaker-pattern-with-ihttpclientfactory-and-polly"></a><span data-ttu-id="6686a-122">Implementieren eines Circuit Breaker-Musters mit `IHttpClientFactory` und Polly</span><span class="sxs-lookup"><span data-stu-id="6686a-122">Implement Circuit Breaker pattern with `IHttpClientFactory` and Polly</span></span>

<span data-ttu-id="6686a-123">Ebenso wie für die Implementierung von Wiederholungen wird auch für Circuit Breakers empfohlen, auf bewährte .NET-Bibliotheken wie Polly und die native Integration in `IHttpClientFactory` zurückzugreifen.</span><span class="sxs-lookup"><span data-stu-id="6686a-123">As when implementing retries, the recommended approach for circuit breakers is to take advantage of proven .NET libraries like Polly and its native integration with `IHttpClientFactory`.</span></span>

<span data-ttu-id="6686a-124">Eine Circuit Breaker-Richtlinie kann zu Ihrer ausgehenden `IHttpClientFactory`-Middlewarepipeline hinzugefügt werden, indem Sie einfach einen einzelnen inkrementellen Codeabschnitt zu dem Code hinzufügen, der bei der Verwendung von `IHttpClientFactory` bereits vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="6686a-124">Adding a circuit breaker policy into your `IHttpClientFactory` outgoing middleware pipeline is as simple as adding a single incremental piece of code to what you already have when using `IHttpClientFactory`.</span></span>

<span data-ttu-id="6686a-125">Der nachfolgende Code für Wiederholungen von HTTP-Aufrufen wird nur insofern geändert, als die Circuit Breaker-Richtlinie der zu verwendenden Richtlinienliste hinzugefügt wird. Dies wird in folgendem inkrementellen Code veranschaulicht, der Teil der ConfigureServices()-Methode ist.</span><span class="sxs-lookup"><span data-stu-id="6686a-125">The only addition here to the code used for HTTP call retries is the code where you add the Circuit Breaker policy to the list of policies to use, as shown in the following incremental code, part of the ConfigureServices() method.</span></span>

```csharp
//ConfigureServices()  - Startup.cs
services.AddHttpClient<IBasketService, BasketService>()
        .SetHandlerLifetime(TimeSpan.FromMinutes(5))  //Sample. Default lifetime is 2 minutes
        .AddHttpMessageHandler<HttpClientAuthorizationDelegatingHandler>()
        .AddPolicyHandler(GetRetryPolicy())
        .AddPolicyHandler(GetCircuitBreakerPolicy());
```

<span data-ttu-id="6686a-126">Durch die Methode `AddPolicyHandler()` werden dem `HttpClient`-Objekt, das Sie verwenden, Richtlinien hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="6686a-126">The `AddPolicyHandler()` method is what adds policies to the `HttpClient` objects you'll use.</span></span> <span data-ttu-id="6686a-127">In diesem Fall wird eine Polly-Richtlinie für einen Circuit Breaker hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="6686a-127">In this case, it's adding a Polly policy for a circuit breaker.</span></span>

<span data-ttu-id="6686a-128">Für einen modulareren Ansatz wird die Circuit Breaker-Richtlinie in einer separaten Methode namens `GetCircuitBreakerPolicy()` definiert, wie in folgendem Code veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="6686a-128">To have a more modular approach, the Circuit Breaker Policy is defined in a separate method called `GetCircuitBreakerPolicy()`, as shown in the following code:</span></span>

```csharp
static IAsyncPolicy<HttpResponseMessage> GetCircuitBreakerPolicy()
{
    return HttpPolicyExtensions
        .HandleTransientHttpError()
        .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30));
}
```

<span data-ttu-id="6686a-129">Im obigen Codebeispiel wird die Circuit Breaker-Richtlinie dafür konfiguriert, die Kommunikation zu unterbrechen oder fortzusetzen, wenn beim Wiederholen der HTTP-Anforderungen fünf aufeinanderfolgende Fehler aufgetreten sind.</span><span class="sxs-lookup"><span data-stu-id="6686a-129">In the code example above, the circuit breaker policy is configured so it breaks or opens the circuit when there have been five consecutive faults when retrying the Http requests.</span></span> <span data-ttu-id="6686a-130">In diesem Fall wird der Schaltkreis 30 Sekunden lang unterbrochen: In diesem Zeitraum schlagen Aufrufe durch den Circuit Breaker sofort fehl, statt tatsächlich durchgeführt zu werden.</span><span class="sxs-lookup"><span data-stu-id="6686a-130">When that happens, the circuit will break for 30 seconds: in that period, calls will be failed immediately by the circuit-breaker rather than actually be placed.</span></span>  <span data-ttu-id="6686a-131">Die Richtlinie interpretiert [relevante Ausnahmen und HTTP-Statuscodes](/aspnet/core/fundamentals/http-requests#handle-transient-faults) automatisch als Fehler.</span><span class="sxs-lookup"><span data-stu-id="6686a-131">The policy automatically interprets [relevant exceptions and HTTP status codes](/aspnet/core/fundamentals/http-requests#handle-transient-faults) as faults.</span></span>  

<span data-ttu-id="6686a-132">Circuit Breakers sollten auch verwendet werden, um Anforderungen an eine Fallbackinfrastruktur umzuleiten, wenn Probleme bei einer bestimmten Ressource aufgetreten sind, die in einer anderen Umgebung als die Clientanwendung oder der Dienst bereitgestellt wird, die bzw. der den HTTP-Aufruf ausführt.</span><span class="sxs-lookup"><span data-stu-id="6686a-132">Circuit breakers should also be used to redirect requests to a fallback infrastructure if you had issues in a particular resource that's deployed in a different environment than the client application or service that's performing the HTTP call.</span></span> <span data-ttu-id="6686a-133">Auf diese Weise kann die Clientanwendung bei einem Ausfall im Rechenzentrum, der nur Back-End-Microservices, nicht aber Clientanwendungen betrifft, Anforderungen an Fallbackdienste umleiten.</span><span class="sxs-lookup"><span data-stu-id="6686a-133">That way, if there's an outage in the datacenter that impacts only your backend microservices but not your client applications, the client applications can redirect to the fallback services.</span></span> <span data-ttu-id="6686a-134">Für Polly wird aktuell eine Richtlinie zur Automatisierung dieses [Failoverrichtlinienszenarios](https://github.com/App-vNext/Polly/wiki/Polly-Roadmap#failover-policy) geplant.</span><span class="sxs-lookup"><span data-stu-id="6686a-134">Polly is planning a new policy to automate this [failover policy](https://github.com/App-vNext/Polly/wiki/Polly-Roadmap#failover-policy) scenario.</span></span>

<span data-ttu-id="6686a-135">Die erwähnten Features sind nur für Fälle geeignet, in denen das Failover mit .NET Code und nicht automatisch von Azure unter Berücksichtigung von Speicherorttransparenz verwaltet wird.</span><span class="sxs-lookup"><span data-stu-id="6686a-135">All those features are for cases where you're managing the failover from within the .NET code, as opposed to having it managed automatically for you by Azure, with location transparency.</span></span>

<span data-ttu-id="6686a-136">Bei der Verwendung von HttpClient besteht aus Benutzerperspektive keine Notwendigkeit, neue Elemente hinzuzufügen, da der Code wie in den vorherigen Abschnitten dargestellt identisch mit dem ist, der bei `HttpClient` mit `IHttpClientFactory` verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="6686a-136">From a usage point of view, when using HttpClient, there’s no need to add anything new here because the code is the same than when using `HttpClient` with `IHttpClientFactory`, as shown in previous sections.</span></span>

## <a name="test-http-retries-and-circuit-breakers-in-eshoponcontainers"></a><span data-ttu-id="6686a-137">Testen von HTTP-Wiederholungen und Circuit Breakern in eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="6686a-137">Test Http retries and circuit breakers in eShopOnContainers</span></span>

<span data-ttu-id="6686a-138">Sobald Sie die eShopOnContainers-Lösung in einem Docker-Host starten, müssen mehrere Container gestartet werden.</span><span class="sxs-lookup"><span data-stu-id="6686a-138">Whenever you start the eShopOnContainers solution in a Docker host, it needs to start multiple containers.</span></span> <span data-ttu-id="6686a-139">Einige Container wie der SQL Server-Container werden langsamer gestartet und initialisiert.</span><span class="sxs-lookup"><span data-stu-id="6686a-139">Some of the containers are slower to start and initialize, like the SQL Server container.</span></span> <span data-ttu-id="6686a-140">Dies ist v.a. dann der Fall, wenn Sie die eShopOnContainers-Anwendung zum ersten Mal in Docker bereitstellen, da die Images und die Datenbank eingerichtet werden müssen.</span><span class="sxs-lookup"><span data-stu-id="6686a-140">This is especially true the first time you deploy the eShopOnContainers application into Docker because it needs to set up the images and the database.</span></span> <span data-ttu-id="6686a-141">Der langsamere Start einiger Container kann dazu führen, dass die anderen Dienste auch dann anfänglich HTTP-Ausnahmen auslösen, wenn Sie, wie in den vorherigen Abschnitten beschrieben, Abhängigkeiten zwischen Containern auf der docker-compose-Ebene festlegen.</span><span class="sxs-lookup"><span data-stu-id="6686a-141">The fact that some containers start slower than others can cause the rest of the services to initially throw HTTP exceptions, even if you set dependencies between containers at the docker-compose level, as explained in previous sections.</span></span> <span data-ttu-id="6686a-142">Diese docker-compose-Abhängigkeiten zwischen Containern befinden sich nur auf der Prozessebene.</span><span class="sxs-lookup"><span data-stu-id="6686a-142">Those docker-compose dependencies between containers are just at the process level.</span></span> <span data-ttu-id="6686a-143">Auch wenn der Einstiegspunktprozess des Containers bereits gestartet wurde, ist SQL Server möglicherweise noch nicht für Abfragen bereit.</span><span class="sxs-lookup"><span data-stu-id="6686a-143">The container’s entry point process might be started, but SQL Server might not be ready for queries.</span></span> <span data-ttu-id="6686a-144">Das Ergebnis können zahlreiche Fehler sein. Außerdem wird in der Anwendung möglicherweise eine Ausnahme angezeigt, wenn sie versucht, den Container zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="6686a-144">The result can be a cascade of errors, and the application can get an exception when trying to consume that particular container.</span></span>

<span data-ttu-id="6686a-145">Diese Art von Fehler kann auch beim Start angezeigt werden, wenn die Anwendung in der Cloud bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="6686a-145">You might also see this type of error on startup when the application is deploying to the cloud.</span></span> <span data-ttu-id="6686a-146">In diesem Fall können Orchestratoren einen Container zwischen Knoten oder virtuellen Computern hin- und herschieben (was dem Start neuer Instanzen entspricht), wenn die Anzahl der Container für Clusterknoten ausgeglichen wird.</span><span class="sxs-lookup"><span data-stu-id="6686a-146">In that case, orchestrators might be moving containers from one node or VM to another (that is, starting new instances) when balancing the number of containers across the cluster’s nodes.</span></span>

<span data-ttu-id="6686a-147">eShopOnContainers behebt diese Probleme beim Starten aller Container, indem das zuvor veranschaulichte Wiederholungsmuster verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="6686a-147">The way 'eShopOnContainers' solves those issues when starting all the containers is by using the Retry pattern illustrated earlier.</span></span>

### <a name="test-the-circuit-breaker-in-eshoponcontainers"></a><span data-ttu-id="6686a-148">Testen des Circuit Breakers in eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="6686a-148">Test the circuit breaker in eShopOnContainers</span></span>

<span data-ttu-id="6686a-149">Es gibt mehrere Möglichkeiten, die Kommunikation zu unterbrechen oder fortzusetzen und ihn auf diese Weise mit eShopOnContainers zu testen.</span><span class="sxs-lookup"><span data-stu-id="6686a-149">There are a few ways you can break/open the circuit and test it with eShopOnContainers.</span></span>

<span data-ttu-id="6686a-150">Eine Option besteht darin, die zulässige Anzahl von Wiederholungen in der Trennschalterrichtlinie auf eins zu reduzieren und die gesamte Lösung erneut in Docker bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="6686a-150">One option is to lower the allowed number of retries to 1 in the circuit breaker policy and redeploy the whole solution into Docker.</span></span> <span data-ttu-id="6686a-151">Bei einem einzelnen Neuversuch ist die Wahrscheinlichkeit hoch, dass die HTTP-Anforderung bei der Bereitstellung fehlschlägt, der Circuit Breaker geöffnet und eine Fehlermeldung angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="6686a-151">With a single retry, there's a good chance that an HTTP request will fail during deployment, the circuit breaker will open, and you get an error.</span></span>

<span data-ttu-id="6686a-152">Eine weitere Option besteht in der Verwendung benutzerdefinierter Middleware, die im **Basket**-Microservice implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="6686a-152">Another option is to use custom middleware that's implemented in the **Basket** microservice.</span></span> <span data-ttu-id="6686a-153">Wenn diese Middleware aktiviert ist, fängt sie alle HTTP-Anforderungen ab und gibt den Statuscode 500 zurück.</span><span class="sxs-lookup"><span data-stu-id="6686a-153">When this middleware is enabled, it catches all HTTP requests and returns status code 500.</span></span> <span data-ttu-id="6686a-154">Sie können die Middleware aktivieren, indem Sie eine GET-Anforderung an den URI stellen, der den Fehler auslöst. Dabei können Sie z.B. folgende Anforderungen verwenden:</span><span class="sxs-lookup"><span data-stu-id="6686a-154">You can enable the middleware by making a GET request to the failing URI, like the following:</span></span>

- `GET http://localhost:5103/failing`\
  <span data-ttu-id="6686a-155">Diese Anforderung gibt den aktuellen Status der Middleware zurück.</span><span class="sxs-lookup"><span data-stu-id="6686a-155">This request returns the current state of the middleware.</span></span> <span data-ttu-id="6686a-156">Wenn die Middleware aktiviert ist, gibt die Anforderung den Statuscode 500 zurück.</span><span class="sxs-lookup"><span data-stu-id="6686a-156">If the middleware is enabled, the request return status code 500.</span></span> <span data-ttu-id="6686a-157">Wenn die Middleware deaktiviert ist, wird keine Antwort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="6686a-157">If the middleware is disabled, there's no response.</span></span>

- `GET http://localhost:5103/failing?enable`\
  <span data-ttu-id="6686a-158">Diese Anforderung aktiviert die Middleware.</span><span class="sxs-lookup"><span data-stu-id="6686a-158">This request enables the middleware.</span></span>

- `GET http://localhost:5103/failing?disable`\
  <span data-ttu-id="6686a-159">Diese Anforderung deaktiviert die Middleware.</span><span class="sxs-lookup"><span data-stu-id="6686a-159">This request disables the middleware.</span></span>

<span data-ttu-id="6686a-160">Sobald die Anwendung ausgeführt wird, können Sie z.B. die Middleware aktivieren, indem Sie mit dem unten aufgeführten URI in einem Browser eine Anforderung stellen.</span><span class="sxs-lookup"><span data-stu-id="6686a-160">For instance, once the application is running, you can enable the middleware by making a request using the following URI in any browser.</span></span> <span data-ttu-id="6686a-161">Beachten Sie, dass der Microservice für Bestellungen den Port 5103 verwendet.</span><span class="sxs-lookup"><span data-stu-id="6686a-161">Note that the ordering microservice uses port 5103.</span></span>

`http://localhost:5103/failing?enable`

<span data-ttu-id="6686a-162">Mit dem URI `http://localhost:5103/failing` können Sie anschließend wie in Abbildung 8–5 dargestellt den Status überprüfen.</span><span class="sxs-lookup"><span data-stu-id="6686a-162">You can then check the status using the URI `http://localhost:5103/failing`, as shown in Figure 8-5.</span></span>

![Screenshot der Überprüfung des Status einer fehlschlagenden Middlewaresimulation.](./media/implement-circuit-breaker-pattern/failing-middleware-simulation.png)

<span data-ttu-id="6686a-164">**Abbildung 8-5.**</span><span class="sxs-lookup"><span data-stu-id="6686a-164">**Figure 8-5**.</span></span> <span data-ttu-id="6686a-165">Überprüfung des „Fehlerstatus“ der ASP.NET-Middleware (hier deaktiviert)</span><span class="sxs-lookup"><span data-stu-id="6686a-165">Checking the state of the “Failing” ASP.NET middleware – In this case, disabled.</span></span>

<span data-ttu-id="6686a-166">Der Warenkorbmicroservice antwortet bei Aufruf immer mit dem Statuscode 500.</span><span class="sxs-lookup"><span data-stu-id="6686a-166">At this point, the Basket microservice responds with status code 500 whenever you call invoke it.</span></span>

<span data-ttu-id="6686a-167">Sobald die Middleware ausgeführt wird, können Sie versuchen, über die MVC-Webanwendung eine Bestellung aufzugeben.</span><span class="sxs-lookup"><span data-stu-id="6686a-167">Once the middleware is running, you can try making an order from the MVC web application.</span></span> <span data-ttu-id="6686a-168">Da die Anforderungen fehlschlagen, wird die Kommunikation fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="6686a-168">Because the requests fail, the circuit will open.</span></span>

<span data-ttu-id="6686a-169">Wie im folgenden Beispiel zu sehen ist, befindet sich in der MVC-Webanwendung ein catch-Block in der Logik zum Aufgeben einer Bestellung.</span><span class="sxs-lookup"><span data-stu-id="6686a-169">In the following example, you can see that the MVC web application has a catch block in the logic for placing an order.</span></span>  <span data-ttu-id="6686a-170">Wenn im Code eine durch den offenen Trennschalter ausgelöste Ausnahme abgefangen wird, erhält der Benutzer eine Wartebenachrichtigung.</span><span class="sxs-lookup"><span data-stu-id="6686a-170">If the code catches an open-circuit exception, it shows the user a friendly message telling them to wait.</span></span>

```csharp
public class CartController : Controller
{
    //…
    public async Task<IActionResult> Index()
    {
        try
        {
            var user = _appUserParser.Parse(HttpContext.User);
            //Http requests using the Typed Client (Service Agent)
            var vm = await _basketSvc.GetBasket(user);
            return View(vm);
        }
        catch (BrokenCircuitException)
        {
            // Catches error when Basket.api is in circuit-opened mode
            HandleBrokenCircuitException();
        }
        return View();
    }

    private void HandleBrokenCircuitException()
    {
        TempData["BasketInoperativeMsg"] = "Basket Service is inoperative, please try later on. (Business message due to Circuit-Breaker)";
    }
}
```

<span data-ttu-id="6686a-171">Die durch den Code ausgelösten Schritte werden im Folgenden kurz zusammengefasst.</span><span class="sxs-lookup"><span data-stu-id="6686a-171">Here’s a summary.</span></span> <span data-ttu-id="6686a-172">Die Wiederholungsrichtlinie versucht mehrmals, HTTP-Anforderungen zu stellen, was zu HTTP-Fehlern führt.</span><span class="sxs-lookup"><span data-stu-id="6686a-172">The Retry policy tries several times to make the HTTP request and gets HTTP errors.</span></span> <span data-ttu-id="6686a-173">Wenn die maximale Anzahl der Wiederholungen erreicht wird, die für die Circuit Breaker-Richtlinie festgelegt wurde (in diesem Fall 5), löst die Anwendung die Ausnahme „BrokenCircuitException“ aus.</span><span class="sxs-lookup"><span data-stu-id="6686a-173">When the number of retries reaches the maximum number set for the Circuit Breaker policy (in this case, 5), the application throws a BrokenCircuitException.</span></span> <span data-ttu-id="6686a-174">Das Ergebnis ist eine Benutzerbenachrichtigung (siehe Abbildung 8-6).</span><span class="sxs-lookup"><span data-stu-id="6686a-174">The result is a friendly message, as shown in Figure 8-6.</span></span>

![Screenshot der MVC-Web-App mit einem Fehler wegen nicht funktionierendem Warenkorbdienst.](./media/implement-circuit-breaker-pattern/basket-service-inoperative.png)

<span data-ttu-id="6686a-176">**Abbildung 8-6.**</span><span class="sxs-lookup"><span data-stu-id="6686a-176">**Figure 8-6**.</span></span> <span data-ttu-id="6686a-177">Trennschalter, der einen Fehler zurückgibt, der auf der Benutzeroberfläche angezeigt wird</span><span class="sxs-lookup"><span data-stu-id="6686a-177">Circuit breaker returning an error to the UI</span></span>

<span data-ttu-id="6686a-178">Sie können unterschiedliche Logiken für das Fortsetzen oder Unterbrechen der Kommunikation festlegen.</span><span class="sxs-lookup"><span data-stu-id="6686a-178">You can implement different logic for when to open/break the circuit.</span></span> <span data-ttu-id="6686a-179">Alternativ können Sie auch eine HTTP-Anforderung an einen anderen Back-End-Microservice stellen, falls ein Fallbackrechenzentrum oder ein redundantes Back-End-System vorliegt.</span><span class="sxs-lookup"><span data-stu-id="6686a-179">Or you can try an HTTP request against a different back-end microservice if there's a fallback datacenter or redundant back-end system.</span></span>

<span data-ttu-id="6686a-180">Eine weitere Möglichkeit für `CircuitBreakerPolicy` ist die Verwendung von `Isolate` (dadurch wird das Fortsetzen der Kommunikation erzwungen und dafür gesorgt, dass diese bestehen bleibt) und `Reset` (dadurch wird die Kommunikation wieder unterbrochen).</span><span class="sxs-lookup"><span data-stu-id="6686a-180">Finally, another possibility for the `CircuitBreakerPolicy` is to use `Isolate` (which forces open and holds open the circuit) and `Reset` (which closes it again).</span></span> <span data-ttu-id="6686a-181">Diese können für die Erstellung eines Hilfs-HTTP-Endpunkts verwendet werden, der Isolate und Reset direkt in der Richtlinie aufruft.</span><span class="sxs-lookup"><span data-stu-id="6686a-181">These could be used to build a utility HTTP endpoint that invokes Isolate and Reset directly on the policy.</span></span>  <span data-ttu-id="6686a-182">Ein derartiger HTTP-Endpunkt kann auch, falls er entsprechend gesichert ist, in einer Produktionsumgebung verwendet werden, um ein Downstreamsystem beispielsweise bei einem Upgrade vorübergehend zu isolieren.</span><span class="sxs-lookup"><span data-stu-id="6686a-182">Such an HTTP endpoint could also be used, suitably secured, in production for temporarily isolating a downstream system, such as when you want to upgrade it.</span></span> <span data-ttu-id="6686a-183">Alternativ könnte er den Trennschalter manuell auslösen, um ein Downstreamsystem zu schützen, das möglicherweise fehlerhaft ist.</span><span class="sxs-lookup"><span data-stu-id="6686a-183">Or it could trip the circuit manually to protect a downstream system you suspect to be faulting.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="6686a-184">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="6686a-184">Additional resources</span></span>

- <span data-ttu-id="6686a-185">**Circuit Breaker-Muster**</span><span class="sxs-lookup"><span data-stu-id="6686a-185">**Circuit Breaker pattern**</span></span>\
  [https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker](/azure/architecture/patterns/circuit-breaker)

>[!div class="step-by-step"]
><span data-ttu-id="6686a-186">[Zurück](implement-http-call-retries-exponential-backoff-polly.md)
>[Weiter](monitor-app-health.md)</span><span class="sxs-lookup"><span data-stu-id="6686a-186">[Previous](implement-http-call-retries-exponential-backoff-polly.md)
[Next](monitor-app-health.md)</span></span>
