---
title: Kommunikation in einer Microservicearchitektur
description: Erkunden Sie verschiedene Kommunikationsmöglichkeiten zwischen Microservices, und lernen Sie die Auswirkungen synchroner und asynchroner Optionen kennen.
ms.date: 01/30/2020
ms.openlocfilehash: f2d6e78966bb7d5f481de6db0ab1dcfe2812a1b5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401520"
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="dace1-103">Kommunikation in einer Microservicearchitektur</span><span class="sxs-lookup"><span data-stu-id="dace1-103">Communication in a microservice architecture</span></span>

<span data-ttu-id="dace1-104">In einer monolithischen-Anwendung, die in einem einzelnen Prozess ausgeführt wird, rufen sich die Komponenten gegenseitig mit Methoden- oder Funktionsaufrufen auf Sprachebene auf.</span><span class="sxs-lookup"><span data-stu-id="dace1-104">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="dace1-105">Diese können stark gekoppelt sein, wenn Sie Objekte mit Code erstellen (z.B. `new ClassName()`), oder entkoppelt aufgerufen werden, wenn Sie die Abhängigkeitsinjektion verwenden, indem Sie auf Abstraktionen und nicht auf konkrete Objektinstanzen verweisen.</span><span class="sxs-lookup"><span data-stu-id="dace1-105">These can be strongly coupled if you're creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you're using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="dace1-106">In beiden Fällen werden die Objekte innerhalb des gleichen Prozesses ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="dace1-106">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="dace1-107">Die größte Herausforderung bei der Änderung einer monolithischen Anwendung in eine auf Microservices basierende Anwendung besteht in der Änderung des Kommunikationsmechanismus.</span><span class="sxs-lookup"><span data-stu-id="dace1-107">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="dace1-108">Eine direkte Konvertierung von prozessinternen Methodenaufrufen in RPC-Aufrufe bei Diensten verursacht eine wortreiche und ineffiziente Kommunikation, die in verteilten Umgebungen nicht zufriedenstellend funktioniert.</span><span class="sxs-lookup"><span data-stu-id="dace1-108">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that won't perform well in distributed environments.</span></span> <span data-ttu-id="dace1-109">Die Herausforderungen beim ordnungsgemäßen Entwerfen eines verteilten Systems gut bekannt, dass es dazu sogar den Kanon [Irrtümer der verteilten Verarbeitung](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) gibt. Darin werden Vermutungen aufgeführt, die Entwickler häufig anstellen, wenn sie von monolithischen zu verteilten Entwürfen wechseln.</span><span class="sxs-lookup"><span data-stu-id="dace1-109">The challenges of designing distributed system properly are well enough known that there's even a canon known as the [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="dace1-110">Es gibt nicht eine, sondern mehrere Lösungen.</span><span class="sxs-lookup"><span data-stu-id="dace1-110">There isn't one solution, but several.</span></span> <span data-ttu-id="dace1-111">Bei einer Lösung werden die Unternehmensmicroservices so weit wie möglich isoliert.</span><span class="sxs-lookup"><span data-stu-id="dace1-111">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="dace1-112">Anschließend verwenden Sie zwischen den internen Microservices eine asynchrone Kommunikation und ersetzen die für die prozessinterne Kommunikation zwischen Objekten typische differenzierte Kommunikation durch die undifferenzierte Kommunikation.</span><span class="sxs-lookup"><span data-stu-id="dace1-112">You then use asynchronous communication between the internal microservices and replace fine-grained communication that's typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="dace1-113">Hierzu können Sie Aufrufe gruppieren und Daten zurückgeben, welche die Ergebnisse mehrerer interner Aufrufe an den Client aggregieren.</span><span class="sxs-lookup"><span data-stu-id="dace1-113">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="dace1-114">Bei einer auf Microservices basierenden Anwendung handelt es sich um ein verteiltes System, das in mehreren Prozessen oder Services ausgeführt wird und normalerweise sogar mehrere Server oder Hosts übergreift.</span><span class="sxs-lookup"><span data-stu-id="dace1-114">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="dace1-115">Jede Dienstinstanz ist in der Regel ein Prozess.</span><span class="sxs-lookup"><span data-stu-id="dace1-115">Each service instance is typically a process.</span></span> <span data-ttu-id="dace1-116">Daher müssen Dienste bei der Interaktion ein prozessinternes Kommunikationsprotokoll wie HTTP, AMQP oder ein Binärprotokoll wie TCP verwenden. Welches Protokoll verwendet wird, hängt von der Art des jeweiligen Diensts ab.</span><span class="sxs-lookup"><span data-stu-id="dace1-116">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="dace1-117">Die Microservicecommunity vertritt die Grundidee [Intelligente Endpunkte und unnütze Pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes). Dieses Motto unterstützt einen Entwurf, der zwischen Microservices möglichst entkoppelt und innerhalb eines einzelnen Microservices möglichst kohäsiv ist.</span><span class="sxs-lookup"><span data-stu-id="dace1-117">The microservice community promotes the philosophy of "[smart endpoints and dumb pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" This slogan encourages a design that's as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="dace1-118">Wie zuvor erläutert wurde, verfügt jeder Microservice über seine eigenen Daten und seine eigene Domänenlogik.</span><span class="sxs-lookup"><span data-stu-id="dace1-118">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="dace1-119">Die Microservices, die eine End-to-End-Anwendung erstellen, sind jedoch in der Regel einfach choreografiert, indem REST-Kommunikationen statt komplexer Protokolle wie WS-\* und flexible, ereignisgesteuerte Kommunikationen statt zentralisierter Geschäftsprozessorchestratoren verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dace1-119">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="dace1-120">Die zwei häufig verwendeten Protokolle sind HTTP-Anforderung/-Antwort mit Ressourcen-APIs (bei den meisten Abfragen) und asynchrones Lightweight-Messaging, das bei der Kommunikation von Updates mehrere Microservices übergreifend zum Einsatz kommt.</span><span class="sxs-lookup"><span data-stu-id="dace1-120">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="dace1-121">In den folgenden Abschnitten werden diese Protokolle näher erläutert.</span><span class="sxs-lookup"><span data-stu-id="dace1-121">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="dace1-122">Kommunikationstypen</span><span class="sxs-lookup"><span data-stu-id="dace1-122">Communication types</span></span>

<span data-ttu-id="dace1-123">Clients und Dienste können über viele verschiedene Kommunikationstypen miteinander kommunizieren, von denen alle unterschiedliche Szenarios und Ziele zum Gegenstand haben.</span><span class="sxs-lookup"><span data-stu-id="dace1-123">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="dace1-124">Diese Kommunikationstypen können zunächst in zwei Achsen klassifiziert werden.</span><span class="sxs-lookup"><span data-stu-id="dace1-124">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="dace1-125">Auf der ersten Achse wird definiert, ob das Protokoll synchron oder asynchron ist:</span><span class="sxs-lookup"><span data-stu-id="dace1-125">The first axis defines if the protocol is synchronous or asynchronous:</span></span>

- <span data-ttu-id="dace1-126">Synchrones Protokoll.</span><span class="sxs-lookup"><span data-stu-id="dace1-126">Synchronous protocol.</span></span> <span data-ttu-id="dace1-127">HTTP ist ein synchrones Protokoll.</span><span class="sxs-lookup"><span data-stu-id="dace1-127">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="dace1-128">Der Client sendet eine Anforderung und wartet auf eine Antwort vom Dienst.</span><span class="sxs-lookup"><span data-stu-id="dace1-128">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="dace1-129">Das geschieht unabhängig von der Ausführung des Clientcodes, der synchron (Thread ist blockiert) oder asynchron (Thread ist nicht blockiert und die Antwort erreicht schließlich einen Rückruf) sein könnte.</span><span class="sxs-lookup"><span data-stu-id="dace1-129">That's independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread isn't blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="dace1-130">Wichtig ist in diesem Zusammenhang, dass das Protokoll (HTTP/HTTPS) synchron ist und der Clientcode den Vorgang nur dann fortsetzen kann, wenn er die Antwort vom HTTP-Server empfängt.</span><span class="sxs-lookup"><span data-stu-id="dace1-130">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

- <span data-ttu-id="dace1-131">Asynchrones Protokoll.</span><span class="sxs-lookup"><span data-stu-id="dace1-131">Asynchronous protocol.</span></span> <span data-ttu-id="dace1-132">Andere Protokolle wie z.B. AMQP (ein Protokoll, das von vielen Betriebssystemen und Cloudumgebungen unterstützt wird) verwenden asynchrone Nachrichten.</span><span class="sxs-lookup"><span data-stu-id="dace1-132">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="dace1-133">Der Absender des Clientcodes oder der Nachricht wartet in der Regel nicht auf eine Antwort.</span><span class="sxs-lookup"><span data-stu-id="dace1-133">The client code or message sender usually doesn't wait for a response.</span></span> <span data-ttu-id="dace1-134">Er sendet die Nachricht so, als würde er eine Nachricht an eine RabbitMQ-Warteschlange oder einen anderen Nachrichtenbroker senden.</span><span class="sxs-lookup"><span data-stu-id="dace1-134">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="dace1-135">Auf der zweiten Achse wird definiert, ob die Kommunikation über einen einzelnen oder mehrere Empfänger verfügt:</span><span class="sxs-lookup"><span data-stu-id="dace1-135">The second axis defines if the communication has a single receiver or multiple receivers:</span></span>

- <span data-ttu-id="dace1-136">Einzelner Empfänger.</span><span class="sxs-lookup"><span data-stu-id="dace1-136">Single receiver.</span></span> <span data-ttu-id="dace1-137">Jede Anforderung muss von genau einem Empfänger oder Dienst verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="dace1-137">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="dace1-138">Ein Beispiel für diese Kommunikation ist das [Befehlsmuster](https://en.wikipedia.org/wiki/Command_pattern).</span><span class="sxs-lookup"><span data-stu-id="dace1-138">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

- <span data-ttu-id="dace1-139">Mehrere Empfänger.</span><span class="sxs-lookup"><span data-stu-id="dace1-139">Multiple receivers.</span></span> <span data-ttu-id="dace1-140">Jede Anforderung kann von 0 (null) bis hin zu mehreren Empfängern verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="dace1-140">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="dace1-141">Dieser Kommunikationstyp muss asynchron sein.</span><span class="sxs-lookup"><span data-stu-id="dace1-141">This type of communication must be asynchronous.</span></span> <span data-ttu-id="dace1-142">Ein Beispiel hierfür ist der Mechanismus [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern), der in Mustern wie der [ereignisgesteuerten Architektur](https://microservices.io/patterns/data/event-driven-architecture.html) verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dace1-142">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](https://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="dace1-143">Diese basiert bei der Verteilung von Datenupdates über Ereignisse zwischen mehreren Microservices auf einer Ereignisbusschnittstelle oder einem Nachrichtenbroker. Sie wird in der Regel über einen Servicebus oder ein mit [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) vergleichbares Artefakt unter Verwendung von [Themen und Abonnements](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) implementiert.</span><span class="sxs-lookup"><span data-stu-id="dace1-143">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it's usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="dace1-144">Eine auf Microservices basierende Anwendung verwendet häufig eine Kombination aus diesen Kommunikationstypen.</span><span class="sxs-lookup"><span data-stu-id="dace1-144">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="dace1-145">Am häufigsten wird als Kommunikationstyp die Kommunikation über einzelne Empfänger mit einem synchronen Protokoll wie HTTP/HTTPS verwendet, wenn ein regulärer HTTP-Dienst der Web-API aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="dace1-145">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="dace1-146">Zudem verwenden Microservices für die asynchrone Kommunikation zwischen Microservices in der Regel Messagingprotokolle.</span><span class="sxs-lookup"><span data-stu-id="dace1-146">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="dace1-147">Sie sollten sich mit diesen Achsen vertraut machen, um die möglichen Kommunikationsmechanismen zu kennen. Beim Erstellen von Microservices spielen Sie jedoch keine bedeutende Rolle.</span><span class="sxs-lookup"><span data-stu-id="dace1-147">These axes are good to know so you have clarity on the possible communication mechanisms, but they're not the important concerns when building microservices.</span></span> <span data-ttu-id="dace1-148">Bei der Integration von Microservices stehen weder die asynchronen Eigenschaften der Clientthreadausführung noch die asynchronen Eigenschaften des ausgewählten Protokolls im Vordergrund.</span><span class="sxs-lookup"><span data-stu-id="dace1-148">Neither the asynchronous nature of client thread execution nor the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="dace1-149">Was *wirklich* wichtig ist, ist die Möglichkeit, Ihre Microservices asynchron integrieren zu können und gleichzeitig die Unabhängigkeit der Microservices zu erhalten. Dies wird im folgenden Abschnitt erläutert.</span><span class="sxs-lookup"><span data-stu-id="dace1-149">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="dace1-150">Asynchrone Integration von Microservices erzwingt die Unabhängigkeit eines Microservices</span><span class="sxs-lookup"><span data-stu-id="dace1-150">Asynchronous microservice integration enforces microservice's autonomy</span></span>

<span data-ttu-id="dace1-151">Wie zuvor erwähnt, steht bei der Erstellung einer auf Microservices basierenden Anwendung die Integrationsart Ihrer Microservices im Vordergrund.</span><span class="sxs-lookup"><span data-stu-id="dace1-151">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="dace1-152">Im Idealfall sollten Sie versuchen, die Kommunikation zwischen den internen Microservices zu minimieren.</span><span class="sxs-lookup"><span data-stu-id="dace1-152">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="dace1-153">Je weniger Kommunikation zwischen Microservices stattfindet, desto besser.</span><span class="sxs-lookup"><span data-stu-id="dace1-153">The fewer communications between microservices, the better.</span></span> <span data-ttu-id="dace1-154">In vielen Fällen müssen Sie die Microservices integrieren.</span><span class="sxs-lookup"><span data-stu-id="dace1-154">But in many cases, you'll have to somehow integrate the microservices.</span></span> <span data-ttu-id="dace1-155">Wenn dies erforderlich ist, gilt als entscheidende Regel, dass die Kommunikation zwischen den Microservices asynchron sein sollte.</span><span class="sxs-lookup"><span data-stu-id="dace1-155">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="dace1-156">Das bedeutet nicht, dass Sie ein bestimmtes Protokoll verwenden müssen (z.B. asynchrones Messaging im Vergleich zu synchronem HTTP).</span><span class="sxs-lookup"><span data-stu-id="dace1-156">That doesn't mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="dace1-157">Es bedeutet lediglich, dass die Kommunikation zwischen Microservices nur über die asynchrone Verteilung von Daten erfolgen sollte. Versuchen Sie jedoch beim ersten Vorgang der HTTP-Anforderung/Antwort des Diensts nicht von anderen internen Microservices abhängig zu sein.</span><span class="sxs-lookup"><span data-stu-id="dace1-157">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service's HTTP request/response operation.</span></span>

<span data-ttu-id="dace1-158">Machen Sie sich möglichst nie von synchroner Kommunikation (Anforderung/Antwort) zwischen mehreren Microservices abhängig, auch nicht bei Abfragen.</span><span class="sxs-lookup"><span data-stu-id="dace1-158">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="dace1-159">Das Ziel der einzelnen Microservices besteht darin, autonom und für den Clientconsumer verfügbar zu sein. Dies gilt auch dann, wenn die anderen Dienste der End-to-End-Anwendung inaktiv oder fehlerhaft sind.</span><span class="sxs-lookup"><span data-stu-id="dace1-159">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="dace1-160">Wenn Sie einen Aufruf von einem Microservice an andere Microservices ausführen möchten (z.B. das Ausführen einer HTTP-Anforderung für eine Datenabfrage), um eine Antwort für eine Clientanwendung bereitstellen zu können, verfügen Sie über eine Architektur, die beim Fehlschlagen einiger Microservices nicht stabil sein wird.</span><span class="sxs-lookup"><span data-stu-id="dace1-160">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) to be able to provide a response to a client application, you have an architecture that won't be resilient when some microservices fail.</span></span>

<span data-ttu-id="dace1-161">Darüber hinaus verlieren Ihre Microservices durch HTTP-Abhängigkeiten zwischen Microservices, z.B. beim Erstellen langer Anforderungs-/Antwortzyklen mit HTTP-Anforderungsketten (s. erster Abschnitt von Abbildung 4-15), ihre Unabhängigkeit. Zudem wird ihre Leistung beeinträchtigt, sobald einer der Dienste in dieser Kette nicht ordnungsgemäß funktioniert.</span><span class="sxs-lookup"><span data-stu-id="dace1-161">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain isn't performing well.</span></span>

<span data-ttu-id="dace1-162">Je mehr Sie synchrone Abhängigkeiten zwischen Microservices hinzufügen, z.B. in Form von Abfrageanforderungen, desto schlechter wird die Gesamtantwortzeit bei den Client-Apps.</span><span class="sxs-lookup"><span data-stu-id="dace1-162">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![Diagramm, das zeigt drei Typen von Kommunikation über Microservices hinweg zeigt.](./media/communication-in-microservice-architecture/sync-vs-async-patterns-across-microservices.png)

<span data-ttu-id="dace1-164">**Abbildung 4-15**.</span><span class="sxs-lookup"><span data-stu-id="dace1-164">**Figure 4-15**.</span></span> <span data-ttu-id="dace1-165">Antimuster und Muster bei der Kommunikation zwischen Microservices</span><span class="sxs-lookup"><span data-stu-id="dace1-165">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="dace1-166">Wie in dem obigen Diagramm gezeigt, wird in der synchronen Kommunikation eine „Kette“ von Anforderungen zwischen Microservices erstellt, während die Clientanforderung verarbeitet wird.</span><span class="sxs-lookup"><span data-stu-id="dace1-166">As shown in the above diagram, in synchronous communication a "chain" of requests is created between microservices while serving the client request.</span></span> <span data-ttu-id="dace1-167">Dies ist ein Antimuster.</span><span class="sxs-lookup"><span data-stu-id="dace1-167">This is an anti-pattern.</span></span> <span data-ttu-id="dace1-168">In der asynchronen Kommunikation verwenden Microservices asynchrone Nachrichten oder HTTP-Abrufe zur Kommunikation mit anderen Microservices – die Clientanforderung wird sofort beantwortet.</span><span class="sxs-lookup"><span data-stu-id="dace1-168">In asynchronous communication microservices use asynchronous messages or http polling to communicate with other microservices, but the client request is served right away.</span></span>

<span data-ttu-id="dace1-169">Wenn Ihr Microservice eine weitere Aktion in einem anderen Microservice auslösen muss, sollten Sie diese Aktion möglichst nicht synchron und im Rahmen des ursprünglichen Anforderungs- und Antwortvorgangs des Microservices ausführen.</span><span class="sxs-lookup"><span data-stu-id="dace1-169">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="dace1-170">Führen Sie die Aktion stattdessen asynchron aus (über asynchrones Messaging oder Integrationsereignisse, Warteschlangen usw.).</span><span class="sxs-lookup"><span data-stu-id="dace1-170">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="dace1-171">Rufen Sie die Aktion jedoch möglichst nicht synchron im Rahmen des ursprünglichen synchronen Anforderungs- und Antwortvorgangs auf.</span><span class="sxs-lookup"><span data-stu-id="dace1-171">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="dace1-172">Und schließlich sollten Sie sich nicht auf die Erstellung synchroner Anforderungen für Daten stützen, wenn Ihr ursprünglicher Microservice Daten benötigt, die ursprünglich zu anderen Microservices gehörten (an diesem Punkt treten beim Erstellen von Microservices die meisten Probleme auf).</span><span class="sxs-lookup"><span data-stu-id="dace1-172">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that's originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="dace1-173">Stattdessen können Sie diese Daten (nur die benötigten Attribute) in der Datenbank des ersten Dienstes replizieren oder verteilen, indem Sie die letztliche Konsistenz verwenden (in der Regel über Integrationsereignisse, wie in den folgenden Abschnitten erläutert).</span><span class="sxs-lookup"><span data-stu-id="dace1-173">Instead, replicate or propagate that data (only the attributes you need) into the initial service's database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="dace1-174">Wie zuvor im Abschnitt [Identifizieren von Domänenmodellgrenzen für jeden Microservice](identify-microservice-domain-model-boundaries.md) erwähnt, stellt das Duplizieren einiger Daten in mehreren Microservices keinen falschen Entwurf dar. Im Gegenteil: Dadurch können Sie die Daten in die spezifische Sprache bzw. Benennungen dieser zusätzlichen Domäne oder des begrenzten Kontexts übersetzen.</span><span class="sxs-lookup"><span data-stu-id="dace1-174">As noted earlier in the [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) section, duplicating some data across several microservices isn't an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="dace1-175">In der Anwendung [eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers) gibt es beispielsweise den Microservice `identity-api`, der bei der Entität `User` für die meisten Benutzerdaten zuständig ist.</span><span class="sxs-lookup"><span data-stu-id="dace1-175">For instance, in the [eShopOnContainers application](https://github.com/dotnet-architecture/eShopOnContainers) you have a microservice named `identity-api` that's in charge of most of the user's data with an entity named `User`.</span></span> <span data-ttu-id="dace1-176">Wenn Sie jedoch Daten über den Benutzer im Microservice `Ordering` speichern müssen, speichern Sie diese unter einer anderen Entität mit dem Namen `Buyer`.</span><span class="sxs-lookup"><span data-stu-id="dace1-176">However, when you need to store data about the user within the `Ordering` microservice, you store it as a different entity named `Buyer`.</span></span> <span data-ttu-id="dace1-177">Die Entität `Buyer` weist die gleiche Identität wie die ursprüngliche Entität `User` auf, sie verfügt jedoch möglicherweise nur über die Attribute, die von der Domäne `Ordering` benötigt werden, und nicht über das gesamte Benutzerprofil.</span><span class="sxs-lookup"><span data-stu-id="dace1-177">The `Buyer` entity shares the same identity with the original `User` entity, but it might have only the few attributes needed by the `Ordering` domain, and not the whole user profile.</span></span>

<span data-ttu-id="dace1-178">Sie können für die Microservices übergreifende asynchrone Übertragung und Weitergabe von Daten ein beliebiges Protokoll verwenden, um die letztliche Konsistenz zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dace1-178">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="dace1-179">Wie bereits erwähnt, könnten Sie Integrationsereignisse mithilfe eines Ereignisbus oder Nachrichtenbrokers verwenden. Alternativ könnten Sie auch HTTP verwenden, indem Sie stattdessen die anderen Dienste abrufen.</span><span class="sxs-lookup"><span data-stu-id="dace1-179">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="dace1-180">Die Vorgehensweise ist nicht wichtig.</span><span class="sxs-lookup"><span data-stu-id="dace1-180">It doesn't matter.</span></span> <span data-ttu-id="dace1-181">Wichtig ist, dass Sie keine synchronen Abhängigkeiten zwischen Ihren Microservices schaffen.</span><span class="sxs-lookup"><span data-stu-id="dace1-181">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="dace1-182">In den folgenden Abschnitten werden die verschiedenen Kommunikationsstile erläutert, die für die Verwendung in einer auf Microservices basierenden Anwendung in Betracht kommen.</span><span class="sxs-lookup"><span data-stu-id="dace1-182">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="dace1-183">Kommunikationsstile</span><span class="sxs-lookup"><span data-stu-id="dace1-183">Communication styles</span></span>

<span data-ttu-id="dace1-184">Abhängig von dem zu verwendenden Kommunikationstyp können Sie zwischen vielen Protokollen und Optionen auswählen, die für die Kommunikation verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="dace1-184">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="dace1-185">Wenn Sie einen synchronen, auf Anforderungen/Antworten basierenden Kommunikationsmechanismus verwenden, kommen am häufigsten HTTP- und REST-Protokolle zum Einsatz, insbesondere dann, wenn Sie Ihre Dienste außerhalb des Docker-Hosts oder des Microserviceclusters veröffentlichen.</span><span class="sxs-lookup"><span data-stu-id="dace1-185">If you're using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you're publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="dace1-186">Bei der internen Kommunikation zwischen Diensten (innerhalb Ihres Docker-Hosts oder Microserviceclusters) können Sie auch Kommunikationsmechanismen im Binärformat verwenden (z.B. WCF über TCP und Binärformat).</span><span class="sxs-lookup"><span data-stu-id="dace1-186">If you're communicating between services internally (within your Docker host or microservices cluster), you might also want to use binary format communication mechanisms (like WCF using TCP and binary format).</span></span> <span data-ttu-id="dace1-187">Alternativ können Sie auch asynchrone, nachrichtenbasierte Kommunikationsmechanismen wie AMQP verwenden.</span><span class="sxs-lookup"><span data-stu-id="dace1-187">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="dace1-188">Es gibt auch mehrere Nachrichtenformate wie JSON, XML oder sogar Binärformate, die effizienter sein können.</span><span class="sxs-lookup"><span data-stu-id="dace1-188">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="dace1-189">Wenn es sich bei dem von Ihnen ausgewählten Binärformat um keinen Standard handelt, sollten Sie Ihre Dienste nicht mit diesem Format öffentlich veröffentlichen.</span><span class="sxs-lookup"><span data-stu-id="dace1-189">If your chosen binary format isn't a standard, it's probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="dace1-190">Sie könnten für die interne Kommunikation zwischen Ihren Microservices ein nicht standardmäßiges Format verwenden.</span><span class="sxs-lookup"><span data-stu-id="dace1-190">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="dace1-191">Dies wäre bei der Kommunikation zwischen Microservices innerhalb Ihres Docker-Hosts oder Microserviceclusters (z.B. Docker-Orchestratoren) oder bei proprietären Clientanwendungen möglich, die mit den Microservices kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="dace1-191">You might do this when communicating between microservices within your Docker host or microservice cluster (for example, Docker orchestrators), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="dace1-192">Kommunikation über Anforderungen/Antworten mit HTTP und REST</span><span class="sxs-lookup"><span data-stu-id="dace1-192">Request/response communication with HTTP and REST</span></span>

<span data-ttu-id="dace1-193">Wenn ein Client die Kommunikation über Anforderungen/Antworten verwendet, sendet er eine Anforderung an einen Dienst. Der Dienst verarbeitet die Anforderung dann und sendet eine Antwort zurück.</span><span class="sxs-lookup"><span data-stu-id="dace1-193">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="dace1-194">Die Kommunikation über Anforderungen/Antworten eignet sich besonders zum Abfragen von Daten für eine Echtzeit-Benutzeroberfläche (eine Live-Benutzeroberfläche) über Client-Apps.</span><span class="sxs-lookup"><span data-stu-id="dace1-194">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="dace1-195">Daher wird dieser Kommunikationsmechanismus (s. Abbildung 4-16) in einer Microservicearchitektur wahrscheinlich bei den meisten Abfragen verwendet.</span><span class="sxs-lookup"><span data-stu-id="dace1-195">Therefore, in a microservice architecture you'll probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![Diagramm, das Anforderung/Antwort-Kommunikation für Liveabfragen und Updates zeigt.](./media/communication-in-microservice-architecture/request-response-comms-live-queries-updates.png)

<span data-ttu-id="dace1-197">**Abbildung 4-16**.</span><span class="sxs-lookup"><span data-stu-id="dace1-197">**Figure 4-16**.</span></span> <span data-ttu-id="dace1-198">Verwenden der Kommunikation über HTTP-Anforderungen/-Antworten (synchron oder asynchron)</span><span class="sxs-lookup"><span data-stu-id="dace1-198">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="dace1-199">Wenn ein Client die Kommunikation über Anforderungen/Antworten verwendet, setzt er voraus, dass die Antwort innerhalb kurzer Zeit (in der Regel nach weniger als einer Sekunde oder höchstens ein paar Sekunden) eintreffen wird.</span><span class="sxs-lookup"><span data-stu-id="dace1-199">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="dace1-200">Bei verzögerten Antworten müssen Sie eine asynchrone Kommunikation implementieren, die auf [Messagingmustern](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) und [Messagingtechnologien](https://en.wikipedia.org/wiki/Message-oriented_middleware) basiert. Dieser Ansatz unterscheidet sich von dem Ansatz, der im nächsten Abschnitt erläutert wird.</span><span class="sxs-lookup"><span data-stu-id="dace1-200">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="dace1-201">Ein beliebter Architekturstil für die Kommunikation über Anforderungen/Antworten ist [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span><span class="sxs-lookup"><span data-stu-id="dace1-201">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="dace1-202">Dieser Ansatz basiert auf dem [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)-Protokoll, das HTTP-Verben wie GET, POST und PUT umfasst, und ist eng daran gekoppelt.</span><span class="sxs-lookup"><span data-stu-id="dace1-202">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="dace1-203">REST ist bei der Erstellung von Diensten der am häufigsten verwendete Architekturstil für die Kommunikation.</span><span class="sxs-lookup"><span data-stu-id="dace1-203">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="dace1-204">Sie können REST-Dienste implementieren, wenn Sie ASP.NET Core Web-API-Dienste entwickeln.</span><span class="sxs-lookup"><span data-stu-id="dace1-204">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="dace1-205">Die Verwendung von HTTP-REST-Diensten als Interface Definition Language bietet einen Mehrwert.</span><span class="sxs-lookup"><span data-stu-id="dace1-205">There's additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="dace1-206">Wenn Sie beispielsweise [Swagger-Metadaten](https://swagger.io/) für die Beschreibung Ihrer Dienst-API verwenden, können Sie Tools verwenden, die Client-Stubs generieren. Diese können Ihre Dienste direkt erkennen und verwenden.</span><span class="sxs-lookup"><span data-stu-id="dace1-206">For instance, if you use [Swagger metadata](https://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="dace1-207">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="dace1-207">Additional resources</span></span>

- <span data-ttu-id="dace1-208">**Martin Fowler. Richardson Maturity Model** (Beschreibung des REST-Modells).</span><span class="sxs-lookup"><span data-stu-id="dace1-208">**Martin Fowler. Richardson Maturity Model** A description of the REST model.</span></span> \
  <https://martinfowler.com/articles/richardsonMaturityModel.html>

- <span data-ttu-id="dace1-209">**Swagger** (offizielle Website).</span><span class="sxs-lookup"><span data-stu-id="dace1-209">**Swagger** The official site.</span></span> \
  <https://swagger.io/>

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="dace1-210">Auf HTTP basierende Push- und Echtzeitkommunikation</span><span class="sxs-lookup"><span data-stu-id="dace1-210">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="dace1-211">Eine andere Möglichkeit (in der Regel zu anderen Zwecken als REST) ist eine in Echtzeitkommunikation und eine 1:n-Kommunikation mit Frameworks der höheren Ebene wie [ASP.NET SignalR](https://www.asp.net/signalr) und Protokollen wie [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span><span class="sxs-lookup"><span data-stu-id="dace1-211">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="dace1-212">Wie in Abbildung 4-17 zu sehen ist, bedeutet HTTP-Kommunikation in Echtzeit, dass Sie über Servercode verfügen können, der bei Zurverfügungstellung der Daten Inhalte mithilfe von Push an verbundene Clients überträgt, statt den Server auf eine Clientanforderung nach neuen Daten warten zu lassen.</span><span class="sxs-lookup"><span data-stu-id="dace1-212">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![Diagramm, das Push- und Echtzeitkommunikation auf Grundlage von SignalR zeigt.](./media/communication-in-microservice-architecture/one-to-many-communication.png)

<span data-ttu-id="dace1-214">**Abbildung 4-17**.</span><span class="sxs-lookup"><span data-stu-id="dace1-214">**Figure 4-17**.</span></span> <span data-ttu-id="dace1-215">Asynchrone 1:1-Nachrichtenkommunikation in Echtzeit</span><span class="sxs-lookup"><span data-stu-id="dace1-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="dace1-216">SignalR ist ein guter Ansatz für die Echtzeitkommunikation, um Inhalte von einem Back-End-Server an Clients zu übertragen.</span><span class="sxs-lookup"><span data-stu-id="dace1-216">SignalR is a good way to achieve real-time communication for pushing content to the clients from a back-end server.</span></span> <span data-ttu-id="dace1-217">Da die Kommunikation in Echtzeit erfolgt, werden die Änderungen in Client-Apps praktisch sofort angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dace1-217">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="dace1-218">Dies wird normalerweise von einem Protokoll wie WebSockets unter Verwendung vieler WebSockets-Verbindungen (eine pro Client) gesteuert.</span><span class="sxs-lookup"><span data-stu-id="dace1-218">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="dace1-219">Ein typisches Beispiel ist, wenn ein Dienst die Bewertungsänderung eines Sportspiels an viele Client-Apps gleichzeitig überträgt.</span><span class="sxs-lookup"><span data-stu-id="dace1-219">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="dace1-220">[Zurück](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
>[Weiter](asynchronous-message-based-communication.md)</span><span class="sxs-lookup"><span data-stu-id="dace1-220">[Previous](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
[Next](asynchronous-message-based-communication.md)</span></span>
