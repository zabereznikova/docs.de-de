---
title: Asynchrone nachrichtenbasierte Kommunikation
description: '.NET-Microservicearchitektur für .NET-Containeranwendungen | Die asynchrone nachrichtenbasierte Kommunikation ist ein wesentliches Konzept der Microservicearchitektur: Sie ist die ideale Option, damit Microservices unabhängig voneinander bleiben und zugleich synchronisiert werden.'
ms.date: 01/13/2021
ms.openlocfilehash: f9d92e2640721b12d47223902712c420b06a5618
ms.sourcegitcommit: a4cecb7389f02c27e412b743f9189bd2a6dea4d6
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 01/14/2021
ms.locfileid: "98189589"
---
# <a name="asynchronous-message-based-communication"></a><span data-ttu-id="a625a-103">Asynchrone nachrichtenbasierte Kommunikation</span><span class="sxs-lookup"><span data-stu-id="a625a-103">Asynchronous message-based communication</span></span>

<span data-ttu-id="a625a-104">Asynchrone nachrichtenbasierte und ereignisgesteuerte Kommunikation ist von entscheidender Bedeutung, wenn Änderungen an mehrere Microservices und ihre zugehörigen Domänenmodelle weitergegeben werden.</span><span class="sxs-lookup"><span data-stu-id="a625a-104">Asynchronous messaging and event-driven communication are critical when propagating changes across multiple microservices and their related domain models.</span></span> <span data-ttu-id="a625a-105">Wie bereits in einem anderen Artikel über Microservices und begrenzte Kontexte erwähnt wurde, können Modelle (Benutzer, Kunde, Produkt, Konto usw.) unterschiedliche Auswirkungen auf verschiedene Microservices oder begrenzte Kontexte haben.</span><span class="sxs-lookup"><span data-stu-id="a625a-105">As mentioned earlier in the discussion microservices and Bounded Contexts (BCs), models (User, Customer, Product, Account, etc.) can mean different things to different microservices or BCs.</span></span> <span data-ttu-id="a625a-106">Wenn also Änderungen auftreten, muss ihre Umsetzung in den unterschiedlichen Modellen abgestimmt werden.</span><span class="sxs-lookup"><span data-stu-id="a625a-106">That means that when changes occur, you need some way to reconcile changes across the different models.</span></span> <span data-ttu-id="a625a-107">Eine Lösung für dieses Problem besteht in letztlicher Konsistenz und ereignisgesteuerter Kommunikation, die auf asynchronem Messaging beruht.</span><span class="sxs-lookup"><span data-stu-id="a625a-107">A solution is eventual consistency and event-driven communication based on asynchronous messaging.</span></span>

<span data-ttu-id="a625a-108">Bei der Verwendung von Messaging kommunizieren Prozesse durch den asynchronen Nachrichtenaustausch.</span><span class="sxs-lookup"><span data-stu-id="a625a-108">When using messaging, processes communicate by exchanging messages asynchronously.</span></span> <span data-ttu-id="a625a-109">Ein Client sendet über eine Nachricht einen Befehl oder eine Anforderung an einen Dienst.</span><span class="sxs-lookup"><span data-stu-id="a625a-109">A client makes a command or a request to a service by sending it a message.</span></span> <span data-ttu-id="a625a-110">Wenn der Dienst antworten muss, sendet er eine andere Nachricht zurück an den Client.</span><span class="sxs-lookup"><span data-stu-id="a625a-110">If the service needs to reply, it sends a different message back to the client.</span></span> <span data-ttu-id="a625a-111">Da es sich um nachrichtenbasierte Kommunikation handelt, nimmt der Client an, dass die Antwort nicht sofort empfangen und möglicherweise überhaupt keine Antwort zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="a625a-111">Since it's a message-based communication, the client assumes that the reply won't be received immediately, and that there might be no response at all.</span></span>

<span data-ttu-id="a625a-112">Eine Nachricht setzt sich aus einem Header (Metadaten zur Identifizierung und Sicherheit) und dem Nachrichtentext zusammen.</span><span class="sxs-lookup"><span data-stu-id="a625a-112">A message is composed by a header (metadata such as identification or security information) and a body.</span></span> <span data-ttu-id="a625a-113">Nachrichten werden in der Regel über asynchrone Protokolle wie AMQP gesendet.</span><span class="sxs-lookup"><span data-stu-id="a625a-113">Messages are usually sent through asynchronous protocols like AMQP.</span></span>

<span data-ttu-id="a625a-114">Die bevorzugte Infrastruktur für diese Art der Kommunikation ist in der Microservicescommunity ein schlanker Nachrichtenbroker, der sich von großen Brokern und Orchestratoren unterscheidet, die in einer SOA-Architektur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="a625a-114">The preferred infrastructure for this type of communication in the microservices community is a lightweight message broker, which is different than the large brokers and orchestrators used in SOA.</span></span> <span data-ttu-id="a625a-115">In einem schlanken Nachrichtenbroker hat die Infrastruktur nur die Aufgabe, als Nachrichtenbroker zu agieren, der auf einfachen Implementierungen wie RabbitMQ oder einem skalierbaren Servicebus in der Cloud wie Azure Service Bus basiert.</span><span class="sxs-lookup"><span data-stu-id="a625a-115">In a lightweight message broker, the infrastructure is typically "dumb," acting only as a message broker, with simple implementations such as RabbitMQ or a scalable service bus in the cloud like Azure Service Bus.</span></span> <span data-ttu-id="a625a-116">In diesem Szenario werden wichtige Entscheidungen nach wie vor in den Endpunkten, die Nachrichten erzeugen und nutzen, und damit in den Microservices getroffen.</span><span class="sxs-lookup"><span data-stu-id="a625a-116">In this scenario, most of the "smart" thinking still lives in the endpoints that are producing and consuming messages-that is, in the microservices.</span></span>

<span data-ttu-id="a625a-117">Sie sollten außerdem versuchen, für die Kommunikation zwischen internen Diensten nur asynchrones Messaging und für Nachrichten von Clientanwendungen an Front-End-Dienste (API-Gateways und zusätzlich die erste Ebene von Microservices) ausschließlich die synchrone Kommunikation (z.B. über HTTP) zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="a625a-117">Another rule you should try to follow, as much as possible, is to use only asynchronous messaging between the internal services, and to use synchronous communication (such as HTTP) only from the client apps to the front-end services (API Gateways plus the first level of microservices).</span></span>

<span data-ttu-id="a625a-118">Unterschieden wird bei asynchronem Messaging zwischen nachrichtenbasierter Kommunikation mit einem Empfänger und nachrichtenbasierte Kommunikation mit mehreren Empfängern.</span><span class="sxs-lookup"><span data-stu-id="a625a-118">There are two kinds of asynchronous messaging communication: single receiver message-based communication, and multiple receivers message-based communication.</span></span> <span data-ttu-id="a625a-119">In den folgenden Abschnitten erfahren Sie mehr darüber.</span><span class="sxs-lookup"><span data-stu-id="a625a-119">The following sections provide details about them.</span></span>

## <a name="single-receiver-message-based-communication"></a><span data-ttu-id="a625a-120">Nachrichtenbasierte Kommunikation mit einem Empfänger</span><span class="sxs-lookup"><span data-stu-id="a625a-120">Single-receiver message-based communication</span></span>

<span data-ttu-id="a625a-121">Die asynchrone nachrichtenbasierte Kommunikation mit einem Empfänger ist eine Punkt-zu-Punkt-Kommunikation: Eine Nachricht wird an genau einen Consumer gesendet, der den Kanal liest. Dabei wird die Nachricht nur einmal verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="a625a-121">Message-based asynchronous communication with a single receiver means there's point-to-point communication that delivers a message to exactly one of the consumers that's reading from the channel, and that the message is processed just once.</span></span> <span data-ttu-id="a625a-122">Es gibt jedoch Situationen, in denen dies anders ist.</span><span class="sxs-lookup"><span data-stu-id="a625a-122">However, there are special situations.</span></span> <span data-ttu-id="a625a-123">In einem Cloudsystem, das automatisch versucht, Fehler zu beheben, könnte dieselbe Nachricht z.B. mehrere Male gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="a625a-123">For instance, in a cloud system that tries to automatically recover from failures, the same message could be sent multiple times.</span></span> <span data-ttu-id="a625a-124">Aufgrund von Netzwerkfehlern oder anderen Fehlern muss der Client in der Lage sein, Nachrichten erneut zu senden. Der Server muss außerdem einen idempotenten Vorgang implementieren, um eine bestimmte Nachricht nur einmal verarbeiten zu müssen.</span><span class="sxs-lookup"><span data-stu-id="a625a-124">Due to network or other failures, the client has to be able to retry sending messages, and the server has to implement an operation to be idempotent in order to process a particular message just once.</span></span>

<span data-ttu-id="a625a-125">Wie in Abbildung 4-18 dargestellt wird, eigent sich die nachrichtenbasierte Kommunikation mit einem Empfänger besonders gut für das Senden asynchroner Befehle von einem Microservice zu einem anderen.</span><span class="sxs-lookup"><span data-stu-id="a625a-125">Single-receiver message-based communication is especially well suited for sending asynchronous commands from one microservice to another as shown in Figure 4-18 that illustrates this approach.</span></span>

<span data-ttu-id="a625a-126">Nachdem Sie die nachrichtenbasierte Kommunikation mithilfe von Befehlen oder Ereignissen gestartet haben, sollten Sie sie nicht zusammen mit der synchronen HTTP-Kommunikation verwenden.</span><span class="sxs-lookup"><span data-stu-id="a625a-126">Once you start sending message-based communication (either with commands or events), you should avoid mixing message-based communication with synchronous HTTP communication.</span></span>

![Ein einzelner Microservice empfängt eine asynchrone Nachricht](./media/asynchronous-message-based-communication/single-receiver-message-based-communication.png)

<span data-ttu-id="a625a-128">**Abbildung 4-18.**</span><span class="sxs-lookup"><span data-stu-id="a625a-128">**Figure 4-18**.</span></span> <span data-ttu-id="a625a-129">Ein einzelner Microservice empfängt eine asynchrone Nachricht</span><span class="sxs-lookup"><span data-stu-id="a625a-129">A single microservice receiving an asynchronous message</span></span>

<span data-ttu-id="a625a-130">Wenn die Befehle von Clientanwendungen stammen, können sie als synchrone HTTP-Befehle implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="a625a-130">When the commands come from client applications, they can be implemented as HTTP synchronous commands.</span></span> <span data-ttu-id="a625a-131">Verwenden Sie nachrichtenbasierte Befehle, wenn Sie auf höhere Skalierbarkeit angewiesen sind oder bereits über einen nachrichtenbasierten Geschäftsprozess verfügen.</span><span class="sxs-lookup"><span data-stu-id="a625a-131">Use message-based commands when you need higher scalability or when you're already in a message-based business process.</span></span>

## <a name="multiple-receivers-message-based-communication"></a><span data-ttu-id="a625a-132">Nachrichtenbasierte Kommunikation mit mehreren Empfängern</span><span class="sxs-lookup"><span data-stu-id="a625a-132">Multiple-receivers message-based communication</span></span>

<span data-ttu-id="a625a-133">Wenn Sie einen flexibleren Ansatz benötigen, können Sie auch einen Veröffentlichen/Abonnieren-Vorgang verwenden, damit die Nachrichten des Senders zusätzlichen Abonnentenmicroservices oder externen Anwendungen zur Verfügung gestellt werden.</span><span class="sxs-lookup"><span data-stu-id="a625a-133">As a more flexible approach, you might also want to use a publish/subscribe mechanism so that your communication from the sender will be available to additional subscriber microservices or to external applications.</span></span> <span data-ttu-id="a625a-134">Es empfiehlt sich daher, dem [Offen/Geschlossen-Prinzip](https://en.wikipedia.org/wiki/Open/closed_principle) im sendenden Dienst zu folgen.</span><span class="sxs-lookup"><span data-stu-id="a625a-134">Thus, it helps you to follow the [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) in the sending service.</span></span> <span data-ttu-id="a625a-135">Auf diese Weise können später zusätzliche Abonnenten hinzugefügt werden, ohne dass der sendende Dienst geändert wird.</span><span class="sxs-lookup"><span data-stu-id="a625a-135">That way, additional subscribers can be added in the future without the need to modify the sender service.</span></span>

<span data-ttu-id="a625a-136">Wenn Sie die Veröffentlichen/Abonnieren-Kommunikation verwenden, können Sie z.B. eine Ereignisbusschnittstelle nutzen, um Ereignisse für Abonnenten zu veröffentlichen.</span><span class="sxs-lookup"><span data-stu-id="a625a-136">When you use a publish/subscribe communication, you might be using an event bus interface to publish events to any subscriber.</span></span>

## <a name="asynchronous-event-driven-communication"></a><span data-ttu-id="a625a-137">Asynchrone ereignisgesteuerte Kommunikation</span><span class="sxs-lookup"><span data-stu-id="a625a-137">Asynchronous event-driven communication</span></span>

<span data-ttu-id="a625a-138">Bei Verwendung der asynchronen ereignisgesteuerten Kommunikation veröffentlicht ein Microservice ein Integrationsereignis, wenn eine Änderung in der zugehörigen Domäne eintritt und ein anderer Microservice darüber informiert werden muss (beispielsweise im Fall einer Preisänderung in einem Microservice für einen Produktkatalog).</span><span class="sxs-lookup"><span data-stu-id="a625a-138">When using asynchronous event-driven communication, a microservice publishes an integration event when something happens within its domain and another microservice needs to be aware of it, like a price change in a product catalog microservice.</span></span> <span data-ttu-id="a625a-139">Zusätzliche Microservices abonnieren die Ereignisse, damit sie sie asynchron empfangen können.</span><span class="sxs-lookup"><span data-stu-id="a625a-139">Additional microservices subscribe to the events so they can receive them asynchronously.</span></span> <span data-ttu-id="a625a-140">In diesem Fall aktualisieren die Empfänger möglicherweise ihre eigenen Domänenentitäten, was dazu führen kann, dass weitere Integrationsereignisse veröffentlicht werden.</span><span class="sxs-lookup"><span data-stu-id="a625a-140">When that happens, the receivers might update their own domain entities, which can cause more integration events to be published.</span></span> <span data-ttu-id="a625a-141">Dieses System des Veröffentlichens/Abonnierens erfolgt über die Implementierung eines Ereignisbusses.</span><span class="sxs-lookup"><span data-stu-id="a625a-141">This publish/subscribe system is performed by using an implementation of an event bus.</span></span> <span data-ttu-id="a625a-142">Der Ereignisbus kann als Abstraktion oder Schnittstelle entworfen werden und verfügt über eine API, die für das Abonnieren bzw. Abbestellen und das Veröffentlichen von Ereignissen benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="a625a-142">The event bus can be designed as an abstraction or interface, with the API that's needed to subscribe or unsubscribe to events and to publish events.</span></span> <span data-ttu-id="a625a-143">Des Weiteren kann der Ereignisbus über mindestens eine Implementierung verfügen, die auf einem Nachrichtenbroker für die prozessübergreifende Kommunikation basiert. Beispiele hierfür sind Nachrichtenwarteschlangen oder Service Busse, die die asynchrone Kommunikation und ein Veröffentlichen/Abonnieren-Modell unterstützen.</span><span class="sxs-lookup"><span data-stu-id="a625a-143">The event bus can also have one or more implementations based on any inter-process and messaging broker, like a messaging queue or service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="a625a-144">Wenn ein System letztliche Konsistenz verwendet, die durch Integrationsereignisse gesteuert wird, sollte dieser Ansatz für den Endbenutzer transparent gestaltet werden.</span><span class="sxs-lookup"><span data-stu-id="a625a-144">If a system uses eventual consistency driven by integration events, it's recommended that this approach is made clear to the end user.</span></span> <span data-ttu-id="a625a-145">Das System sollte keinen Ansatz verwenden, der Integrationsereignisse wie im Fall von SignalR oder beim Abrufen von Systemen vom Client imitiert.</span><span class="sxs-lookup"><span data-stu-id="a625a-145">The system shouldn't use an approach that mimics integration events, like SignalR or polling systems from the client.</span></span> <span data-ttu-id="a625a-146">Sowohl der Endbenutzer als auch der Geschäftsinhaber müssen die letztliche Konsistenz im System explizit berücksichtigen und erkennen, dass dieser Ansatz in Unternehmen oft kein Problem darstellt, solange er explizit dargelegt wird.</span><span class="sxs-lookup"><span data-stu-id="a625a-146">The end user and the business owner have to explicitly embrace eventual consistency in the system and realize that in many cases the business doesn't have any problem with this approach, as long as it's explicit.</span></span> <span data-ttu-id="a625a-147">Dieser Ansatz ist wichtig, weil Benutzer erwarten, dass einige Ergebnisse sofort angezeigt werden, und dies letztlich ggf. nicht der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="a625a-147">This approach is important because users might expect to see some results immediately and this aspect might not happen with eventual consistency.</span></span>

<span data-ttu-id="a625a-148">Wie bereits unter [Challenges and solutions for distributed data management (Herausforderungen und Lösungen für die verteilte Datenverwaltung)](distributed-data-management.md) beschrieben wurde, können Sie Integrationsereignisse dazu nutzen, microserviceübergreifende Geschäftsaufgaben zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="a625a-148">As noted earlier in the [Challenges and solutions for distributed data management](distributed-data-management.md) section, you can use integration events to implement business tasks that span multiple microservices.</span></span> <span data-ttu-id="a625a-149">So kommt es zu letztlicher Konsistenz zwischen diesen Diensten.</span><span class="sxs-lookup"><span data-stu-id="a625a-149">Thus, you'll have eventual consistency between those services.</span></span> <span data-ttu-id="a625a-150">Eine letztlich konsistente Transaktion besteht aus einer Reihe von verteilten Aktionen.</span><span class="sxs-lookup"><span data-stu-id="a625a-150">An eventually consistent transaction is made up of a collection of distributed actions.</span></span> <span data-ttu-id="a625a-151">Bei jeder Aktion aktualisiert der zugehörige Microservice eine Domänenentität und veröffentlicht ein weiteres Integrationsereignis, das die nächste Aktion innerhalb derselben End-to-End-Geschäftsaufgabe auslöst.</span><span class="sxs-lookup"><span data-stu-id="a625a-151">At each action, the related microservice updates a domain entity and publishes another integration event that raises the next action within the same end-to-end business task.</span></span>

<span data-ttu-id="a625a-152">Zu beachten ist, dass Sie möglicherweise mit mehreren Microservices kommunizieren müssen, die für dasselbe Ereignis abonniert sind.</span><span class="sxs-lookup"><span data-stu-id="a625a-152">An important point is that you might want to communicate to multiple microservices that are subscribed to the same event.</span></span> <span data-ttu-id="a625a-153">Dazu können Sie das Veröffentlichen/Abonnieren-Messaging verwenden, das auf ereignisgesteuerter Kommunikation basiert, wie in Abbildung 4-19 gezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="a625a-153">To do so, you can use publish/subscribe messaging based on event-driven communication, as shown in Figure 4-19.</span></span> <span data-ttu-id="a625a-154">Dieser Veröffentlichen/Abonnieren-Mechanismus kann nicht nur für die Microservicearchitektur genutzt werden.</span><span class="sxs-lookup"><span data-stu-id="a625a-154">This publish/subscribe mechanism isn't exclusive to the microservice architecture.</span></span> <span data-ttu-id="a625a-155">Vergleichbar ist die Funktionsweise dieses Ansatzes damit, wie [begrenzte Kontexte](https://martinfowler.com/bliki/BoundedContext.html) in DDD kommunizieren sollte, oder wie Änderungen von der Schreibdatenbank zur Lesedatenbank im Architekturmuster [CQRS (Command and Query Responsibility Segregation)](https://martinfowler.com/bliki/CQRS.html) weitergegeben werden.</span><span class="sxs-lookup"><span data-stu-id="a625a-155">It's similar to the way [Bounded Contexts](https://martinfowler.com/bliki/BoundedContext.html) in DDD should communicate, or to the way you propagate updates from the write database to the read database in the [Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) architecture pattern.</span></span> <span data-ttu-id="a625a-156">Das Ziel ist letztliche Konsistenz zwischen mehreren Datenquellen im verteilten System.</span><span class="sxs-lookup"><span data-stu-id="a625a-156">The goal is to have eventual consistency between multiple data sources across your distributed system.</span></span>

![Das Diagramm zeigt die asynchrone ereignisgesteuerte Kommunikation.](./media/asynchronous-message-based-communication/asynchronous-event-driven-communication.png)

<span data-ttu-id="a625a-158">**Abbildung 4-19.**</span><span class="sxs-lookup"><span data-stu-id="a625a-158">**Figure 4-19**.</span></span> <span data-ttu-id="a625a-159">Asynchrone ereignisgesteuerte Nachrichtenkommunikation</span><span class="sxs-lookup"><span data-stu-id="a625a-159">Asynchronous event-driven message communication</span></span>

<span data-ttu-id="a625a-160">Bei der asynchronen ereignisgesteuerten Kommunikation veröffentlicht ein Microservice Ereignisse auf einem Ereignisbus. Viele Microservices können diesen dann abonnieren, um Benachrichtigungen zu erhalten und damit zu interagieren.</span><span class="sxs-lookup"><span data-stu-id="a625a-160">In asynchronous event-driven communication, one microservice publishes events to an event bus and many microservices can subscribe to it, to get notified and act on it.</span></span> <span data-ttu-id="a625a-161">Die Implementierung bestimmt darüber, welches Protokoll für die ereignisgesteuerte Nachrichtenkommunikation verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="a625a-161">Your implementation will determine what protocol to use for event-driven, message-based communications.</span></span> <span data-ttu-id="a625a-162">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) kann dazu beitragen, eine zuverlässige Kommunikation unter Verwendung von Warteschlangen zu gewährleisten.</span><span class="sxs-lookup"><span data-stu-id="a625a-162">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) can help achieve reliable queued communication.</span></span>

<span data-ttu-id="a625a-163">Bei der Nutzung eines Ereignisbusses empfiehlt sich eine Abstraktionsebene (beispielsweise eine Ereignisbusschnittstelle), die auf einer zugehörigen Implementierung in Klassen mit Code basiert, der die API eines Nachrichtenbrokers wie [RabbitMQ](https://www.rabbitmq.com/) oder eines Service Busses wie [Azure Service Bus mit Themen](/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) verwendet.</span><span class="sxs-lookup"><span data-stu-id="a625a-163">When you use an event bus, you might want to use an abstraction level (like an event bus interface) based on a related implementation in classes with code using the API from a message broker like [RabbitMQ](https://www.rabbitmq.com/) or a service bus like [Azure Service Bus with Topics](/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="a625a-164">Alternativ können Sie auch Service Busse auf höherer Ebene wie NServiceBus, MassTransit oder Brighter verwenden, um den Ereignisbus und das Veröffentlichen/Abonnieren-System umzusetzen.</span><span class="sxs-lookup"><span data-stu-id="a625a-164">Alternatively, you might want to use a higher-level service bus like NServiceBus, MassTransit, or Brighter to articulate your event bus and publish/subscribe system.</span></span>

## <a name="a-note-about-messaging-technologies-for-production-systems"></a><span data-ttu-id="a625a-165">Hinweis zu Messagingtechnologien für Produktionssysteme</span><span class="sxs-lookup"><span data-stu-id="a625a-165">A note about messaging technologies for production systems</span></span>

<span data-ttu-id="a625a-166">Die Messagingtechnologien zur Implementierung eines abstrakten Ereignisbusses werden auf unterschiedlichen Ebenen eingesetzt.</span><span class="sxs-lookup"><span data-stu-id="a625a-166">The messaging technologies available for implementing your abstract event bus are at different levels.</span></span> <span data-ttu-id="a625a-167">Produkte wie RabbitMQ (ein Nachrichtenbroker) und Azure Service Bus sind auf einer niedrigeren Ebene anzusiedeln als andere Produkte wie NServiceBus, MassTransit oder Brighter, die zusätzlich zu RabbitMQ und Azure Service Bus verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="a625a-167">For instance, products like RabbitMQ (a messaging broker transport) and Azure Service Bus sit at a lower level than other products like, NServiceBus, MassTransit, or Brighter, which can work on top of RabbitMQ and Azure Service Bus.</span></span> <span data-ttu-id="a625a-168">Die Auswahl des geeigneten Produkts hängt davon ab, welchen Funktionsumfang auf der Anwendungsebene und welche Standardskalierbarkeit Sie für die Anwendung benötigen.</span><span class="sxs-lookup"><span data-stu-id="a625a-168">Your choice depends on how many rich features at the application level and out-of-the-box scalability you need for your application.</span></span> <span data-ttu-id="a625a-169">Für die Implementierung eines Proof-of-Concept-Ereignisbusses für eine Entwicklungsumgebung (s. eShopOnContainers-Beispiel) ist eine einfache Implementierung zusätzlich zu einer im Docker-Container ausgeführten RabbitMQ-Installation möglicherweise ausreichend.</span><span class="sxs-lookup"><span data-stu-id="a625a-169">For implementing just a proof-of-concept event bus for your development environment, as it was done in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running on a Docker container might be enough.</span></span>

<span data-ttu-id="a625a-170">Für unternehmenskritische Systeme und Produktionssysteme, für die eine sehr hohe Skalierbarkeit erforderlich ist, sollten Sie jedoch Azure Service Bus testen und verwenden.</span><span class="sxs-lookup"><span data-stu-id="a625a-170">However, for mission-critical and production systems that need hyper-scalability, you might want to evaluate Azure Service Bus.</span></span> <span data-ttu-id="a625a-171">Für auf höherer Ebene angesiedelte Abstraktionen und Features, die die Entwicklung von verteilten Anwendungen vereinfachen, empfehlen sich andere kommerzielle Busse und Open Source-Service Busse wie NServiceBus, MassTransit und Brighter.</span><span class="sxs-lookup"><span data-stu-id="a625a-171">For high-level abstractions and features that make the development of distributed applications easier, we recommend that you evaluate other commercial and open-source service buses, such as NServiceBus, MassTransit, and Brighter.</span></span> <span data-ttu-id="a625a-172">Selbstverständlichen können Sie auch eigene Dienstbusfeatures erstellen, die auf Technologien wie RabbitMQ und Docker für niedrigere Ebenen basieren.</span><span class="sxs-lookup"><span data-stu-id="a625a-172">Of course, you can build your own service-bus features on top of lower-level technologies like RabbitMQ and Docker.</span></span> <span data-ttu-id="a625a-173">Sie sollten jedoch beachten, dass Eigenentwicklungen für eine individuelle Unternehmensanwendung möglicherweise zu kostspielig sind.</span><span class="sxs-lookup"><span data-stu-id="a625a-173">But that plumbing work might cost too much for a custom enterprise application.</span></span>

## <a name="resiliently-publishing-to-the-event-bus"></a><span data-ttu-id="a625a-174">Resilientes Veröffentlichen im Ereignisbus</span><span class="sxs-lookup"><span data-stu-id="a625a-174">Resiliently publishing to the event bus</span></span>

<span data-ttu-id="a625a-175">Eine Herausforderung beim Implementieren einer ereignisgesteuerten Architektur für mehrere Microservices besteht darin, den Zustand durch einen unteilbaren Vorgang im ursprünglichen Microservice zu aktualisieren, während das zugehörige Integrationsereignis auf der Grundlage von Transaktionen resilient im Ereignisbus veröffentlicht wird.</span><span class="sxs-lookup"><span data-stu-id="a625a-175">A challenge when implementing an event-driven architecture across multiple microservices is how to atomically update state in the original microservice while resiliently publishing its related integration event into the event bus, somehow based on transactions.</span></span> <span data-ttu-id="a625a-176">Die folgende Liste, die allerdings nicht zwangsläufig vollständig ist, enthält mehrere Ansätze, um diese Funktionalität zu erzielen.</span><span class="sxs-lookup"><span data-stu-id="a625a-176">The following are a few ways to accomplish this functionality, although there could be additional approaches as well.</span></span>

- <span data-ttu-id="a625a-177">Verwenden einer Transaktionswarteschlange wie MSMQ, die auf DTC basiert</span><span class="sxs-lookup"><span data-stu-id="a625a-177">Using a transactional (DTC-based) queue like MSMQ.</span></span> <span data-ttu-id="a625a-178">(dieser Ansatz ist allerdings bereits älter und wird nicht mehr empfohlen).</span><span class="sxs-lookup"><span data-stu-id="a625a-178">(However, this is a legacy approach.)</span></span>

- <span data-ttu-id="a625a-179">Verwenden von Transaktionsprotokollmining.</span><span class="sxs-lookup"><span data-stu-id="a625a-179">Using transaction log mining.</span></span>

- <span data-ttu-id="a625a-180">Verwenden des [Musters „Ereignissourcing“](/azure/architecture/patterns/event-sourcing).</span><span class="sxs-lookup"><span data-stu-id="a625a-180">Using full [Event Sourcing](/azure/architecture/patterns/event-sourcing) pattern.</span></span>

- <span data-ttu-id="a625a-181">Verwenden des [Musters „Postausgang“](https://www.kamilgrzybek.com/design/the-outbox-pattern/). Hierbei bildet eine Transaktionsdatenbanktabelle als Nachrichtenwarteschlange die Basis für eine Ereigniserstellerkomponente, die das Ereignis erstellt und veröffentlicht.</span><span class="sxs-lookup"><span data-stu-id="a625a-181">Using the [Outbox pattern](https://www.kamilgrzybek.com/design/the-outbox-pattern/): a transactional database table as a message queue that will be the base for an event-creator component that would create the event and publish it.</span></span>

<span data-ttu-id="a625a-182">Bei der Verwendung der asynchronen Kommunikation sollten darüber hinaus die Idempotenz und die Deduplizierung von Nachrichten berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="a625a-182">Additional topics to consider when using asynchronous communication are message idempotence and message deduplication.</span></span> <span data-ttu-id="a625a-183">Diese Themen werden an anderer Stelle in diesem Leitfaden unter [Implementieren ereignisbasierter Kommunikation zwischen Microservices (Integrationsereignissen)](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) behandelt.</span><span class="sxs-lookup"><span data-stu-id="a625a-183">These topics are covered in the section [Implementing event-based communication between microservices (integration events)](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) later in this guide.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="a625a-184">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="a625a-184">Additional resources</span></span>

- <span data-ttu-id="a625a-185">**Event Driven Messaging (Ereignisgesteuertes Messaging)**  </span><span class="sxs-lookup"><span data-stu-id="a625a-185">**Event Driven Messaging** </span></span>\
  <https://patterns.arcitura.com/soa-patterns/design_patterns/event_driven_messaging>

- <span data-ttu-id="a625a-186">**Publish/Subscribe Channel (Veröffentlichungs-/Abonnementkanal)**  </span><span class="sxs-lookup"><span data-stu-id="a625a-186">**Publish/Subscribe Channel** </span></span>\
  <https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html>

- <span data-ttu-id="a625a-187">**Udi Dahan. Clarified CQRS (Erläuterung zu CQRS)**  </span><span class="sxs-lookup"><span data-stu-id="a625a-187">**Udi Dahan. Clarified CQRS** </span></span>\
  <https://udidahan.com/2009/12/09/clarified-cqrs/>

- <span data-ttu-id="a625a-188">**Command and Query Responsibility Segregation (CQRS)**  </span><span class="sxs-lookup"><span data-stu-id="a625a-188">**Command and Query Responsibility Segregation (CQRS)** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/cqrs>

- <span data-ttu-id="a625a-189">**Kommunizieren zwischen gebundenen Kontexten** </span><span class="sxs-lookup"><span data-stu-id="a625a-189">**Communicating Between Bounded Contexts** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/jj591572(v=pandp.10)>

- <span data-ttu-id="a625a-190">**Letztliche Konsistenz** </span><span class="sxs-lookup"><span data-stu-id="a625a-190">**Eventual consistency** </span></span>\
  <https://en.wikipedia.org/wiki/Eventual_consistency>

- <span data-ttu-id="a625a-191">**Jimmy Bogard. Refactoring für die Dienstbeständigkeit: Eine Beurteilung der Kopplung** </span><span class="sxs-lookup"><span data-stu-id="a625a-191">**Jimmy Bogard. Refactoring Towards Resilience: Evaluating Coupling** </span></span>\
  <https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/>

> [!div class="step-by-step"]
> <span data-ttu-id="a625a-192">[Zurück](communication-in-microservice-architecture.md)
> [Weiter](maintain-microservice-apis.md)</span><span class="sxs-lookup"><span data-stu-id="a625a-192">[Previous](communication-in-microservice-architecture.md)
[Next](maintain-microservice-apis.md)</span></span>
