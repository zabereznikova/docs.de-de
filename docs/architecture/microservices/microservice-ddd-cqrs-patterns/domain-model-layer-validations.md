---
title: Entwerfen von Validierungen auf der Domänenmodellebene
description: .NET-Microservicesarchitektur für .NET-Containeranwendungen | Wichtige Konzepte für Validierungen von Domänenmodellen
ms.date: 10/08/2018
ms.openlocfilehash: 18c8350d0bf514a8a01a210a2a2a6d8f73317580
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/18/2020
ms.locfileid: "94820630"
---
# <a name="design-validations-in-the-domain-model-layer"></a><span data-ttu-id="fba76-103">Entwerfen von Validierungen auf der Domänenmodellebene</span><span class="sxs-lookup"><span data-stu-id="fba76-103">Design validations in the domain model layer</span></span>

<span data-ttu-id="fba76-104">In DDD können Validierungsregeln als Invarianten betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="fba76-104">In DDD, validation rules can be thought as invariants.</span></span> <span data-ttu-id="fba76-105">Die wichtigste Verantwortung eines Aggregats besteht darin, Invarianten für Zustandsänderungen für alle Entitäten innerhalb dieses Aggregats zu erzwingen.</span><span class="sxs-lookup"><span data-stu-id="fba76-105">The main responsibility of an aggregate is to enforce invariants across state changes for all the entities within that aggregate.</span></span>

<span data-ttu-id="fba76-106">Domänenentitäten sollten immer gültige Entitäten sein.</span><span class="sxs-lookup"><span data-stu-id="fba76-106">Domain entities should always be valid entities.</span></span> <span data-ttu-id="fba76-107">Es gibt eine bestimmte Anzahl an Invarianten für ein Objekt, die immer zutreffen sollten.</span><span class="sxs-lookup"><span data-stu-id="fba76-107">There are a certain number of invariants for an object that should always be true.</span></span> <span data-ttu-id="fba76-108">Beispielsweise muss ein Bestellelementobjekt immer über eine Menge mit einer positiven ganzen Zahl plus Artikelnamen und Artikelpreis verfügen.</span><span class="sxs-lookup"><span data-stu-id="fba76-108">For example, an order item object always has to have a quantity that must be a positive integer, plus an article name and price.</span></span> <span data-ttu-id="fba76-109">Aus diesem Grund liegt die Erzwingung von Invarianten in der Verantwortung der Domänenentitäten (insbesondere des Aggregatstamms) und ein Entitätsobjekt sollte nicht existieren können, wenn es nicht gültig ist.</span><span class="sxs-lookup"><span data-stu-id="fba76-109">Therefore, invariants enforcement is the responsibility of the domain entities (especially of the aggregate root) and an entity object should not be able to exist without being valid.</span></span> <span data-ttu-id="fba76-110">Invariante Regeln werden einfach als Verträge angegeben, und Ausnahmen oder Benachrichtigungen werden ausgelöst, wenn sie verletzt werden.</span><span class="sxs-lookup"><span data-stu-id="fba76-110">Invariant rules are simply expressed as contracts, and exceptions or notifications are raised when they are violated.</span></span>

<span data-ttu-id="fba76-111">Die Überlegung dahinter ist, dass viele Fehler auftreten, weil sich Objekte in einem Zustand befinden, in dem sie nie sein sollten.</span><span class="sxs-lookup"><span data-stu-id="fba76-111">The reasoning behind this is that many bugs occur because objects are in a state they should never have been in.</span></span>

<span data-ttu-id="fba76-112">Nehmen wir an, dass wir SendUserCreationEmailService haben, der ein UserProfile akzeptiert... Wie können wir innerhalb dieses Diensts begründen, dass Name nicht NULL ist?</span><span class="sxs-lookup"><span data-stu-id="fba76-112">Let's propose we now have a SendUserCreationEmailService that takes a UserProfile ... how can we rationalize in that service that Name is not null?</span></span> <span data-ttu-id="fba76-113">Überprüfen wir ihn erneut?</span><span class="sxs-lookup"><span data-stu-id="fba76-113">Do we check it again?</span></span> <span data-ttu-id="fba76-114">Oder wahrscheinlicher... Sie kümmern sich einfach nicht darum und „hoffen auf das Beste“ – Sie hoffen, dass jemand die Validierung durchführt, bevor es an Sie gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="fba76-114">Or more likely ... you just don't bother to check and "hope for the best"—you hope that someone bothered to validate it before sending it to you.</span></span> <span data-ttu-id="fba76-115">Natürlich sollten wir bei der Verwendung von TDD einen der ersten Tests schreiben, bei dem ein Fehler ausgelöst wird, wenn ich einen Kunden mit einem Namen mit einem Wert von NULL schicke.</span><span class="sxs-lookup"><span data-stu-id="fba76-115">Of course, using TDD one of the first tests we should be writing is that if I send a customer with a null name that it should raise an error.</span></span> <span data-ttu-id="fba76-116">Sobald Sie diese Art von Tests immer wieder schreiben, erkennen Sie: „Wenn Namen nie NULL sein dürften, wären alle diese Tests gar nicht nötig.“</span><span class="sxs-lookup"><span data-stu-id="fba76-116">But once we start writing these kinds of tests over and over again we realize ... "wait if we never allowed name to become null we wouldn't have all of these tests".</span></span>

## <a name="implement-validations-in-the-domain-model-layer"></a><span data-ttu-id="fba76-117">Implementieren von Validierungen auf der Domänenmodellebene</span><span class="sxs-lookup"><span data-stu-id="fba76-117">Implement validations in the domain model layer</span></span>

<span data-ttu-id="fba76-118">Validierungen werden in der Regel in Domänenentitätskonstruktoren oder in Methoden implementiert, die die Entität aktualisieren können.</span><span class="sxs-lookup"><span data-stu-id="fba76-118">Validations are usually implemented in domain entity constructors or in methods that can update the entity.</span></span> <span data-ttu-id="fba76-119">Es gibt mehrere Möglichkeiten zum Implementieren von Validierungen, z.B. das Validieren von Daten und Auslösen von Ausnahmen, wenn die Validierung fehlschlägt.</span><span class="sxs-lookup"><span data-stu-id="fba76-119">There are multiple ways to implement validations, such as verifying data and raising exceptions if the validation fails.</span></span> <span data-ttu-id="fba76-120">Es gibt auch erweiterte Muster wie die Verwendung des Spezifikationsmusters für Validierungen und die Benachrichtigungsmuster zum Zurückgeben einer Auflistung von Fehlern, anstatt eine Ausnahme für jede auftretende Validierung zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="fba76-120">There are also more advanced patterns such as using the Specification pattern for validations, and the Notification pattern to return a collection of errors instead of returning an exception for each validation as it occurs.</span></span>

### <a name="validate-conditions-and-throw-exceptions"></a><span data-ttu-id="fba76-121">Validieren von Bedingungen und Auslösen von Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="fba76-121">Validate conditions and throw exceptions</span></span>

<span data-ttu-id="fba76-122">Das folgende Codebeispiel zeigt die einfachste Vorgehensweise zur Validierung in einer Domänenentität durch Auslösen einer Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="fba76-122">The following code example shows the simplest approach to validation in a domain entity by raising an exception.</span></span> <span data-ttu-id="fba76-123">In der Verweistabelle am Ende dieses Abschnitts sehen Sie Links zu fortgeschritteneren Implementierungen, die auf den zuvor besprochenen Mustern basieren.</span><span class="sxs-lookup"><span data-stu-id="fba76-123">In the references table at the end of this section you can see links to more advanced implementations based on the patterns we have discussed previously.</span></span>

```csharp
public void SetAddress(Address address)
{
    _shippingAddress = address?? throw new ArgumentNullException(nameof(address));
}
```

<span data-ttu-id="fba76-124">Ein besseres Beispiel würde zeigen, dass man sicherstellen muss, dass der interne Zustand sich nicht geändert hat oder dass alle Mutationen einer Methode aufgetreten sind.</span><span class="sxs-lookup"><span data-stu-id="fba76-124">A better example would demonstrate the need to ensure that either the internal state did not change, or that all the mutations for a method occurred.</span></span> <span data-ttu-id="fba76-125">Die folgende Implementierung würde z.B. das Objekt in einem ungültigen Zustand belassen:</span><span class="sxs-lookup"><span data-stu-id="fba76-125">For example, the following implementation would leave the object in an invalid state:</span></span>

```csharp
public void SetAddress(string line1, string line2,
    string city, string state, int zip)
{
    _shippingAddress.line1 = line1 ?? throw new ...
    _shippingAddress.line2 = line2;
    _shippingAddress.city = city ?? throw new ...
    _shippingAddress.state = (IsValid(state) ? state : throw new …);
}
```

<span data-ttu-id="fba76-126">Wenn der Wert des Zustands ungültig ist, wurden die erste Adresszeile und der Ort bereits geändert.</span><span class="sxs-lookup"><span data-stu-id="fba76-126">If the value of the state is invalid, the first address line and the city have already been changed.</span></span> <span data-ttu-id="fba76-127">Somit wird die Adresse möglicherweise ungültig.</span><span class="sxs-lookup"><span data-stu-id="fba76-127">That might make the address invalid.</span></span>

<span data-ttu-id="fba76-128">Ein ähnlicher Ansatz kann im Entitätskonstruktor verwendet werden, wodurch eine Ausnahme ausgelöst wird, um sicherzustellen, dass die Entität gültig ist, sobald sie erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="fba76-128">A similar approach can be used in the entity's constructor, raising an exception to make sure that the entity is valid once it is created.</span></span>

### <a name="use-validation-attributes-in-the-model-based-on-data-annotations"></a><span data-ttu-id="fba76-129">Verwenden von Validierungsattributen im Modell anhand von Datenanmerkungen</span><span class="sxs-lookup"><span data-stu-id="fba76-129">Use validation attributes in the model based on data annotations</span></span>

<span data-ttu-id="fba76-130">Datenanmerkungen können ähnlich wie die Required- oder MaxLength-Attribute zum Konfigurieren von EF Core-Datenbankfeld-Eigenschaften verwendet werden, wie im Abschnitt [Tabellenzuordnung](infrastructure-persistence-layer-implementation-entity-framework-core.md#table-mapping) detailliert erläutert. Allerdings [können sie nicht mehr für die Entitätsvalidierung EF Core verwendet werden](https://github.com/dotnet/efcore/issues/3680) (Gleiches gilt für die <xref:System.ComponentModel.DataAnnotations.IValidatableObject.Validate%2A?displayProperty=nameWithType>-Methode), wie dies seit EF 4.x in .NET Framework der Fall war.</span><span class="sxs-lookup"><span data-stu-id="fba76-130">Data annotations, like the Required or MaxLength attributes, can be used to configure EF Core database field properties, as explained in detail in the [Table mapping](infrastructure-persistence-layer-implementation-entity-framework-core.md#table-mapping) section, but [they no longer work for entity validation in EF Core](https://github.com/dotnet/efcore/issues/3680) (neither does the <xref:System.ComponentModel.DataAnnotations.IValidatableObject.Validate%2A?displayProperty=nameWithType> method), as they have done since EF 4.x in .NET Framework.</span></span>

<span data-ttu-id="fba76-131">Datenanmerkungen und die <xref:System.ComponentModel.DataAnnotations.IValidatableObject>-Schnittstelle können weiterhin für die Modellvalidierung während der Modellbindung verwendet werden, bevor die Controlleraktionen aufgerufen werden. Dies ist jedoch für ein ViewModel- oder DTO-Modell vorgesehen. Dabei handelt es sich um einen MVC- oder API-Aspekt, der nicht im Domänenmodell behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="fba76-131">Data annotations and the <xref:System.ComponentModel.DataAnnotations.IValidatableObject> interface can still be used for model validation during model binding, prior to the controller's actions invocation as usual, but that model is meant to be a ViewModel or DTO and that's an MVC or API concern not a domain model concern.</span></span>

<span data-ttu-id="fba76-132">Nachdem die Unterschiede in den Konzepten nun klar sind, können Sie Datenanmerkungen und `IValidatableObject` in der Entitätsklasse weiterhin für die Validierung verwenden, wenn Ihre Aktionen einen Objektparameter der Entitätsklasse empfangen. Dies wird aber nicht empfohlen.</span><span class="sxs-lookup"><span data-stu-id="fba76-132">Having made the conceptual difference clear, you can still use data annotations and `IValidatableObject` in the entity class for validation, if your actions receive an entity class object parameter, which is not recommended.</span></span> <span data-ttu-id="fba76-133">In diesem Fall erfolgt die Validierung bei der Modellbindung, vor dem Aufrufen der Aktion, und Sie können das Ergebnis in der ModelState.IsValid-Eigenschaft des Controllers überprüfen. Aber auch hier gilt: Die Validierung erfolgt im Controller, d. h., nicht bevor das Entitätsobjekt in DbContext gespeichert wird, wie es seit EF 4.x der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="fba76-133">In that case, validation will occur upon model binding, just before invoking the action and you can check the controller's ModelState.IsValid property to check the result, but then again, it happens in the controller, not before persisting the entity object in the DbContext, as it had done since EF 4.x.</span></span>

<span data-ttu-id="fba76-134">Sie können die benutzerdefinierte Validierung weiterhin mithilfe von Datenanmerkungen und der `IValidatableObject.Validate`-Methode in die Entitätsklasse implementieren, indem Sie die SaveChanges-Methode von DbContext überschreiben.</span><span class="sxs-lookup"><span data-stu-id="fba76-134">You can still implement custom validation in the entity class using data annotations and the `IValidatableObject.Validate` method, by overriding the DbContext's SaveChanges method.</span></span>

<span data-ttu-id="fba76-135">Eine Beispielimplementierung für die Validierung von `IValidatableObject`-Elementen finden Sie in [diesem Kommentar auf GitHub](https://github.com/dotnet/efcore/issues/3680#issuecomment-155502539).</span><span class="sxs-lookup"><span data-stu-id="fba76-135">You can see a sample implementation for validating `IValidatableObject` entities in [this comment on GitHub](https://github.com/dotnet/efcore/issues/3680#issuecomment-155502539).</span></span> <span data-ttu-id="fba76-136">Dieses Beispiel führt keine attributbasierten Validierungen durch. Diese lassen sich jedoch durch Reflexion in der gleichen Überschreibung implementieren.</span><span class="sxs-lookup"><span data-stu-id="fba76-136">That sample doesn't do attribute-based validations, but they should be easy to implement using reflection in the same override.</span></span>

<span data-ttu-id="fba76-137">Allerdings bleibt das Domänenmodell aus DDD-Sicht am besten schlank, mit der Verwendung von Ausnahmen in den Verhaltensmethoden Ihrer Entität, oder durch die Implementierung der Spezifikations- und Benachrichtigungsmuster, um Validierungsregeln zu erzwingen.</span><span class="sxs-lookup"><span data-stu-id="fba76-137">However, from a DDD point of view, the domain model is best kept lean with the use of exceptions in your entity's behavior methods, or by implementing the Specification and Notification patterns to enforce validation rules.</span></span>

<span data-ttu-id="fba76-138">Es kann sich als sinnvoll erweisen, Datenanmerkungen auf Anwendungsebene in ViewModel-Klassen (statt Domänenentitäten) zu verwenden, die Eingaben zur Modellvalidierung in der Benutzeroberflächenebene akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="fba76-138">It can make sense to use data annotations at the application layer in ViewModel classes (instead of domain entities) that will accept input, to allow for model validation within the UI layer.</span></span> <span data-ttu-id="fba76-139">Dies sollte jedoch nicht unter Ausschluss der Validierung innerhalb des Domänenmodells ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="fba76-139">However, this should not be done at the exclusion of validation within the domain model.</span></span>

### <a name="validate-entities-by-implementing-the-specification-pattern-and-the-notification-pattern"></a><span data-ttu-id="fba76-140">Validieren von Entitäten durch Implementieren der Spezifikations- und Benachrichtigungsmuster</span><span class="sxs-lookup"><span data-stu-id="fba76-140">Validate entities by implementing the Specification pattern and the Notification pattern</span></span>

<span data-ttu-id="fba76-141">Es gibt einen komplexeren Ansatz zum Implementieren von Validierungen im Domänenmodell. Hierbei wird das Spezifikationsmuster in Verbindung mit dem Benachrichtigungsmuster implementiert, wie in einigen der unten aufgeführten zusätzlichen Ressourcen beschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="fba76-141">Finally, a more elaborate approach to implementing validations in the domain model is by implementing the Specification pattern in conjunction with the Notification pattern, as explained in some of the additional resources listed later.</span></span>

<span data-ttu-id="fba76-142">Es ist erwähnenswert, dass Sie auch nur eines dieser Muster verwenden können – z.B. das manuelle Validieren mit Steueranweisungen und das Verwenden des Benachrichtigungsmusters zum Stapeln und Zurückgeben einer Liste von Validierungsfehlern.</span><span class="sxs-lookup"><span data-stu-id="fba76-142">It is worth mentioning that you can also use just one of those patterns—for example, validating manually with control statements, but using the Notification pattern to stack and return a list of validation errors.</span></span>

### <a name="use-deferred-validation-in-the-domain"></a><span data-ttu-id="fba76-143">Verwenden der verzögerten Validierung in der Domäne</span><span class="sxs-lookup"><span data-stu-id="fba76-143">Use deferred validation in the domain</span></span>

<span data-ttu-id="fba76-144">Es gibt verschiedene Ansätze für den Umgang mit verzögerten Validierungen in der Domäne.</span><span class="sxs-lookup"><span data-stu-id="fba76-144">There are various approaches to deal with deferred validations in the domain.</span></span> <span data-ttu-id="fba76-145">In seinem Buch [Implementing Domain-Driven Design (Implementieren von domänengesteuertem Design)](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577) erläutert Vaughn Vernon dies im Abschnitt zur Validierung.</span><span class="sxs-lookup"><span data-stu-id="fba76-145">In his book [Implementing Domain-Driven Design](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577), Vaughn Vernon discusses these in the section on validation.</span></span>

### <a name="two-step-validation"></a><span data-ttu-id="fba76-146">Zweistufige Validierung</span><span class="sxs-lookup"><span data-stu-id="fba76-146">Two-step validation</span></span>

<span data-ttu-id="fba76-147">Ziehen Sie auch die zweistufige Validierung in Betracht.</span><span class="sxs-lookup"><span data-stu-id="fba76-147">Also consider two-step validation.</span></span> <span data-ttu-id="fba76-148">Verwenden Sie Feldebenenvalidierung für Ihre Datentransferobjekte (DTOs) und Domänenebenenvalidierung innerhalb Ihrer Entitäten.</span><span class="sxs-lookup"><span data-stu-id="fba76-148">Use field-level validation on your command Data Transfer Objects (DTOs) and domain-level validation inside your entities.</span></span> <span data-ttu-id="fba76-149">Dazu wird ein Ergebnisobjekt anstelle von Ausnahmen zurückgegeben, um den Umgang mit den Validierungsfehlern zu erleichtern.</span><span class="sxs-lookup"><span data-stu-id="fba76-149">You can do this by returning a result object instead of exceptions in order to make it easier to deal with the validation errors.</span></span>

<span data-ttu-id="fba76-150">Wenn Sie z.B. die Feldvalidierung mit Datenanmerkungen verwenden, duplizieren Sie die Validierungsdefinition nicht.</span><span class="sxs-lookup"><span data-stu-id="fba76-150">Using field validation with data annotations, for example, you do not duplicate the validation definition.</span></span> <span data-ttu-id="fba76-151">Die Ausführung kann jedoch im Fall von DTOs serverseitig und clientseitig sein (beispielsweise Befehle und ViewModels).</span><span class="sxs-lookup"><span data-stu-id="fba76-151">The execution, though, can be both server-side and client-side in the case of DTOs (commands and ViewModels, for instance).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="fba76-152">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="fba76-152">Additional resources</span></span>

- <span data-ttu-id="fba76-153">**Rachel Appel. Introduction to model validation in ASP.NET Core MVC** \ (Einführung in die Modellvalidierung im ASP.NET Core MVC)</span><span class="sxs-lookup"><span data-stu-id="fba76-153">**Rachel Appel. Introduction to model validation in ASP.NET Core MVC** </span></span>\
  <https://docs.microsoft.com/aspnet/core/mvc/models/validation>

- <span data-ttu-id="fba76-154">**Rick Anderson. Adding validation** \ (Hinzufügen der Validierung)</span><span class="sxs-lookup"><span data-stu-id="fba76-154">**Rick Anderson. Adding validation** </span></span>\
  <https://docs.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation>

- <span data-ttu-id="fba76-155">**Martin Fowler. Replacing Throwing Exceptions with Notification in Validations** \ (Ersetzen des Auslösens von Ausnahmen durch Benachrichtigungen in Validierungen)</span><span class="sxs-lookup"><span data-stu-id="fba76-155">**Martin Fowler. Replacing Throwing Exceptions with Notification in Validations** </span></span>\
  <https://martinfowler.com/articles/replaceThrowWithNotification.html>

- <span data-ttu-id="fba76-156">**Specification and Notification Patterns** \ (Spezifikations- und Benachrichtigungsmuster)</span><span class="sxs-lookup"><span data-stu-id="fba76-156">**Specification and Notification Patterns** </span></span>\
  <https://www.codeproject.com/Tips/790758/Specification-and-Notification-Patterns>

- <span data-ttu-id="fba76-157">**Lev Gorodinski. Validation in Domain-Driven Design (DDD)**  \ (Validierung in Domain-Driven-Design [DDD])</span><span class="sxs-lookup"><span data-stu-id="fba76-157">**Lev Gorodinski. Validation in Domain-Driven Design (DDD)** </span></span>\
  <http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/>

- <span data-ttu-id="fba76-158">**Colin Jack. Domain Model Validation** \ (Validierung des Domänenmodells)</span><span class="sxs-lookup"><span data-stu-id="fba76-158">**Colin Jack. Domain Model Validation** </span></span>\
  <https://colinjack.blogspot.com/2008/03/domain-model-validation.html>

- <span data-ttu-id="fba76-159">**Jimmy Bogard. Validation in a DDD world** \ (Validierung in einer DDD-Welt)</span><span class="sxs-lookup"><span data-stu-id="fba76-159">**Jimmy Bogard. Validation in a DDD world** </span></span>\
  <https://lostechies.com/jimmybogard/2009/02/15/validation-in-a-ddd-world/>

> [!div class="step-by-step"]
> <span data-ttu-id="fba76-160">[Zurück](enumeration-classes-over-enum-types.md)
> [Weiter](client-side-validation.md)</span><span class="sxs-lookup"><span data-stu-id="fba76-160">[Previous](enumeration-classes-over-enum-types.md)
[Next](client-side-validation.md)</span></span>
