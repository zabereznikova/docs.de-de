---
title: Implementieren eines Microservicedomänenmodells mit .NET Core
description: .NET-Microservicearchitektur für .NET-Containeranwendungen | Übersicht über die Implementierungsdetails eines DDD-orientierten Domänenmodells
ms.date: 10/08/2018
ms.openlocfilehash: bff9cbda08e519038056268151a1721427f0ac01
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/12/2019
ms.locfileid: "73972046"
---
# <a name="implement-a-microservice-domain-model-with-net-core"></a><span data-ttu-id="17cc9-103">Implementieren eines Microservicedomänenmodells mit .NET Core</span><span class="sxs-lookup"><span data-stu-id="17cc9-103">Implement a microservice domain model with .NET Core</span></span>

<span data-ttu-id="17cc9-104">Im letzten Abschnitt wurden die Prinzipen und Muster zum Design erläutert, die grundlegend für das Erstellen eines Domänenmodells sind.</span><span class="sxs-lookup"><span data-stu-id="17cc9-104">In the previous section, the fundamental design principles and patterns for designing a domain model were explained.</span></span> <span data-ttu-id="17cc9-105">Jetzt soll dargestellt werden, wie Sie das Domänenmodell mithilfe von .NET Core (einfacher C\#-Code) und EF Core implementieren.</span><span class="sxs-lookup"><span data-stu-id="17cc9-105">Now it is time to explore possible ways to implement the domain model by using .NET Core (plain C\# code) and EF Core.</span></span> <span data-ttu-id="17cc9-106">Beachten Sie dass das Domänenmodell in diesem Beispiel nur aus Ihrem Code besteht.</span><span class="sxs-lookup"><span data-stu-id="17cc9-106">Note that your domain model will be composed simply of your code.</span></span> <span data-ttu-id="17cc9-107">Es enthält nur die EF Core-Modellanforderungen, aber keine echten Abhängigkeiten von EF.</span><span class="sxs-lookup"><span data-stu-id="17cc9-107">It will have just the EF Core model requirements, but not real dependencies on EF.</span></span> <span data-ttu-id="17cc9-108">Es sollten keine festen Abhängigkeiten oder Verweise auf EF Core auf eine objektrelationale Abbildung (Object-relational Mapping, ORM) in Ihrem Domänenmodell enthalten sein.</span><span class="sxs-lookup"><span data-stu-id="17cc9-108">You should not have hard dependencies or references to EF Core or any other ORM in your domain model.</span></span>

## <a name="domain-model-structure-in-a-custom-net-standard-library"></a><span data-ttu-id="17cc9-109">Domänenmodellstruktur in einer benutzerdefinierten .NET Standard-Bibliothek</span><span class="sxs-lookup"><span data-stu-id="17cc9-109">Domain model structure in a custom .NET Standard Library</span></span>

<span data-ttu-id="17cc9-110">Die Ordnerorganisation, die für die Referenzanwendung „eShopOnContainers“ verwendet wird, stellt das Modell für das domänengesteuerte Design für die Anwendung dar.</span><span class="sxs-lookup"><span data-stu-id="17cc9-110">The folder organization used for the eShopOnContainers reference application demonstrates the DDD model for the application.</span></span> <span data-ttu-id="17cc9-111">Möglicherweise stellen Sie fest, dass die Ordnerorganisation Ihren Überlegungen zum Anwendungsentwurf angepasst werden muss.</span><span class="sxs-lookup"><span data-stu-id="17cc9-111">You might find that a different folder organization more clearly communicates the design choices made for your application.</span></span> <span data-ttu-id="17cc9-112">Wie in Abbildung 7-10 dargestellt, gibt es im Domänenmodell für Bestellungen zwei Aggregate: das Aggregat „Order“ und das Aggregat „Buyer“.</span><span class="sxs-lookup"><span data-stu-id="17cc9-112">As you can see in Figure 7-10, in the ordering domain model there are two aggregates, the order aggregate and the buyer aggregate.</span></span> <span data-ttu-id="17cc9-113">Jedes Aggregat besteht aus einer Gruppe von Domänenentitäten und Wertobjekten. Sie können aber auch über ein Aggregat verfügen, das aus genau einer Domänenentität besteht (dem Aggregatstamm oder der Stammentität).</span><span class="sxs-lookup"><span data-stu-id="17cc9-113">Each aggregate is a group of domain entities and value objects, although you could have an aggregate composed of a single domain entity (the aggregate root or root entity) as well.</span></span>

<span data-ttu-id="17cc9-114">:::image type="complex" source="./media/net-core-microservice-domain-model/ordering-microservice-container.png" alt-text="Screenshot des Projekts „Ordering.Domain“ im Projektmappen-Explorer.":::</span><span class="sxs-lookup"><span data-stu-id="17cc9-114">:::image type="complex" source="./media/net-core-microservice-domain-model/ordering-microservice-container.png" alt-text="Screenshot of the Ordering.Domain project in Solution Explorer.":::</span></span>
<span data-ttu-id="17cc9-115">Ansicht im Projektmappen-Explorer: Projekt Ordering.Domain mit dem Ordner „AggregatesModel“, der die Ordner „BuyerAggregate“ und „OrderAggregate“ enthält, die jeweils ihre Entitätsklassen, Wertobjektdateien und so weiter enthalten</span><span class="sxs-lookup"><span data-stu-id="17cc9-115">The Solution Explorer view for the Ordering.Domain project, showing the AggregatesModel folder containing the BuyerAggregate and OrderAggregate folders, each one containing it's entity classes, value object files and so on.</span></span>
:::image-end:::

<span data-ttu-id="17cc9-116">**Abbildung 7-10**.</span><span class="sxs-lookup"><span data-stu-id="17cc9-116">**Figure 7-10**.</span></span> <span data-ttu-id="17cc9-117">Domänenmodellstruktur für den Microservice für Bestellungen in eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="17cc9-117">Domain model structure for the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="17cc9-118">Außerdem umfasst die Ebene des Domänenmodells Repositoryverträge (Schnittstellen), die die Infrastrukturanforderungen Ihres Domänemodells ausmachen.</span><span class="sxs-lookup"><span data-stu-id="17cc9-118">Additionally, the domain model layer includes the repository contracts (interfaces) that are the infrastructure requirements of your domain model.</span></span> <span data-ttu-id="17cc9-119">Anders gesagt: Diese Schnittstellen drücken aus, welche Repositorys und Methoden die Infrastrukturebene implementieren muss.</span><span class="sxs-lookup"><span data-stu-id="17cc9-119">In other words, these interfaces express what repositories and the methods the infrastructure layer must implement.</span></span> <span data-ttu-id="17cc9-120">Es ist wichtig, dass die Implementierung der Repositorys außerhalb der Domänemodellebene in der Bibliothek auf Infrastruktureben platziert wird, damit die Domänenmodellebene nicht durch die APIs oder Klassen der Infrastrukturtechnologien wie Entity Framework verunreinigt wird.</span><span class="sxs-lookup"><span data-stu-id="17cc9-120">It is critical that the implementation of the repositories be placed outside of the domain model layer, in the infrastructure layer library, so the domain model layer is not “contaminated” by API or classes from infrastructure technologies, like Entity Framework.</span></span>

<span data-ttu-id="17cc9-121">Außerdem wird ein [SeedWork](https://martinfowler.com/bliki/Seedwork.html)-Ordner angezeigt, der benutzerbasierte Basisklassen enthält, die Sie als Grundlage für Ihre Domänenentitäten und Wertobjekte verwenden können, sodass redundanter Code in den Objektklassen der einzelnen Domänen vermieden wird.</span><span class="sxs-lookup"><span data-stu-id="17cc9-121">You can also see a [SeedWork](https://martinfowler.com/bliki/Seedwork.html) folder that contains custom base classes that you can use as a base for your domain entities and value objects, so you do not have redundant code in each domain’s object class.</span></span>

## <a name="structure-aggregates-in-a-custom-net-standard-library"></a><span data-ttu-id="17cc9-122">Strukturieren von Aggregaten in einer benutzerdefinierten .NET Standard-Bibliothek</span><span class="sxs-lookup"><span data-stu-id="17cc9-122">Structure aggregates in a custom .NET Standard library</span></span>

<span data-ttu-id="17cc9-123">Ein Aggregat bezieht sich auf einen Cluster von Domänenobjekten, die entsprechend der Transaktionskonsistenz gruppiert sind.</span><span class="sxs-lookup"><span data-stu-id="17cc9-123">An aggregate refers to a cluster of domain objects grouped together to match transactional consistency.</span></span> <span data-ttu-id="17cc9-124">Bei diesen Objekten kann es sich um Instanzen von Entitäten (wobei eine der Entitäten der Aggregatstamm oder die Stammentität ist) einschließlich zusätzlicher Wertobjekte handeln.</span><span class="sxs-lookup"><span data-stu-id="17cc9-124">Those objects could be instances of entities (one of which is the aggregate root or root entity) plus any additional value objects.</span></span>

<span data-ttu-id="17cc9-125">Der Begriff „Transaktionskonsistenz“ bedeutet, dass ein Aggregat am Ende einer geschäftlichen Transaktion garantiert konsistent und aktuell ist.</span><span class="sxs-lookup"><span data-stu-id="17cc9-125">Transactional consistency means that an aggregate is guaranteed to be consistent and up to date at the end of a business action.</span></span> <span data-ttu-id="17cc9-126">Das Aggregat „Order“ aus dem Domänenmodell des Microservices für Bestellungen setzt sich wie in Abbildung 7-11 dargestellt zusammen.</span><span class="sxs-lookup"><span data-stu-id="17cc9-126">For example, the order aggregate from the eShopOnContainers ordering microservice domain model is composed as shown in Figure 7-11.</span></span>

<span data-ttu-id="17cc9-127">:::image type="complex" source="./media/net-core-microservice-domain-model/vs-solution-explorer-order-aggregate.png" alt-text="Screenshot des Ordners „OrderAggregate“ und seiner Klassen.":::</span><span class="sxs-lookup"><span data-stu-id="17cc9-127">:::image type="complex" source="./media/net-core-microservice-domain-model/vs-solution-explorer-order-aggregate.png" alt-text="Screenshot of the OrderAggregate folder and its classes.":::</span></span>
<span data-ttu-id="17cc9-128">Detailansicht des Ordners OrderAggregate: „Address.cs“ ist ein Wertobjekt, „IOrderRepository“ eine Repositoryschnittstelle, „Order.cs“ ein Aggregatstamm, „OrderItem.cs“ eine untergeordnete Entität und „OrderStatus.cs“ eine Enumerationsklasse.</span><span class="sxs-lookup"><span data-stu-id="17cc9-128">A detailed view of the OrderAggregate folder: Address.cs is a value object, IOrderRepository is a repo interface, Order.cs is an aggregate root, OrderItem.cs is a child entity, and OrderStatus.cs is an enumeration class.</span></span>
:::image-end:::

<span data-ttu-id="17cc9-129">**Abbildung 7-11**.</span><span class="sxs-lookup"><span data-stu-id="17cc9-129">**Figure 7-11**.</span></span> <span data-ttu-id="17cc9-130">Das Aggregat „Order“ in einer Visual Studio-Projektmappe</span><span class="sxs-lookup"><span data-stu-id="17cc9-130">The order aggregate in Visual Studio solution</span></span>

<span data-ttu-id="17cc9-131">Wenn Sie eine der Dateien in einem Aggregatordner öffnen, sehen Sie, dass diese entweder als benutzerdefinierte Basisklasse oder als benutzerdefinierte Schnittstelle markiert ist. Dies gilt z.B. für Entitäten oder Wertobjekte, die in den [SeedWork](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork)-Ordner implementiert wurden.</span><span class="sxs-lookup"><span data-stu-id="17cc9-131">If you open any of the files in an aggregate folder, you can see how it is marked as either a custom base class or interface, like entity or value object, as implemented in the [SeedWork](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork) folder.</span></span>

## <a name="implement-domain-entities-as-poco-classes"></a><span data-ttu-id="17cc9-132">Implementieren von Domänenentitäten als POCO-Klassen</span><span class="sxs-lookup"><span data-stu-id="17cc9-132">Implement domain entities as POCO classes</span></span>

<span data-ttu-id="17cc9-133">Domänenmodelle werden in .NET implementiert, indem POCO-Klassen erstellt werden, die Domänenentitäten implementieren.</span><span class="sxs-lookup"><span data-stu-id="17cc9-133">You implement a domain model in .NET by creating POCO classes that implement your domain entities.</span></span> <span data-ttu-id="17cc9-134">Im folgenden Beispiel ist die Klasse „Order“ als Entität und als Aggregatstamm definiert.</span><span class="sxs-lookup"><span data-stu-id="17cc9-134">In the following example, the Order class is defined as an entity and also as an aggregate root.</span></span> <span data-ttu-id="17cc9-135">Da die Klasse „Order“ von der Basisklasse „Entity“ abgeleitet wird, kann diese häufig verwendeten Code wiederverwenden, der in Zusammenhang mit den Entitäten steht.</span><span class="sxs-lookup"><span data-stu-id="17cc9-135">Because the Order class derives from the Entity base class, it can reuse common code related to entities.</span></span> <span data-ttu-id="17cc9-136">Denken Sie daran, dass diese Basisklassen und Schnittstellen von Ihnen im Domänenmodellprojekt definiert werden. Es handelt sich also um Ihren Code und nicht um Infrastrukturcode aus einer ORM wie EF.</span><span class="sxs-lookup"><span data-stu-id="17cc9-136">Bear in mind that these base classes and interfaces are defined by you in the domain model project, so it is your code, not infrastructure code from an ORM like EF.</span></span>

```csharp
// COMPATIBLE WITH ENTITY FRAMEWORK CORE 2.0
// Entity is a custom base class with the ID
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId;

    public OrderStatus OrderStatus { get; private set; }
    private int _orderStatusId;

    private string _description;
    private int? _paymentMethodId;

    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;

    public Order(string userId, Address address, int cardTypeId, string cardNumber, string cardSecurityNumber,
            string cardHolderName, DateTime cardExpiration, int? buyerId = null, int? paymentMethodId = null)
    {
        _orderItems = new List<OrderItem>();
        _buyerId = buyerId;
        _paymentMethodId = paymentMethodId;
        _orderStatusId = OrderStatus.Submitted.Id;
        _orderDate = DateTime.UtcNow;
        Address = address;

        // ...Additional code ...
    }

    public void AddOrderItem(int productId, string productName,
                            decimal unitPrice, decimal discount,
                            string pictureUrl, int units = 1)
    {
        //...
        // Domain rules/logic for adding the OrderItem to the order
        // ...

        var orderItem = new OrderItem(productId, productName, unitPrice, discount, pictureUrl, units);

        _orderItems.Add(orderItem);

    }
    // ...
    // Additional methods with domain rules/logic related to the Order aggregate
    // ...
}
```

<span data-ttu-id="17cc9-137">Beachten Sie, dass es sich dabei um eine Domänenentität handelt, die als POCO-Klasse implementiert ist.</span><span class="sxs-lookup"><span data-stu-id="17cc9-137">It is important to note that this is a domain entity implemented as a POCO class.</span></span> <span data-ttu-id="17cc9-138">Diese Entität hat keine direkten Abhängigkeiten von EF Core oder anderen Infrastrukturframeworks.</span><span class="sxs-lookup"><span data-stu-id="17cc9-138">It does not have any direct dependency on Entity Framework Core or any other infrastructure framework.</span></span> <span data-ttu-id="17cc9-139">Diese Implementierung eignet sich hervorragend für domänengesteuertes Design, da es sich nur um C\#-Code handelt, der ein Domänenmodell implementiert.</span><span class="sxs-lookup"><span data-stu-id="17cc9-139">This implementation is as it should be in DDD, just C\# code implementing a domain model.</span></span>

<span data-ttu-id="17cc9-140">Außerdem wird die Klasse durch eine Schnittstelle namens „IAggregateRoot“ ergänzt.</span><span class="sxs-lookup"><span data-stu-id="17cc9-140">In addition, the class is decorated with an interface named IAggregateRoot.</span></span> <span data-ttu-id="17cc9-141">Diese Schnittstelle ist leer und wird gelegentlich als *marker interface* (Markierungsschnittstelle) bezeichnet, die verwendet wird, um anzudeuten, dass es sich bei dieser Entitätsklasse ebenfalls um einen Aggregatstamm handelt.</span><span class="sxs-lookup"><span data-stu-id="17cc9-141">That interface is an empty interface, sometimes called a *marker interface*, that is used just to indicate that this entity class is also an aggregate root.</span></span>

<span data-ttu-id="17cc9-142">Markierugsschnittstellen werden gelegentlich zwar als Antimuster bezeichnet, jedoch sind sie hilfreich, um eine Klasse zu markieren – insbesondere, wenn sich diese Schnittstelle weiterentwickelt.</span><span class="sxs-lookup"><span data-stu-id="17cc9-142">A marker interface is sometimes considered as an anti-pattern; however, it is also a clean way to mark a class, especially when that interface might be evolving.</span></span> <span data-ttu-id="17cc9-143">Der Marker kann zwar auch Attribute verwenden, jedoch geht es schneller, die Basisklasse (Entität) neben der IAggregate-Schnittstelle zu überprüfen, anstatt einen Attributmarker für Aggregate oberhalb der Klasse zu positionieren.</span><span class="sxs-lookup"><span data-stu-id="17cc9-143">An attribute could be the other choice for the marker, but it is quicker to see the base class (Entity) next to the IAggregate interface instead of putting an Aggregate attribute marker above the class.</span></span> <span data-ttu-id="17cc9-144">Sie können hier nach Belieben entscheiden.</span><span class="sxs-lookup"><span data-stu-id="17cc9-144">It is a matter of preferences, in any case.</span></span>

<span data-ttu-id="17cc9-145">Wenn ein Aggregatstamm vorhanden ist, bedeutet dies, dass der meiste Code, der im Zusammenhang mit der Konsistenz und den Geschäftsregeln der Entitäten des Aggregats steht, als Methoden in der Aggregatstammklasse „Order“ implementiert werden soll (z.B. AddOrderItem beim Hinzufügen eines OrderItem-Objekts zum Aggregat).</span><span class="sxs-lookup"><span data-stu-id="17cc9-145">Having an aggregate root means that most of the code related to consistency and business rules of the aggregate’s entities should be implemented as methods in the Order aggregate root class (for example, AddOrderItem when adding an OrderItem object to the aggregate).</span></span> <span data-ttu-id="17cc9-146">Sie sollten OrderItems-Objekte nicht unabhängig oder direkt erstellen oder aktualisieren. Stattdessen sollte die AggregateRoot-Klasse die Kontrolle und Konsistenz jedes Aktualisierungsvorgangs gegenüber der untergeordneten Entitäten behalten.</span><span class="sxs-lookup"><span data-stu-id="17cc9-146">You should not create or update OrderItems objects independently or directly; the AggregateRoot class must keep control and consistency of any update operation against its child entities.</span></span>

## <a name="encapsulate-data-in-the-domain-entities"></a><span data-ttu-id="17cc9-147">Kapseln von Daten in Domänenentitäten</span><span class="sxs-lookup"><span data-stu-id="17cc9-147">Encapsulate data in the Domain Entities</span></span>

<span data-ttu-id="17cc9-148">Ein häufiges Problem im Zusammenhang mit Entitätsmodellen ist, dass sie Navigationseigenschaften für Auflistungen als öffentlich zugängliche Listentypen zur Verfügung stellen.</span><span class="sxs-lookup"><span data-stu-id="17cc9-148">A common problem in entity models is that they expose collection navigation properties as publicly accessible list types.</span></span> <span data-ttu-id="17cc9-149">Dadurch kann jedes Mitglied des Entwicklerteams die Inhalte dieser Auflistungstypen ändern. Dabei können möglicherweise wichtige Geschäftsregeln umgangen werden, die im Zusammenhang mit der Auflistung stehen, wodurch das Objekt im Status „ungültig“ hinterlassen wird.</span><span class="sxs-lookup"><span data-stu-id="17cc9-149">This allows any collaborator developer to manipulate the contents of these collection types, which may bypass important business rules related to the collection, possibly leaving the object in an invalid state.</span></span> <span data-ttu-id="17cc9-150">Zur Lösung dieses Problems können Sie den Zugriff auf verwandte Auslistungen auf „schreibgeschützt“ beschränken und explizit Methoden zur Verfügung stellen, über die Clients Änderungen vornehmen können.</span><span class="sxs-lookup"><span data-stu-id="17cc9-150">The solution to this is to expose read-only access to related collections and explicitly provide methods that define ways in which clients can manipulate them.</span></span>

<span data-ttu-id="17cc9-151">Beachten Sie, dass viele Attribute im vorherigen Code schreibgeschützt oder privat sind und nur von Klassenmethoden aktualisiert werden können. So berücksichtigt jedes Update Invarianten der Geschäftsdomäne und die Logik, die in der Klassenmethode angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="17cc9-151">In the previous code, note that many attributes are read-only or private and are only updatable by the class methods, so any update considers business domain invariants and logic specified within the class methods.</span></span>

<span data-ttu-id="17cc9-152">Wenn Sie sich z.B. an die Muster des domänengesteuerten Designs halten, **sollten Sie den folgenden Vorgang *nicht*** über eine Befehlshandlermethode oder Anwendungsschichtklasse ausführen (genau genommen, sollten Sie dazu gar nicht berechtigt sein):</span><span class="sxs-lookup"><span data-stu-id="17cc9-152">For example, following DDD patterns, **you should *not* do the following** from any command handler method or application layer class (actually, it should be impossible for you to do so):</span></span>

```csharp
// WRONG ACCORDING TO DDD PATTERNS – CODE AT THE APPLICATION LAYER OR
// COMMAND HANDLERS
// Code in command handler methods or Web API controllers
//... (WRONG) Some code with business logic out of the domain classes ...
OrderItem myNewOrderItem = new OrderItem(orderId, productId, productName,
    pictureUrl, unitPrice, discount, units);

//... (WRONG) Accessing the OrderItems collection directly from the application layer // or command handlers
myOrder.OrderItems.Add(myNewOrderItem);
//...
```

<span data-ttu-id="17cc9-153">In diesem Fall handelt es sich bei der Methode „Add“ nur um einen Vorgang zum Hinzufügen von Daten mit Direktzugriff auf die OrderItems-Auflistung.</span><span class="sxs-lookup"><span data-stu-id="17cc9-153">In this case, the Add method is purely an operation to add data, with direct access to the OrderItems collection.</span></span> <span data-ttu-id="17cc9-154">Aus diesem Grund wird ein Großteil der Domänenlogik, Regeln oder Validierungen, der im Zusammenhang mit diesem Vorgang mit den untergeordneten Entitäten steht, auf die Anwendungsebene verteilt (Befehlshandler und Web-API-Controller).</span><span class="sxs-lookup"><span data-stu-id="17cc9-154">Therefore, most of the domain logic, rules, or validations related to that operation with the child entities will be spread across the application layer (command handlers and Web API controllers).</span></span>

<span data-ttu-id="17cc9-155">Wenn Sie den Aggregatstamm umgehen, kann dieser weder seine Invarianten noch seine Gültigkeit oder Konsistenz garantieren.</span><span class="sxs-lookup"><span data-stu-id="17cc9-155">If you go around the aggregate root, the aggregate root cannot guarantee its invariants, its validity, or its consistency.</span></span> <span data-ttu-id="17cc9-156">So wird Ihr Code mit der Zeit sehr unübersichtlich, oder es entsteht Transaktionsskriptcode.</span><span class="sxs-lookup"><span data-stu-id="17cc9-156">Eventually you will have spaghetti code or transactional script code.</span></span>

<span data-ttu-id="17cc9-157">Wenn Entitäten über öffentliche Setter in einer Entitätseigenschaft verfügen, steht dies im Widerspruch zu den Mustern des domänengesteuerten Designs.</span><span class="sxs-lookup"><span data-stu-id="17cc9-157">To follow DDD patterns, entities must not have public setters in any entity property.</span></span> <span data-ttu-id="17cc9-158">Änderungen einer Entität sollten durch explizite Methoden mit expliziten ubiquitären Sprachen zu den Änderungen ausgelöst werden, die in der Entität ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="17cc9-158">Changes in an entity should be driven by explicit methods with explicit ubiquitous language about the change they are performing in the entity.</span></span>

<span data-ttu-id="17cc9-159">Außerdem soll es sich bei Auflistungen innerhalb der Entität (wie die der Bestellelemente) um schreibgeschützte Eigenschaften handeln (also um die nachfolgend erläuterte AsReadOnly-Methode).</span><span class="sxs-lookup"><span data-stu-id="17cc9-159">Furthermore, collections within the entity (like the order items) should be read-only properties (the AsReadOnly method explained later).</span></span> <span data-ttu-id="17cc9-160">Sie sollten die Entität nur innerhalb der Methoden der Aggregatstammklasse oder der Methoden der untergeordneten Klasse aktualisieren können.</span><span class="sxs-lookup"><span data-stu-id="17cc9-160">You should be able to update it only from within the aggregate root class methods or the child entity methods.</span></span>

<span data-ttu-id="17cc9-161">Wie Sie in dem Aggregatstamm „Order“ sehen können, sollten alle Setters den Status „privat“ haben oder zumindest extern schreibgeschützt sein, sodass jeder Vorgang für die Daten der Entität oder der untergeordneten Entitäten über Methoden in den Entitätsklassen ausgeführt werden muss.</span><span class="sxs-lookup"><span data-stu-id="17cc9-161">As you can see in the code for the Order aggregate root, all setters should be private or at least read-only externally, so that any operation against the entity’s data or its child entities has to be performed through methods in the entity class.</span></span> <span data-ttu-id="17cc9-162">Dadurch bleibt die Konsistenz auf kontrollierte und objektorientierte Weise erhalten, und es wird kein Transaktionsskriptcode verwendet.</span><span class="sxs-lookup"><span data-stu-id="17cc9-162">This maintains consistency in a controlled and object-oriented way instead of implementing transactional script code.</span></span>

<span data-ttu-id="17cc9-163">Im folgenden Codeausschnitt sehen Sie, wie Sie am besten den Task codieren, über den das OrderItem-Objekt dem Aggregat „Order“ hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="17cc9-163">The following code snippet shows the proper way to code the task of adding an OrderItem object to the Order aggregate.</span></span>

```csharp
// RIGHT ACCORDING TO DDD--CODE AT THE APPLICATION LAYER OR COMMAND HANDLERS
// The code in command handlers or WebAPI controllers, related only to application stuff
// There is NO code here related to OrderItem object’s business logic
myOrder.AddOrderItem(productId, productName, pictureUrl, unitPrice, discount, units);

// The code related to OrderItem params validations or domain rules should
// be WITHIN the AddOrderItem method.

//...
```

<span data-ttu-id="17cc9-164">In diesem Ausschnitt wird ein Großteil der Validierungen oder Logik, die im Zusammenhang mit dem OrderItem-Objekt stehen, vom Aggregatstamm „Order“ über die Methode „AddOrderItem“ gesteuert. Dies gilt insbesondere für Validierungen und Logik, die im Zusammenhang mit anderen Elementen im Aggregat stehen.</span><span class="sxs-lookup"><span data-stu-id="17cc9-164">In this snippet, most of the validations or logic related to the creation of an OrderItem object will be under the control of the Order aggregate root—in the AddOrderItem method—especially validations and logic related to other elements in the aggregate.</span></span> <span data-ttu-id="17cc9-165">Es kann z.B. sein, dass als Ergebnis mehrerer Aufrufe der AddOrderItem-Methode dasselbe Produktelement zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="17cc9-165">For instance, you might get the same product item as the result of multiple calls to AddOrderItem.</span></span> <span data-ttu-id="17cc9-166">Sie können in dieser Methode die Produktelemente untersuchen und dieselben Produktelemente in ein OrderItem-Objekt mit mehreren Einheiten zusammenfassen.</span><span class="sxs-lookup"><span data-stu-id="17cc9-166">In that method, you could examine the product items and consolidate the same product items into a single OrderItem object with several units.</span></span> <span data-ttu-id="17cc9-167">Wenn es außerdem unterschiedliche Rabatte gibt, aber die Produkt-ID unverändert bleibt, wird sehr wahrscheinlich der höhere Rabatt ausgewählt.</span><span class="sxs-lookup"><span data-stu-id="17cc9-167">Additionally, if there are different discount amounts but the product ID is the same, you would likely apply the higher discount.</span></span> <span data-ttu-id="17cc9-168">Dieses Prinzip gilt in jeder anderen Domänenlogik für das OrderItem-Objekt.</span><span class="sxs-lookup"><span data-stu-id="17cc9-168">This principle applies to any other domain logic for the OrderItem object.</span></span>

<span data-ttu-id="17cc9-169">Zudem wird der neue OrderItem(params)-Vorgang ebenfalls über die AddOrderItem-Methode aus dem Aggregatstamm „Order“ durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="17cc9-169">In addition, the new OrderItem(params) operation will also be controlled and performed by the AddOrderItem method from the Order aggregate root.</span></span> <span data-ttu-id="17cc9-170">Aus diesem Grund befindet sich ein Großteil der Logik oder Validierungen, die im Zusammenhang mit diesem Vorgang stehen, an einem gemeinsamen Ort im Aggregatstamm, insbesondere alle Elemente, die Auswirkungen auf die Konsistenz zwischen anderen untergeordneten Elementen haben.</span><span class="sxs-lookup"><span data-stu-id="17cc9-170">Therefore, most of the logic or validations related to that operation (especially anything that impacts the consistency between other child entities) will be in a single place within the aggregate root.</span></span> <span data-ttu-id="17cc9-171">Dies ist der wichtigste Zweck des Aggregatstammmusters.</span><span class="sxs-lookup"><span data-stu-id="17cc9-171">That is the ultimate purpose of the aggregate root pattern.</span></span>

<span data-ttu-id="17cc9-172">Wenn Sie Entity Framework Core 1.1 oder höher verwenden, kann besser eine Entität des domänengesteuerten Designs festgelegt werden, da diese neben Eigenschaften auch die [Zuordnung zu Feldern](https://docs.microsoft.com/ef/core/modeling/backing-field) zulässt.</span><span class="sxs-lookup"><span data-stu-id="17cc9-172">When you use Entity Framework Core 1.1 or later, a DDD entity can be better expressed because it allows [mapping to fields](https://docs.microsoft.com/ef/core/modeling/backing-field) in addition to properties.</span></span> <span data-ttu-id="17cc9-173">Dies ist nützlich, wenn Auflistungen von untergeordneten Entitäten oder Wertobjekten geschützt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="17cc9-173">This is useful when protecting collections of child entities or value objects.</span></span> <span data-ttu-id="17cc9-174">Mit dieser Erweiterung können Sie einfache private Felder anstelle von Eigenschaften nutzen, und Sie können jedes Update für die Feldauflistung in öffentlichen Methoden ausführen und schreibgeschützten Zugriff über die AsReadOnly-Methode bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="17cc9-174">With this enhancement, you can use simple private fields instead of properties and you can implement any update to the field collection in public methods and provide read-only access through the AsReadOnly method.</span></span>

<span data-ttu-id="17cc9-175">Wenn Sie das domänengesteuerte Design verwenden, sollten Sie nur über die Methoden in der Entität (oder den Konstruktor) ein Update für diese ausführen, sodass Eigenschaften nur mit einem get-Accessor definiert werden.</span><span class="sxs-lookup"><span data-stu-id="17cc9-175">In DDD you want to update the entity only through methods in the entity (or the constructor) in order to control any invariant and the consistency of the data, so properties are defined only with a get accessor.</span></span> <span data-ttu-id="17cc9-176">Die Eigenschaften werden über private Felder gesichert.</span><span class="sxs-lookup"><span data-stu-id="17cc9-176">The properties are backed by private fields.</span></span> <span data-ttu-id="17cc9-177">Auf private Members kann nur innerhalb einer Klasse zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="17cc9-177">Private members can only be accessed from within the class.</span></span> <span data-ttu-id="17cc9-178">Es gibt jedoch eine Ausnahme: EF Core muss auch diese Felder festlegen, damit das Objekt mit den richtigen Werten zurückgegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="17cc9-178">However, there one exception: EF Core needs to set these fields as well (so it can return the object with the proper values).</span></span>

### <a name="map-properties-with-only-get-accessors-to-the-fields-in-the-database-table"></a><span data-ttu-id="17cc9-179">Zuordnen von Eigenschaften zu Feldern in der Datenbanktabelle mit get-Accessors</span><span class="sxs-lookup"><span data-stu-id="17cc9-179">Map properties with only get accessors to the fields in the database table</span></span>

<span data-ttu-id="17cc9-180">Das Zuordnen von Eigenschaften zu Datenbanktabellen ist nicht allein Aufgabe der Domäne, sondern Teil der Infrastruktur und der Persistenzebene.</span><span class="sxs-lookup"><span data-stu-id="17cc9-180">Mapping properties to database table columns is not a domain responsibility but part of the infrastructure and persistence layer.</span></span> <span data-ttu-id="17cc9-181">Das wird an dieser Stelle erwähnt, damit Sie die neuen Funktionen von EF Core 1.1 oder höher kennen lernen, die mit der Vorgehensweise beim Modellieren von Entitäten im Zusammenhang stehen.</span><span class="sxs-lookup"><span data-stu-id="17cc9-181">We mention this here just so you are aware of the new capabilities in EF Core 1.1 or later related to how you can model entities.</span></span> <span data-ttu-id="17cc9-182">Ausführliche Informationen zu diesem Thema finden Sie in dem Abschnitt zur Infrastruktur und Persistenz.</span><span class="sxs-lookup"><span data-stu-id="17cc9-182">Additional details on this topic are explained in the infrastructure and persistence section.</span></span>

<span data-ttu-id="17cc9-183">Wenn Sie EF Core 1.0 oder höher verwenden, müssen Sie im Zusammenhang mit DbContext die Eigenschaften zuordnen, die nur über Getter den Feldern in der Datenbanktabelle zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="17cc9-183">When you use EF Core 1.0 or later, within the DbContext you need to map the properties that are defined only with getters to the actual fields in the database table.</span></span> <span data-ttu-id="17cc9-184">Diesen Vorgang führen Sie mit der HasField-Methode der PropertyBuilder-Klasse aus.</span><span class="sxs-lookup"><span data-stu-id="17cc9-184">This is done with the HasField method of the PropertyBuilder class.</span></span>

### <a name="map-fields-without-properties"></a><span data-ttu-id="17cc9-185">Zuordnen von Feldern ohne Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="17cc9-185">Map fields without properties</span></span>

<span data-ttu-id="17cc9-186">Mit dem Feature in EF Core 1.1 oder höher, über das Sie Feldern Spalten zuordnen, müssen Sie nicht unbedingt Eigenschaften verwenden.</span><span class="sxs-lookup"><span data-stu-id="17cc9-186">With the feature in EF Core 1.1 or later to map columns to fields, it is also possible to not use properties.</span></span> <span data-ttu-id="17cc9-187">Stattdessen reicht es aus, wenn Sie den Feldern nur Spalten aus einer Tabelle zuordnen.</span><span class="sxs-lookup"><span data-stu-id="17cc9-187">Instead, you can just map columns from a table to fields.</span></span> <span data-ttu-id="17cc9-188">Dies ist ein häufiger auftretender Anwendungsfall, da es sich dabei um private Felder für einen internen Zustand handelt, auf den außerhalb der Entität nicht zugegriffen werden muss.</span><span class="sxs-lookup"><span data-stu-id="17cc9-188">A common use case for this is private fields for an internal state that does not need to be accessed from outside the entity.</span></span>

<span data-ttu-id="17cc9-189">Beispielsweise enthält das nachfolgende OrderAggregate-Codebeispiel mehrere private Felder wie das `_paymentMethodId`-Feld, denen keine Eigenschaften für den Setter oder Getter zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="17cc9-189">For example, in the preceding OrderAggregate code example, there are several private fields, like the  `_paymentMethodId` field, that have no related property for either a setter or getter.</span></span> <span data-ttu-id="17cc9-190">Dieses Feld könnte außerdem innerhalb der Geschäftslogik der Bestellung berechnet und über die Methoden der Bestellung verwendet werden. Es muss allerdings in der Datenbank beibehalten werden.</span><span class="sxs-lookup"><span data-stu-id="17cc9-190">That field could also be calculated within the order’s business logic and used from the order’s methods, but it needs to be persisted in the database as well.</span></span> <span data-ttu-id="17cc9-191">In EF Core gibt es (ab Version 1.1) die Möglichkeit, ein Feld zuzuordnen, wenn keine passende Eigenschaft der Spalte in der Datenbank zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="17cc9-191">So in EF Core (since v1.1) there is a way to map a field without a related property to a column in the database.</span></span> <span data-ttu-id="17cc9-192">Dies wird ebenfalls in diesem Handbuch im Abschnitt [Infrastrukturebene](ddd-oriented-microservice.md#the-infrastructure-layer) erläutert.</span><span class="sxs-lookup"><span data-stu-id="17cc9-192">This is also explained in the [Infrastructure layer](ddd-oriented-microservice.md#the-infrastructure-layer) section of this guide.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="17cc9-193">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="17cc9-193">Additional resources</span></span>

- <span data-ttu-id="17cc9-194">**Vaughn Vernon. Modeling Aggregates with DDD and Entity Framework (Modellieren von Aggregaten mit dem domänengesteuerten Design und Entity Framework).**</span><span class="sxs-lookup"><span data-stu-id="17cc9-194">**Vaughn Vernon. Modeling Aggregates with DDD and Entity Framework.**</span></span> <span data-ttu-id="17cc9-195">Hinweis: Dieser Artikel gilt *nicht* für Entity Framework Core.</span><span class="sxs-lookup"><span data-stu-id="17cc9-195">Note that this is *not* Entity Framework Core.</span></span> \
  <https://kalele.io/blog-posts/modeling-aggregates-with-ddd-and-entity-framework/>

- <span data-ttu-id="17cc9-196">**Julie Lerman. Datenpunkte – Codierung für Domain-Driven Design: Tipps für Entwickler mit Datenschwerpunkt** </span><span class="sxs-lookup"><span data-stu-id="17cc9-196">**Julie Lerman. Data Points - Coding for Domain-Driven Design: Tips for Data-Focused Devs** </span></span>\
  <https://docs.microsoft.com/archive/msdn-magazine/2013/august/data-points-coding-for-domain-driven-design-tips-for-data-focused-devs>

- <span data-ttu-id="17cc9-197">**Udi Dahan. How to create fully encapsulated Domain Models (Erstellen eines vollständig gekapselten Domänenmodells)**  </span><span class="sxs-lookup"><span data-stu-id="17cc9-197">**Udi Dahan. How to create fully encapsulated Domain Models** </span></span>\
  <http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/>

> [!div class="step-by-step"]
> <span data-ttu-id="17cc9-198">[Zurück](microservice-domain-model.md)
> [Weiter](seedwork-domain-model-base-classes-interfaces.md)</span><span class="sxs-lookup"><span data-stu-id="17cc9-198">[Previous](microservice-domain-model.md)
[Next](seedwork-domain-model-base-classes-interfaces.md)</span></span>
