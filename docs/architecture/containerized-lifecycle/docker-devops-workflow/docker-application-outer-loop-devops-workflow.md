---
title: Schritte im Outer-Loop-DevOps-Workflow für eine Docker-Anwendung
description: Lernen Sie die Schritte für die „äußere Schleife“ des DevOps-Workflows
ms.date: 08/06/2020
ms.openlocfilehash: 5515c204b09cecba323540572c6769c65c6c93ab
ms.sourcegitcommit: ef50c99928183a0bba75e07b9f22895cd4c480f8
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 08/07/2020
ms.locfileid: "87915265"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="24a89-103">Schritte im Outer-Loop-DevOps-Workflow für eine Docker-Anwendung</span><span class="sxs-lookup"><span data-stu-id="24a89-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="24a89-104">Abbildung 5–1 zeigt eine End-to-End-Darstellung der Schritte, aus denen der DevOps-Outer-Loop-Workflow besteht.</span><span class="sxs-lookup"><span data-stu-id="24a89-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span> <span data-ttu-id="24a89-105">Sie zeigt die „äußere Schleife“ von DevOps.</span><span class="sxs-lookup"><span data-stu-id="24a89-105">It shows the "outer loop" of DevOps.</span></span> <span data-ttu-id="24a89-106">Wenn Code per Push an das Repository übertragen wird, beginnt die CD-Pipeline, in der die Anwendung bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="24a89-106">When code is pushed to the repo, a CI pipeline is started, then begins the CD pipeline, where the application gets deployed.</span></span> <span data-ttu-id="24a89-107">Aus bereitgestellten Anwendungen gesammelte Metriken werden in die Entwicklungsworkload rückgekoppelt, in der die „innere Schleife“ stattfindet, sodass die Entwicklungsteams über reale Daten verfügen, mit denen sie auf Benutzer- und Geschäftsanforderungen reagieren können.</span><span class="sxs-lookup"><span data-stu-id="24a89-107">Metrics collected from deployed applications are fed back into the development workload, where the "inner loop" occurs, so development teams have actual data to respond to user and business needs.</span></span>

![Diagramm, das die 6 Schritte der „äußeren Schleife“ des DevOps-Workflows zeigt.](./media/docker-application-outer-loop-devops-workflow/overview-dev-ops-outter-loop-workflow.png)

<span data-ttu-id="24a89-109">**Abbildung 5–1**.</span><span class="sxs-lookup"><span data-stu-id="24a89-109">**Figure 5-1**.</span></span> <span data-ttu-id="24a89-110">DevOps-Outer-Loop-Workflow für Docker-Anwendungen mit Microsoft-Tools</span><span class="sxs-lookup"><span data-stu-id="24a89-110">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="24a89-111">Sehen wir uns die einzelnen Schritte nun ausführlicher an.</span><span class="sxs-lookup"><span data-stu-id="24a89-111">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="24a89-112">Schritt 1: Inner-Loop-Entwicklungsworkflow</span><span class="sxs-lookup"><span data-stu-id="24a89-112">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="24a89-113">Dieser Schritt wird im Detail in Kapitel 4 erläutert, zusammenfassend lässt sich aber sagen, dass diese Stelle den Anfang der äußeren Schleife darstellt, dem Moment, in dem ein Entwickler Code per Push in das Quellcodeverwaltungssystem (wie etwa Git) überträgt und so Aktionen der CI-Pipeline einleitet.</span><span class="sxs-lookup"><span data-stu-id="24a89-113">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="24a89-114">Schritt 2: Integration und Verwaltung der Quellcodeverwaltung mit Azure DevOps Services und Git</span><span class="sxs-lookup"><span data-stu-id="24a89-114">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="24a89-115">In diesem Schritt benötigen Sie ein Versionskontrollsystem, um eine konsolidierte Version des gesamten Codes zu erfassen, der von den verschiedenen Entwicklern im Team kommt.</span><span class="sxs-lookup"><span data-stu-id="24a89-115">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="24a89-116">Auch wenn Quellcodeverwaltung (Source Code Control, SCC) und Quellcodemanagement den meisten Entwicklern in Fleisch und Blut übergegangen sein dürften, beim Erstellen von Docker-Anwendungen in einem DevOps-Lebenszyklus muss unbedingt hervorgehoben werden, dass die Docker-Images mit der Anwendung nicht direkt vom Computer des Entwicklers aus an die globale Docker-Registrierung (etwa die Azure Container Registry oder den Docker Hub) übermittelt werden dürfen.</span><span class="sxs-lookup"><span data-stu-id="24a89-116">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="24a89-117">Ganz im Gegenteil müssen die zu veröffentlichenden und in Produktionsumgebungen bereitzustellenden Docker-Images ausschließlich aus dem Quellcode erstellt werden, der auf der Grundlage Ihres Quellcode-Repositorys (z.B. Git) in Ihre globale Build- oder CI-Pipeline integriert wird.</span><span class="sxs-lookup"><span data-stu-id="24a89-117">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="24a89-118">Die von Entwicklern generierten lokalen Images sollte von ihnen nur zum Testen auf ihren eigenen Computern verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="24a89-118">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="24a89-119">Deshalb ist es wichtig, dass die DevOps-Pipeline vom SCC-Code aktiviert wird.</span><span class="sxs-lookup"><span data-stu-id="24a89-119">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="24a89-120">Azure DevOps Services und Team Foundation Server unterstützen Git und die Team Foundation-Versionskontrolle.</span><span class="sxs-lookup"><span data-stu-id="24a89-120">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="24a89-121">Sie können zwischen ihnen wählen und dies für ein einheitliche Microsoft-End-to-End-Erfahrung nutzen.</span><span class="sxs-lookup"><span data-stu-id="24a89-121">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="24a89-122">Sie können Ihren Code jedoch auch in externen Repositorys (wie GitHub, lokalen Git-Repositorys oder Subversion) verwalten und sind dann trotzdem in der Lage, Verbindungen damit herzustellen und Ihren Code als Ausgangspunkt für Ihre DevOps-CI-Pipeline abzurufen.</span><span class="sxs-lookup"><span data-stu-id="24a89-122">However, you can also manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="24a89-123">Schritt 3: Erstellen, CI, Integrieren und Testen mit Azure DevOps Services und Docker</span><span class="sxs-lookup"><span data-stu-id="24a89-123">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="24a89-124">CI hat sich als moderner Standard für Softwaretests und -bereitstellungen durchgesetzt.</span><span class="sxs-lookup"><span data-stu-id="24a89-124">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="24a89-125">Die Docker-Lösung erhält eine klare Separation of Concerns zwischen den Entwicklungs- und Betriebsteams aufrecht.</span><span class="sxs-lookup"><span data-stu-id="24a89-125">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="24a89-126">Die Unveränderlichkeit von Docker-Images stellt eine wiederholbare Bereitstellung zwischen dem sicher, was entwickelt, mithilfe von CI getestet und in der Produktionsumgebung bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="24a89-126">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="24a89-127">Durch eine übergreifend auf Entwicklerlaptops bereitgestellte Docker-Engine und Testinfrastruktur werden die Container über Umgebungsgrenzen hinweg portierbar.</span><span class="sxs-lookup"><span data-stu-id="24a89-127">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="24a89-128">Nachdem Sie über ein Versionskontrollsystem mit dem richtigen übermittelten Code verfügen, benötigen Sie einen *Builddienst*, um den Code aufzunehmen und die globalen Builds und Tests auszuführen.</span><span class="sxs-lookup"><span data-stu-id="24a89-128">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="24a89-129">Bei dem internen Workflow für diesen Schritt (CI, Erstellen, Testen) handelt es sich um den Aufbau einer CI-Pipeline, die aus Ihrem Coderepository (Git usw.), Ihrem Buildserver (Azure DevOps Services), der Docker-Engine und einer Docker-Registrierung besteht.</span><span class="sxs-lookup"><span data-stu-id="24a89-129">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="24a89-130">Sie können Azure DevOps Services als Grundlage zum Erstellen Ihrer Anwendungen und Festlegen Ihrer CI-Pipeline sowie zum Veröffentlichen der erstellten „Artefakte“ in einem „Artefaktrepository“ verwenden, wie im nächsten Schritt erläutert.</span><span class="sxs-lookup"><span data-stu-id="24a89-130">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="24a89-131">Bei der Verwendung von Docker für die Bereitstellung sind die „endgültigen Artefakte“, die bereitgestellt werden sollen, Docker-Images, in denen Ihre Anwendung oder Ihre Dienste eingebettet sind.</span><span class="sxs-lookup"><span data-stu-id="24a89-131">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="24a89-132">Diese Images werden per Push an eine *Docker-Registrierung* übertragen oder auf ihr veröffentlicht (dabei kann es sich um ein privates Repository in der Art der Azure Container Registry oder um ein öffentliches wie die Docker Hub-Registrierung handeln, die verbreitet für offizielle Basisimages verwendet wird).</span><span class="sxs-lookup"><span data-stu-id="24a89-132">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="24a89-133">Dies ist das grundlegende Konzept: Die CI-Pipeline wird durch einen Commit an ein SCC-Repository wie Git gestartet.</span><span class="sxs-lookup"><span data-stu-id="24a89-133">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="24a89-134">Der Commit bewirkt, dass Azure DevOps Services einen Buildauftrag innerhalb eines Docker-Containers ausführen und nach erfolgreichem Abschluss dieses Auftrags ein Docker-Image per Push in die Docker-Registrierung übertragen, wie in Abbildung 5–2 dargestellt.</span><span class="sxs-lookup"><span data-stu-id="24a89-134">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span> <span data-ttu-id="24a89-135">Der erste Teil der äußeren Schleife umfasst die Schritte 1 bis 3, von der Codeerstellung, Ausführung, Debuggen und Validierung, über das Coderepository bis hin zu den CI-Schritten für Erstellen und Testen.</span><span class="sxs-lookup"><span data-stu-id="24a89-135">The first part of the outer loop involves steps 1 to 3, from code, run, debug and validate, then the code repo up to the build and test CI step.</span></span>

![Diagramm, das die am CI-Workflow beteiligten drei Schritte zeigt.](./media/docker-application-outer-loop-devops-workflow/continuous-integration-steps.png)

<span data-ttu-id="24a89-137">**Abbildung 5-2**.</span><span class="sxs-lookup"><span data-stu-id="24a89-137">**Figure 5-2**.</span></span> <span data-ttu-id="24a89-138">Die in CI enthaltenen Schritte</span><span class="sxs-lookup"><span data-stu-id="24a89-138">The steps involved in CI</span></span>

<span data-ttu-id="24a89-139">Dies sind die grundlegenden Schritte im CI-Workflow mit Docker und Azure DevOps Services:</span><span class="sxs-lookup"><span data-stu-id="24a89-139">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="24a89-140">Der Entwickler übermittelt einen Commit per Push an ein SCC-Repository (Git/Azure DevOps Services, GitHub usw.).</span><span class="sxs-lookup"><span data-stu-id="24a89-140">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="24a89-141">Wenn Sie Azure DevOps Services oder Git verwenden, ist CI integriert, was bedeutet, dass Sie einfach nur ein Kontrollkästchen in den Azure DevOps Services aktivieren müssen.</span><span class="sxs-lookup"><span data-stu-id="24a89-141">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="24a89-142">Wenn Sie eine externe SCC (wie GitHub) verwenden, benachrichtigt ein `webhook` Azure DevOps Services über das Update oder führt einen Push auf Git/GitHub aus.</span><span class="sxs-lookup"><span data-stu-id="24a89-142">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="24a89-143">Azure DevOps Services ruft das SCC-Repository ab, einschließlich des Dockerfiles mit der Beschreibung des Images, sowie den Anwendungs- und Testcode.</span><span class="sxs-lookup"><span data-stu-id="24a89-143">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="24a89-144">Azure DevOps Services erstellt ein Docker-Image und bezeichnet es mit einer Buildnummer.</span><span class="sxs-lookup"><span data-stu-id="24a89-144">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="24a89-145">Azure DevOps Services instanziiert den Docker-Container innerhalb des bereitgestellten Docker-Hosts und führt die geeigneten Tests aus.</span><span class="sxs-lookup"><span data-stu-id="24a89-145">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="24a89-146">Wenn die Tests erfolgreich sind, wird das Image zuerst mit einem aussagekräftigen Namen neu benannt, damit Sie wissen, dass es sich um einen „verbürgten Build“ (wie etwa „/1.0.0“ oder eine beliebige andere Bezeichnung) handelt, und anschließend per Push in Ihre Docker-Registrierung (Docker Hub, Azure Container Registry, DTR usw.) übertragen.</span><span class="sxs-lookup"><span data-stu-id="24a89-146">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="24a89-147">Implementieren der CI-Pipeline mit Azure DevOps Services und der Docker-Erweiterung für Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="24a89-147">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="24a89-148">Visual Studio Azure DevOps Services enthält Build- und Releasevorlagen, die Sie in Ihrer CI/CD-Pipeline verwenden können. Mithilfe dieser Pipeline können Sie Docker-Images per Push in eine authentifizierte Docker-Registrierung übertragen, Docker-Images ausführen oder andere an der Docker-Eingabeaufforderung verfügbare Vorgänge ausführen.</span><span class="sxs-lookup"><span data-stu-id="24a89-148">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="24a89-149">Außerdem wird eine Docker Compose-Aufgabe hinzugefügt, mit der Sie Docker-Anwendungen für mehrere Container erstellen, per Push übertragen und ausführen sowie andere von der Docker Compose-Eingabeaufforderung angebotene Vorgänge ausführen können, wie in Abbildung 5–3 dargestellt.</span><span class="sxs-lookup"><span data-stu-id="24a89-149">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Screenshot der Docker CI-Pipeline in Azure DevOps.](./media/docker-application-outer-loop-devops-workflow/docker-ci-pipeline-azure-devops.png)

<span data-ttu-id="24a89-151">**Abbildung 5-3**.</span><span class="sxs-lookup"><span data-stu-id="24a89-151">**Figure 5-3**.</span></span> <span data-ttu-id="24a89-152">Die Docker CI-Pipeline in Azure DevOps Services einschließlich Build- und Releasevorlagen und verwandten Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="24a89-152">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="24a89-153">Sie können diese Vorlagen und Aufgaben verwenden, um Ihre CI/CD-Artefakte für das Erstellen/Testen und Bereitstellen in Azure Service Fabric, Azure Kubernetes Service und ähnlichen Angeboten zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="24a89-153">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="24a89-154">Mit diesen Visual Studio Team Services-Aufgaben, einem in Azure bereitgestellten Linux-Docker Host bzw. einer VM und Ihrer bevorzugten Docker-Registrierung (Azure Container Registry, Docker Hub, privatem Docker DTR oder einer beliebigen anderen Docker-Registrierung) können Sie Ihre Docker CI-Pipeline auf sehr konsistente Weise aufbauen.</span><span class="sxs-lookup"><span data-stu-id="24a89-154">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="24a89-155">***Anforderungen:***</span><span class="sxs-lookup"><span data-stu-id="24a89-155">***Requirements:***</span></span>

- <span data-ttu-id="24a89-156">Azure DevOps Services oder Team Foundation Server 2015 Update 3 oder höher für lokale Installationen.</span><span class="sxs-lookup"><span data-stu-id="24a89-156">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="24a89-157">Ein Azure DevOps Services-Agent, der über die Docker-Binarys verfügt.</span><span class="sxs-lookup"><span data-stu-id="24a89-157">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="24a89-158">Eine einfache Möglichkeit zum Erstellen eines dieser Agents besteht darin, Docker zum Ausführen eines Containers zu verwenden, der auf dem Docker-Image des Azure DevOps Services-Agent basiert.</span><span class="sxs-lookup"><span data-stu-id="24a89-158">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> <span data-ttu-id="24a89-159">[!INFORMATION] Weitere Informationen zur Zusammenstellung einer Azure DevOps Services Docker CI-Pipeline und eine Möglichkeit zum Anzeigen der exemplarischen Vorgehensweisen finden Sie auf diesen Websites:</span><span class="sxs-lookup"><span data-stu-id="24a89-159">[!INFORMATION] To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="24a89-160">Ausführen eines Visual Studio Team Services-Agents (jetzt Azure DevOps Services) als Docker-Container: </span><span class="sxs-lookup"><span data-stu-id="24a89-160">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: </span></span>\
>   <https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent>
>
> - <span data-ttu-id="24a89-161">Erstellen von .NET Core Linux-Docker-Images mit Azure DevOps Services: </span><span class="sxs-lookup"><span data-stu-id="24a89-161">Building .NET Core Linux Docker images with Azure DevOps Services: </span></span>\
>   <https://docs.microsoft.com/archive/blogs/stevelasker/building-net-core-linux-docker-images-with-visual-studio-team-services>
>
> - <span data-ttu-id="24a89-162">Erstellen eines Linux-basierten Visual Studio Team Service-Buildcomputers mit Docker-Unterstützung: </span><span class="sxs-lookup"><span data-stu-id="24a89-162">Building a Linux-based Visual Studio Team Service build machine with Docker support: </span></span>\
>   <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support>

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="24a89-163">Integrieren, Testen und Validieren von Docker-Anwendungen mit mehreren Containern</span><span class="sxs-lookup"><span data-stu-id="24a89-163">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="24a89-164">Die meisten Docker-Anwendungen bestehen normalerweise aus mehreren Containern anstelle eines einzelnen Containers.</span><span class="sxs-lookup"><span data-stu-id="24a89-164">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="24a89-165">Ein gutes Beispiel bildet eine an Microservices ausgerichtete Anwendung, für die Sie pro Microservice einen Container verwenden würden.</span><span class="sxs-lookup"><span data-stu-id="24a89-165">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="24a89-166">Aber auch ohne strikte Beachtung des Microservice-Ansatzes ist es wahrscheinlich, dass Ihre Docker-Anwendung sich aus mehreren Containern oder Diensten zusammensetzen würde.</span><span class="sxs-lookup"><span data-stu-id="24a89-166">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="24a89-167">Daher müssen Sie nach dem Erstellen der Anwendungscontainer in der CI-Pipeline die gesamte Anwendung mit allen ihren Containern in einem Docker-Integrationshost oder sogar auf einem Testcluster, an den Sie Ihre Container verteilen, bereitstellen, integrieren und testen.</span><span class="sxs-lookup"><span data-stu-id="24a89-167">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="24a89-168">Wenn Sie einen einzelnen Host verwenden, können Sie Docker-Befehle wie „docker-compose“ zum Erstellen und Bereitstellen von zugehörigen Containern zum Testen und Überprüfen der Docker-Umgebung auf einem einzelnen virtuellen Computer verwenden.</span><span class="sxs-lookup"><span data-stu-id="24a89-168">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="24a89-169">Wenn Sie aber mit einem Orchestratorcluster wie DC/OS, Kubernetes oder Docker Swarm arbeiten, müssen Sie Ihre Container mithilfe eines anderen Mechanismus oder Orchestrators bereitstellen, abhängig von dem gewählten Cluster/Scheduler.</span><span class="sxs-lookup"><span data-stu-id="24a89-169">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="24a89-170">Im Folgenden finden Sie verschiedene Arten von Tests, die Sie für Docker-Container ausführen können:</span><span class="sxs-lookup"><span data-stu-id="24a89-170">The following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="24a89-171">Komponententests für Docker-Container</span><span class="sxs-lookup"><span data-stu-id="24a89-171">Unit tests for Docker containers</span></span>

- <span data-ttu-id="24a89-172">Testen von Gruppen von aufeinander bezogenen Anwendungen oder Microservices</span><span class="sxs-lookup"><span data-stu-id="24a89-172">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="24a89-173">Tests in der Produktion und "Canary Release"-Versionen</span><span class="sxs-lookup"><span data-stu-id="24a89-173">Test in production and "canary" releases</span></span>

<span data-ttu-id="24a89-174">Der wichtige Punkt ist hier, dass Integrations- und Funktionstests von außerhalb der Container ausgeführt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="24a89-174">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="24a89-175">Die Tests sind nicht in den von Ihnen bereitgestellten Containern enthalten und werden nicht in ihnen ausgeführt, da die Container auf statischen Images basieren, die exakt mit denen übereinstimmen sollten, die Sie in der Produktionsumgebung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="24a89-175">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="24a89-176">Eine praktische Option beim Testen komplexerer Szenarien, etwa solcher, die mehrere Cluster beinhalten (Testcluster, Stagingcluster und Produktionscluster), besteht darin, die Images in einer Registrierung zu veröffentlichen, damit sie in verschiedenen Clustern getestet werden können.</span><span class="sxs-lookup"><span data-stu-id="24a89-176">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="24a89-177">Übertragen Sie das benutzerdefinierte Docker-Anwendungsimage per Push in Ihre globale Docker-Registrierung</span><span class="sxs-lookup"><span data-stu-id="24a89-177">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="24a89-178">Nachdem die Docker-Images getestet und validiert wurden, ist es sinnvoll, sie zu kennzeichnen und in Ihrer Docker-Registrierung zu veröffentlichen.</span><span class="sxs-lookup"><span data-stu-id="24a89-178">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="24a89-179">Die Docker-Registrierung stellt eine wesentliche Komponente im Lebenszyklus von Docker-Anwendungen dar, da sie der zentrale Ort ist, an dem Sie Ihren benutzerdefinierten Test (auch als „verbürgtes Image“ bezeichnet) für die Bereitstellung in den QA- und Produktionsumgebungen speichern.</span><span class="sxs-lookup"><span data-stu-id="24a89-179">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="24a89-180">In ähnlicher Weise, wie der in Ihrem SSC-Repository (Git usw.) gespeicherte Anwendungscode Ihre SSOT (Single Source of Truth) ist, stellt die Docker-Registrierung Ihre SSOT für Ihre binäre Anwendung oder für die in der QA- oder Produktionsumgebung bereitzustellenden Anwendungsteile dar.</span><span class="sxs-lookup"><span data-stu-id="24a89-180">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="24a89-181">Normalerweise ist es sinnvoll, private Repositorys für Ihre benutzerdefinierten Images entweder in einem privaten Repository in der Azure Container Registry, in einer lokalen Registrierung wie der Docker Trusted Registry oder in einer öffentlichen Cloudregistrierung mit eingeschränktem Zugriff (wie Docker Hub) aufzubewahren, mit der Einschränkung, dass Sie im letzten Fall der Sicherheit des Anbieters vertrauen müssen, falls Ihr Code nicht Open Source ist.</span><span class="sxs-lookup"><span data-stu-id="24a89-181">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="24a89-182">Die eingesetzten Methoden sind in allen Fällen ähnlich und basieren auf dem `docker push`-Befehl, wie in Abbildung 5–4 dargestellt.</span><span class="sxs-lookup"><span data-stu-id="24a89-182">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![Diagramm, das den Pushvorgang benutzerdefinierter Images in eine Containerregistrierung zeigt.](./media/docker-application-outer-loop-devops-workflow/docker-push-custom-images.png)

<span data-ttu-id="24a89-184">**Abbildung 5-4**.</span><span class="sxs-lookup"><span data-stu-id="24a89-184">**Figure 5-4**.</span></span> <span data-ttu-id="24a89-185">Veröffentlichen von benutzerdefinierten Images in der Docker-Registrierung</span><span class="sxs-lookup"><span data-stu-id="24a89-185">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="24a89-186">Zum Aufbau der Integration und zum Testen (CI) in Schritt 3 können Sie die resultierenden Docker-Images in einer privaten oder öffentlichen Registrierung veröffentlichen.</span><span class="sxs-lookup"><span data-stu-id="24a89-186">In step 3, for building integration and testing (CI) you might publish the resulting docker images to a private or public registry.</span></span> <span data-ttu-id="24a89-187">Es gibt viele Angebote für Docker-Registrierungen von Cloudanbietern, wie Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry usw.</span><span class="sxs-lookup"><span data-stu-id="24a89-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="24a89-188">Mithilfe der Docker-Aufgaben können Sie eine Reihe von Dienstimages, die durch eine `docker-compose.yml`-Datei definiert sind, mit mehreren Tags per Push an eine authentifizierte Docker-Registrierung (wie die Container Registry) übertragen, wie in Abbildung 5–5 dargestellt.</span><span class="sxs-lookup"><span data-stu-id="24a89-188">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![Screenshot, der den Schritt zum Veröffentlichen von Images in einer Registrierung zeigt.](./media/docker-application-outer-loop-devops-workflow/publish-custom-image-to-docker-registry.png)

<span data-ttu-id="24a89-190">**Abbildung 5-5**.</span><span class="sxs-lookup"><span data-stu-id="24a89-190">**Figure 5-5**.</span></span> <span data-ttu-id="24a89-191">Verwenden von Azure DevOps Services zum Veröffentlichen benutzerdefinierter Images in einer Docker-Registrierung</span><span class="sxs-lookup"><span data-stu-id="24a89-191">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> <span data-ttu-id="24a89-192">[!INFORMATION] Weitere Informationen zur Azure Container Registry finden Sie unter <https://aka.ms/azurecontainerregistry>.</span><span class="sxs-lookup"><span data-stu-id="24a89-192">[!INFORMATION] For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="24a89-193">Schritt 4: CD, Bereitstellen</span><span class="sxs-lookup"><span data-stu-id="24a89-193">Step 4: CD, Deploy</span></span>

<span data-ttu-id="24a89-194">Die Unveränderlichkeit von Docker-Images stellt eine wiederholbare Bereitstellung von dem sicher, was entwickelt, mithilfe von CI getestet und in der Produktionsumgebung bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="24a89-194">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="24a89-195">Nachdem Sie die Docker-Anwendungsimages in Ihrer Docker-Registrierung (privat oder öffentlich) veröffentlicht haben, können Sie sie aus Ihrer CD-Pipeline mithilfe von Azure DevOps Services-Pipelineaufgaben oder Azure DevOps Services Release Management in Ihren verschiedenen Umgebungen (Produktion, QA, Staging usw.) bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="24a89-195">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="24a89-196">Allerdings hängt es an diesem Punkt davon ab, welche Art Docker-Anwendung Sie bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="24a89-196">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="24a89-197">Das Bereitstellen einer einfachen Anwendung (unter den Gesichtspunkten von Zusammensetzung und Bereitstellung) wie einer monolithischen Anwendung, die ein paar Container oder Dienste umfasst und auf ein paar Servern oder VMs bereitgestellt wird, unterscheidet sich vom Bereitstellen komplexerer Anwendungen, wie einer an Microservices orientierten Anwendung mit Hyperskalierung.</span><span class="sxs-lookup"><span data-stu-id="24a89-197">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="24a89-198">Diese zwei Szenarien werden in den folgenden Abschnitten erläutert.</span><span class="sxs-lookup"><span data-stu-id="24a89-198">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="24a89-199">Bereitstellen von zusammengesetzten Docker-Anwendungen in mehreren Docker-Umgebungen</span><span class="sxs-lookup"><span data-stu-id="24a89-199">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="24a89-200">Sehen wir uns zunächst das weniger komplizierte Szenario an: das Bereitstellen auf einfachen Docker-Hosts (VMs oder Servern) in einer einzelnen Umgebung oder mehreren Umgebungen (QA, Staging und Produktion).</span><span class="sxs-lookup"><span data-stu-id="24a89-200">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="24a89-201">In diesem Szenario kann Ihre CD-Pipeline intern docker-compose (aus Ihren Azure DevOps Services-Bereitstellungsaufgaben) verwenden, um die Docker-Anwendungen mit ihrem zugehörigen Satz von Containern oder Diensten bereitzustellen, wie in Abbildung 5–6 dargestellt.</span><span class="sxs-lookup"><span data-stu-id="24a89-201">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![Diagramm, das den Schritt für die CD-Bereitstellung in drei Umgebungen zeigt.](./media/docker-application-outer-loop-devops-workflow/deploy-app-containers-to-docker-host-environments.png)

<span data-ttu-id="24a89-203">**Abbildung 5–6**.</span><span class="sxs-lookup"><span data-stu-id="24a89-203">**Figure 5-6**.</span></span> <span data-ttu-id="24a89-204">Bereitstellen von Anwendungscontainern in einer Registrierung für einfache Docker-Hostumgebungen</span><span class="sxs-lookup"><span data-stu-id="24a89-204">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="24a89-205">Abbildung 5–7 hebt hervor, wie Sie Ihre Build-CI mithilfe von Azure DevOps Services mit QA-/Testumgebungen verbinden können, indem Sie im Dialogfeld „Aufgabe hinzufügen“ auf „Docker Compose“ klicken.</span><span class="sxs-lookup"><span data-stu-id="24a89-205">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="24a89-206">Beim Bereitstellen in Staging- oder Produktionsumgebungen würden jedoch normalerweise Funktionen der Releaseverwaltung zum Einsatz kommen, die mehrere Umgebungen (wie QA, Staging und Produktion) behandeln.</span><span class="sxs-lookup"><span data-stu-id="24a89-206">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="24a89-207">Wenn Sie auf einzelnen Docker-Hosts bereitstellen, wird die Aufgabe „Docker Compose“ von Azure DevOps Services verwendet (die hinter den Kulissen den `docker-compose up`-Befehl aufruft).</span><span class="sxs-lookup"><span data-stu-id="24a89-207">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="24a89-208">Wenn Sie in Azure Kubernetes Service (AKS) bereitstellen, wird die Docker-Bereitstellungsaufgabe verwendet, wie im anschließenden Abschnitt erläutert.</span><span class="sxs-lookup"><span data-stu-id="24a89-208">If you're deploying to Azure Kubernetes Service (AKS), it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![Screenshot, der das Dialogfeld „Aufgaben hinzufügen“ der Docker Compose-Aufgabe zeigt.](./media/docker-application-outer-loop-devops-workflow/add-tasks-docker-compose.png)

<span data-ttu-id="24a89-210">**Abbildung 5-7**.</span><span class="sxs-lookup"><span data-stu-id="24a89-210">**Figure 5-7**.</span></span> <span data-ttu-id="24a89-211">Hinzufügen einer Docker Compose-Aufgabe in einer Azure DevOps Services-Pipeline</span><span class="sxs-lookup"><span data-stu-id="24a89-211">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="24a89-212">Wenn Sie ein Release in Azure DevOps Services erstellen, wird ein Satz Eingabeartefakte benötigt.</span><span class="sxs-lookup"><span data-stu-id="24a89-212">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="24a89-213">Diese Artefakte sollen für die Lebensdauer des Release für alle Umgebungen unveränderlich sein.</span><span class="sxs-lookup"><span data-stu-id="24a89-213">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="24a89-214">Wenn Sie Container einführen, bezeichnen die Eingabeartefakte bereitzustellende Images in einer Registrierung.</span><span class="sxs-lookup"><span data-stu-id="24a89-214">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="24a89-215">Je nachdem, wie diese Images identifiziert werden, besteht keine Garantie, dass sie über die Dauer des Release gleich bleiben – der offensichtlichste Fall ist der Verweis auf `myimage:latest` aus einer `docker-compose`-Datei.</span><span class="sxs-lookup"><span data-stu-id="24a89-215">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="24a89-216">Die Azure DevOps Services-Vorlagen geben Ihnen die Möglichkeit, Buildartefakte zu generieren, die bestimmte Registrierungsimagedigests enthalten, die die gleiche Imagebinärdatei garantiert eindeutig identifizieren.</span><span class="sxs-lookup"><span data-stu-id="24a89-216">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="24a89-217">Das ist die Art Eingabe, die Sie sich wirklich als Grundlage eines Release wünschen.</span><span class="sxs-lookup"><span data-stu-id="24a89-217">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="24a89-218">Verwalten von Releases in Docker-Umgebungen mithilfe von Azure DevOps Services Release Management</span><span class="sxs-lookup"><span data-stu-id="24a89-218">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="24a89-219">Mithilfe der Azure DevOps Services-Vorlagen können Sie ein neues Image erstellen, es in einer Docker-Registrierung veröffentlichen, es auf Linux- oder Windows-Hosts ausführen und Befehle wie `docker-compose` verwenden, um mehrere Container als vollständige Anwendung bereitzustellen, all das mithilfe der Funktionen von Azure DevOps Services Release Management, die für mehrere Umgebungen bestimmt sind, wie in Abbildung 5–8 dargestellt.</span><span class="sxs-lookup"><span data-stu-id="24a89-219">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![Screenshot, der die Konfiguration von Docker Compose-Releases zeigt.](./media/docker-application-outer-loop-devops-workflow/configure-docker-compose-release.png)

<span data-ttu-id="24a89-221">**Abbildung 5-8**.</span><span class="sxs-lookup"><span data-stu-id="24a89-221">**Figure 5-8**.</span></span> <span data-ttu-id="24a89-222">Konfigurieren von Azure DevOps Services Docker Compose-Aufgaben in Azure DevOps Services Release Management</span><span class="sxs-lookup"><span data-stu-id="24a89-222">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="24a89-223">Bedenken Sie jedoch, dass es sich bei dem in Abbildung 5–6 gezeigten und in Abbildung 5–8 implementierten Szenario um ein einfaches handelt (es wird auf einzelnen Docker-Hosts und VMs bereitgestellt, und es gibt einen einzelnen Container bzw. eine einzelne Instanz pro Image), das wahrscheinlich nur für Entwicklungs- und Testszenarien verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="24a89-223">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="24a89-224">In den meisten Produktionsszenarien in Unternehmen würden Sie wohl Hochverfügbarkeit (High Availability, HA) und komfortabel zu verwaltende Skalierbarkeit mithilfe von Lastenausgleich über mehrere Knoten, Server und VMs hinweg und zuzüglich „intelligentes Failover“ fordern, sodass beim Ausfall eines Servers oder Knotens dessen Dienste und Container auf einen anderen Hostserver oder in eine andere VM verschoben würden.</span><span class="sxs-lookup"><span data-stu-id="24a89-224">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="24a89-225">In diesem Fall benötigen Sie weiter fortgeschrittene Technologien, wie Containercluster, Orchestratoren und Scheduler.</span><span class="sxs-lookup"><span data-stu-id="24a89-225">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="24a89-226">Das Verfahren zum Bereitstellen auf solchen Clustern beruht daher in der Beherrschung der fortgeschrittenen Szenarien, die im nächsten Abschnitt erläutert werden.</span><span class="sxs-lookup"><span data-stu-id="24a89-226">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="24a89-227">Bereitstellen von Docker-Anwendungen auf Docker-Clustern</span><span class="sxs-lookup"><span data-stu-id="24a89-227">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="24a89-228">Verteilte Anwendungen erfordern ihrem Wesen nach Computeressourcen, die ebenfalls verteilt sind.</span><span class="sxs-lookup"><span data-stu-id="24a89-228">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="24a89-229">Für Funktionalität im Produktionsmaßstab benötigen Sie Clusterfunktionen, die hohe Skalierbarkeit und Hochverfügbarkeit auf der Grundlage gepoolter Ressourcen zur Verfügung stellen.</span><span class="sxs-lookup"><span data-stu-id="24a89-229">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="24a89-230">Sie könnten aus einem CLI-Tool oder von einer Webbenutzeroberfläche aus Container manuell auf diesen Clustern bereitstellen, aber Sie sollten diese Art von manueller Arbeit für Spotchecks bei der Bereitstellung oder Verwaltungszwecke wie horizontales Skalieren oder Überwachung reservieren.</span><span class="sxs-lookup"><span data-stu-id="24a89-230">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="24a89-231">Unter CD-Gesichtspunkten und insbesondere im Hinblick auf Azure DevOps Services können Sie speziell erstellte Bereitstellungsaufgaben aus Ihren Azure DevOps Services Release Management-Umgebungen ausführen, die Ihre in Containern verpackten Anwendungen im Containerdienst auf verteilten Clustern bereitstellen, wie in Abbildung 5–9 veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="24a89-231">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![Diagramm, das den Schritt für die CD-Bereitstellung in Orchestratoren zeigt.](./media/docker-application-outer-loop-devops-workflow/cd-deploy-to-orchestrators.png)

<span data-ttu-id="24a89-233">**Abbildung 5-9**.</span><span class="sxs-lookup"><span data-stu-id="24a89-233">**Figure 5-9**.</span></span> <span data-ttu-id="24a89-234">Bereitstellen von verteilten Anwendungen im Containerdienst</span><span class="sxs-lookup"><span data-stu-id="24a89-234">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="24a89-235">Beim Bereitstellen auf bestimmten Clustern oder Orchestratoren würden Sie traditionell von spezifischen Bereitstellungsskripts und für jeden Orchestrator spezifischen Mechanismen ausgehen (d.h. die Bereitstellungsmechanismen von Kubernetes und Service Fabric unterscheiden sich), statt das einfachere und komfortable `docker-compose`-Tool zu verwenden, das auf der `docker-compose.yml`-Definitionsdatei basiert.</span><span class="sxs-lookup"><span data-stu-id="24a89-235">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="24a89-236">Aufgrund der Docker-Bereitstellungsaufgabe von Azure DevOps Services, die in Abbildung 5–10 dargestellt ist, können Sie jetzt auch auf den unterstützten Orchestratoren bereitstellen, indem Sie einfach Ihre vertraute `docker-compose.yml`-Datei verwenden, da das Tool die erforderliche „Übersetzung“ für Sie vornimmt (von Ihrer `docker-compose.yml`-Datei in das für den Orchestrator erforderliche Format).</span><span class="sxs-lookup"><span data-stu-id="24a89-236">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, now you can also deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that "translation" for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![Screenshot, der die Aufgabe „In Kubernetes bereitstellen“ zeigt.](./media/docker-application-outer-loop-devops-workflow/add-deploy-to-kubernetes-task.png)

<span data-ttu-id="24a89-238">**Abbildung 5-10**.</span><span class="sxs-lookup"><span data-stu-id="24a89-238">**Figure 5-10**.</span></span> <span data-ttu-id="24a89-239">Hinzufügen der Aufgabe zum Bereitstellen in Kubernetes zu Ihrer Umgebung</span><span class="sxs-lookup"><span data-stu-id="24a89-239">Adding the Deploy to Kubernetes task to your Environment</span></span>

<span data-ttu-id="24a89-240">Abbildung 5–11 veranschaulicht, wie Sie die Aufgabe „Für Kubernetes bereitstellen“ mit den zur Konfiguration verfügbaren Abschnitten bearbeiten können.</span><span class="sxs-lookup"><span data-stu-id="24a89-240">Figure 5-11 demonstrates how you can edit the Deploy to Kubernetes task with the sections available for configuration.</span></span> <span data-ttu-id="24a89-241">Dies ist die Aufgabe, die Ihre verwendungsbereiten benutzerdefinierten Docker-Images für die Bereitstellung als Container im Cluster abruft.</span><span class="sxs-lookup"><span data-stu-id="24a89-241">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![Screenshot, der die Konfiguration der Aufgabe „In Kubernetes bereitstellen“ zeigt.](./media/docker-application-outer-loop-devops-workflow/edit-deploy-to-kubernetes-task.png)

<span data-ttu-id="24a89-243">**Abbildung 5-11**.</span><span class="sxs-lookup"><span data-stu-id="24a89-243">**Figure 5-11**.</span></span> <span data-ttu-id="24a89-244">Definition der Docker-Bereitstellungsaufgabe bei der Bereitstellung für ACS DC/OS</span><span class="sxs-lookup"><span data-stu-id="24a89-244">Docker Deploy task definition deploying to ACS DC/OS</span></span>

> <span data-ttu-id="24a89-245">[!INFORMATION] Weitere Informationen zur CD-Pipeline mit Azure DevOps Services und Docker finden Sie unter <https://azure.microsoft.com/services/devops/pipelines></span><span class="sxs-lookup"><span data-stu-id="24a89-245">[!INFORMATION] To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="24a89-246">Schritt 5: Ausführen und Verwalten</span><span class="sxs-lookup"><span data-stu-id="24a89-246">Step 5: Run and manage</span></span>

<span data-ttu-id="24a89-247">Da das Ausführen und Verwalten von Anwendungen in Produktionsumgebungen auf Unternehmensniveau ein eigenes, wichtiges Thema ist und aufgrund der Art der Vorgänge und Personen, die auf dieser Ebene (IT-Operations) arbeiten sowie dem großen Umfang dieses Gebiets, ist ihm das gesamte nächste Kapitel gewidmet.</span><span class="sxs-lookup"><span data-stu-id="24a89-247">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="24a89-248">Schritt 6: Überwachen und Diagnostizieren</span><span class="sxs-lookup"><span data-stu-id="24a89-248">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="24a89-249">Dieses Thema wird ebenfalls im nächsten Kapitel als Teil der Aufgaben behandelt, die IT in Produktionssystemen ausführt. Es muss aber hervorgehoben werden, dass die in diesem Schritt erhaltenen Erkenntnisse an das Entwicklungsteam rückgekoppelt werden müssen, sodass die Anwendung fortlaufend verbessert wird.</span><span class="sxs-lookup"><span data-stu-id="24a89-249">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="24a89-250">Unter diesem Blickwinkel ist es ebenfalls Teil von DevOps, obwohl die Aufgaben und Betriebsvorgänge normalerweise von der IT-Abteilung durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="24a89-250">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="24a89-251">Nur wenn Überwachung und Diagnose zu 100 % im Zugriffsbereich von DevOps liegen, werden die vom Entwicklungsteam durchgeführten Überwachungsprozesse und Analysen in Test- oder Betaumgebungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="24a89-251">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="24a89-252">Dies erfolgt entweder in Form von Auslastungstests oder durch Überwachen von Beta- oder QA-Umgebungen, in denen Betatester die neuen Versionen ausprobieren.</span><span class="sxs-lookup"><span data-stu-id="24a89-252">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="24a89-253">[Zurück](index.md)
>[Weiter](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="24a89-253">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
