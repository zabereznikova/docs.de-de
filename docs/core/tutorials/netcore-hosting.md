---
title: Schreiben eines benutzerdefinierten .NET Core-Laufzeithosts
description: Erfahren Sie, wie Sie die.NET Core-Runtime vom nativen Code aus hosten können, um erweiterte Szenarien zu unterstützen, die eine Kontrolle der Funktionsweise der.NET Core-Runtime erfordern.
author: mjrousos
ms.topic: how-to
ms.date: 12/21/2018
ms.openlocfilehash: 358cbff1ded3bd4ee9a3f78965eac1e1b1883ede
ms.sourcegitcommit: 635a0ff775d2447a81ef7233a599b8f88b162e5d
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 12/17/2020
ms.locfileid: "97633845"
---
# <a name="write-a-custom-net-core-host-to-control-the-net-runtime-from-your-native-code"></a><span data-ttu-id="0262d-103">Schreiben Sie einen benutzerdefinierten .NET Core-Host, um die .NET-Runtime über den systemeigenen Code zu steuern.</span><span class="sxs-lookup"><span data-stu-id="0262d-103">Write a custom .NET Core host to control the .NET runtime from your native code</span></span>

<span data-ttu-id="0262d-104">Wie alle verwalteten Codes werden .NET Core-Anwendungen von einem Host ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="0262d-104">Like all managed code, .NET Core applications are executed by a host.</span></span> <span data-ttu-id="0262d-105">Der Host ist für das Starten der Runtime (einschließlich Komponenten wie die JIT und Garbage Collector) und das Aufrufen von verwalteten Einstiegspunkten verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="0262d-105">The host is responsible for starting the runtime (including components like the JIT and garbage collector) and invoking managed entry points.</span></span>

<span data-ttu-id="0262d-106">Das Hosten der Laufzeit von .NET Core ist ein erweitertes Szenario, und in den meisten Fällen brauchen sich .NET Core-Entwickler nicht darum kümmern, da die Buildprozesse von .NET Core einen Standardhost bereitstellen, der die .NET Core-Anwendungen ausführt.</span><span class="sxs-lookup"><span data-stu-id="0262d-106">Hosting the .NET Core runtime is an advanced scenario and, in most cases, .NET Core developers don't need to worry about hosting because .NET Core build processes provide a default host to run .NET Core applications.</span></span> <span data-ttu-id="0262d-107">Unter speziellen Umständen kann es jedoch hilfreich sein, die .NET Core-Laufzeit explizit zu hosten, entweder als Mittel zum Aufrufen von verwalteten Codes in einem nativen Prozess oder um mehr Kontrolle über die Funktionsweise der Laufzeit zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="0262d-107">In some specialized circumstances, though, it can be useful to explicitly host the .NET Core runtime, either as a means of invoking managed code in a native process or in order to gain more control over how the runtime works.</span></span>

<span data-ttu-id="0262d-108">Dieser Artikel bietet einen Überblick über die erforderlichen Schritte zum Starten der .NET Core-Runtime aus nativem Code und für das Ausführen von darin enthaltenem verwalteten Code.</span><span class="sxs-lookup"><span data-stu-id="0262d-108">This article gives an overview of the steps necessary to start the .NET Core runtime from native code and execute managed code in it.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="0262d-109">Voraussetzungen</span><span class="sxs-lookup"><span data-stu-id="0262d-109">Prerequisites</span></span>

<span data-ttu-id="0262d-110">Da Hosts native Anwendungen sind, wird in diesem Tutorial das Erstellen einer C++-Anwendung zum Hosten von .NET Core behandelt.</span><span class="sxs-lookup"><span data-stu-id="0262d-110">Because hosts are native applications, this tutorial covers constructing a C++ application to host .NET Core.</span></span> <span data-ttu-id="0262d-111">Sie benötigen eine C++-Entwicklungsumgebung (z.B. von [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span><span class="sxs-lookup"><span data-stu-id="0262d-111">You will need a C++ development environment (such as that provided by [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span></span>

<span data-ttu-id="0262d-112">Sie sollten außerdem über eine einfache .NET Core-Anwendung zum Testen des Hosts verfügen, daher sollten Sie die [.NET Core SDK](https://dotnet.microsoft.com/download) installieren und [eine kleine .NET Core-Testanwendung erstellen](with-visual-studio.md) (z.B. die Anwendung „Hello World“).</span><span class="sxs-lookup"><span data-stu-id="0262d-112">You will also want a simple .NET Core application to test the host with, so you should install the [.NET Core SDK](https://dotnet.microsoft.com/download) and [build a small .NET Core test app](with-visual-studio.md) (such as a 'Hello World' app).</span></span> <span data-ttu-id="0262d-113">Die „Hello World“-Anwendung, die von der neuen Projektvorlage der .NET Core-Konsole erstellt wird, ist ausreichend.</span><span class="sxs-lookup"><span data-stu-id="0262d-113">The 'Hello World' app created by the new .NET Core console project template is sufficient.</span></span>

## <a name="hosting-apis"></a><span data-ttu-id="0262d-114">Hosting-APIs</span><span class="sxs-lookup"><span data-stu-id="0262d-114">Hosting APIs</span></span>

<span data-ttu-id="0262d-115">Sie können zwei verschiedene APIs verwenden, um .NET Core zu hosten.</span><span class="sxs-lookup"><span data-stu-id="0262d-115">There are two different APIs that can be used to host .NET Core.</span></span> <span data-ttu-id="0262d-116">In diesem Artikel (und den zugehörigen [Beispielen](https://github.com/dotnet/samples/tree/master/core/hosting)) werden diese beiden Optionen behandelt.</span><span class="sxs-lookup"><span data-stu-id="0262d-116">This article (and its associated [samples](https://github.com/dotnet/samples/tree/master/core/hosting)) covers these 2 options.</span></span>

* <span data-ttu-id="0262d-117">Die bevorzugte Methode zum Hosten der .NET Core-Runtime ab .NET Core 3.0 ist mithilfe der APIs der Bibliotheken `nethost` und `hostfxr`.</span><span class="sxs-lookup"><span data-stu-id="0262d-117">The preferred method of hosting the .NET Core runtime in .NET Core 3.0 and above is with the `nethost` and `hostfxr` libraries' APIs.</span></span> <span data-ttu-id="0262d-118">Diese Einstiegspunkte bewältigen die Komplexität des Auffindens und Einrichtens der Runtime für die Initialisierung und ermöglichen sowohl das Starten einer verwalteten Anwendung als auch das Aufrufen einer statischen verwalteten Methode.</span><span class="sxs-lookup"><span data-stu-id="0262d-118">These entry points handle the complexity of finding and setting up the runtime for initialization and allow both launching a managed application and calling into a static managed method.</span></span>
* <span data-ttu-id="0262d-119">Die API [`coreclrhost.h`](https://github.com/dotnet/runtime/blob/master/src/coreclr/hosts/inc/coreclrhost.h) wird jedoch bei früheren Versionen als .NET Core 3.0 bevorzugt für das Hosten der .NET Core-Runtime verwendet.</span><span class="sxs-lookup"><span data-stu-id="0262d-119">The preferred method of hosting the .NET Core runtime prior to .NET Core 3.0 is with the [`coreclrhost.h`](https://github.com/dotnet/runtime/blob/master/src/coreclr/hosts/inc/coreclrhost.h) API.</span></span> <span data-ttu-id="0262d-120">Diese API enthält Funktionen, mit denen Sie die Runtime einfach starten und beenden können und verwalteten Code aufrufen können, indem Sie entweder eine entsprechende ausführbare Datei ausführen oder verwaltete statische Methoden aufrufen.</span><span class="sxs-lookup"><span data-stu-id="0262d-120">This API exposes functions for easily starting and stopping the runtime and invoking managed code (either by launching a managed exe or by calling static managed methods).</span></span>

## <a name="sample-hosts"></a><span data-ttu-id="0262d-121">Beispielhosts</span><span class="sxs-lookup"><span data-stu-id="0262d-121">Sample Hosts</span></span>

<span data-ttu-id="0262d-122">[Beispielhosts](https://github.com/dotnet/samples/tree/master/core/hosting) zur Veranschaulichung der Schritte in diesen Tutorials sind im GitHub-Repository „dotnet/samples“ auf verfügbar.</span><span class="sxs-lookup"><span data-stu-id="0262d-122">[Sample hosts](https://github.com/dotnet/samples/tree/master/core/hosting) demonstrating the steps outlined in the tutorials below are available in the dotnet/samples GitHub repository.</span></span> <span data-ttu-id="0262d-123">Durch die Kommentare in den Beispielen werden die nummerierten Schritte in diesem Tutorial ihrer Position im Beispiel eindeutig zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="0262d-123">Comments in the samples clearly associate the numbered steps from these tutorials with where they're performed in the sample.</span></span> <span data-ttu-id="0262d-124">Anweisungen zum Herunterladen finden Sie unter [Beispiele und Lernprogramme](../../samples-and-tutorials/index.md#view-and-download-samples).</span><span class="sxs-lookup"><span data-stu-id="0262d-124">For download instructions, see [Samples and Tutorials](../../samples-and-tutorials/index.md#view-and-download-samples).</span></span>

<span data-ttu-id="0262d-125">Bedenken Sie, dass die Beispielhosts zu Lernzwecken gedacht und somit bei der Fehlerüberprüfung nachsichtig sind. Die Lesbarkeit steht in diesem Fall über der Effizienz.</span><span class="sxs-lookup"><span data-stu-id="0262d-125">Keep in mind that the sample hosts are meant to be used for learning purposes, so they are light on error checking and are designed to emphasize readability over efficiency.</span></span>

## <a name="create-a-host-using-nethosth-and-hostfxrh"></a><span data-ttu-id="0262d-126">Erstellen eines Hosts mithilfe von `nethost.h` und `hostfxr.h`</span><span class="sxs-lookup"><span data-stu-id="0262d-126">Create a host using `nethost.h` and `hostfxr.h`</span></span>

<span data-ttu-id="0262d-127">In den folgenden Schritten wird detailliert beschrieben, wie Sie die Bibliotheken `nethost` und `hostfxr` verwenden können, um die .NET Core-Runtime in einer nativen Anwendung zu starten und eine verwaltete statische Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0262d-127">The following steps detail how to use the `nethost` and `hostfxr` libraries to start the .NET Core runtime in a native application and call into a managed static method.</span></span> <span data-ttu-id="0262d-128">Im [Beispiel](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithHostFxr) werden der mit dem .NET SDK installierte Header `nethost` und die Bibliothek sowie Kopien der Dateien [`coreclr_delegates.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/coreclr_delegates.h) und [`hostfxr.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/hostfxr.h) aus dem Repository [dotnet/runtime](https://github.com/dotnet/runtime) verwendet.</span><span class="sxs-lookup"><span data-stu-id="0262d-128">The [sample](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithHostFxr) uses the `nethost` header and library installed with the .NET SDK and copies of the [`coreclr_delegates.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/coreclr_delegates.h) and [`hostfxr.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/hostfxr.h) files from the [dotnet/runtime](https://github.com/dotnet/runtime) repository.</span></span>

### <a name="step-1---load-hostfxr-and-get-exported-hosting-functions"></a><span data-ttu-id="0262d-129">Schritt 1: Laden von `hostfxr` und Abrufen der exportierten Hostingfunktionen</span><span class="sxs-lookup"><span data-stu-id="0262d-129">Step 1 - Load `hostfxr` and get exported hosting functions</span></span>

<span data-ttu-id="0262d-130">Die Bibliothek `nethost` bietet die Funktion `get_hostfxr_path` für das Auffinden der Bibliothek `hostfxr`.</span><span class="sxs-lookup"><span data-stu-id="0262d-130">The `nethost` library provides the `get_hostfxr_path` function for locating the `hostfxr` library.</span></span> <span data-ttu-id="0262d-131">Die Bibliothek `hostfxr` macht die Funktionen zum Hosten der .NET Core-Runtime verfügbar.</span><span class="sxs-lookup"><span data-stu-id="0262d-131">The `hostfxr` library exposes functions for hosting the .NET Core runtime.</span></span> <span data-ttu-id="0262d-132">Die vollständige Liste der Funktionen finden Sie in [`hostfxr.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/hostfxr.h) und im [Entwurfsdokument zum nativen Hosting](https://github.com/dotnet/runtime/blob/master/docs/design/features/native-hosting.md).</span><span class="sxs-lookup"><span data-stu-id="0262d-132">The full list of functions can be found in [`hostfxr.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/hostfxr.h) and the [native hosting design document](https://github.com/dotnet/runtime/blob/master/docs/design/features/native-hosting.md).</span></span> <span data-ttu-id="0262d-133">Im Beispiel und in diesem Tutorial wird Folgendes verwendet:</span><span class="sxs-lookup"><span data-stu-id="0262d-133">The sample and this tutorial use the following:</span></span>

* <span data-ttu-id="0262d-134">`hostfxr_initialize_for_runtime_config`: Initialisiert einen Hostkontext und bereitet die Initialisierung der .NET Core-Runtime mithilfe der angegebenen Runtimekonfiguration vor.</span><span class="sxs-lookup"><span data-stu-id="0262d-134">`hostfxr_initialize_for_runtime_config`: Initializes a host context and prepares for initialization of the .NET Core runtime using the specified runtime configuration.</span></span>
* <span data-ttu-id="0262d-135">`hostfxr_get_runtime_delegate`: Ruft einen Delegaten für Runtimefunktionalität ab.</span><span class="sxs-lookup"><span data-stu-id="0262d-135">`hostfxr_get_runtime_delegate`: Gets a delegate for runtime functionality.</span></span>
* <span data-ttu-id="0262d-136">`hostfxr_close`: Schließt einen Hostkontext.</span><span class="sxs-lookup"><span data-stu-id="0262d-136">`hostfxr_close`: Closes a host context.</span></span>

<span data-ttu-id="0262d-137">Die Bibliothek `hostfxr` wird mithilfe von `get_hostfxr_path` gefunden.</span><span class="sxs-lookup"><span data-stu-id="0262d-137">The `hostfxr` library is found using `get_hostfxr_path`.</span></span> <span data-ttu-id="0262d-138">Sie wird anschließend geladen, und ihre Exporte werden abgerufen.</span><span class="sxs-lookup"><span data-stu-id="0262d-138">It is then loaded and its exports are retrieved.</span></span>

[!code-cpp[HostFxrHost#LoadHostFxr](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#LoadHostFxr)]

### <a name="step-2---initialize-and-start-the-net-core-runtime"></a><span data-ttu-id="0262d-139">Schritt 2: Initialisieren und Starten der .NET Core-Runtime</span><span class="sxs-lookup"><span data-stu-id="0262d-139">Step 2 - Initialize and start the .NET Core runtime</span></span>

<span data-ttu-id="0262d-140">Die Funktionen `hostfxr_initialize_for_runtime_config` und `hostfxr_get_runtime_delegate` initialisieren und starten die .NET Core-Runtime unter Verwendung der Runtimekonfiguration für die verwaltete Komponente, die geladen wird.</span><span class="sxs-lookup"><span data-stu-id="0262d-140">The `hostfxr_initialize_for_runtime_config` and `hostfxr_get_runtime_delegate` functions initialize and start the .NET Core runtime using the runtime configuration for the managed component that will be loaded.</span></span> <span data-ttu-id="0262d-141">Die Funktion `hostfxr_get_runtime_delegate` wird verwendet, um einen Runtimedelegaten abzurufen, der das Laden einer verwalteten Assembly und das Abrufen eines Funktionszeigers auf eine statische Methode in dieser Assembly ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="0262d-141">The `hostfxr_get_runtime_delegate` function is used to get a runtime delegate that allows loading a managed assembly and getting a function pointer to a static method in that assembly.</span></span>

[!code-cpp[HostFxrHost#Initialize](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#Initialize)]

### <a name="step-3---load-managed-assembly-and-get-function-pointer-to-a-managed-method"></a><span data-ttu-id="0262d-142">Schritt 3: Laden der verwalteten Assembly und Abrufen des Funktionszeigers auf eine verwaltete Methode</span><span class="sxs-lookup"><span data-stu-id="0262d-142">Step 3 - Load managed assembly and get function pointer to a managed method</span></span>

<span data-ttu-id="0262d-143">Der Runtimedelegat wird aufgerufen, um die verwaltete Assembly zu laden und einen Funktionszeiger auf eine verwaltete Methode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="0262d-143">The runtime delegate is called to load the managed assembly and get a function pointer to a managed method.</span></span> <span data-ttu-id="0262d-144">Der Delegat benötigt den Assemblypfad, Typ- und Methodennamen als Eingaben und gibt einen Funktionszeiger zurück, mit dem die verwaltete Methode aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="0262d-144">The delegate requires the assembly path, type name, and method name as inputs and returns a function pointer that can be used to invoke the managed method.</span></span>

[!code-cpp[HostFxrHost#LoadAndGet](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#LoadAndGet)]

<span data-ttu-id="0262d-145">Durch die Übergabe von `nullptr` als Delegatentypname beim Aufruf des Runtimedelegaten verwendet das Beispiel eine Standardsignatur für die verwaltete Methode:</span><span class="sxs-lookup"><span data-stu-id="0262d-145">By passing `nullptr` as the delegate type name when calling the runtime delegate, the sample uses a default signature for the managed method:</span></span>

```csharp
public delegate int ComponentEntryPoint(IntPtr args, int sizeBytes);
```

<span data-ttu-id="0262d-146">Eine andere Signatur kann verwendet werden, indem beim Aufruf des Runtimedelegaten der Name des Delegatentyps angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="0262d-146">A different signature can be used by specifying the delegate type name when calling the runtime delegate.</span></span>

### <a name="step-4---run-managed-code"></a><span data-ttu-id="0262d-147">Schritt 4: Ausführen von verwaltetem Code</span><span class="sxs-lookup"><span data-stu-id="0262d-147">Step 4 - Run managed code!</span></span>

<span data-ttu-id="0262d-148">Der native Host kann nun die verwaltete Methode aufrufen und die gewünschten Parameter an sie übergeben.</span><span class="sxs-lookup"><span data-stu-id="0262d-148">The native host can now call the managed method and pass it the desired parameters.</span></span>

[!code-cpp[HostFxrHost#CallManaged](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#CallManaged)]

## <a name="create-a-host-using-coreclrhosth"></a><span data-ttu-id="0262d-149">Erstellen eines Hosts mithilfe von `coreclrhost.h`</span><span class="sxs-lookup"><span data-stu-id="0262d-149">Create a host using `coreclrhost.h`</span></span>

<span data-ttu-id="0262d-150">In den folgenden Schritten wird detailliert beschrieben, wie Sie die API `coreclrhost.h` verwenden können, um die .NET Core-Runtime in einer nativen Anwendung zu starten und eine verwaltete statische Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0262d-150">The following steps detail how to use the `coreclrhost.h` API to start the .NET Core runtime in a native application and call into a managed static method.</span></span> <span data-ttu-id="0262d-151">Für die Codeausschnitte in diesem Artikel werden einige Windows-spezifische APIs verwendet. Im [vollständigen Beispielhost](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithCoreClrHost) sind jedoch Windows- und Linux-Codepfade enthalten.</span><span class="sxs-lookup"><span data-stu-id="0262d-151">The code snippets in this document use some Windows-specific APIs, but the [full sample host](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithCoreClrHost) shows both Windows and Linux code paths.</span></span>

<span data-ttu-id="0262d-152">Der [Host Unix CoreRun](https://github.com/dotnet/runtime/tree/master/src/coreclr/hosts/unixcorerun) zeigt ein komplexeres, realistisches Beispiel für das Hosting mit `coreclrhost.h`.</span><span class="sxs-lookup"><span data-stu-id="0262d-152">The [Unix CoreRun host](https://github.com/dotnet/runtime/tree/master/src/coreclr/hosts/unixcorerun) shows a more complex, real-world example of hosting using `coreclrhost.h`.</span></span>

### <a name="step-1---find-and-load-coreclr"></a><span data-ttu-id="0262d-153">Schritt 1: Suchen und Laden von CoreCLR</span><span class="sxs-lookup"><span data-stu-id="0262d-153">Step 1 - Find and load CoreCLR</span></span>

<span data-ttu-id="0262d-154">Die APIs für die .NET Core-Runtime befinden sich in *coreclr.dll* (Windows), *libcoreclr.so* (Linux) und *libcoreclr.dylib* (macOS).</span><span class="sxs-lookup"><span data-stu-id="0262d-154">The .NET Core runtime APIs are in *coreclr.dll* (on Windows), in *libcoreclr.so* (on Linux), or in *libcoreclr.dylib* (on macOS).</span></span> <span data-ttu-id="0262d-155">Wenn Sie .NET Core hosten möchten, müssen Sie zunächst die CoreCLR-Bibliothek laden.</span><span class="sxs-lookup"><span data-stu-id="0262d-155">The first step to hosting .NET Core is to load the CoreCLR library.</span></span> <span data-ttu-id="0262d-156">Einige Hosts durchsuchen unterschiedliche Pfade oder verwenden Eingabeparameter, um die Bibliothek zu suchen, während anderen bekannt ist, dass diese aus einem bestimmten Pfad geladen werden muss (z. B. neben dem Host oder von einem computerweiten Speicherort).</span><span class="sxs-lookup"><span data-stu-id="0262d-156">Some hosts probe different paths or use input parameters to find the library while others know to load it from a certain path (next to the host, for example, or from a machine-wide location).</span></span>

<span data-ttu-id="0262d-157">Sobald die Bibliothek gefunden wurde, wird sie mit `LoadLibraryEx` (Windows) oder `dlopen` (Linux/macOS) geladen.</span><span class="sxs-lookup"><span data-stu-id="0262d-157">Once found, the library is loaded with `LoadLibraryEx` (on Windows) or `dlopen` (on Linux/macOS).</span></span>

[!code-cpp[CoreClrHost#1](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#1)]

### <a name="step-2---get-net-core-hosting-functions"></a><span data-ttu-id="0262d-158">Schritt 2: .NET Core-Hostingfunktionen</span><span class="sxs-lookup"><span data-stu-id="0262d-158">Step 2 - Get .NET Core hosting functions</span></span>

<span data-ttu-id="0262d-159">In CoreClrHost sind einige wichtige Methoden enthalten, die für das Hosten von .NET Core nützlich sind:</span><span class="sxs-lookup"><span data-stu-id="0262d-159">CoreClrHost has several important methods useful for hosting .NET Core:</span></span>

* <span data-ttu-id="0262d-160">`coreclr_initialize`: Startet die .NET Core-Runtime und richtet die (einzige) Standardanwendungsdomäne ein.</span><span class="sxs-lookup"><span data-stu-id="0262d-160">`coreclr_initialize`: Starts the .NET Core runtime and sets up the default (and only) AppDomain.</span></span>
* <span data-ttu-id="0262d-161">`coreclr_execute_assembly`: Führt eine verwaltete Assembly aus.</span><span class="sxs-lookup"><span data-stu-id="0262d-161">`coreclr_execute_assembly`: Executes a managed assembly.</span></span>
* <span data-ttu-id="0262d-162">`coreclr_create_delegate`: Erstellt einen Funktionszeiger zu einer verwalteten Methode.</span><span class="sxs-lookup"><span data-stu-id="0262d-162">`coreclr_create_delegate`: Creates a function pointer to a managed method.</span></span>
* <span data-ttu-id="0262d-163">`coreclr_shutdown`: Beendet die .NET Core-Runtime.</span><span class="sxs-lookup"><span data-stu-id="0262d-163">`coreclr_shutdown`: Shuts down the .NET Core runtime.</span></span>
* <span data-ttu-id="0262d-164">`coreclr_shutdown_2`: Funktioniert wie `coreclr_shutdown`, ruft jedoch zusätzlich den Exitcode des verwalteten Codes ab.</span><span class="sxs-lookup"><span data-stu-id="0262d-164">`coreclr_shutdown_2`: Like `coreclr_shutdown`, but also retrieves the managed code's exit code.</span></span>

<span data-ttu-id="0262d-165">Nachdem Sie die CoreCLR-Bibliothek geladen haben, müssen Sie mithilfe von `GetProcAddress` (Windows) oder `dlsym` (Linux/macOS) auf diese Funktion verweisen.</span><span class="sxs-lookup"><span data-stu-id="0262d-165">After loading the CoreCLR library, the next step is to get references to these functions using `GetProcAddress` (on Windows) or `dlsym` (on Linux/macOS).</span></span>

[!code-cpp[CoreClrHost#2](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#2)]

### <a name="step-3---prepare-runtime-properties"></a><span data-ttu-id="0262d-166">Schritt 3: Vorbereiten der Runtimeeigenschaften</span><span class="sxs-lookup"><span data-stu-id="0262d-166">Step 3 - Prepare runtime properties</span></span>

<span data-ttu-id="0262d-167">Bevor Sie die Runtime starten, müssen Sie einige Eigenschaften auf bestimmte Verhaltensweisen festlegen (insbesondere für das Assemblyladeprogramm).</span><span class="sxs-lookup"><span data-stu-id="0262d-167">Before starting the runtime, it is necessary to prepare some properties to specify behavior (especially concerning the assembly loader).</span></span>

<span data-ttu-id="0262d-168">Das gilt üblicherweise für folgende Eigenschaften:</span><span class="sxs-lookup"><span data-stu-id="0262d-168">Common properties include:</span></span>

* <span data-ttu-id="0262d-169">`TRUSTED_PLATFORM_ASSEMBLIES`: Diese Eigenschaft stellt eine Liste der Assemblypfade (unter Windows durch „;“ und unter Linux durch „:“ getrennt) dar, die die Runtime standardmäßig auflösen kann.</span><span class="sxs-lookup"><span data-stu-id="0262d-169">`TRUSTED_PLATFORM_ASSEMBLIES` This is a list of assembly paths (delimited by ';' on Windows and ':' on Linux) which the runtime will be able to resolve by default.</span></span> <span data-ttu-id="0262d-170">Einige Hosts verfügen über hartcodierte Manifeste mit Assemblys, die geladen werden können.</span><span class="sxs-lookup"><span data-stu-id="0262d-170">Some hosts have hard-coded manifests listing assemblies they can load.</span></span> <span data-ttu-id="0262d-171">Andere platzieren Bibliotheken in dieser Liste an bestimmten Positionen (z. B. neben *coreclr.dll*).</span><span class="sxs-lookup"><span data-stu-id="0262d-171">Others will put any library in certain locations (next to *coreclr.dll*, for example) on this list.</span></span>
* <span data-ttu-id="0262d-172">`APP_PATHS` Dies ist eine Liste der Pfade, in denen nach einer Assembly gesucht werden soll, wenn sie in der Liste der vertrauenswürdigen Plattformassemblys (TPA) nicht gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="0262d-172">`APP_PATHS` This is a list of paths to probe in for an assembly if it can't be found in the trusted platform assemblies (TPA) list.</span></span> <span data-ttu-id="0262d-173">Da der Host mehr Kontrolle darüber hat, welche Assemblys mithilfe der TPA-Liste geladen werden, wird empfohlen, für alle Hosts festzulegen, welche Assemblys diese erwarten und diese explizit aufzulisten.</span><span class="sxs-lookup"><span data-stu-id="0262d-173">Because the host has more control over which assemblies are loaded using the TPA list, it is a best practice for hosts to determine which assemblies they expect to load and list them explicitly.</span></span> <span data-ttu-id="0262d-174">Über diese Eigenschaft können Sie auch die Überprüfung von Runtimes aktivieren.</span><span class="sxs-lookup"><span data-stu-id="0262d-174">If probing at run time is needed, however, this property can enable that scenario.</span></span>
* <span data-ttu-id="0262d-175">`APP_NI_PATHS`: Diese Liste ähnelt APP_PATHS sehr ähnlich, gilt jedoch für Pfade, die nach nativen Images durchsucht werden sollen.</span><span class="sxs-lookup"><span data-stu-id="0262d-175">`APP_NI_PATHS` This list is similar to APP_PATHS except that it's meant to be paths that will be probed for native images.</span></span>
* <span data-ttu-id="0262d-176">`NATIVE_DLL_SEARCH_DIRECTORIES`: Diese Eigenschaft ist eine Liste der Pfade, die das Ladeprogramm durchsuchen soll, wenn es nach nativen Bibliotheken sucht, die über p/invoke aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="0262d-176">`NATIVE_DLL_SEARCH_DIRECTORIES` This property is a list of paths the loader should probe when looking for native libraries called via p/invoke.</span></span>
* <span data-ttu-id="0262d-177">`PLATFORM_RESOURCE_ROOTS` Diese Liste enthält die Pfade, in denen nach Assemblys der Ressourcensatelliten (in kulturspezifischen Unterverzeichnissen) gesucht wird.</span><span class="sxs-lookup"><span data-stu-id="0262d-177">`PLATFORM_RESOURCE_ROOTS` This list includes paths to probe in for resource satellite assemblies (in culture-specific subdirectories).</span></span>

<span data-ttu-id="0262d-178">In diesem Beispielhost wird die TPA-Liste erstellt, indem alle Bibliotheken im aktuellen Verzeichnis aufgelistet werden:</span><span class="sxs-lookup"><span data-stu-id="0262d-178">In this sample host, the TPA list is constructed by simply listing all libraries in the current directory:</span></span>

[!code-cpp[CoreClrHost#7](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#7)]

<span data-ttu-id="0262d-179">Da es sich um ein einfaches Beispiel handelt, ist nur die Eigenschaft `TRUSTED_PLATFORM_ASSEMBLIES` erforderlich:</span><span class="sxs-lookup"><span data-stu-id="0262d-179">Because the sample is simple, it only needs the `TRUSTED_PLATFORM_ASSEMBLIES` property:</span></span>

[!code-cpp[CoreClrHost#3](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#3)]

### <a name="step-4---start-the-runtime"></a><span data-ttu-id="0262d-180">Schritt 4: Starten der Runtime</span><span class="sxs-lookup"><span data-stu-id="0262d-180">Step 4 - Start the runtime</span></span>

<span data-ttu-id="0262d-181">`coreclrhost.h`-APIs starten die Runtime und erstellen die Standard-AppDomain mit einem einzigen Befehl.</span><span class="sxs-lookup"><span data-stu-id="0262d-181">`coreclrhost.h` APIs start the runtime and create the default AppDomain all with a single call.</span></span> <span data-ttu-id="0262d-182">Die Funktion `coreclr_initialize` akzeptiert einen Basispfad, einen Namen und die zuvor beschriebenen Eigenschaften und gibt ein Handle zum Host über den Parameter `hostHandle` zurück.</span><span class="sxs-lookup"><span data-stu-id="0262d-182">The `coreclr_initialize` function takes a base path, name, and the properties described earlier and returns back a handle to the host via the `hostHandle` parameter.</span></span>

[!code-cpp[CoreClrHost#4](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#4)]

### <a name="step-5---run-managed-code"></a><span data-ttu-id="0262d-183">Schritt 5: Ausführen von verwaltetem Code</span><span class="sxs-lookup"><span data-stu-id="0262d-183">Step 5 - Run managed code!</span></span>

<span data-ttu-id="0262d-184">Wenn die Runtime gestartet wurde, kann der Host verwalteten Code abrufen.</span><span class="sxs-lookup"><span data-stu-id="0262d-184">With the runtime started, the host can call managed code.</span></span> <span data-ttu-id="0262d-185">Dafür stehen verschiedene Möglichkeiten zur Auswahl.</span><span class="sxs-lookup"><span data-stu-id="0262d-185">This can be done in a couple of different ways.</span></span> <span data-ttu-id="0262d-186">Im Beispielcode für dieses Tutorial wird die Funktion `coreclr_create_delegate` verwendet, um einen Delegaten für eine verwaltete statische Methode zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="0262d-186">The sample code linked to this tutorial uses the `coreclr_create_delegate` function to create a delegate to a static managed method.</span></span> <span data-ttu-id="0262d-187">Diese API akzeptiert den [Assemblynamen](../../standard/assembly/names.md), den namespacequalifizierten Typnamen und den Methodennamen als Eingabe und gibt einen Delegaten zurück, mit dem die Methode aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="0262d-187">This API takes the [assembly name](../../standard/assembly/names.md), namespace-qualified type name, and method name as inputs and returns a delegate that can be used to invoke the method.</span></span>

[!code-cpp[CoreClrHost#5](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#5)]

<span data-ttu-id="0262d-188">In diesem Beispiel kann der Host nun `managedDelegate` verwenden, um die Methode `ManagedWorker.DoWork` aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0262d-188">In this sample, the host can now call `managedDelegate` to run the `ManagedWorker.DoWork` method.</span></span>

<span data-ttu-id="0262d-189">Alternativ kann die `coreclr_execute_assembly`-Funktion verwendet werden, um eine verwaltete ausführbare Datei zu starten.</span><span class="sxs-lookup"><span data-stu-id="0262d-189">Alternatively, the `coreclr_execute_assembly` function can be used to launch a managed executable.</span></span> <span data-ttu-id="0262d-190">Diese API akzeptiert einen Assemblypfad und ein Array aus Argumenten als Eingabeparameter.</span><span class="sxs-lookup"><span data-stu-id="0262d-190">This API takes an assembly path and array of arguments as input parameters.</span></span> <span data-ttu-id="0262d-191">Sie lädt die Assembly aus diesem Pfad und ruft deren main-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="0262d-191">It loads the assembly at that path and invokes its main method.</span></span>

```c++
int hr = executeAssembly(
        hostHandle,
        domainId,
        argumentCount,
        arguments,
        "HelloWorld.exe",
        (unsigned int*)&exitCode);
```

### <a name="step-6---shutdown-and-clean-up"></a><span data-ttu-id="0262d-192">Schritt 6: Beenden und Bereinigen</span><span class="sxs-lookup"><span data-stu-id="0262d-192">Step 6 - Shutdown and clean up</span></span>

<span data-ttu-id="0262d-193">Wenn der Host den verwalteten Code ausgeführt hat, wird die .NET Core-Runtime schließlich mithilfe von `coreclr_shutdown` oder `coreclr_shutdown_2` beendet.</span><span class="sxs-lookup"><span data-stu-id="0262d-193">Finally, when the host is done running managed code, the .NET Core runtime is shut down with `coreclr_shutdown` or `coreclr_shutdown_2`.</span></span>

[!code-cpp[CoreClrHost#6](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#6)]

<span data-ttu-id="0262d-194">CoreCLR unterstützt keine erneute Initialisierung oder das Entladen.</span><span class="sxs-lookup"><span data-stu-id="0262d-194">CoreCLR does not support reinitialization or unloading.</span></span> <span data-ttu-id="0262d-195">Rufen Sie `coreclr_initialize` nicht erneut auf oder entladen Sie die CoreCLR-Bibliothek.</span><span class="sxs-lookup"><span data-stu-id="0262d-195">Do not call `coreclr_initialize` again or unload the CoreCLR library.</span></span>

## <a name="conclusion"></a><span data-ttu-id="0262d-196">Zusammenfassung</span><span class="sxs-lookup"><span data-stu-id="0262d-196">Conclusion</span></span>

<span data-ttu-id="0262d-197">Sobald Ihr Host erstellt wurde, können Sie ihn testen, indem Sie ihn über die Befehlszeile ausführen und Argumente übergeben, die der Host erwartet.</span><span class="sxs-lookup"><span data-stu-id="0262d-197">Once your host is built, it can be tested by running it from the command line and passing any arguments the host expects.</span></span> <span data-ttu-id="0262d-198">Beim Angeben der .NET Core-Anwendung, die den Host ausführt, müssen Sie die DLL-Datei verwenden, die von `dotnet build` erzeugt wurde.</span><span class="sxs-lookup"><span data-stu-id="0262d-198">When specifying the .NET Core app for the host to run, be sure to use the .dll that is produced by `dotnet build`.</span></span> <span data-ttu-id="0262d-199">Ausführbare Dateien (EXE-Dateien), die für eigenständige Anwendungen von `dotnet publish` erstellt wurden, stellen die Standardeinstellung des .NET Core-Hosts dar, sodass die Anwendung in Hauptszenarios direkt über die Befehlszeile gestartet werden kann. Der Benutzercode wird in eine DLL-Datei mit dem gleichen Namen kompiliert.</span><span class="sxs-lookup"><span data-stu-id="0262d-199">Executables (.exe files) produced by `dotnet publish` for self-contained applications are actually the default .NET Core host (so that the app can be launched directly from the command line in mainline scenarios); user code is compiled into a dll of the same name.</span></span>

<span data-ttu-id="0262d-200">Wenn anfangs Funktionsstörungen auftreten, überprüfen Sie, ob *coreclr.dll* an dem Speicherort zur Verfügung steht, den der Host erwartet, ob sich alle erforderlichen Frameworkbibliotheken in der TPA-Liste befinden und ob die CoreCLR-Bitanzahl (32-Bit oder 64-Bit) der Erstellungsart des Host entspricht.</span><span class="sxs-lookup"><span data-stu-id="0262d-200">If things don't work initially, double-check that *coreclr.dll* is available in the location expected by the host, that all necessary Framework libraries are in the TPA list, and that CoreCLR's bitness (32-bit or 64-bit) matches how the host was built.</span></span>

<span data-ttu-id="0262d-201">Das Hosten der Laufzeit von .NET Core ist ein erweitertes Szenario, das für viele Entwickler nicht erforderlich ist, aber für diejenigen, die verwalteten Code von einem nativen Prozess starten müssen, oder die mehr Kontrolle über das Verhalten der .NET Core-Laufzeit benötigen, kann es sehr nützlich sein.</span><span class="sxs-lookup"><span data-stu-id="0262d-201">Hosting the .NET Core runtime is an advanced scenario that many developers won't require, but for those who need to launch managed code from a native process, or who need more control over the .NET Core runtime's behavior, it can be very useful.</span></span>
