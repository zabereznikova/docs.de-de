---
title: Übersicht über EventPipe
description: Hier erfahren Sie mehr über EventPipe und die Verwendung dieser Komponente für die Ablaufverfolgung von .NET-Anwendungen, um Leistungsprobleme diagnostizieren zu können.
ms.date: 11/09/2020
ms.topic: overview
ms.openlocfilehash: 00378c4f409b307afa9183e40de6078cdafd3ae7
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/18/2020
ms.locfileid: "94820617"
---
# <a name="eventpipe"></a><span data-ttu-id="5e7e7-103">EventPipe</span><span class="sxs-lookup"><span data-stu-id="5e7e7-103">EventPipe</span></span>

<span data-ttu-id="5e7e7-104">EventPipe ist eine Runtimekomponente, die wie ETW oder LTTng zum Erfassen von Ablaufverfolgungsdaten verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-104">EventPipe is a runtime component that can be used to collect tracing data, similar to ETW or LTTng.</span></span> <span data-ttu-id="5e7e7-105">EventPipe soll es .NET-Entwicklern ermöglichen, die Aktivitäten ihrer .NET-Anwendungen problemlos nachverfolgen zu können, ohne sich dabei auf plattformspezifische und betriebssystemnative Komponenten wie ETW oder LTTng verlassen zu müssen.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-105">The goal of EventPipe is to allow .NET developers to easily trace their .NET applications without having to rely on platform-specific OS-native components such as ETW or LTTng.</span></span>

<span data-ttu-id="5e7e7-106">EventPipe ist der Mechanismus hinter vielen der Diagnosetools und kann zum Verarbeiten von Ereignissen, die von der Runtime ausgegeben werden, sowie von benutzerdefinierten Ereignissen verwendet werden, die mit [EventSource](xref:System.Diagnostics.Tracing.EventSource) geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-106">EventPipe is the mechanism behind many of the diagnostic tools and can be used for consuming events emitted by the runtime as well as custom events written with [EventSource](xref:System.Diagnostics.Tracing.EventSource).</span></span>

<span data-ttu-id="5e7e7-107">Dieser Artikel bietet eine allgemeine Übersicht über EventPipe, und es wird beschrieben, wann und wie EventPipe verwendet werden sollte und wie die Komponente Ihren Anforderungen entsprechend konfiguriert werden kann.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-107">This article is a high-level overview of EventPipe describing when and how to use EventPipe, and how to configure it to best suit your needs.</span></span>

## <a name="eventpipe-basics"></a><span data-ttu-id="5e7e7-108">EventPipe-Grundlagen</span><span class="sxs-lookup"><span data-stu-id="5e7e7-108">EventPipe basics</span></span>

<span data-ttu-id="5e7e7-109">EventPipe aggregiert Ereignisse, die von Runtimekomponenten (z. B. Just-In-Time-Compiler oder Garbage Collector) ausgegeben werden, und Ereignisse, die aus [EventSource](xref:System.Diagnostics.Tracing.EventSource)-Instanzen in den Bibliotheken und im Benutzercode geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-109">EventPipe aggregates events emitted by runtime components - for example, the Just-In-Time compiler or the garbage collector - and events written from [EventSource](xref:System.Diagnostics.Tracing.EventSource) instances in the libraries and user code.</span></span>

<span data-ttu-id="5e7e7-110">Die Ereignisse werden dann serialisiert und können direkt in eine Datei geschrieben oder über einen prozessexternen Diagnoseport genutzt werden.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-110">The events are then serialized and can be written directly to a file or consumed through a Diagnostics Port from out-of-proces.</span></span> <span data-ttu-id="5e7e7-111">Unter Windows werden Diagnoseports als `NamedPipe`s implementiert.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-111">On Windows, Diagnostic Ports are implemented as `NamedPipe`s.</span></span> <span data-ttu-id="5e7e7-112">Auf Nicht-Windows-Plattformen wie Linux oder macOS werden sie mithilfe von Unix Domain Sockets implementiert.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-112">On non-Windows platforms, such as Linux or macOS, it is implemented using Unix Domain Sockets.</span></span> <span data-ttu-id="5e7e7-113">Weitere Informationen zum Diagnoseport und die Interaktion mit diesem über das benutzerdefinierte, prozessübergreifende Kommunikationsprotokoll finden Sie in der [Dokumentation zum IPC-Diagnoseprotokoll](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md).</span><span class="sxs-lookup"><span data-stu-id="5e7e7-113">For more information about the Diagnostics Port and how to interact with it via its custom inter-process communication protocol, see the [diagnostics IPC protocol documentation](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md).</span></span>

<span data-ttu-id="5e7e7-114">EventPipe schreibt die serialisierten Ereignisse dann im `.nettrace`-Dateiformat entweder als Stream über die Diagnoseports oder direkt in eine Datei.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-114">EventPipe then writes the serialized events in the `.nettrace` file format, either as a stream via Diagnostic Ports or directly to a file.</span></span> <span data-ttu-id="5e7e7-115">Weitere Informationen zum EventPipe-Serialisierungsformat finden Sie in der [Dokumentation zum EventPipe-Format](https://github.com/microsoft/perfview/blob/master/src/TraceEvent/EventPipe/EventPipeFormat.md).</span><span class="sxs-lookup"><span data-stu-id="5e7e7-115">To learn more about the EventPipe serialization format, refer to the [EventPipe format documentation](https://github.com/microsoft/perfview/blob/master/src/TraceEvent/EventPipe/EventPipeFormat.md).</span></span>

## <a name="eventpipe-vs-etwlttng"></a><span data-ttu-id="5e7e7-116">EventPipe im Vergleich zu ETW/LTTng</span><span class="sxs-lookup"><span data-stu-id="5e7e7-116">EventPipe vs. ETW/LTTng</span></span>

<span data-ttu-id="5e7e7-117">EventPipe ist Teil der .NET-Runtime (CoreCLR) und so konzipiert, dass diese Komponente auf allen Plattformen, die .NET Core unterstützt, auf dieselbe Weise funktioniert.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-117">EventPipe is part of the .NET runtime (CoreCLR) and is designed to work the same way across all the platforms .NET Core supports.</span></span> <span data-ttu-id="5e7e7-118">Dadurch können auf EventPipe basierende Ablaufverfolgungstools wie `dotnet-counters`, `dotnet-gcdump` und `dotnet-trace` problemlos plattformübergreifend verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-118">This allows tracing tools based on EventPipe, such as `dotnet-counters`, `dotnet-gcdump`, and `dotnet-trace`, to work seamlessly across platforms.</span></span>

<span data-ttu-id="5e7e7-119">Da EventPipe jedoch eine integrierte Runtimekomponente ist, ist der zugehörige Bereich auf verwalteten Code und die Runtime selbst beschränkt.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-119">However, because EventPipe is a runtime built-in component, its scope is limited to managed code and the runtime itself.</span></span> <span data-ttu-id="5e7e7-120">EventPipe kann nicht zum Nachverfolgen detaillierterer Ereignisse wie das Auflösen von nativen Codestapeln oder das Abrufen verschiedener Kernelereignisse verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-120">EventPipe cannot be used for tracking some lower-level events, such as resolving native code stack or getting various kernel events.</span></span> <span data-ttu-id="5e7e7-121">Wenn Sie die C/C++-Interop in Ihrer App verwenden, die Runtime selbst überwachen (in C++ geschrieben) oder eine genauere Diagnose des App-Verhaltens haben möchten, die Kernelereignisse erfordert (d. h. threadnative, den Kontext wechselnde Ereignisse), sollten Sie ETW oder [perf/LTTng](./trace-perfcollect-lttng.md) verwenden.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-121">If you use C/C++ interop in your app or you want to trace the runtime itself (which is written in C++), or want deeper diagnostics into the behavior of the app that requires kernel events (that is, native-thread context-switching events) you should use ETW or [perf/LTTng](./trace-perfcollect-lttng.md).</span></span>

<span data-ttu-id="5e7e7-122">Ein weiterer wichtiger Unterschied zwischen EventPipe und ETW/LTTng besteht in den Anforderungen für die Berechtigungen für Administratoren und Root-Benutzer.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-122">Another major difference between EventPipe and ETW/LTTng is admin/root privilege requirement.</span></span> <span data-ttu-id="5e7e7-123">Sie müssen Administrator oder Root-Benutzer sein, um eine Anwendung mithilfe von ETW oder LTTng nachverfolgen zu können.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-123">To trace an application using ETW or LTTng you need to be an admin/root.</span></span> <span data-ttu-id="5e7e7-124">Wenn Sie EventPipe verwenden, können Sie Anwendungen nachverfolgen, solange die Ablaufverfolgung (z. B. `dotnet-trace`) für den Benutzer ausgeführt wird, der die Anwendung gestartet hat.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-124">Using EventPipe, you can trace applications as long as the tracer (for example, `dotnet-trace`) is run as the same user as the user that launched the application.</span></span>

<span data-ttu-id="5e7e7-125">Die folgende Tabelle ist eine Zusammenfassung der Unterschiede zwischen EventPipe und ETW/LTTng.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-125">The following table is a summary of the differences between EventPipe and ETW/LTTng.</span></span>

|<span data-ttu-id="5e7e7-126">Funktion</span><span class="sxs-lookup"><span data-stu-id="5e7e7-126">Feature</span></span>|<span data-ttu-id="5e7e7-127">EventPipe</span><span class="sxs-lookup"><span data-stu-id="5e7e7-127">EventPipe</span></span>|<span data-ttu-id="5e7e7-128">ETW</span><span class="sxs-lookup"><span data-stu-id="5e7e7-128">ETW</span></span>|<span data-ttu-id="5e7e7-129">LTTng</span><span class="sxs-lookup"><span data-stu-id="5e7e7-129">LTTng</span></span>|
|-------|---------|---|-----------|
|<span data-ttu-id="5e7e7-130">Plattformübergreifend</span><span class="sxs-lookup"><span data-stu-id="5e7e7-130">Cross-platform</span></span>|<span data-ttu-id="5e7e7-131">Ja</span><span class="sxs-lookup"><span data-stu-id="5e7e7-131">Yes</span></span>|<span data-ttu-id="5e7e7-132">Nein (nur unter Windows)</span><span class="sxs-lookup"><span data-stu-id="5e7e7-132">No (only on Windows)</span></span>|<span data-ttu-id="5e7e7-133">Nein (nur für unterstützte Linux-Distributionen)</span><span class="sxs-lookup"><span data-stu-id="5e7e7-133">No (only on supported Linux distros)</span></span>|
|<span data-ttu-id="5e7e7-134">Anfordern von Berechtigungen für Administratoren und Root-Benutzer</span><span class="sxs-lookup"><span data-stu-id="5e7e7-134">Require admin/root privilege</span></span>|<span data-ttu-id="5e7e7-135">Nein</span><span class="sxs-lookup"><span data-stu-id="5e7e7-135">No</span></span>|<span data-ttu-id="5e7e7-136">Ja</span><span class="sxs-lookup"><span data-stu-id="5e7e7-136">Yes</span></span>|<span data-ttu-id="5e7e7-137">Ja</span><span class="sxs-lookup"><span data-stu-id="5e7e7-137">Yes</span></span>|
|<span data-ttu-id="5e7e7-138">Abrufen von Betriebssystem- oder Kernelereignissen</span><span class="sxs-lookup"><span data-stu-id="5e7e7-138">Can get OS/kernel events</span></span>|<span data-ttu-id="5e7e7-139">Nein</span><span class="sxs-lookup"><span data-stu-id="5e7e7-139">No</span></span>|<span data-ttu-id="5e7e7-140">Ja</span><span class="sxs-lookup"><span data-stu-id="5e7e7-140">Yes</span></span>|<span data-ttu-id="5e7e7-141">Ja</span><span class="sxs-lookup"><span data-stu-id="5e7e7-141">Yes</span></span>|
|<span data-ttu-id="5e7e7-142">Auflösen nativer Aufruflisten</span><span class="sxs-lookup"><span data-stu-id="5e7e7-142">Can resolve native callstacks</span></span>|<span data-ttu-id="5e7e7-143">Nein</span><span class="sxs-lookup"><span data-stu-id="5e7e7-143">No</span></span>|<span data-ttu-id="5e7e7-144">Ja</span><span class="sxs-lookup"><span data-stu-id="5e7e7-144">Yes</span></span>|<span data-ttu-id="5e7e7-145">Ja</span><span class="sxs-lookup"><span data-stu-id="5e7e7-145">Yes</span></span>|

## <a name="use-eventpipe-to-trace-your-net-application"></a><span data-ttu-id="5e7e7-146">Verwenden von EventPipe zum Nachverfolgen der .NET-Anwendung</span><span class="sxs-lookup"><span data-stu-id="5e7e7-146">Use EventPipe to trace your .NET application</span></span>

<span data-ttu-id="5e7e7-147">Sie können EventPipe verwenden, um Ihre .NET-Anwendung auf unterschiedlichste Weise nachzuverfolgen:</span><span class="sxs-lookup"><span data-stu-id="5e7e7-147">You can use EventPipe to trace your .NET application in many ways:</span></span>

* <span data-ttu-id="5e7e7-148">Verwenden Sie eines der [Diagnosetools](#tools-that-use-eventpipe), die auf EventPipe basieren.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-148">Use one of the [diagnostics tools](#tools-that-use-eventpipe) that are built on top of EventPipe.</span></span>

* <span data-ttu-id="5e7e7-149">Verwenden Sie die [Microsoft.Diagnostics.NETCore.Client](https://github.com/dotnet/diagnostics/blob/master/documentation/diagnostics-client-library-instructions.md)-Bibliothek, um Ihr eigenes Tool zum Konfigurieren und Starten von EventPipe-Sitzungen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-149">Use [Microsoft.Diagnostics.NETCore.Client](https://github.com/dotnet/diagnostics/blob/master/documentation/diagnostics-client-library-instructions.md) library to write your own tool to configure and start EventPipe sessions yourself.</span></span>

* <span data-ttu-id="5e7e7-150">Verwenden Sie [Umgebungsvariablen](#trace-using-environment-variables) zum Starten von EventPipe.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-150">Use [environment variables](#trace-using-environment-variables) to start EventPipe.</span></span>

<span data-ttu-id="5e7e7-151">Nachdem Sie eine `nettrace`-Datei erstellt haben, die Ihre EventPipe-Ereignisse enthält, können Sie die Datei in [`PerfView`](https://github.com/Microsoft/perfview#perfview-overview) oder Visual Studio anzeigen.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-151">After you've produced a `nettrace` file that contains your EventPipe events, you can view the file in [`PerfView`](https://github.com/Microsoft/perfview#perfview-overview) or Visual Studio.</span></span> <span data-ttu-id="5e7e7-152">Auf Nicht-Windows-Plattformen können Sie die `nettrace`-Datei mithilfe des Befehls [`dotnet-trace convert`](./dotnet-trace.md#dotnet-trace-convert) in das `speedscope`- oder `Chromium`-Ablaufverfolgungsformat konvertieren und mit [`speedscope`](https://www.speedscope.app/) oder Chrome DevTools anzeigen.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-152">On non-Windows platforms, you can convert the `nettrace` file to a `speedscope` or `Chromium` trace format by using [`dotnet-trace convert`](./dotnet-trace.md#dotnet-trace-convert) command and view it with [`speedscope`](https://www.speedscope.app/) or Chrome DevTools.</span></span>

<span data-ttu-id="5e7e7-153">Sie können EventPipe-Ablaufnachverfolgungen mit [TraceEvent](https://github.com/Microsoft/perfview/blob/master/documentation/TraceEvent/TraceEventLibrary.md) auch programmgesteuert analysieren.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-153">You can also analyze EventPipe traces programmatically with [TraceEvent](https://github.com/Microsoft/perfview/blob/master/documentation/TraceEvent/TraceEventLibrary.md).</span></span>

### <a name="tools-that-use-eventpipe"></a><span data-ttu-id="5e7e7-154">Tools, die EventPipe verwenden</span><span class="sxs-lookup"><span data-stu-id="5e7e7-154">Tools that use EventPipe</span></span>

<span data-ttu-id="5e7e7-155">Dies ist die einfachste Möglichkeit, EventPipe zum Nachverfolgen Ihrer Anwendung zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-155">This is the easiest way to use EventPipe to trace your application.</span></span> <span data-ttu-id="5e7e7-156">Weitere Informationen zur Verwendung dieser Tools finden Sie in der Dokumentation zu den einzelnen Tools.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-156">To learn more about how to use each of these tools, refer to each tool's documentation.</span></span>

* <span data-ttu-id="5e7e7-157">[dotnet-counters](./dotnet-counters.md) ermöglicht Ihnen das Überwachen und Erfassen von verschiedenen Metriken, die von der .NET-Runtime und Kernbibliotheken ausgegeben werden. Dies ist ebenfalls für benutzerdefinierte Metriken möglich, die Sie selbst schreiben.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-157">[dotnet-counters](./dotnet-counters.md) lets you monitor and collect various metrics emitted by the .NET runtime and core libraries, as well as custom metrics you can write.</span></span>

* <span data-ttu-id="5e7e7-158">Mit [dotnet-gcdump](./dotnet-gcdump.md) können Sie GC-Heapspeicherabbilder von Liveprozessen erfassen, um den verwalteten Heap einer Anwendung zu analysieren.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-158">[dotnet-gcdump](./dotnet-gcdump.md) lets you collect GC heap dumps of live processes for analyzing an application's managed heap.</span></span>

* <span data-ttu-id="5e7e7-159">[dotnet-trace](./dotnet-trace.md) ermöglicht das Erfassen von Ablaufnachverfolgungen von Anwendungen, um die Leistung zu analysieren.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-159">[dotnet-trace](./dotnet-trace.md) lets you collect traces of applications to analyze for performance.</span></span>

## <a name="trace-using-environment-variables"></a><span data-ttu-id="5e7e7-160">Ablaufverfolgung mithilfe von Umgebungsvariablen</span><span class="sxs-lookup"><span data-stu-id="5e7e7-160">Trace using environment variables</span></span>

<span data-ttu-id="5e7e7-161">Der bevorzugte Mechanismus für die Verwendung von EventPipe ist die Verwendung der Bibliothek `dotnet-trace` oder `Microsoft.Diagnostics.NETCore.Client`.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-161">The preferred mechanism for using EventPipe is to use `dotnet-trace` or the `Microsoft.Diagnostics.NETCore.Client` library.</span></span>

<span data-ttu-id="5e7e7-162">Sie können jedoch die folgenden Umgebungsvariablen verwenden, um eine EventPipe-Sitzung für eine App einzurichten und die Ablaufverfolgung direkt in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-162">However, you can use the following environment variables to set up an EventPipe session on an app and have it write the trace directly to a file.</span></span> <span data-ttu-id="5e7e7-163">Beenden Sie die Anwendung, um die Ablaufverfolgung zu beenden.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-163">To stop tracing, exit the application.</span></span>

* <span data-ttu-id="5e7e7-164">`COMPlus_EnableEventPipe`: Legen Sie diese Umgebungsvariable auf `1` fest, um eine EventPipe-Sitzung zu starten, die die Ablaufverfolgung direkt in eine Datei schreibt.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-164">`COMPlus_EnableEventPipe`: Set this to `1` to start an EventPipe session that writes directly to a file.</span></span> <span data-ttu-id="5e7e7-165">Der Standardwert ist `0`.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-165">The default value is `0`.</span></span>

* <span data-ttu-id="5e7e7-166">`COMPlus_EventPipeOutputPath`: Dies ist der Pfad zur ausgegebenen EventPipe-Ablaufverfolgungsdatei, wenn diese für die Ausführung über `COMPlus_EnableEventPipe` konfiguriert ist.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-166">`COMPlus_EventPipeOutputPath`: The path to the output EventPipe trace file when it's configured to run via `COMPlus_EnableEventPipe`.</span></span> <span data-ttu-id="5e7e7-167">Der Standardwert ist `trace.nettrace`, der in demselben Verzeichnis erstellt wird, über das die App ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-167">The default value is `trace.nettrace`, which will be created in the same directory that the app is running from.</span></span>

* <span data-ttu-id="5e7e7-168">`COMPlus_CircularBufferMB`: Dies ist die Größe des von EventPipe verwendeten internen Puffers, wenn eine Ausführung über `COMPlus_EnableEventPipe` konfiguriert ist.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-168">`COMPlus_CircularBufferMB`: The size of the internal buffer that is used by EventPipe when it's configured to run via `COMPlus_EnableEventPipe`.</span></span>

* <span data-ttu-id="5e7e7-169">`COMPlus_EventPipeConfig`: Hiermit wird die EventPipe-Sitzungskonfiguration eingerichtet, wenn eine EventPipe-Sitzung mit `COMPlus_EnableEventPipe` gestartet wird.</span><span class="sxs-lookup"><span data-stu-id="5e7e7-169">`COMPlus_EventPipeConfig`: Sets up the EventPipe session configuration when starting an EventPipe session with `COMPlus_EnableEventPipe`.</span></span>

  <span data-ttu-id="5e7e7-170">Die Syntax ist wie folgt:</span><span class="sxs-lookup"><span data-stu-id="5e7e7-170">The syntax is as follows:</span></span>

  `<provider>:<keyword>:<level>`

  <span data-ttu-id="5e7e7-171">Sie können auch mehrere Anbieter angeben, indem Sie sie mit einem Komma verketten:</span><span class="sxs-lookup"><span data-stu-id="5e7e7-171">You can also specify multiple providers by concatenating them with a comma:</span></span>

  `<provider1>:<keyword1>:<level1>,<provider2>:<keyword2>:<level2>`

  <span data-ttu-id="5e7e7-172">Wenn diese Umgebungsvariable nicht festgelegt ist, EventPipe aber durch `COMPlus_EnableEventPipe` aktiviert wird, wird die Ablaufverfolgung gestartet, indem die folgenden Anbieter mit den folgenden Schlüsselwörtern und Ebenen aktiviert werden:</span><span class="sxs-lookup"><span data-stu-id="5e7e7-172">If this environment variable is not set but EventPipe is enabled by `COMPlus_EnableEventPipe`, it will start tracing by enabling the following providers with the following keywords and levels:</span></span>

  - `Microsoft-Windows-DotNETRuntime:4c14fccbd:5`
  - `Microsoft-Windows-DotNETRuntimePrivate:4002000b:5`
  - `Microsoft-DotNETCore-SampleProfiler:0:5`
