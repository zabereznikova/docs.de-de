---
title: EventCounters in .NET Core
description: In diesem Artikel erfahren Sie, was EventCounters sind, wie Sie diese implementieren und wie Sie sie nutzen können.
ms.date: 08/07/2020
ms.openlocfilehash: 08180b5580d2e7fe782fbd531a26872715825cdf
ms.sourcegitcommit: 4b79862c5b41fbd86cf38f926f6a49516059f6f2
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 12/18/2020
ms.locfileid: "97678200"
---
# <a name="eventcounters-in-net-core"></a><span data-ttu-id="91179-103">EventCounters in .NET Core</span><span class="sxs-lookup"><span data-stu-id="91179-103">EventCounters in .NET Core</span></span>

<span data-ttu-id="91179-104">**Dieser Artikel gilt für:** ✔️ .NET Core 3.0 SDK und neuere Versionen</span><span class="sxs-lookup"><span data-stu-id="91179-104">**This article applies to: ✔️** .NET Core 3.0 SDK and later versions</span></span>

<span data-ttu-id="91179-105">EventCounters sind .NET Core-APIs, die für eine schlanke und plattformübergreifende Leistungsmetriksammlung nahezu in Echtzeit verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="91179-105">EventCounters are .NET Core APIs used for lightweight, cross-platform, and near real-time performance metric collection.</span></span> <span data-ttu-id="91179-106">EventCounters wurden als plattformübergreifende Alternative zu den „Leistungsindikatoren“ von .NET Framework unter Windows hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="91179-106">EventCounters were added as a cross-platform alternative to the "performance counters" of the .NET Framework on Windows.</span></span> <span data-ttu-id="91179-107">In diesem Artikel erfahren Sie, was EventCounters sind, wie Sie diese implementieren und wie Sie sie nutzen können.</span><span class="sxs-lookup"><span data-stu-id="91179-107">In this article you'll learn what EventCounters are, how to implement them, and how to consume them.</span></span>

<span data-ttu-id="91179-108">Die .NET Core-Laufzeit und einige .NET-Bibliotheken veröffentlichen grundlegende Diagnoseinformationen mithilfe von EventCounters ab .NET Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="91179-108">The .NET Core runtime and a few .NET libraries publish basic diagnostics information using EventCounters starting in .NET Core 3.0.</span></span> <span data-ttu-id="91179-109">Abgesehen von den EventCounters, die von der .NET-Laufzeit bereitgestellt werden, können Sie auch Ihre eigenen EventCounters implementieren.</span><span class="sxs-lookup"><span data-stu-id="91179-109">Apart from the EventCounters that are provided by the .NET runtime, you may choose to implement your own EventCounters.</span></span> <span data-ttu-id="91179-110">EventCounters kann zum Nachverfolgen verschiedener Metriken verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="91179-110">EventCounters can be used to track various metrics.</span></span> <span data-ttu-id="91179-111">Weitere Informationen finden Sie unter [Bekannte EventCounters in .NET](available-counters.md).</span><span class="sxs-lookup"><span data-stu-id="91179-111">Learn more about them in the [well-known EventCounters in .NET](available-counters.md)</span></span>

<span data-ttu-id="91179-112">EventCounters sind Teil einer <xref:System.Diagnostics.Tracing.EventSource> und werden in regelmäßigen Abständen automatisch an Listenertools übermittelt.</span><span class="sxs-lookup"><span data-stu-id="91179-112">EventCounters live as a part of an <xref:System.Diagnostics.Tracing.EventSource>, and are automatically pushed to listener tools on a regular basis.</span></span> <span data-ttu-id="91179-113">Wie alle anderen Ereignisse für eine <xref:System.Diagnostics.Tracing.EventSource> können sie sowohl prozessintern als auch prozessextern über <xref:System.Diagnostics.Tracing.EventListener> und [EventPipe](./eventpipe.md) genutzt werden.</span><span class="sxs-lookup"><span data-stu-id="91179-113">Like all other events on an <xref:System.Diagnostics.Tracing.EventSource>, they can be consumed both in-proc and out-of-proc via <xref:System.Diagnostics.Tracing.EventListener> and [EventPipe](./eventpipe.md).</span></span> <span data-ttu-id="91179-114">Dieser Artikel konzentriert sich auf die plattformübergreifenden Funktionen von EventCounters und schließt PerfView und ETW (Event Tracing for Windows, Ereignisablaufverfolgung für Windows) bewusst aus, obwohl beides mit EventCounters verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="91179-114">This article focuses on the cross-platform capabilities of EventCounters, and intentionally excludes PerfView and ETW (Event Tracing for Windows) - although both can be used with EventCounters.</span></span>

![Abbildung zu EventCounters in-process und out-of-process](media/event-counters.svg)

## <a name="eventcounter-api-overview"></a><span data-ttu-id="91179-116">Übersicht über die EventCounter-API</span><span class="sxs-lookup"><span data-stu-id="91179-116">EventCounter API overview</span></span>

<span data-ttu-id="91179-117">Es gibt zwei Hauptkategorien von Leistungsindikatoren.</span><span class="sxs-lookup"><span data-stu-id="91179-117">There are two primary categories of counters.</span></span> <span data-ttu-id="91179-118">Einige Leistungsindikatoren beziehen sich auf „Ratenwerte“, etwa auf die Gesamtzahl der Ausnahmen, die Gesamtzahl der GCs und die Gesamtzahl der Anforderungen.</span><span class="sxs-lookup"><span data-stu-id="91179-118">Some counters are for "rate" values, such as total number of exceptions, total number of GCs, and total number of requests.</span></span> <span data-ttu-id="91179-119">Andere Leistungsindikatoren sind „Momentaufnahmewerte“, z. B. Heapverwendung, CPU-Auslastung und Arbeitssatzgröße.</span><span class="sxs-lookup"><span data-stu-id="91179-119">Other counters are "snapshot" values, such as heap usage, CPU usage, and working set size.</span></span> <span data-ttu-id="91179-120">Innerhalb jeder dieser Kategorien von Indikatoren gibt es zwei Arten von Indikatoren, die sich dadurch unterscheiden, wie sie ihren Wert ermitteln.</span><span class="sxs-lookup"><span data-stu-id="91179-120">Within each of these categories of counters, there are two types of counters that vary by how they get their value.</span></span> <span data-ttu-id="91179-121">Abrufindikatoren erhalten ihren Wert über einen Rückruf, und bei nicht abrufenden Indikatoren wird der Wert direkt für die Instanz des Indikators festgelegt.</span><span class="sxs-lookup"><span data-stu-id="91179-121">Polling counters retrieve their value via a callback, and non-polling counters have their values directly set on the counter instance.</span></span>

<span data-ttu-id="91179-122">Die Indikatoren werden durch die folgenden Implementierungen dargestellt:</span><span class="sxs-lookup"><span data-stu-id="91179-122">The counters are represented by the following implementations:</span></span>

* <xref:System.Diagnostics.Tracing.EventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingEventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>
* <xref:System.Diagnostics.Tracing.PollingCounter>

<span data-ttu-id="91179-123">Ein Ereignislistener gibt an, wie lang Messintervalle sind.</span><span class="sxs-lookup"><span data-stu-id="91179-123">An event listener specifies how long measurement intervals are.</span></span> <span data-ttu-id="91179-124">Am Ende jedes Intervalls wird ein Wert an den Listener für jeden Indikator übermittelt.</span><span class="sxs-lookup"><span data-stu-id="91179-124">At the end of each interval a value is transmitted to the listener for each counter.</span></span> <span data-ttu-id="91179-125">Die Implementierungen eines Indikators bestimmen, welche APIs und Berechnungen verwendet werden, um den Wert für jedes Intervall zu generieren.</span><span class="sxs-lookup"><span data-stu-id="91179-125">The implementations of a counter determine what APIs and calculations are used to produce the value each interval.</span></span>

1. <span data-ttu-id="91179-126"><xref:System.Diagnostics.Tracing.EventCounter> zeichnet einen Satz von Werten auf.</span><span class="sxs-lookup"><span data-stu-id="91179-126">The <xref:System.Diagnostics.Tracing.EventCounter> records a set of values.</span></span> <span data-ttu-id="91179-127">Die <xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType>-Methode fügt dem Satz einen neuen Wert hinzu.</span><span class="sxs-lookup"><span data-stu-id="91179-127">The <xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType> method adds a new value to the set.</span></span> <span data-ttu-id="91179-128">Mit jedem Intervall wird eine statistische Zusammenfassung für den Satz berechnet, z. B. Mindestwert, Maximalwert und Mittelwert.</span><span class="sxs-lookup"><span data-stu-id="91179-128">With each interval, a statistical summary for the set is computed, such as the min, max, and mean.</span></span> <span data-ttu-id="91179-129">Das Tool [dotnet-counters](dotnet-counters.md) zeigt immer den Mittelwert an.</span><span class="sxs-lookup"><span data-stu-id="91179-129">The [dotnet-counters](dotnet-counters.md) tool will always display the mean value.</span></span> <span data-ttu-id="91179-130"><xref:System.Diagnostics.Tracing.EventCounter> ist nützlich, um einen diskreten Satz von Vorgängen zu beschreiben.</span><span class="sxs-lookup"><span data-stu-id="91179-130">The <xref:System.Diagnostics.Tracing.EventCounter> is useful to describe a discrete set of operations.</span></span> <span data-ttu-id="91179-131">Zu den üblichen Verwendungszwecken kann die Überwachung der durchschnittlichen Größe der jüngsten E/A-Vorgänge in Bytes oder des durchschnittlichen Geldwerts einer Reihe von Finanztransaktionen gehören.</span><span class="sxs-lookup"><span data-stu-id="91179-131">Common usage may include monitoring the average size in bytes of recent IO operations, or the average monetary value of a set of financial transactions.</span></span>

1. <span data-ttu-id="91179-132"><xref:System.Diagnostics.Tracing.IncrementingEventCounter> zeichnet eine laufende Summe für jedes Zeitintervall auf.</span><span class="sxs-lookup"><span data-stu-id="91179-132">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> records a running total for each time interval.</span></span> <span data-ttu-id="91179-133">Die <xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType>-Methode fügt der Summe Werte hinzu.</span><span class="sxs-lookup"><span data-stu-id="91179-133">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType> method adds to the total.</span></span> <span data-ttu-id="91179-134">Wenn `Increment()` z. B. drei Mal während eines Intervalls mit den Werten `1`, `2` und `5` aufgerufen wird, wird die laufende Summe von `8` als Indikatorwert für dieses Intervall gemeldet.</span><span class="sxs-lookup"><span data-stu-id="91179-134">For example, if `Increment()` is called three times during one interval with values `1`, `2`, and `5`, then the running total of `8` will be reported as the counter value for this interval.</span></span> <span data-ttu-id="91179-135">Mit dem Tool [dotnet-counters](dotnet-counters.md) wird die Rate als die aufgezeichnete Summe/Zeit angezeigt.</span><span class="sxs-lookup"><span data-stu-id="91179-135">The [dotnet-counters](dotnet-counters.md) tool will display the rate as the recorded total / time.</span></span> <span data-ttu-id="91179-136"><xref:System.Diagnostics.Tracing.IncrementingEventCounter> ist hilfreich, um zu messen, wie häufig eine Aktion ausgeführt wird, z. B. die Anzahl der pro Sekunde verarbeiteten Anforderungen.</span><span class="sxs-lookup"><span data-stu-id="91179-136">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> is useful to measure how frequently an action is occurring, such as the number of requests processed per second.</span></span>

1. <span data-ttu-id="91179-137"><xref:System.Diagnostics.Tracing.PollingCounter> verwendet einen Rückruf, um den Wert zu bestimmen, der gemeldet wird.</span><span class="sxs-lookup"><span data-stu-id="91179-137">The <xref:System.Diagnostics.Tracing.PollingCounter> uses a callback to determine the value that is reported.</span></span> <span data-ttu-id="91179-138">Bei jedem Zeitintervall wird die vom Benutzer bereitgestellte Rückruffunktion aufgerufen, und der Rückgabewert wird als Indikatorwert verwendet.</span><span class="sxs-lookup"><span data-stu-id="91179-138">With each time interval, the user provided callback function is invoked and the return value is used as the counter value.</span></span> <span data-ttu-id="91179-139"><xref:System.Diagnostics.Tracing.PollingCounter> kann verwendet werden, um eine Metrik aus einer externen Quelle abzufragen, z. B. zum Abrufen der aktuellen freien Bytes auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="91179-139">A <xref:System.Diagnostics.Tracing.PollingCounter> can be used to query a metric from an external source, for example getting the current free bytes on a disk.</span></span> <span data-ttu-id="91179-140">Der Indikator kann auch verwendet werden, um benutzerdefinierte Statistiken aufzuzeichnen, die bei Bedarf von einer Anwendung berechnet werden können.</span><span class="sxs-lookup"><span data-stu-id="91179-140">It can also be used to report custom statistics that can be computed on demand by an application.</span></span> <span data-ttu-id="91179-141">Beispiele hierfür sind Angaben zum 95. Perzentil der aktuellen Anforderungslatenz oder die aktuelle Treffer- oder Fehlquote eines Caches.</span><span class="sxs-lookup"><span data-stu-id="91179-141">Examples include reporting the 95th percentile of recent request latencies, or the current hit or miss ratio of a cache.</span></span>

1. <span data-ttu-id="91179-142"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter> verwendet einen Rückruf, um den gemeldeten Inkrementwert zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="91179-142">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses a callback to determine the reported increment value.</span></span> <span data-ttu-id="91179-143">In jedem Zeitintervall wird der Rückruf aufgerufen, dann wird die Differenz zwischen dem aktuellen Aufruf und dem letzten Aufruf als gemeldeter Wert verwendet.</span><span class="sxs-lookup"><span data-stu-id="91179-143">With each time interval, the callback is invoked, and then the difference between the current invocation, and the last invocation is the reported value.</span></span> <span data-ttu-id="91179-144">Das Tool [dotnet-counters](dotnet-counters.md) zeigt die Differenz immer als Rate an, als aufgezeichneten Wert bzw. als Zeit.</span><span class="sxs-lookup"><span data-stu-id="91179-144">The [dotnet-counters](dotnet-counters.md) tool will always display the difference as a rate, the reported value / time.</span></span> <span data-ttu-id="91179-145">Dieser Indikator ist nützlich, wenn es nicht praktikabel ist, eine API für jedes Vorkommen aufzurufen, aber die Möglichkeit besteht, die Gesamtzahl der Vorkommen abzufragen.</span><span class="sxs-lookup"><span data-stu-id="91179-145">This counter is useful when it isn't feasible to call an API on each occurrence, but it's possible to query the total number of occurrences.</span></span> <span data-ttu-id="91179-146">Sie könnten z. B. die Anzahl der pro Sekunde in eine Datei geschriebenen Bytes aufzeichnen, auch ohne Benachrichtigung bei jedem Schreiben eines Bytes.</span><span class="sxs-lookup"><span data-stu-id="91179-146">For example, you could report the number of bytes written to a file per second, even without a notification each time a byte is written.</span></span>

## <a name="implement-an-eventsource"></a><span data-ttu-id="91179-147">Implementieren einer EventSource</span><span class="sxs-lookup"><span data-stu-id="91179-147">Implement an EventSource</span></span>

<span data-ttu-id="91179-148">Der folgende Code implementiert eine Beispiel-<xref:System.Diagnostics.Tracing.EventSource>, die als benannter `"Sample.EventCounter.Minimal"`-Anbieter zur Verfügung gestellt wird.</span><span class="sxs-lookup"><span data-stu-id="91179-148">The following code implements a sample <xref:System.Diagnostics.Tracing.EventSource> exposed as the named `"Sample.EventCounter.Minimal"` provider.</span></span> <span data-ttu-id="91179-149">Diese Quelle enthält ein <xref:System.Diagnostics.Tracing.EventCounter>-Element,das die Anforderungsverarbeitungszeit darstellt.</span><span class="sxs-lookup"><span data-stu-id="91179-149">This source contains an <xref:System.Diagnostics.Tracing.EventCounter> representing request processing time.</span></span> <span data-ttu-id="91179-150">Ein solcher Indikator besitzt einen Namen (d. h. seine eindeutige ID in der Quelle) und einen Anzeigenamen. Beides wird von Listenertools wie [dotnet-counter](dotnet-counters.md) verwendet.</span><span class="sxs-lookup"><span data-stu-id="91179-150">Such a counter has a name (that is, its unique ID in the source) and a display name, both used by listener tools such as [dotnet-counter](dotnet-counters.md).</span></span>

:::code language="csharp" source="snippets/EventCounters/MinimalEventCounterSource.cs":::

<span data-ttu-id="91179-151">Sie verwenden `dotnet-counters ps`, um eine Liste der .NET-Prozesse anzuzeigen, die überwacht werden können:</span><span class="sxs-lookup"><span data-stu-id="91179-151">You use `dotnet-counters ps` to display a list of .NET processes that can be monitored:</span></span>

```console
dotnet-counters ps
   1398652 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399072 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399112 dotnet     C:\Program Files\dotnet\dotnet.exe
   1401880 dotnet     C:\Program Files\dotnet\dotnet.exe
   1400180 sample-counters C:\sample-counters\bin\Debug\netcoreapp3.1\sample-counters.exe
```

<span data-ttu-id="91179-152">Übergeben Sie den <xref:System.Diagnostics.Tracing.EventSource>-Namen an die `--counters`-Option, um die Überwachung des Indikators zu starten:</span><span class="sxs-lookup"><span data-stu-id="91179-152">Pass the <xref:System.Diagnostics.Tracing.EventSource> name to the `--counters` option to start monitoring your counter:</span></span>

```console
dotnet-counters monitor --process-id 1400180 --counters Sample.EventCounter.Minimal
```

<span data-ttu-id="91179-153">Das folgende Beispiel zeigt die Überwachunsausgabe:</span><span class="sxs-lookup"><span data-stu-id="91179-153">The following example shows monitor output:</span></span>

```console
Press p to pause, r to resume, q to quit.
    Status: Running

[Samples-EventCounterDemos-Minimal]
    Request Processing Time (ms)                            0.445
```

<span data-ttu-id="91179-154">Drücken Sie <kbd>q</kbd>, um den Überwachungsbefehl zu beenden.</span><span class="sxs-lookup"><span data-stu-id="91179-154">Press <kbd>q</kbd> to stop the monitoring command.</span></span>

#### <a name="conditional-counters"></a><span data-ttu-id="91179-155">Bedingte Indikatoren</span><span class="sxs-lookup"><span data-stu-id="91179-155">Conditional counters</span></span>

<span data-ttu-id="91179-156">Beim Implementieren einer <xref:System.Diagnostics.Tracing.EventSource>können die enthaltenen Leistungsindikatoren bedingt instanziiert werden, wenn die <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType>-Methode mit dem Wert <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> für `EventCommand.Enable` aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="91179-156">When implementing an <xref:System.Diagnostics.Tracing.EventSource>, the containing counters can be conditionally instantiated when the <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> method is called with a <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> value of `EventCommand.Enable`.</span></span> <span data-ttu-id="91179-157">Um eine Indikatorinstanz nur dann sicher zu instanziieren, wenn sie `null` ist, verwenden Sie den [NULL-Sammeloperator](../../csharp/language-reference/operators/null-coalescing-operator.md).</span><span class="sxs-lookup"><span data-stu-id="91179-157">To safely instantiate a counter instance only if it is `null`, use the [null-coalescing assignment operator](../../csharp/language-reference/operators/null-coalescing-operator.md).</span></span> <span data-ttu-id="91179-158">Darüber hinaus können benutzerdefinierte Methoden die <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A>-Methode auswerten, um zu bestimmen, ob die aktuelle Ereignisquelle aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="91179-158">Additionally, custom methods can evaluate the <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> method to determine whether or not the current event source is enabled.</span></span>

:::code language="csharp" source="snippets/EventCounters/ConditionalEventCounterSource.cs":::

> [!TIP]
> <span data-ttu-id="91179-159">Bedingte Indikatoren sind Leistungsindikatoren, die bedingt instanziiert werden: eine Mikrooptimierung.</span><span class="sxs-lookup"><span data-stu-id="91179-159">Conditional counters are counters that are conditionally instantiated, a micro-optimization.</span></span> <span data-ttu-id="91179-160">Die Laufzeit übernimmt dieses Muster für Szenarien, in denen normalerweise keine Leistungsindikatoren verwendet werden, um den Bruchteil einer Millisekunde einzusparen.</span><span class="sxs-lookup"><span data-stu-id="91179-160">The runtime adopts this pattern for scenarios where counters are normally not used, to save a fraction of a millisecond.</span></span>

### <a name="net-core-runtime-example-counters"></a><span data-ttu-id="91179-161">Beispielindikatoren für die .NET Core-Laufzeit</span><span class="sxs-lookup"><span data-stu-id="91179-161">.NET Core runtime example counters</span></span>

<span data-ttu-id="91179-162">Es gibt viele hervorragende Beispielimplementierungen in der .NET Core-Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="91179-162">There are many great example implementations in the .NET Core runtime.</span></span> <span data-ttu-id="91179-163">Hier sehen Sie die Laufzeitimplementierung für den Leistungsindikator, der die Größe des Arbeitssatzes der Anwendung nachverfolgt.</span><span class="sxs-lookup"><span data-stu-id="91179-163">Here is the runtime implementation for the counter that tracks the working set size of the application.</span></span>

```csharp
var workingSetCounter = new PollingCounter(
    "working-set",
    this,
    () => (double)(Environment.WorkingSet / 1_000_000))
{
    DisplayName = "Working Set",
    DisplayUnits = "MB"
};
```

<span data-ttu-id="91179-164"><xref:System.Diagnostics.Tracing.PollingCounter> meldet die aktuelle Menge an physischem Arbeitsspeicher, der dem Prozess (Arbeitssatz) der App zugeordnet ist, da eine Metrik zu einem bestimmten Zeitpunkt erfasst wird.</span><span class="sxs-lookup"><span data-stu-id="91179-164">The <xref:System.Diagnostics.Tracing.PollingCounter> reports the current amount of physical memory mapped to the process (working set) of the app, since it captures a metric at a moment in time.</span></span> <span data-ttu-id="91179-165">Der Rückruf zum Abrufen eines Werts ist der bereitgestellte Lambdaausdruck, bei dem es sich nur um einen Aufrufs der <xref:System.Environment.WorkingSet?displayProperty=fullName>-API handelt.</span><span class="sxs-lookup"><span data-stu-id="91179-165">The callback for polling a value is the provided lambda expression, which is just a call to the <xref:System.Environment.WorkingSet?displayProperty=fullName> API.</span></span> <span data-ttu-id="91179-166"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> und <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> sind optionale Eigenschaften, die festgelegt werden können, um der Consumerseite des Indikators zu helfen, den Wert deutlicher anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="91179-166"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> and <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> are optional properties that can be set to help the consumer side of the counter to display the value more clearly.</span></span> <span data-ttu-id="91179-167">Beispielsweise werden diese Eigenschaften von [dotnet-counters](dotnet-counters.md) zum Anzeigen der anzeigefreundlicheren Version der Indikatornamen verwendet.</span><span class="sxs-lookup"><span data-stu-id="91179-167">For example, [dotnet-counters](dotnet-counters.md) uses these properties to display the more display-friendly version of the counter names.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="91179-168">Die `DisplayName`-Eigenschaften sind nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="91179-168">The `DisplayName` properties are not localized.</span></span>

<span data-ttu-id="91179-169">Für <xref:System.Diagnostics.Tracing.PollingCounter> und <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> sind keine weiteren Aktionen erforderlich.</span><span class="sxs-lookup"><span data-stu-id="91179-169">For the <xref:System.Diagnostics.Tracing.PollingCounter>, and the <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>, nothing else needs to be done.</span></span> <span data-ttu-id="91179-170">Beide Indikatoren fragen die Werte selbst in einem vom Consumer angeforderten Intervall ab.</span><span class="sxs-lookup"><span data-stu-id="91179-170">They both poll the values themselves at an interval requested by the consumer.</span></span>

<span data-ttu-id="91179-171">Im Folgenden finden Sie ein Beispiel für einen mit <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> implementierten Laufzeitindikator.</span><span class="sxs-lookup"><span data-stu-id="91179-171">Here is an example of a runtime counter implemented using <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>.</span></span>

```csharp
var monitorContentionCounter = new IncrementingPollingCounter(
    "monitor-lock-contention-count",
    this,
    () => Monitor.LockContentionCount
)
{
    DisplayName = "Monitor Lock Contention Count",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

<span data-ttu-id="91179-172"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter> verwendet die <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType>-API, um das Inkrement der Gesamtzahl der Sperrkonflikte zu melden.</span><span class="sxs-lookup"><span data-stu-id="91179-172">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses the <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> API to report the increment of the total lock contention count.</span></span> <span data-ttu-id="91179-173">Die <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale>-Eigenschaft ist optional, aber wenn sie verwendet wird, kann Sie einen Hinweis darauf bereitstellen, in welchem Zeitintervall der Indikator am besten angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="91179-173">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> property is optional, but when used it can provide a hint for what time interval the counter is best displayed at.</span></span> <span data-ttu-id="91179-174">Beispielsweise wird die Anzahl der Sperrkonflikte am besten als _Anzahl pro Sekunde_ angezeigt, sodass deren <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> auf eine Sekunde festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="91179-174">For example, the lock contention count is best displayed as _count per second_, so its <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is set to one second.</span></span> <span data-ttu-id="91179-175">Die Anzeigerate kann für verschiedene Typen von Ratenindikatoren angepasst werden.</span><span class="sxs-lookup"><span data-stu-id="91179-175">The display rate can be adjusted for different types of rate counters.</span></span>

> [!NOTE]
> <span data-ttu-id="91179-176"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> wird _nicht_ von [dotnet-counters](dotnet-counters.md) verwendet, und Ereignislistener müssen den Indikator nicht verwenden.</span><span class="sxs-lookup"><span data-stu-id="91179-176">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is _not_ used by [dotnet-counters](dotnet-counters.md), and event listeners are not required to use it.</span></span>

<span data-ttu-id="91179-177">Es gibt weitere Indikatorimplementierungen im [.NET-Runtime](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs)-Repository, die als Referenz verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="91179-177">There are more counter implementations to use as a reference in the [.NET runtime](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs) repo.</span></span>

## <a name="concurrency"></a><span data-ttu-id="91179-178">Parallelität</span><span class="sxs-lookup"><span data-stu-id="91179-178">Concurrency</span></span>

> [!TIP]
> <span data-ttu-id="91179-179">Die EventCounters-API garantiert keine Threadsicherheit.</span><span class="sxs-lookup"><span data-stu-id="91179-179">The EventCounters API does not guarantee thread safety.</span></span> <span data-ttu-id="91179-180">Wenn die an <xref:System.Diagnostics.Tracing.PollingCounter>- oder <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>-Instanzen übergebenen Delegaten von mehreren Threads aufgerufen werden, liegt es in Ihrer Verantwortung, die Threadsicherheit der Delegaten zu gewährleisten.</span><span class="sxs-lookup"><span data-stu-id="91179-180">When the delegates passed to <xref:System.Diagnostics.Tracing.PollingCounter> or <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> instances are called by multiple threads, it's your responsibility to guarantee the delegates' thread-safety.</span></span>

<span data-ttu-id="91179-181">Ziehen Sie z. B. die folgende <xref:System.Diagnostics.Tracing.EventSource> in Betracht, um Anforderungen nachzuverfolgen.</span><span class="sxs-lookup"><span data-stu-id="91179-181">For example, consider the following <xref:System.Diagnostics.Tracing.EventSource> to keep track of requests.</span></span>

:::code language="csharp" source="snippets/EventCounters/RequestEventSource.cs":::

<span data-ttu-id="91179-182">Die `AddRequest()`-Methode kann aus einem Anforderungshandler aufgerufen werden, und `RequestRateCounter` fragt den Wert in dem Intervall ab, das vom Consumer des Indikators angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="91179-182">The `AddRequest()` method can be called from a request handler, and the `RequestRateCounter` polls the value at the interval specified by the consumer of the counter.</span></span> <span data-ttu-id="91179-183">Allerdings kann die `AddRequest()`-Methode von mehreren Threads gleichzeitig aufgerufen werden, wobei eine Racebedingung für `_requestCount` festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="91179-183">However, the `AddRequest()` method can be called by multiple threads at once, putting a race condition on `_requestCount`.</span></span> <span data-ttu-id="91179-184">Eine threadsichere alternative Möglichkeit, `_requestCount` zu inkrementieren, ist die Verwendung von <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="91179-184">A thread-safe alternative way to increment the `_requestCount` is to use <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType>.</span></span>

```csharp
public void AddRequest() => Interlocked.Increment(ref _requestCount);
```

<span data-ttu-id="91179-185">Zur Vermeidung unterbrochener Lesevorgänge (in 32-Bit-Architekturen) des `long`-Felds `_requestCount` verwenden Sie <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="91179-185">To prevent torn reads (on 32-bit architectures) of the `long`-field `_requestCount` use <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType>.</span></span>

```csharp
_requestRateCounter = new IncrementingPollingCounter("request-rate", this, () => Interlocked.Read(ref _requestCount))
{
    DisplayName = "Request Rate",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

## <a name="consume-eventcounters"></a><span data-ttu-id="91179-186">Nutzen von EventCounters</span><span class="sxs-lookup"><span data-stu-id="91179-186">Consume EventCounters</span></span>

<span data-ttu-id="91179-187">Es gibt zwei Hauptmethoden, um EventCounters in-process oder out-of-process zu nutzen.</span><span class="sxs-lookup"><span data-stu-id="91179-187">There are two primary ways of consuming EventCounters, either in-proc, or out-of-proc.</span></span> <span data-ttu-id="91179-188">Die Nutzung von EventCounters lässt sich in drei Ebenen von verschiedenen genutzten Technologien unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="91179-188">The consumption of EventCounters can be distinguished into three layers of various consuming technologies.</span></span>

- <span data-ttu-id="91179-189">Transportereignisse in einem Rohdatenstrom über ETW oder EventPipe:</span><span class="sxs-lookup"><span data-stu-id="91179-189">Transporting events in a raw stream via ETW or EventPipe:</span></span>
  - <span data-ttu-id="91179-190">ETW-APIs sind im Lieferumfang des Windows-Betriebssystems enthalten, und EventPipe ist als [.NET-API](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console) oder als diagnostisches [IPC-Protokoll](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md) verfügbar.</span><span class="sxs-lookup"><span data-stu-id="91179-190">ETW APIs come with the Windows OS, and EventPipe is accessible as a [.NET API](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console), or the diagnostic [IPC protocol](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md).</span></span>
- <span data-ttu-id="91179-191">Decodieren des binären Ereignisdatenstroms in Ereignisse:</span><span class="sxs-lookup"><span data-stu-id="91179-191">Decoding the binary event stream into events:</span></span>
  - <span data-ttu-id="91179-192">Die [TraceEvent-Bibliothek](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) verarbeitet sowohl das ETW- als auch das EventPipe-Streamformat.</span><span class="sxs-lookup"><span data-stu-id="91179-192">The [TraceEvent library](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) handles both ETW and EventPipe stream formats.</span></span>
- <span data-ttu-id="91179-193">Befehlszeilen- und GUI-Tools:</span><span class="sxs-lookup"><span data-stu-id="91179-193">Command-line and GUI tools:</span></span>
  - <span data-ttu-id="91179-194">Tools wie PerfView (ETW oder EventPipe), dotnet-counters (nur EventPipe) und dotnet-monitor (nur EventPipe).</span><span class="sxs-lookup"><span data-stu-id="91179-194">Tools like PerfView (ETW or EventPipe), dotnet-counters (EventPipe only), and dotnet-monitor (EventPipe only).</span></span>

### <a name="consume-out-of-proc"></a><span data-ttu-id="91179-195">Out-of-Process-Nutzung</span><span class="sxs-lookup"><span data-stu-id="91179-195">Consume out-of-proc</span></span>

<span data-ttu-id="91179-196">Die Out-of-Process-Nutzung von EventCounters ist ein sehr gängiger Ansatz.</span><span class="sxs-lookup"><span data-stu-id="91179-196">Consuming EventCounters out-of-proc is a very common approach.</span></span> <span data-ttu-id="91179-197">Sie können [dotnet-counters](dotnet-counters.md) verwenden, um die Indikatoren in plattformübergreifender Weise über eine EventPipe zu nutzen.</span><span class="sxs-lookup"><span data-stu-id="91179-197">You can use [dotnet-counters](dotnet-counters.md) to consume them in a cross-platform manner via an EventPipe.</span></span> <span data-ttu-id="91179-198">Das Tool `dotnet-counters` ist ein plattformübergreifendes globales CLI-Tool, das zum Überwachen der Indikatorwerte verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="91179-198">The `dotnet-counters` tool is a cross-platform dotnet CLI global tool that can be used to monitor the counter values.</span></span> <span data-ttu-id="91179-199">Informationen dazu, wie Sie `dotnet-counters` zum Überwachen Ihrer Leistungsindikatoren verwenden, finden Sie unter [dotnet-counters](dotnet-counters.md) oder im Tutorial [Messen der Leistung mithilfe von EventCounters](event-counter-perf.md).</span><span class="sxs-lookup"><span data-stu-id="91179-199">To find out how to use `dotnet-counters` to monitor your counters, see [dotnet-counters](dotnet-counters.md), or work through the [Measure performance using EventCounters](event-counter-perf.md) tutorial.</span></span>

#### <a name="dotnet-trace"></a><span data-ttu-id="91179-200">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="91179-200">dotnet-trace</span></span>

<span data-ttu-id="91179-201">Das Tool `dotnet-trace` kann verwendet werden, um die Indikatordaten über eine EventPipe zu nutzen.</span><span class="sxs-lookup"><span data-stu-id="91179-201">The `dotnet-trace` tool can be used to consume the counter data through an EventPipe.</span></span> <span data-ttu-id="91179-202">Im Folgenden finden Sie ein Beispiel für die Verwendung von `dotnet-trace` zum Erfassen von Indikatordaten.</span><span class="sxs-lookup"><span data-stu-id="91179-202">Here is an example using `dotnet-trace` to collect counter data.</span></span>

```console
dotnet-trace collect --process-id <pid> Sample.EventCounter.Minimal:0:0:EventCounterIntervalSec=1
```

<span data-ttu-id="91179-203">Weitere Informationen zum Erfassen von Indikatorwerten im Zeitverlauf finden Sie in der [dotnet-trace](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time)-Dokumentation.</span><span class="sxs-lookup"><span data-stu-id="91179-203">For more information on how to collect counter values over time, see the [dotnet-trace](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time) documentation.</span></span>

#### <a name="azure-application-insights"></a><span data-ttu-id="91179-204">Azure Application Insights</span><span class="sxs-lookup"><span data-stu-id="91179-204">Azure Application Insights</span></span>

<span data-ttu-id="91179-205">EventCounters können von Azure Monitor genutzt werden, insbesondere von Azure Application Insights.</span><span class="sxs-lookup"><span data-stu-id="91179-205">EventCounters can be consumed by Azure Monitor, specifically Azure Application Insights.</span></span> <span data-ttu-id="91179-206">Leistungsindikatoren können hinzugefügt und entfernt werden, und Sie können benutzerdefinierte oder bekannte Leistungsindikatoren angeben.</span><span class="sxs-lookup"><span data-stu-id="91179-206">Counters can be added and removed, and you're free to specify custom counters, or well-known counters.</span></span> <span data-ttu-id="91179-207">Weitere Informationen finden Sie unter [Anpassen der zu erfassenden Leistungsindikatoren](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span><span class="sxs-lookup"><span data-stu-id="91179-207">For more information, see [Customizing counters to be collected](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span></span>

#### <a name="dotnet-monitor"></a><span data-ttu-id="91179-208">dotnet-monitor</span><span class="sxs-lookup"><span data-stu-id="91179-208">dotnet-monitor</span></span>

<span data-ttu-id="91179-209">Das Tool `dotnet-monitor` ist ein experimentelles Tool, das den Zugriff auf Diagnoseinformationen in einem .NET-Prozess erleichtert.</span><span class="sxs-lookup"><span data-stu-id="91179-209">The `dotnet-monitor` tool is an experimental tool that makes it easier to get access to diagnostics information in a .NET process.</span></span> <span data-ttu-id="91179-210">Das Tool dient als Zusammenfassung aller Diagnosetools.</span><span class="sxs-lookup"><span data-stu-id="91179-210">The tool serves as a superset of all diagnostics tools.</span></span> <span data-ttu-id="91179-211">Neben der Stapelüberwachung kann es zum Überwachen von Metriken und zum Erfassen von Arbeitsspeicherabbildern und Garbage-Collection-Speicherabbildern verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="91179-211">In addition to traces, it can monitor metrics, collect memory dumps, and collect GC dumps.</span></span> <span data-ttu-id="91179-212">Das Tool wird sowohl als CLI-Tool als auch als Docker-Image bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="91179-212">It's distributed as both a CLI tool and a docker image.</span></span> <span data-ttu-id="91179-213">Es stellt eine REST-API zur Verfügung und die Sammlung von Diagnoseartefakten erfolgt über REST-Aufrufe.</span><span class="sxs-lookup"><span data-stu-id="91179-213">It exposes a REST API, and the collection of diagnostic artifacts occurs through REST calls.</span></span>

<span data-ttu-id="91179-214">Weitere Informationen finden Sie unter [Vorstellung von dotnet-monitor, einem experimentellen Tool](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span><span class="sxs-lookup"><span data-stu-id="91179-214">For more information, see [Introducing dotnet-monitor, an experimental tool](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span></span>

### <a name="consume-in-proc"></a><span data-ttu-id="91179-215">In-Process-Nutzung</span><span class="sxs-lookup"><span data-stu-id="91179-215">Consume in-proc</span></span>

<span data-ttu-id="91179-216">Sie können die Indikatorwerte über die <xref:System.Diagnostics.Tracing.EventListener>-API nutzen.</span><span class="sxs-lookup"><span data-stu-id="91179-216">You can consume the counter values via the <xref:System.Diagnostics.Tracing.EventListener> API.</span></span> <span data-ttu-id="91179-217">Ein <xref:System.Diagnostics.Tracing.EventListener> ist eine In-Process-Möglichkeit, alle Ereignisse zu nutzen, die von allen Instanzen einer <xref:System.Diagnostics.Tracing.EventSource> in der Anwendung geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="91179-217">An <xref:System.Diagnostics.Tracing.EventListener> is an in-proc way of consuming any events written by all instances of an <xref:System.Diagnostics.Tracing.EventSource> in your application.</span></span> <span data-ttu-id="91179-218">Weitere Informationen zur Verwendung der `EventListener`-API finden Sie unter <xref:System.Diagnostics.Tracing.EventListener>.</span><span class="sxs-lookup"><span data-stu-id="91179-218">For more information on how to use the `EventListener` API, see <xref:System.Diagnostics.Tracing.EventListener>.</span></span>

<span data-ttu-id="91179-219">Zuerst muss die <xref:System.Diagnostics.Tracing.EventSource>, die den Indikatorwert generiert, aktiviert werden.</span><span class="sxs-lookup"><span data-stu-id="91179-219">First, the <xref:System.Diagnostics.Tracing.EventSource> that produces the counter value needs to be enabled.</span></span> <span data-ttu-id="91179-220">Überschreiben Sie die <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType>-Methode, um eine Benachrichtigung zu erhalten, wenn eine <xref:System.Diagnostics.Tracing.EventSource> erstellt wird. Wenn dies die richtige <xref:System.Diagnostics.Tracing.EventSource> für Ihre EventCounters ist, können Sie dafür <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> aufrufen.</span><span class="sxs-lookup"><span data-stu-id="91179-220">Override the <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> method to get a notification when an <xref:System.Diagnostics.Tracing.EventSource> is created, and if this is the correct <xref:System.Diagnostics.Tracing.EventSource> with your EventCounters, then you can call <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> on it.</span></span> <span data-ttu-id="91179-221">Dies ist eine Beispielüberschreibung:</span><span class="sxs-lookup"><span data-stu-id="91179-221">Here is an example override:</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs" range="16-27":::

#### <a name="sample-code"></a><span data-ttu-id="91179-222">Beispielcode</span><span class="sxs-lookup"><span data-stu-id="91179-222">Sample code</span></span>

<span data-ttu-id="91179-223">Im Folgenden sehen Sie eine Beispielklasse <xref:System.Diagnostics.Tracing.EventListener>, die alle Indikatornamen und -werte aus der <xref:System.Diagnostics.Tracing.EventSource> der .NET-Laufzeit ausgibt, um ihre internen Indikatoren (`System.Runtime`) in einem bestimmten Intervall zu veröffentlichen.</span><span class="sxs-lookup"><span data-stu-id="91179-223">Here is a sample <xref:System.Diagnostics.Tracing.EventListener> class that prints out all the counter names and values from the .NET runtime's <xref:System.Diagnostics.Tracing.EventSource>, for publishing its internal counters (`System.Runtime`) at some interval.</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs":::

<span data-ttu-id="91179-224">Wie oben gezeigt, _müssen_ Sie sicherstellen, dass beim Aufruf von <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A> das `"EventCounterIntervalSec"`-Argument im Argument `filterPayload` festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="91179-224">As shown above, you _must_ make sure the `"EventCounterIntervalSec"` argument is set in the `filterPayload` argument when calling <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A>.</span></span> <span data-ttu-id="91179-225">Andernfalls können die Leistungsindikatoren keine Werte ausgeben, da sie nicht wissen, in welchem Intervall Werte ausgegeben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="91179-225">Otherwise the counters will not be able to flush out values since it doesn't know at which interval it should be getting flushed out.</span></span>

## <a name="see-also"></a><span data-ttu-id="91179-226">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="91179-226">See also</span></span>

- [<span data-ttu-id="91179-227">dotnet-counters</span><span class="sxs-lookup"><span data-stu-id="91179-227">dotnet-counters</span></span>](dotnet-counters.md)
- [<span data-ttu-id="91179-228">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="91179-228">dotnet-trace</span></span>](dotnet-trace.md)
- <xref:System.Diagnostics.Tracing.EventCounter>
- <xref:System.Diagnostics.Tracing.EventListener>
- <xref:System.Diagnostics.Tracing.EventSource>
