---
title: Überlegungen zur Leistung (Entity Framework)
ms.date: 03/30/2017
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
ms.openlocfilehash: 6cd0adb7963b3cfc05fcd6f30d8a7039a50f9485
ms.sourcegitcommit: 700ea803fb06c5ce98de017c7f76463ba33ff4a9
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 02/19/2020
ms.locfileid: "77452460"
---
# <a name="performance-considerations-entity-framework"></a><span data-ttu-id="378d3-102">Überlegungen zur Leistung (Entity Framework)</span><span class="sxs-lookup"><span data-stu-id="378d3-102">Performance Considerations (Entity Framework)</span></span>
<span data-ttu-id="378d3-103">In diesem Thema werden Leistungsmerkmale des ADO.NET Entity Framework beschrieben. Außerdem sind einige Vorschläge enthalten, die Sie zur Verbesserung der Leistung von Entity Framework-Anwendungen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="378d3-103">This topic describes performance characteristics of the ADO.NET Entity Framework and provides some considerations to help improve the performance of Entity Framework applications.</span></span>  
  
## <a name="stages-of-query-execution"></a><span data-ttu-id="378d3-104">Phasen der Abfrageausführung</span><span class="sxs-lookup"><span data-stu-id="378d3-104">Stages of Query Execution</span></span>  
 <span data-ttu-id="378d3-105">Zum besseren Verständnis der Abfrageleistung im Entity Framework ist es hilfreich zu verstehen, welche Vorgänge ablaufen, wenn eine Abfrage für ein konzeptionelles Modell ausgeführt wird und dabei Daten als Objekte zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-105">In order to better understand the performance of queries in the Entity Framework, it is helpful to understand the operations that occur when a query executes against a conceptual model and returns data as objects.</span></span> <span data-ttu-id="378d3-106">Die folgende Tabelle beschreibt diese Reihe von Vorgängen.</span><span class="sxs-lookup"><span data-stu-id="378d3-106">The following table describes this series of operations.</span></span>  
  
|<span data-ttu-id="378d3-107">Vorgang</span><span class="sxs-lookup"><span data-stu-id="378d3-107">Operation</span></span>|<span data-ttu-id="378d3-108">Relative Kosten</span><span class="sxs-lookup"><span data-stu-id="378d3-108">Relative Cost</span></span>|<span data-ttu-id="378d3-109">Häufigkeit</span><span class="sxs-lookup"><span data-stu-id="378d3-109">Frequency</span></span>|<span data-ttu-id="378d3-110">Comments</span><span class="sxs-lookup"><span data-stu-id="378d3-110">Comments</span></span>|  
|---------------|-------------------|---------------|--------------|  
|<span data-ttu-id="378d3-111">Laden von Metadaten</span><span class="sxs-lookup"><span data-stu-id="378d3-111">Loading metadata</span></span>|<span data-ttu-id="378d3-112">Mittel</span><span class="sxs-lookup"><span data-stu-id="378d3-112">Moderate</span></span>|<span data-ttu-id="378d3-113">Einmal pro Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="378d3-113">Once in each application domain.</span></span>|<span data-ttu-id="378d3-114">Von Entity Framework verwendete Modell- und Zuordnungsmetadaten werden in eine <xref:System.Data.Metadata.Edm.MetadataWorkspace> geladen.</span><span class="sxs-lookup"><span data-stu-id="378d3-114">Model and mapping metadata used by the Entity Framework is loaded into a <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span></span> <span data-ttu-id="378d3-115">Diese Metadaten werden global zwischengespeichert und stehen für weitere Instanzen von <xref:System.Data.Objects.ObjectContext> in der gleichen Anwendungsdomäne zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="378d3-115">This metadata is cached globally and is available to other instances of <xref:System.Data.Objects.ObjectContext> in the same application domain.</span></span>|  
|<span data-ttu-id="378d3-116">Öffnen der Datenbankverbindung</span><span class="sxs-lookup"><span data-stu-id="378d3-116">Opening the database connection</span></span>|<span data-ttu-id="378d3-117">Mittel<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="378d3-117">Moderate<sup>1</sup></span></span>|<span data-ttu-id="378d3-118">Nach Bedarf.</span><span class="sxs-lookup"><span data-stu-id="378d3-118">As needed.</span></span>|<span data-ttu-id="378d3-119">Da eine geöffnete Verbindung zur Datenbank eine wertvolle Ressource verbraucht, wird die-Entity Framework geöffnet und schließt die Datenbankverbindung nur nach Bedarf.</span><span class="sxs-lookup"><span data-stu-id="378d3-119">Because an open connection to the database consumes a valuable resource, the Entity Framework opens and closes the database connection only as needed.</span></span> <span data-ttu-id="378d3-120">Sie können die Verbindung auch explizit öffnen.</span><span class="sxs-lookup"><span data-stu-id="378d3-120">You can also explicitly open the connection.</span></span> <span data-ttu-id="378d3-121">Weitere Informationen finden Sie unter [Verwalten von Verbindungen und Transaktionen](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-121">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>|  
|<span data-ttu-id="378d3-122">Generieren von Sichten</span><span class="sxs-lookup"><span data-stu-id="378d3-122">Generating views</span></span>|<span data-ttu-id="378d3-123">Hoch</span><span class="sxs-lookup"><span data-stu-id="378d3-123">High</span></span>|<span data-ttu-id="378d3-124">Einmal pro Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="378d3-124">Once in each application domain.</span></span> <span data-ttu-id="378d3-125">(Kann zuvor generiert werden.)</span><span class="sxs-lookup"><span data-stu-id="378d3-125">(Can be pre-generated.)</span></span>|<span data-ttu-id="378d3-126">Bevor von Entity Framework für ein konzeptionelles Modell eine Abfrage ausgeführt oder Änderungen an der Datenquelle gespeichert werden können, muss ein Satz lokaler Abfrageansichten für den Zugriff auf die Datenbank generiert werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-126">Before the Entity Framework can execute a query against a conceptual model or save changes to the data source, it must generate a set of local query views to access the database.</span></span> <span data-ttu-id="378d3-127">Aufgrund der hohen Kosten für die Generierung dieser Ansichten können Sie die Sichten zuvor generieren und dem Projekt zur Entwurfszeit hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="378d3-127">Because of the high cost of generating these views, you can pre-generate the views and add them to the project at design-time.</span></span> <span data-ttu-id="378d3-128">Weitere Informationen finden Sie unter Gewusst [wie: Vorgenerieren von Sichten, um die Abfrageleistung zu verbessern](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-128">For more information, see [How to: Pre-Generate Views to Improve Query Performance](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>|  
|<span data-ttu-id="378d3-129">Vorbereiten der Abfrage</span><span class="sxs-lookup"><span data-stu-id="378d3-129">Preparing the query</span></span>|<span data-ttu-id="378d3-130">Mittel<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="378d3-130">Moderate<sup>2</sup></span></span>|<span data-ttu-id="378d3-131">Einmal für jede eindeutige Abfrage.</span><span class="sxs-lookup"><span data-stu-id="378d3-131">Once for each unique query.</span></span>|<span data-ttu-id="378d3-132">Schließt die Kosten für das Verfassen des Abfragebefehls, die Erstellung einer Befehlsstruktur auf Grundlage von Modell- und Zuordnungsmetadaten und die Definition der Form der zurückgegebenen Daten ein.</span><span class="sxs-lookup"><span data-stu-id="378d3-132">Includes the costs to compose the query command, generate a command tree based on model and mapping metadata, and define the shape of the returned data.</span></span> <span data-ttu-id="378d3-133">Da jetzt sowohl Entity SQL-Abfragebefehle als auch LINQ-Abfragen zwischengespeichert werden, ist für spätere Ausführungen derselben Abfrage weniger Zeit erforderlich.</span><span class="sxs-lookup"><span data-stu-id="378d3-133">Because now both Entity SQL query commands and LINQ queries are cached, later executions of the same query take less time.</span></span> <span data-ttu-id="378d3-134">Sie können weiterhin kompilierte LINQ-Abfragen verwenden, um diesen Aufwand in späteren Ausführungen zu reduzieren. Kompilierte Abfragen können effizienter als LINQ-Abfragen sein, die automatisch zwischengespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-134">You can still use compiled LINQ queries to reduce this cost in later executions and compiled queries can be more efficient than LINQ queries that are automatically cached.</span></span> <span data-ttu-id="378d3-135">Weitere Informationen finden Sie unter [kompilierte Abfragen (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md).</span><span class="sxs-lookup"><span data-stu-id="378d3-135">For more information, see [Compiled Queries  (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md).</span></span> <span data-ttu-id="378d3-136">Allgemeine Informationen zur LINQ-Abfrage Ausführung finden Sie unter [LINQ to Entities](./language-reference/linq-to-entities.md).</span><span class="sxs-lookup"><span data-stu-id="378d3-136">For general information about LINQ query execution, see [LINQ to Entities](./language-reference/linq-to-entities.md).</span></span> <span data-ttu-id="378d3-137">**Hinweis:**  LINQ to Entities Abfragen, die den `Enumerable.Contains`-Operator auf Auflistungen im Arbeitsspeicher anwenden, werden nicht automatisch zwischengespeichert.</span><span class="sxs-lookup"><span data-stu-id="378d3-137">**Note:**  LINQ to Entities queries that apply the `Enumerable.Contains` operator to in-memory collections are not automatically cached.</span></span> <span data-ttu-id="378d3-138">Darüber hinaus ist das Parametrisieren von Auflistungen im Arbeitsspeicher in kompilierten LINQ-Abfragen nicht zulässig.</span><span class="sxs-lookup"><span data-stu-id="378d3-138">Also parameterizing in-memory collections in compiled LINQ queries is not allowed.</span></span>|  
|<span data-ttu-id="378d3-139">Ausführen der Abfrage</span><span class="sxs-lookup"><span data-stu-id="378d3-139">Executing the query</span></span>|<span data-ttu-id="378d3-140">Niedrig<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="378d3-140">Low<sup>2</sup></span></span>|<span data-ttu-id="378d3-141">Einmal für jede Abfrage.</span><span class="sxs-lookup"><span data-stu-id="378d3-141">Once for each query.</span></span>|<span data-ttu-id="378d3-142">Die Kosten für das Ausführen des Befehls für die Datenquelle mithilfe des ADO.NET-Datenanbieters.</span><span class="sxs-lookup"><span data-stu-id="378d3-142">The cost of executing the command against the data source by using the ADO.NET data provider.</span></span> <span data-ttu-id="378d3-143">Da von den meisten Datenquellen Abfragepläne zwischengespeichert werden, kann die gleiche Abfrage ggf. noch schneller ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-143">Because most data sources cache query plans, later executions of the same query may take even less time.</span></span>|  
|<span data-ttu-id="378d3-144">Laden und Überprüfen von Typen</span><span class="sxs-lookup"><span data-stu-id="378d3-144">Loading and validating types</span></span>|<span data-ttu-id="378d3-145">Niedrig<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="378d3-145">Low<sup>3</sup></span></span>|<span data-ttu-id="378d3-146">Einmal für jede <xref:System.Data.Objects.ObjectContext>-Instanz.</span><span class="sxs-lookup"><span data-stu-id="378d3-146">Once for each <xref:System.Data.Objects.ObjectContext> instance.</span></span>|<span data-ttu-id="378d3-147">Typen werden geladen und gegen die Typen geprüft, die das konzeptionelle Modell definiert.</span><span class="sxs-lookup"><span data-stu-id="378d3-147">Types are loaded and validated against the types that the conceptual model defines.</span></span>|  
|<span data-ttu-id="378d3-148">Tracking</span><span class="sxs-lookup"><span data-stu-id="378d3-148">Tracking</span></span>|<span data-ttu-id="378d3-149">Niedrig<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="378d3-149">Low<sup>3</sup></span></span>|<span data-ttu-id="378d3-150">Einmal für jedes Objekt, dass von einer Abfrage zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="378d3-150">Once for each object that a query returns.</span></span> <span data-ttu-id="378d3-151"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="378d3-151"><sup>4</sup></span></span>|<span data-ttu-id="378d3-152">Verwendet eine Abfrage die <xref:System.Data.Objects.MergeOption.NoTracking>-Mergeoption, wird die Leistung in dieser Phase nicht beeinträchtigt.</span><span class="sxs-lookup"><span data-stu-id="378d3-152">If a query uses the <xref:System.Data.Objects.MergeOption.NoTracking> merge option, this stage does not affect performance.</span></span><br /><br /> <span data-ttu-id="378d3-153">Verwendet die Abfrage die <xref:System.Data.Objects.MergeOption.AppendOnly>-, <xref:System.Data.Objects.MergeOption.PreserveChanges>- oder <xref:System.Data.Objects.MergeOption.OverwriteChanges>-Mergeoption, werden Abfrageergebnisse in der <xref:System.Data.Objects.ObjectStateManager> nachverfolgt.</span><span class="sxs-lookup"><span data-stu-id="378d3-153">If the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> merge option, query results are tracked in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="378d3-154">Für jedes von der Abfrage zurückgegebene verfolgte Objekt wird ein <xref:System.Data.EntityKey> generiert, das für die Erstellung eines <xref:System.Data.Objects.ObjectStateEntry> im <xref:System.Data.Objects.ObjectStateManager> verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="378d3-154">An <xref:System.Data.EntityKey> is generated for each tracked object that the query returns and is used to create an <xref:System.Data.Objects.ObjectStateEntry> in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="378d3-155">Wenn ein <xref:System.Data.Objects.ObjectStateEntry> für den <xref:System.Data.EntityKey> vorhanden ist, wird das vorhandene Objekt zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="378d3-155">If an existing <xref:System.Data.Objects.ObjectStateEntry> can be found for the <xref:System.Data.EntityKey>, the existing object is returned.</span></span> <span data-ttu-id="378d3-156">Wir die <xref:System.Data.Objects.MergeOption.PreserveChanges>- oder <xref:System.Data.Objects.MergeOption.OverwriteChanges>-Option verwendet, wird das Objekt vor der Rückgabe aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="378d3-156">If the <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> option is used, the object is updated before it is returned.</span></span><br /><br /> <span data-ttu-id="378d3-157">Weitere Informationen finden Sie unter [Identitäts Auflösung, Zustands Verwaltung und Änderungsnachverfolgung](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-157">For more information, see [Identity Resolution, State Management, and Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
|<span data-ttu-id="378d3-158">Materialisieren der Objekte</span><span class="sxs-lookup"><span data-stu-id="378d3-158">Materializing the objects</span></span>|<span data-ttu-id="378d3-159">Mittel<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="378d3-159">Moderate<sup>3</sup></span></span>|<span data-ttu-id="378d3-160">Einmal für jedes Objekt, dass von einer Abfrage zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="378d3-160">Once for each object that a query returns.</span></span> <span data-ttu-id="378d3-161"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="378d3-161"><sup>4</sup></span></span>|<span data-ttu-id="378d3-162">Der Prozess des Lesens des zurückgegebenen <xref:System.Data.Common.DbDataReader>-Objekts, des Erstellens von Objekten und des Festlegens von Eigenschaftswerten, die auf den Werten in jeder Instanz der <xref:System.Data.Common.DbDataRecord>-Klasse basieren.</span><span class="sxs-lookup"><span data-stu-id="378d3-162">The process of reading the returned <xref:System.Data.Common.DbDataReader> object and creating objects and setting property values that are based on the values in each instance of the <xref:System.Data.Common.DbDataRecord> class.</span></span> <span data-ttu-id="378d3-163">Ist das Objekt bereits im <xref:System.Data.Objects.ObjectContext> vorhanden und wird von der Abfrage die <xref:System.Data.Objects.MergeOption.AppendOnly>- oder <xref:System.Data.Objects.MergeOption.PreserveChanges>-Zusammenführungsoptionen verwendet, wird von dieser Phase die Leistung nicht beeinträchtigt.</span><span class="sxs-lookup"><span data-stu-id="378d3-163">If the object already exists in the <xref:System.Data.Objects.ObjectContext> and the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly> or <xref:System.Data.Objects.MergeOption.PreserveChanges> merge options, this stage does not affect performance.</span></span> <span data-ttu-id="378d3-164">Weitere Informationen finden Sie unter [Identitäts Auflösung, Zustands Verwaltung und Änderungsnachverfolgung](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-164">For more information, see [Identity Resolution, State Management, and Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
  
 <span data-ttu-id="378d3-165"><sup>1</sup> wenn ein Datenquellen Anbieter das Verbindungspooling implementiert, werden die Kosten für das Öffnen einer Verbindung über den Pool verteilt.</span><span class="sxs-lookup"><span data-stu-id="378d3-165"><sup>1</sup> When a data source provider implements connection pooling, the cost of opening a connection is distributed across the pool.</span></span> <span data-ttu-id="378d3-166">Der .NET-Anbieter für SQL Server unterstützt Verbindungspooling.</span><span class="sxs-lookup"><span data-stu-id="378d3-166">The .NET Provider for SQL Server supports connection pooling.</span></span>  
  
 <span data-ttu-id="378d3-167"><sup>2</sup> die Kosten steigen mit erhöhter Abfrage Komplexität.</span><span class="sxs-lookup"><span data-stu-id="378d3-167"><sup>2</sup> Cost increases with increased query complexity.</span></span>  
  
 <span data-ttu-id="378d3-168"><sup>3</sup> Gesamtkosten steigen proportional zur Anzahl von Objekten, die von der Abfrage zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-168"><sup>3</sup> Total cost increases proportional to the number of objects returned by the query.</span></span>  
  
 <span data-ttu-id="378d3-169"><sup>4</sup> dieser mehr Aufwand ist für EntityClient-Abfragen nicht erforderlich, da EntityClient-Abfragen anstelle von Objekten eine <xref:System.Data.EntityClient.EntityDataReader> zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="378d3-169"><sup>4</sup> This overhead is not required for EntityClient queries because EntityClient queries return an <xref:System.Data.EntityClient.EntityDataReader> instead of objects.</span></span> <span data-ttu-id="378d3-170">Weitere Informationen finden Sie unter [EntityClient-Anbieter für das Entity Framework](entityclient-provider-for-the-entity-framework.md).</span><span class="sxs-lookup"><span data-stu-id="378d3-170">For more information, see [EntityClient Provider for the Entity Framework](entityclient-provider-for-the-entity-framework.md).</span></span>  
  
## <a name="additional-considerations"></a><span data-ttu-id="378d3-171">Weitere Überlegungen</span><span class="sxs-lookup"><span data-stu-id="378d3-171">Additional Considerations</span></span>  
 <span data-ttu-id="378d3-172">Die im Folgenden beschriebenen Vorgehensweisen wirken sich möglicherweise auf die Leistung von Entity Framework-Anwendungen aus.</span><span class="sxs-lookup"><span data-stu-id="378d3-172">The following are other considerations that may affect the performance of Entity Framework applications.</span></span>  
  
### <a name="query-execution"></a><span data-ttu-id="378d3-173">Abfrageausführung</span><span class="sxs-lookup"><span data-stu-id="378d3-173">Query Execution</span></span>  
 <span data-ttu-id="378d3-174">Da Abfragen ressourcenintensiv sein können, muss berücksichtigt werden, an welcher Stelle im Code und auf welchem Computer eine Abfrage ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="378d3-174">Because queries can be resource intensive, consider at what point in your code and on what computer a query is executed.</span></span>  
  
#### <a name="deferred-versus-immediate-execution"></a><span data-ttu-id="378d3-175">Verzögerte und unmittelbare Ausführung</span><span class="sxs-lookup"><span data-stu-id="378d3-175">Deferred versus immediate execution</span></span>  
 <span data-ttu-id="378d3-176">Bei der Erstellung einer <xref:System.Data.Objects.ObjectQuery%601>- oder einer LINQ-Abfrage wird die Abfrage möglicherweise nicht sofort ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="378d3-176">When you create an <xref:System.Data.Objects.ObjectQuery%601> or LINQ query, the query may not be executed immediately.</span></span> <span data-ttu-id="378d3-177">Die Abfrageausführung wird so lange verzögert, bis die Ergebnisse benötigt werden, z. B. während einer `foreach` (C#)-Enumeration, einer `For Each` (Visual Basic)-Enumeration oder wenn eine <xref:System.Collections.Generic.List%601>-Auflistung ausgefüllt werden soll.</span><span class="sxs-lookup"><span data-stu-id="378d3-177">Query execution is deferred until the results are needed, such as during a `foreach` (C#) or `For Each` (Visual Basic) enumeration or when it is assigned to fill a <xref:System.Collections.Generic.List%601> collection.</span></span> <span data-ttu-id="378d3-178">Die Abfrage wird ausgeführt, wenn Sie die <xref:System.Data.Objects.ObjectQuery%601.Execute%2A>-Methode für ein <xref:System.Data.Objects.ObjectQuery%601> aufrufen oder wenn Sie eine LINQ-Methode aufrufen, die eine Singleton-Abfrage zurückgibt, z. B. <xref:System.Linq.Enumerable.First%2A> oder <xref:System.Linq.Enumerable.Any%2A>.</span><span class="sxs-lookup"><span data-stu-id="378d3-178">Query execution begins immediately when you call the <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> method on an <xref:System.Data.Objects.ObjectQuery%601> or when you call a LINQ method that returns a singleton query, such as <xref:System.Linq.Enumerable.First%2A> or <xref:System.Linq.Enumerable.Any%2A>.</span></span> <span data-ttu-id="378d3-179">Weitere Informationen finden Sie unter [Objekt Abfragen](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) und [Abfrage Ausführung (LINQ to Entities)](./language-reference/query-execution.md).</span><span class="sxs-lookup"><span data-stu-id="378d3-179">For more information, see [Object Queries](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) and [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
#### <a name="client-side-execution-of-linq-queries"></a><span data-ttu-id="378d3-180">Clientseitige Ausführung von LINQ-Abfragen</span><span class="sxs-lookup"><span data-stu-id="378d3-180">Client-side execution of LINQ queries</span></span>  
 <span data-ttu-id="378d3-181">Obwohl eine LINQ-Abfrage auf dem Computer ausgeführt wird, der die Datenquelle hostet, werden einige Teile der LINQ-Abfrage möglicherweise auf dem Clientcomputer ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="378d3-181">Although the execution of a LINQ query occurs on the computer that hosts the data source, some parts of a LINQ query may be evaluated on the client computer.</span></span> <span data-ttu-id="378d3-182">Weitere Informationen finden Sie im Abschnitt "Store Execution" der [Abfrage Ausführung (LINQ to Entities)](./language-reference/query-execution.md).</span><span class="sxs-lookup"><span data-stu-id="378d3-182">For more information, see the Store Execution section of [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
### <a name="query-and-mapping-complexity"></a><span data-ttu-id="378d3-183">Abfrage- und Zuordnungskomplexität</span><span class="sxs-lookup"><span data-stu-id="378d3-183">Query and Mapping Complexity</span></span>  
 <span data-ttu-id="378d3-184">Die Komplexität einzelner Abfragen und der Zuordnung im Entitätsmodell wirkt sich entscheidend auf die Abfrageleistung aus.</span><span class="sxs-lookup"><span data-stu-id="378d3-184">The complexity of individual queries and of the mapping in the entity model will have a significant effect on query performance.</span></span>  
  
#### <a name="mapping-complexity"></a><span data-ttu-id="378d3-185">Zuordnungskomplexität</span><span class="sxs-lookup"><span data-stu-id="378d3-185">Mapping complexity</span></span>  
 <span data-ttu-id="378d3-186">Modelle, die komplexer als eine einfache 1:1-Zuordnung für Entitäten im konzeptionellen Modell und Tabellen im Speichermodell sind, generieren komplexere Befehle als Modelle mit 1:1-Zuordnung.</span><span class="sxs-lookup"><span data-stu-id="378d3-186">Models that are more complex than a simple one-to-one mapping between entities in the conceptual model and tables in the storage model generate more complex commands than models that have a one-to-one mapping.</span></span>  
  
#### <a name="query-complexity"></a><span data-ttu-id="378d3-187">Abfragekomplexität</span><span class="sxs-lookup"><span data-stu-id="378d3-187">Query complexity</span></span>  
 <span data-ttu-id="378d3-188">Abfragen, die eine große Anzahl von Joins für Befehle erfordern, die für die Datenquelle ausgeführt werden oder eine große Datenmenge zurückgeben, beeinträchtigen möglicherweise die Leistung auf die folgende Weise:</span><span class="sxs-lookup"><span data-stu-id="378d3-188">Queries that require a large number of joins in the commands that are executed against the data source or that return a large amount of data may affect performance in the following ways:</span></span>  
  
- <span data-ttu-id="378d3-189">Scheinbar einfache Abfragen für ein konzeptionelles Modell führen möglicherweise zur Ausführung komplexerer Abfragen für die Datenquelle.</span><span class="sxs-lookup"><span data-stu-id="378d3-189">Queries against a conceptual model that seem simple may result in the execution of more complex queries against the data source.</span></span> <span data-ttu-id="378d3-190">Dies kann auftreten, da Entity Framework eine Abfrage für ein konzeptionelles Modell in eine entsprechende Abfrage für die Datenquelle übersetzt.</span><span class="sxs-lookup"><span data-stu-id="378d3-190">This can occur because the Entity Framework translates a query against a conceptual model into an equivalent query against the data source.</span></span> <span data-ttu-id="378d3-191">Wenn ein einzelner Entitätssatz im konzeptionellen Modell mehr als einer Tabelle in der Datenquelle zugeordnet wird oder einer Jointabelle eine Beziehung zwischen Entitäten zugeordnet wird, sind für den Abfragebefehl für die Datenquellenabfrage möglicherweise Joins erforderlich.</span><span class="sxs-lookup"><span data-stu-id="378d3-191">When a single entity set in the conceptual model maps to more than one table in the data source, or when a relationship between entities is mapped to a join table, the query command executed against the data source query may require one or more joins.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="378d3-192">Verwenden Sie die <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A>-Methode der <xref:System.Data.Objects.ObjectQuery%601>- oder <xref:System.Data.EntityClient.EntityCommand>-Klasse, um die Befehle anzuzeigen, die für die Datenquelle für eine angegebene Abfrage ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-192">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method of the <xref:System.Data.Objects.ObjectQuery%601> or <xref:System.Data.EntityClient.EntityCommand> classes to view the commands that are executed against the data source for a given query.</span></span> <span data-ttu-id="378d3-193">Weitere Informationen finden Sie unter Gewusst [wie: Anzeigen der Speicher Befehle](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-193">For more information, see [How to: View the Store Commands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
- <span data-ttu-id="378d3-194">Geschachtelte Entity SQL-Abfragen erstellen möglicherweise Joins auf dem Server und geben eine große Anzahl von Zeilen zurück.</span><span class="sxs-lookup"><span data-stu-id="378d3-194">Nested Entity SQL queries may create joins on the server and can return a large number of rows.</span></span>  
  
     <span data-ttu-id="378d3-195">Im Folgenden sehen Sie ein Beispiel für eine geschachtelte Abfrage in einer Projektionsklausel:</span><span class="sxs-lookup"><span data-stu-id="378d3-195">The following is an example of a nested query in a projection clause:</span></span>  
  
    ```sql  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2   
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1   
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     <span data-ttu-id="378d3-196">Außerdem bewirken solche Abfragen, dass die Abfragepipeline eine einzelne Abfrage durch die Verdoppelung von Objekten in geschachtelten Abfragen generiert.</span><span class="sxs-lookup"><span data-stu-id="378d3-196">In addition, such queries cause the query pipeline to generate a single query with duplication of objects across nested queries.</span></span> <span data-ttu-id="378d3-197">Deswegen wird eine einzelne Spalte möglicherweise mehrmals dupliziert.</span><span class="sxs-lookup"><span data-stu-id="378d3-197">Because of this, a single column may be duplicated multiple times.</span></span> <span data-ttu-id="378d3-198">In einigen Datenbanken, einschließlich SQL Server, kann hierdurch die TempDB-Tabelle stark vergrößert werden, wodurch die Serverleistung abnehmen kann.</span><span class="sxs-lookup"><span data-stu-id="378d3-198">On some databases, including SQL Server, this can cause the TempDB table to grow very large, which can decrease server performance.</span></span> <span data-ttu-id="378d3-199">Bei der Ausführung geschachtelter Abfragen sollte also vorsichtig vorgegangen werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-199">Care should be taken when you execute nested queries.</span></span>  
  
- <span data-ttu-id="378d3-200">Alle Abfragen, die eine große Datenmenge zurückgeben, können einen Leistungsabfall verursachen, wenn vom Client Operationen ausgeführt werden, von denen Ressourcen in der Größenordnung des Resultsets verbraucht werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-200">Any queries that return a large amount of data can cause decreased performance if the client is performing operations that consume resources in a way that is proportional to the size of the result set.</span></span> <span data-ttu-id="378d3-201">In solchen Fällen sollten Sie erwägen, die von der Abfrage zurückgegebene Datenmenge zu beschränken.</span><span class="sxs-lookup"><span data-stu-id="378d3-201">In such cases, you should consider limiting the amount of data returned by the query.</span></span> <span data-ttu-id="378d3-202">Weitere Informationen finden Sie unter Gewusst [wie: seitenweise durch Abfrageergebnisse](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-202">For more information, see [How to: Page Through Query Results](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
 <span data-ttu-id="378d3-203">Alle automatisch vom Entity Framework generierten Befehle sind möglicherweise komplexer als ähnliche explizit von einem Datenbankentwickler geschriebenen Befehle.</span><span class="sxs-lookup"><span data-stu-id="378d3-203">Any commands automatically generated by the Entity Framework may be more complex than similar commands written explicitly by a database developer.</span></span> <span data-ttu-id="378d3-204">Wenn Sie explizite Kontrolle über die für die Datenquelle ausgeführten Befehle benötigen, erwägen Sie die Definition einer Zuordnung für eine Tabellenwertfunktion oder eine gespeicherte Prozedur.</span><span class="sxs-lookup"><span data-stu-id="378d3-204">If you need explicit control over the commands executed against your data source, consider defining a mapping to a table-valued function or stored procedure.</span></span>  
  
#### <a name="relationships"></a><span data-ttu-id="378d3-205">Beziehungen</span><span class="sxs-lookup"><span data-stu-id="378d3-205">Relationships</span></span>  
 <span data-ttu-id="378d3-206">Für optimale Abfrageleistung müssen Beziehungen zwischen Entitäten als Zuordnungen im Entitätsmodell und als logische Beziehungen in der Datenquelle definiert werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-206">For optimal query performance, you must define relationships between entities both as associations in the entity model and as logical relationships in the data source.</span></span>  
  
### <a name="query-paths"></a><span data-ttu-id="378d3-207">Abfragepfade</span><span class="sxs-lookup"><span data-stu-id="378d3-207">Query Paths</span></span>  
 <span data-ttu-id="378d3-208">Standardmäßig werden verknüpfte Objekte nicht zurückgegeben (obwohl dies für Objekte, die die Beziehungen selbst darstellen, zutrifft), wenn Sie einen <xref:System.Data.Objects.ObjectQuery%601> ausführen.</span><span class="sxs-lookup"><span data-stu-id="378d3-208">By default, when you execute an <xref:System.Data.Objects.ObjectQuery%601>, related objects are not returned (although objects that represent the relationships themselves are).</span></span> <span data-ttu-id="378d3-209">Sie können auf eine von drei Arten verknüpfte Objekte laden:</span><span class="sxs-lookup"><span data-stu-id="378d3-209">You can load related objects in one of three ways:</span></span>  
  
1. <span data-ttu-id="378d3-210">Legen Sie den Abfragepfad fest, bevor die <xref:System.Data.Objects.ObjectQuery%601>-Abfrage ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="378d3-210">Set the query path before the <xref:System.Data.Objects.ObjectQuery%601> is executed.</span></span>  
  
2. <span data-ttu-id="378d3-211">Rufen Sie die `Load`-Methode für die Navigationseigenschaft auf, die das Objekt verfügbar macht.</span><span class="sxs-lookup"><span data-stu-id="378d3-211">Call the `Load` method on the navigation property that the object exposes.</span></span>  
  
3. <span data-ttu-id="378d3-212">Legen Sie die <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A>-Option für das <xref:System.Data.Objects.ObjectContext>-Objekt auf `true` fest.</span><span class="sxs-lookup"><span data-stu-id="378d3-212">Set the <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> option on the <xref:System.Data.Objects.ObjectContext> to `true`.</span></span> <span data-ttu-id="378d3-213">Beachten Sie, dass dies automatisch erfolgt, wenn Sie Code auf Objektebene mit dem [Entity Data Model-Designer](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100))generieren.</span><span class="sxs-lookup"><span data-stu-id="378d3-213">Note that this is done automatically when you generate object-layer code with the [Entity Data Model Designer](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span></span> <span data-ttu-id="378d3-214">Weitere Informationen finden Sie unter [Übersicht über den generierten Code](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-214">For more information see [Generated Code Overview](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span></span>  
  
 <span data-ttu-id="378d3-215">Denken Sie beim Auswählen der Option daran, dass zwischen der Anzahl der Abfragen der Datenbank und der in einer einzelnen Abfrage zurückgegebenen Datenmenge abgewogen werden sollte.</span><span class="sxs-lookup"><span data-stu-id="378d3-215">When you consider which option to use, be aware that there is a tradeoff between the number of requests against the database and the amount of data returned in a single query.</span></span> <span data-ttu-id="378d3-216">Weitere Informationen finden Sie unter [Laden verwandter Objekte](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-216">For more information, see [Loading Related Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
#### <a name="using-query-paths"></a><span data-ttu-id="378d3-217">Verwenden von Abfragepfaden</span><span class="sxs-lookup"><span data-stu-id="378d3-217">Using query paths</span></span>  
 <span data-ttu-id="378d3-218">Abfragepfade definieren das Diagramm von Objekten, die von einer Abfrage zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-218">Query paths define the graph of objects that a query returns.</span></span> <span data-ttu-id="378d3-219">Beim Definieren eines Abfragepfads ist nur eine einzige Abfrage der Datenbank erforderlich, um alle durch den Pfad definierten Objekte zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="378d3-219">When you define a query path, only a single request against the database is required to return all objects that the path defines.</span></span> <span data-ttu-id="378d3-220">Durch die Verwendung von Abfragepfaden können aus scheinbar einfachen Objektabfragen komplexe Befehle werden, die in der Datenquelle ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-220">Using query paths can result in complex commands being executed against the data source from seemingly simple object queries.</span></span> <span data-ttu-id="378d3-221">Der Grund hierfür ist, dass eine oder mehrere Joins erforderlich sind, um verbundene Objekte in einer einzelnen Abfrage zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="378d3-221">This occurs because one or more joins are required to return related objects in a single query.</span></span> <span data-ttu-id="378d3-222">Diese Komplexität nimmt bei Abfragen für ein komplexes Entitätsmodell (z. B. eine Entität mit Vererbung oder ein Pfad, der n:n-Beziehungen enthält) zu.</span><span class="sxs-lookup"><span data-stu-id="378d3-222">This complexity is greater in queries against a complex entity model, such as an entity with inheritance or a path that includes many-to-many relationships.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="378d3-223">Mit der <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A>-Methode kann der von einer <xref:System.Data.Objects.ObjectQuery%601> generierte Befehl angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-223">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method to see the command that will be generated by an <xref:System.Data.Objects.ObjectQuery%601>.</span></span> <span data-ttu-id="378d3-224">Weitere Informationen finden Sie unter Gewusst [wie: Anzeigen der Speicher Befehle](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-224">For more information, see [How to: View the Store Commands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
 <span data-ttu-id="378d3-225">Wenn ein Abfragepfad zu viele verbundene Objekte enthält oder die Objekte zu viele Zeilendaten enthalten, kann die Abfrage möglicherweise nicht von der Datenquelle abgeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-225">When a query path includes too many related objects or the objects contain too much row data, the data source might be unable to complete the query.</span></span> <span data-ttu-id="378d3-226">Dies tritt auf, wenn die Abfrage temporäre Zwischenspeicherung erfordert, die die Kapazität der Datenquelle überschreitet.</span><span class="sxs-lookup"><span data-stu-id="378d3-226">This occurs if the query requires intermediate temporary storage that exceeds the capabilities of the data source.</span></span> <span data-ttu-id="378d3-227">In diesem Fall kann die Komplexität der Datenquellenabfrage verringert werden, indem verbundene Objekte explizit geladen werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-227">When this occurs, you can reduce the complexity of the data source query by explicitly loading related objects.</span></span>  
  
#### <a name="explicitly-loading-related-objects"></a><span data-ttu-id="378d3-228">Explizites Laden verbundener Objekte</span><span class="sxs-lookup"><span data-stu-id="378d3-228">Explicitly loading related objects</span></span>  
 <span data-ttu-id="378d3-229">Zum expliziten Laden verbundener Objekte muss die `Load`-Methode für eine Navigationseigenschaft aufgerufen werden, die eine <xref:System.Data.Objects.DataClasses.EntityCollection%601> oder <xref:System.Data.Objects.DataClasses.EntityReference%601> zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="378d3-229">You can explicitly load related objects by calling the `Load` method on a navigation property that returns an <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span></span> <span data-ttu-id="378d3-230">Explizites Laden erfordert bei jedem Aufruf von `Load` einen Roundtrip zur Datenbank.</span><span class="sxs-lookup"><span data-stu-id="378d3-230">Explicitly loading objects requires a round-trip to the database every time `Load` is called.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="378d3-231">Wenn Sie beim Durchlaufen einer Auflistung zurückgegebener Objekte `Load` aufrufen, z. B. wenn Sie die `foreach`-Anweisung (`For Each` in Visual Basic) verwenden, muss der datenquellenspezifische Anbieter mehrere aktive Resultsets für eine einzelne Verbindung unterstützen.</span><span class="sxs-lookup"><span data-stu-id="378d3-231">if you call `Load` while looping through a collection of returned objects, such as when you use the `foreach` statement (`For Each` in Visual Basic), the data source-specific provider must support multiple active results sets on a single connection.</span></span> <span data-ttu-id="378d3-232">Bei einer SQL Server-Datenbank muss in der Verbindungszeichenfolge des Anbieters der Wert `MultipleActiveResultSets = true` angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-232">For a SQL Server database, you must specify a value of `MultipleActiveResultSets = true` in the provider connection string.</span></span>  
  
 <span data-ttu-id="378d3-233">Sie können auch die <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>-Methode verwenden, wenn die Entitäten nicht über die <xref:System.Data.Objects.DataClasses.EntityCollection%601>-Eigenschaft oder die <xref:System.Data.Objects.DataClasses.EntityReference%601>-Eigenschaft verfügen.</span><span class="sxs-lookup"><span data-stu-id="378d3-233">You can also use the <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> method when there is no <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601> properties on entities.</span></span> <span data-ttu-id="378d3-234">Dies ist bei Verwendung von POCO-Entitäten nützlich.</span><span class="sxs-lookup"><span data-stu-id="378d3-234">This is useful when you are using POCO entities.</span></span>  
  
 <span data-ttu-id="378d3-235">Obwohl durch das explizite Laden von verwandten Objekten die Anzahl der Joins und die Menge von redundanten Daten reduziert wird, erfordert `Load` wiederholte Verbindungen zur Datenbank, was beim expliziten Laden einer großen Anzahl von Objekten kostenintensiv sein kann.</span><span class="sxs-lookup"><span data-stu-id="378d3-235">Although explicitly loading related objects will reduce the number of joins and reduced the amount of redundant data, `Load` requires repeated connections to the database, which can become costly when explicitly loading a large number of objects.</span></span>  
  
### <a name="saving-changes"></a><span data-ttu-id="378d3-236">Speichern von Änderungen</span><span class="sxs-lookup"><span data-stu-id="378d3-236">Saving Changes</span></span>  
 <span data-ttu-id="378d3-237">Wenn Sie die <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>-Methode für einen <xref:System.Data.Objects.ObjectContext> aufrufen, wird für jedes hinzugefügte, aktualisierte oder gelöschte Objekt im Kontext jeweils ein eigener Befehl zum Erstellen, Aktualisieren oder Löschen generiert.</span><span class="sxs-lookup"><span data-stu-id="378d3-237">When you call the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method on an <xref:System.Data.Objects.ObjectContext>, a separate create, update, or delete command is generated for every added, updated, or deleted object in the context.</span></span> <span data-ttu-id="378d3-238">Diese Befehle werden für die Datenquelle in einer einzelnen Transaktion ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="378d3-238">These commands are executed on the data source in a single transaction.</span></span> <span data-ttu-id="378d3-239">Wie bei Abfragen ist die Leistung von Vorgängen für die Erstellung, Aktualisierung und Löschung von der Komplexität der Zuordnung im konzeptionellen Modell abhängig.</span><span class="sxs-lookup"><span data-stu-id="378d3-239">As with queries, the performance of create, update, and delete operations depends on the complexity of the mapping in the conceptual model.</span></span>  
  
### <a name="distributed-transactions"></a><span data-ttu-id="378d3-240">Verteilte Transaktionen</span><span class="sxs-lookup"><span data-stu-id="378d3-240">Distributed Transactions</span></span>  
 <span data-ttu-id="378d3-241">Operationen in einer expliziten Transaktion, die Ressourcen erfordern, die vom verteilten Transaktionskoordinator (DTC) verwaltet werden, sind viel teurer als eine ähnliche Operation, die DTC nicht erfordert.</span><span class="sxs-lookup"><span data-stu-id="378d3-241">Operations in an explicit transaction that require resources that are managed by the distributed transaction coordinator (DTC) will be much more expensive than a similar operation that does not require the DTC.</span></span> <span data-ttu-id="378d3-242">In den folgenden Situationen findet eine Höherstufung zum DTC statt:</span><span class="sxs-lookup"><span data-stu-id="378d3-242">Promotion to the DTC will occur in the following situations:</span></span>  
  
- <span data-ttu-id="378d3-243">Eine explizite Transaktion mit einem Vorgang für eine SQL Server 2000-Datenbank oder andere Datenquellen, die ständig explizite Transaktionen auf den DTC hochstufen.</span><span class="sxs-lookup"><span data-stu-id="378d3-243">An explicit transaction with an operation against a SQL Server 2000 database or other data source that always promote explicit transactions to the DTC.</span></span>  
  
- <span data-ttu-id="378d3-244">Eine explizite Transaktion mit einem Vorgang für SQL Server 2005, wenn die Verbindung vom Entity Framework verwaltet wird.</span><span class="sxs-lookup"><span data-stu-id="378d3-244">An explicit transaction with an operation against SQL Server 2005 when the connection is managed by the Entity Framework.</span></span> <span data-ttu-id="378d3-245">Dies liegt daran, dass SQL Server 2005 den DTC immer dann herauf stuft, wenn eine Verbindung geschlossen und innerhalb einer einzelnen Transaktion erneut geöffnet wird. Dies ist das Standardverhalten des Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="378d3-245">This occurs because SQL Server 2005 promotes to a DTC whenever a connection is closed and reopened within a single transaction, which is the default behavior of the Entity Framework.</span></span> <span data-ttu-id="378d3-246">Beim SQL Server 2008 wird diese DTC-Höherstufung nicht durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="378d3-246">This DTC promotion does not occur when using SQL Server 2008.</span></span> <span data-ttu-id="378d3-247">Öffnen und schließen Sie explizit die Verbindung innerhalb der Transaktion, um diese Höherstufung zu vermeiden, wenn Sie SQL Server 2005 verwenden.</span><span class="sxs-lookup"><span data-stu-id="378d3-247">To avoid this promotion when using SQL Server 2005, you must explicitly open and close the connection within the transaction.</span></span> <span data-ttu-id="378d3-248">Weitere Informationen finden Sie unter [Verwalten von Verbindungen und Transaktionen](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-248">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
 <span data-ttu-id="378d3-249">Eine explizite Transaktion wird verwendet, wenn eine oder mehrere Operationen in einer <xref:System.Transactions>-Transaktion ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-249">An explicit transaction is used when one or more operations are executed inside a <xref:System.Transactions> transaction.</span></span> <span data-ttu-id="378d3-250">Weitere Informationen finden Sie unter [Verwalten von Verbindungen und Transaktionen](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-250">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="strategies-for-improving-performance"></a><span data-ttu-id="378d3-251">Strategien zum Verbessern der Leistung</span><span class="sxs-lookup"><span data-stu-id="378d3-251">Strategies for Improving Performance</span></span>  
 <span data-ttu-id="378d3-252">Sie können die Gesamtleistung von Abfragen in Entity Framework mit den folgenden Strategien verbessern.</span><span class="sxs-lookup"><span data-stu-id="378d3-252">You can improve the overall performance of queries in the Entity Framework by using the following strategies.</span></span>  
  
#### <a name="pre-generate-views"></a><span data-ttu-id="378d3-253">Vorabgenerieren von Sichten</span><span class="sxs-lookup"><span data-stu-id="378d3-253">Pre-generate views</span></span>  
 <span data-ttu-id="378d3-254">Führt eine Anwendung eine Abfrage zum ersten Mal aus, ist das Generieren von Sichten auf Grundlage eines Entitätsmodells kostenintensiv.</span><span class="sxs-lookup"><span data-stu-id="378d3-254">Generating views based on an entity model is a significant cost the first time that an application executes a query.</span></span> <span data-ttu-id="378d3-255">Verwenden Sie das Hilfsprogramm EdmGen.exe, um Sichten als Visual Basic- oder C#-Codedatei vorzugenerieren, die dem Projekt während des Entwurfs hinzugefügt werden kann.</span><span class="sxs-lookup"><span data-stu-id="378d3-255">Use the EdmGen.exe utility to pre-generate views as a Visual Basic or C# code file that can be added to the project during design.</span></span> <span data-ttu-id="378d3-256">Sie können auch mit dem Text Template Transformation Toolkit (Textvorlagentransformations-Toolkit) vorkompilierte Sichten generieren.</span><span class="sxs-lookup"><span data-stu-id="378d3-256">You could also use the Text Template Transformation Toolkit to generate pre-compiled views.</span></span> <span data-ttu-id="378d3-257">Zur Wahrung der Konsistenz mit der aktuellen Version des angegebenen Entitätsmodells werden vorgenerierte Sichten zur Laufzeit überprüft.</span><span class="sxs-lookup"><span data-stu-id="378d3-257">Pre-generated views are validated at runtime to ensure that they are consistent with the current version of the specified entity model.</span></span> <span data-ttu-id="378d3-258">Weitere Informationen finden Sie unter Gewusst [wie: Vorgenerieren von Sichten, um die Abfrageleistung zu verbessern](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-258">For more information, see [How to: Pre-Generate Views to Improve Query Performance](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>
  
 <span data-ttu-id="378d3-259">Beim Arbeiten mit sehr umfangreichen Modellen ist Folgendes zu berücksichtigen:</span><span class="sxs-lookup"><span data-stu-id="378d3-259">When working with very large models, the following consideration applies:</span></span>  
  
 <span data-ttu-id="378d3-260">Das .NET-Metadatenformat beschränkt die Anzahl der Zeichen in Benutzerzeichenfolgen in einer Binärdatei auf 16.777.215 (0xFFFFFF) Zeichen.</span><span class="sxs-lookup"><span data-stu-id="378d3-260">The .NET metadata format limits the number of user string characters in a given binary to 16,777,215 (0xFFFFFF).</span></span> <span data-ttu-id="378d3-261">Wenn Sie Ansichten für ein sehr großes Modell erzeugen und die Ansichts Datei diese Größenbeschränkung erreicht, erhalten Sie den "kein logischer Speicherplatz zum Erstellen von weiteren Benutzer Zeichenfolgen".</span><span class="sxs-lookup"><span data-stu-id="378d3-261">If you are generating views for a very large model and the view file reaches this size limit, you will get the "No logical space left to create more user strings."</span></span> <span data-ttu-id="378d3-262">Kompilierungsfehler.</span><span class="sxs-lookup"><span data-stu-id="378d3-262">compile error.</span></span> <span data-ttu-id="378d3-263">Diese Größenbeschränkung gilt für alle verwalteten Binärdateien.</span><span class="sxs-lookup"><span data-stu-id="378d3-263">This size limitation applies to all managed binaries.</span></span> <span data-ttu-id="378d3-264">Weitere Informationen finden Sie im [Blog](https://docs.microsoft.com/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) , in dem veranschaulicht wird, wie der Fehler beim Arbeiten mit umfangreichen und komplexen Modellen vermieden wird.</span><span class="sxs-lookup"><span data-stu-id="378d3-264">For more information see the [blog](https://docs.microsoft.com/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) that demonstrates how to avoid the error when working with large and complex models.</span></span>  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a><span data-ttu-id="378d3-265">Verwenden der NoTracking-Mergeoption für Abfragen</span><span class="sxs-lookup"><span data-stu-id="378d3-265">Consider using the NoTracking merge option for queries</span></span>  
 <span data-ttu-id="378d3-266">Das Nachverfolgen von zurückgegebenen Objekten im Objektkontext bringt Kosten mit sich.</span><span class="sxs-lookup"><span data-stu-id="378d3-266">There is a cost required to track returned objects in the object context.</span></span> <span data-ttu-id="378d3-267">Zur Ermittlung von Änderungen an Objekten und zur Gewährleistung, dass mehrere Anforderungen für die gleiche logische Entität die gleiche Objektinstanz zurückgeben, ist das Anfügen der Objekte an die <xref:System.Data.Objects.ObjectContext>-Instanz erforderlich.</span><span class="sxs-lookup"><span data-stu-id="378d3-267">Detecting changes to objects and ensuring that multiple requests for the same logical entity return the same object instance requires that objects be attached to an <xref:System.Data.Objects.ObjectContext> instance.</span></span> <span data-ttu-id="378d3-268">Wenn Sie nicht beabsichtigen, Objekte zu aktualisieren oder zu löschen, und keine Identitätsverwaltung erforderlich ist, sollten Sie beim Ausführen von Abfragen die <xref:System.Data.Objects.MergeOption.NoTracking> Merge-Optionen verwenden.</span><span class="sxs-lookup"><span data-stu-id="378d3-268">If you do not plan to make updates or deletes to objects and do not require identity management, consider using the <xref:System.Data.Objects.MergeOption.NoTracking> merge options when you execute queries.</span></span>  
  
#### <a name="return-the-correct-amount-of-data"></a><span data-ttu-id="378d3-269">Zurückgeben der richtigen Datenmenge</span><span class="sxs-lookup"><span data-stu-id="378d3-269">Return the correct amount of data</span></span>  
 <span data-ttu-id="378d3-270">In einigen Szenarien ist das Angeben eines Abfragepfads mithilfe der <xref:System.Data.Objects.ObjectQuery%601.Include%2A>-Methode viel schneller, da weniger Roundtrips zur Datenbank erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="378d3-270">In some scenarios, specifying a query path using the <xref:System.Data.Objects.ObjectQuery%601.Include%2A> method is much faster because it requires fewer round trips to the database.</span></span> <span data-ttu-id="378d3-271">Allerdings sind in anderen Szenarien zusätzliche Roundtrips zur Datenbank zum Laden von verknüpften Objekten ggf. schneller, da die einfacheren Abfragen mit weniger Joins weniger redundante Daten liefern.</span><span class="sxs-lookup"><span data-stu-id="378d3-271">However, in other scenarios, additional round trips to the database to load related objects may be faster because the simpler queries with fewer joins result in less redundancy of data.</span></span> <span data-ttu-id="378d3-272">Deswegen empfiehlt es sich, verschiedene Möglichkeiten zum Abrufen verknüpfter Objekte zu testen und so die leistungsfähigste Methode zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="378d3-272">Because of this, we recommend that you test the performance of various ways to retrieve related objects.</span></span> <span data-ttu-id="378d3-273">Weitere Informationen finden Sie unter [Laden verwandter Objekte](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-273">For more information, see [Loading Related Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
 <span data-ttu-id="378d3-274">Gliedern Sie die Abfrageergebnisse in überschaubare Gruppen, um zu vermeiden, dass zu viel Daten in einer einzelnen Abfrage zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="378d3-274">To avoid returning too much data in a single query, consider paging the results of the query into more manageable groups.</span></span> <span data-ttu-id="378d3-275">Weitere Informationen finden Sie unter Gewusst [wie: seitenweise durch Abfrageergebnisse](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-275">For more information, see [How to: Page Through Query Results](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a><span data-ttu-id="378d3-276">Einschränken des Bereichs des ObjectContext</span><span class="sxs-lookup"><span data-stu-id="378d3-276">Limit the scope of the ObjectContext</span></span>  
 <span data-ttu-id="378d3-277">In den meisten Fällen sollten Sie eine <xref:System.Data.Objects.ObjectContext>-Instanz innerhalb einer `using`-Anweisung (`Using…End Using` in Visual Basic) erstellen.</span><span class="sxs-lookup"><span data-stu-id="378d3-277">In most cases, you should create an <xref:System.Data.Objects.ObjectContext> instance within a `using` statement (`Using…End Using` in Visual Basic).</span></span> <span data-ttu-id="378d3-278">Dies kann die Leistung verbessern, da die dem Objektkontext zugeordneten Ressourcen automatisch freigegeben werden, wenn der Anweisungsblock vom Code beendet wird.</span><span class="sxs-lookup"><span data-stu-id="378d3-278">This can increase performance by ensuring that the resources associated with the object context are disposed automatically when the code exits the statement block.</span></span> <span data-ttu-id="378d3-279">Wenn Steuerelemente jedoch an vom Objektkontext verwaltete Objekte gebunden werden, sollte die <xref:System.Data.Objects.ObjectContext>-Instanz so lange beibehalten werden, bis die Bindung benötigt und manuell freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="378d3-279">However, when controls are bound to objects managed by the object context, the <xref:System.Data.Objects.ObjectContext> instance should be maintained as long as the binding is needed and disposed of manually.</span></span> <span data-ttu-id="378d3-280">Weitere Informationen finden Sie unter [Verwalten von Verbindungen und Transaktionen](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-280">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
#### <a name="consider-opening-the-database-connection-manually"></a><span data-ttu-id="378d3-281">Manuelles Öffnen der Datenbankverbindung</span><span class="sxs-lookup"><span data-stu-id="378d3-281">Consider opening the database connection manually</span></span>  
 <span data-ttu-id="378d3-282">Wenn Ihre Anwendung eine Reihe von Objekt Abfragen ausführt oder häufig <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> aufruft, um Erstellungs-, Aktualisierungs-und Löschvorgänge in der Datenquelle beizubehalten, muss der Entity Framework die Verbindung mit der Datenquelle fortlaufend öffnen und schließen.</span><span class="sxs-lookup"><span data-stu-id="378d3-282">When your application executes a series of object queries or frequently calls <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> to persist create, update, and delete operations to the data source, the Entity Framework must continuously open and close the connection to the data source.</span></span> <span data-ttu-id="378d3-283">Erwägen Sie in diesem Fall, die Verbindung am Start dieser Operationen manuell zu öffnen und die Verbindung zu schließen bzw. freizugeben, wenn die Vorgänge abgeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="378d3-283">In these situations, consider manually opening the connection at the start of these operations and either closing or disposing of the connection when the operations are complete.</span></span> <span data-ttu-id="378d3-284">Weitere Informationen finden Sie unter [Verwalten von Verbindungen und Transaktionen](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="378d3-284">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="performance-data"></a><span data-ttu-id="378d3-285">Leistungsdaten</span><span class="sxs-lookup"><span data-stu-id="378d3-285">Performance Data</span></span>  
 <span data-ttu-id="378d3-286">Einige Leistungsdaten für die Entity Framework werden in den folgenden Beiträgen im ADO.net- [Teamblog](https://docs.microsoft.com/archive/blogs/adonet/)veröffentlicht:</span><span class="sxs-lookup"><span data-stu-id="378d3-286">Some performance data for the Entity Framework is published in the following posts on the [ADO.NET team blog](https://docs.microsoft.com/archive/blogs/adonet/):</span></span>  
  
- [<span data-ttu-id="378d3-287">Untersuchen der Leistung des ADO.NET-Entity Framework-Teil 1</span><span class="sxs-lookup"><span data-stu-id="378d3-287">Exploring the Performance of the ADO.NET Entity Framework - Part 1</span></span>](https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1)  
  
- [<span data-ttu-id="378d3-288">Untersuchen der Leistung des ADO.NET-Entity Framework – Teil 2</span><span class="sxs-lookup"><span data-stu-id="378d3-288">Exploring the Performance of the ADO.NET Entity Framework – Part 2</span></span>](https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-2)  
  
- [<span data-ttu-id="378d3-289">ADO.NET Entity Framework Leistungsvergleich</span><span class="sxs-lookup"><span data-stu-id="378d3-289">ADO.NET Entity Framework Performance Comparison</span></span>](https://docs.microsoft.com/archive/blogs/adonet/ado-net-entity-framework-performance-comparison)  
  
## <a name="see-also"></a><span data-ttu-id="378d3-290">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="378d3-290">See also</span></span>

- [<span data-ttu-id="378d3-291">Überlegungen zur Entwicklung und Bereitstellung</span><span class="sxs-lookup"><span data-stu-id="378d3-291">Development and Deployment Considerations</span></span>](development-and-deployment-considerations.md)
