---
title: Abrufen von Identity- oder Autonumber-Werten
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: d6b7f9cb-81be-44e1-bb94-56137954876d
ms.openlocfilehash: ce3c888ce9e96d1f5768ce9cf3f3eef8cf8624e0
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 05/04/2018
ms.locfileid: "33357150"
---
# <a name="retrieving-identity-or-autonumber-values"></a><span data-ttu-id="1f86a-102">Abrufen von Identity- oder Autonumber-Werten</span><span class="sxs-lookup"><span data-stu-id="1f86a-102">Retrieving Identity or Autonumber Values</span></span>
<span data-ttu-id="1f86a-103">Ein Primärschlüssel in einer relationalen Datenbank ist eine Spalte oder eine Kombination aus Spalten, die stets eindeutige Werte enthält.</span><span class="sxs-lookup"><span data-stu-id="1f86a-103">A primary key in a relational database is a column or combination of columns that always contain unique values.</span></span> <span data-ttu-id="1f86a-104">Wenn Sie den Primärschlüsselwert kennen, können Sie die Zeile lokalisieren, die den Wert enthält.</span><span class="sxs-lookup"><span data-stu-id="1f86a-104">Knowing the primary key value allows you to locate the row that contains it.</span></span> <span data-ttu-id="1f86a-105">Relationale Datenbankmodule, wie SQL Server, Oracle und Microsoft Access/Jet, unterstützen das Erstellen automatisch inkrementierender Spalten, die als Primärschlüssel verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="1f86a-105">Relational database engines, such as SQL Server, Oracle, and Microsoft Access/Jet support the creation of automatically incrementing columns that can be designated as primary keys.</span></span> <span data-ttu-id="1f86a-106">Diese Werte werden vom Server generiert, wenn einer Tabelle Zeilen hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="1f86a-106">These values are generated by the server as rows are added to a table.</span></span> <span data-ttu-id="1f86a-107">In SQL Server legen Sie die Identität einer Spalte fest, in Oracle erstellen Sie eine Sequenz, und in Microsoft Access erstellen Sie eine AutoWert-Spalte.</span><span class="sxs-lookup"><span data-stu-id="1f86a-107">In SQL Server, you set the identity property of a column, in Oracle you create a Sequence, and in Microsoft Access you create an AutoNumber column.</span></span>  
  
 <span data-ttu-id="1f86a-108">Eine <xref:System.Data.DataColumn> kann durch Festlegen der <xref:System.Data.DataColumn.AutoIncrement%2A>-Eigenschaft auf <legacyBold>true</legacyBold> auch zum Generieren automatisch inkrementierender Werte verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1f86a-108">A <xref:System.Data.DataColumn> can also be used to generate automatically incrementing values by setting the <xref:System.Data.DataColumn.AutoIncrement%2A> property to true.</span></span> <span data-ttu-id="1f86a-109">Wenn aber mehrere Clientanwendungen unabhängig voneinander automatisch inkrementierende Werte generieren, kann es passieren, dass zum Schluss in getrennten Instanzen einer <xref:System.Data.DataTable> doppelte Werte vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="1f86a-109">However, you might end up with duplicate values in separate instances of a <xref:System.Data.DataTable>, if multiple client applications are independently generating automatically incrementing values.</span></span> <span data-ttu-id="1f86a-110">Wenn der Server angewiesen wird, automatisch inkrementierende Werte zu generieren, entfallen potenzielle Konflikte, weil jeder Benutzer für jede eingefügte Zeile den generierten Wert abrufen kann.</span><span class="sxs-lookup"><span data-stu-id="1f86a-110">Having the server generate automatically incrementing values eliminates potential conflicts by allowing each user to retrieve the generated value for each inserted row.</span></span>  
  
 <span data-ttu-id="1f86a-111">Bei einem Aufruf der `Update`-Methode eines `DataAdapter` kann die Datenbank Daten zurück an Ihre ADO.NET-Anwendung senden, und zwar entweder als Ausgabeparameter oder als ersten zurückgegebenen Datensatz des Resultsets einer SELECT-Anweisung, die im selben Batch wie die INSERT-Anweisung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1f86a-111">During a call to the `Update` method of a `DataAdapter`, the database can send data back to your ADO.NET application as output parameters or as the first returned record of the result set of a SELECT statement executed in the same batch as the INSERT statement.</span></span> <span data-ttu-id="1f86a-112">ADO.NET kann diese Werte abrufen und die entsprechenden Spalten in der zu aktualisierenden <xref:System.Data.DataRow> aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="1f86a-112">ADO.NET can retrieve these values and update the corresponding columns in the <xref:System.Data.DataRow> being updated.</span></span>  
  
 <span data-ttu-id="1f86a-113">Einige Datenbankmodule, z. B. das Microsoft Access Jet-Datenbankmodul, bieten keine Unterstützung für Ausgabeparameter und sind nicht in der Lage, mehrere Anweisungen in einem einzelnen Batch zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1f86a-113">Some database engines, such as the Microsoft Access Jet database engine, do not support output parameters and cannot process multiple statements in a single batch.</span></span> <span data-ttu-id="1f86a-114">Wenn Sie mit dem Jet-Datenbankmodul arbeiten, können Sie den neuen, für eine eingefügte Zeile generierten AutoWert-Wert abrufen, indem Sie in einem Ereignishandler für das `RowUpdated`-Ereignis des `DataAdapter` einen separaten SELECT-Befehl ausführen.</span><span class="sxs-lookup"><span data-stu-id="1f86a-114">When working with the Jet database engine, you can retrieve the new AutoNumber value generated for an inserted row by executing a separate SELECT command in an event handler for the `RowUpdated` event of the `DataAdapter`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1f86a-115">Statt automatisch inkrementierende Werte zu verwenden, können Sie auch mit der <xref:System.Guid.NewGuid%2A>-Methode eines <xref:System.Guid>-Objekts eine GUID auf dem Clientcomputer generieren, die jedes Mal, wenn eine neue Zeile eingefügt wird, auf den Server kopiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1f86a-115">An alternative to using an auto incrementing value is to use the <xref:System.Guid.NewGuid%2A> method of a <xref:System.Guid> object to generate a GUID, or globally unique identifier, on the client computer that can be copied to the server as each new row is inserted.</span></span> <span data-ttu-id="1f86a-116">Die `NewGuid`-Methode generiert einen 16-Byte-Binärwert, der mit einem Algorithmus erstellt wird, der dafür sorgt, dass mit hoher Wahrscheinlichkeit kein Wert doppelt vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="1f86a-116">The `NewGuid` method generates a 16-byte binary value that is created using an algorithm that provides a high probability that no value will be duplicated.</span></span> <span data-ttu-id="1f86a-117">In einer SQL Server-Datenbank werden GUIDs in einer `uniqueidentifier`-Spalte gespeichert, die SQL Server automatisch mit der Transact-SQL-`NEWID()`-Funktion generieren kann.</span><span class="sxs-lookup"><span data-stu-id="1f86a-117">In a SQL Server database, a GUID is stored in a `uniqueidentifier` column which SQL Server can automatically generate using the Transact-SQL `NEWID()` function.</span></span> <span data-ttu-id="1f86a-118">Die Verwendung einer GUID als Primärschlüssel kann zu Leistungseinbußen führen.</span><span class="sxs-lookup"><span data-stu-id="1f86a-118">Using a GUID as a primary key can adversely affect performance.</span></span> <span data-ttu-id="1f86a-119">SQL Server bietet Unterstützung für die `NEWSEQUENTIALID()` -Funktion, die eine sequenzielle GUID generiert, nicht globale Eindeutigkeit gewährleistet ist, aber effizienter indiziert werden können.</span><span class="sxs-lookup"><span data-stu-id="1f86a-119">SQL Server provides support for the `NEWSEQUENTIALID()` function, which generates a sequential GUID that is not guaranteed to be globally unique but that can be indexed more efficiently.</span></span>  
  
## <a name="retrieving-sql-server-identity-column-values"></a><span data-ttu-id="1f86a-120">Abrufen von SQL Server-Identitätsspaltenwerten</span><span class="sxs-lookup"><span data-stu-id="1f86a-120">Retrieving SQL Server Identity Column Values</span></span>  
 <span data-ttu-id="1f86a-121">Wenn Sie mit Microsoft SQL Server arbeiten, können Sie eine gespeicherte Prozedur mit einem Ausgabeparameter erstellen, um den Identitätswert für eine eingefügte Zeile zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="1f86a-121">When working with Microsoft SQL Server, you can create a stored procedure with an output parameter to return the identity value for an inserted row.</span></span> <span data-ttu-id="1f86a-122">In der folgenden Tabelle werden die drei Transact-SQL-Funktionen in SQL Server beschrieben, mit denen Werte aus Identitätsspalten abgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="1f86a-122">The following table describes the three Transact-SQL functions in SQL Server that can be used to retrieve identity column values.</span></span>  
  
|<span data-ttu-id="1f86a-123">Funktion</span><span class="sxs-lookup"><span data-stu-id="1f86a-123">Function</span></span>|<span data-ttu-id="1f86a-124">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="1f86a-124">Description</span></span>|  
|--------------|-----------------|  
|<span data-ttu-id="1f86a-125">SCOPE_IDENTITY</span><span class="sxs-lookup"><span data-stu-id="1f86a-125">SCOPE_IDENTITY</span></span>|<span data-ttu-id="1f86a-126">Gibt den letzten Identitätswert innerhalb des aktuellen Ausführungsbereichs zurück.</span><span class="sxs-lookup"><span data-stu-id="1f86a-126">Returns the last identity value within the current execution scope.</span></span> <span data-ttu-id="1f86a-127">SCOPE_IDENTITY empfiehlt sich für die meisten Szenarien.</span><span class="sxs-lookup"><span data-stu-id="1f86a-127">SCOPE_IDENTITY is recommended for most scenarios.</span></span>|  
|<span data-ttu-id="1f86a-128">@@IDENTITY</span><span class="sxs-lookup"><span data-stu-id="1f86a-128">@@IDENTITY</span></span>|<span data-ttu-id="1f86a-129">Enthält den letzten Identitätswert, der in einer der Tabellen in der aktuellen Sitzung generiert wurde.</span><span class="sxs-lookup"><span data-stu-id="1f86a-129">Contains the last identity value generated in any table in the current session.</span></span> <span data-ttu-id="1f86a-130">@@IDENTITY von Triggern beeinflusst werden können und möglicherweise nicht die Identitätswert, der Sie erwarten, dass zurück.</span><span class="sxs-lookup"><span data-stu-id="1f86a-130">@@IDENTITY can be affected by triggers and may not return the identity value that you expect.</span></span>|  
|<span data-ttu-id="1f86a-131">IDENT_CURRENT</span><span class="sxs-lookup"><span data-stu-id="1f86a-131">IDENT_CURRENT</span></span>|<span data-ttu-id="1f86a-132">Gibt den letzten Identitätswert zurück, der für eine bestimmte Tabelle in einer der Sitzungen und in einem der Bereiche generiert wurde.</span><span class="sxs-lookup"><span data-stu-id="1f86a-132">Returns the last identity value generated for a specific table in any session and any scope.</span></span>|  
  
 <span data-ttu-id="1f86a-133">Die folgende gespeicherte Prozedur wird veranschaulicht, wie zum Einfügen einer Zeile in der **Kategorien** Tabelle und einen Output-Parameter verwenden, die von der Transact-SQL SCOPE_IDENTITY()-Funktion generierten neue Identitätswert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="1f86a-133">The following stored procedure demonstrates how to insert a row into the **Categories** table and use an output parameter to return the new identity value generated by the Transact-SQL SCOPE_IDENTITY() function.</span></span>  
  
```  
CREATE PROCEDURE dbo.InsertCategory  
  @CategoryName nvarchar(15),  
  @Identity int OUT  
AS  
INSERT INTO Categories (CategoryName) VALUES(@CategoryName)  
SET @Identity = SCOPE_IDENTITY()  
```  
  
 <span data-ttu-id="1f86a-134">Die gespeicherte Prozedur kann dann als Quelle des <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> eines <xref:System.Data.SqlClient.SqlDataAdapter>-Objekts angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="1f86a-134">The stored procedure can then be specified as the source of the <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> of a <xref:System.Data.SqlClient.SqlDataAdapter> object.</span></span> <span data-ttu-id="1f86a-135">Die <xref:System.Data.SqlClient.SqlCommand.CommandType%2A>-Eigenschaft des <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> muss auf <xref:System.Data.CommandType.StoredProcedure> festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="1f86a-135">The <xref:System.Data.SqlClient.SqlCommand.CommandType%2A> property of the <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> must be set to <xref:System.Data.CommandType.StoredProcedure>.</span></span> <span data-ttu-id="1f86a-136">Die Identitätsausgabe wird abgerufen, indem ein <xref:System.Data.SqlClient.SqlParameter> mit dem <xref:System.Data.ParameterDirection>-Wert <xref:System.Data.ParameterDirection.Output> erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="1f86a-136">The identity output is retrieved by creating a <xref:System.Data.SqlClient.SqlParameter> that has a <xref:System.Data.ParameterDirection> of <xref:System.Data.ParameterDirection.Output>.</span></span> <span data-ttu-id="1f86a-137">Bei der `InsertCommand` wird verarbeitet, der automatisch inkrementierende Identitätswert zurückgegeben und platziert Sie der **CategoryID** Spalte der aktuellen Zeile, wenn Sie festlegen, die <xref:System.Data.SqlClient.SqlCommand.UpdatedRowSource%2A> -Eigenschaft des Einfügebefehls auf `UpdateRowSource.OutputParameters` oder `UpdateRowSource.Both`.</span><span class="sxs-lookup"><span data-stu-id="1f86a-137">When the `InsertCommand` is processed, the auto-incremented identity value is returned and placed in the **CategoryID** column of the current row if you set the <xref:System.Data.SqlClient.SqlCommand.UpdatedRowSource%2A> property of the insert command to `UpdateRowSource.OutputParameters` or to `UpdateRowSource.Both`.</span></span>  
  
 <span data-ttu-id="1f86a-138">Wenn Ihr Einfügebefehl einen Batch ausführt, der sowohl eine INSERT-Anweisung als auch eine SELECT-Anweisung enthält, die den neuen Identitätswert zurückgibt, können Sie den neuen Wert abrufen, indem Sie für die `UpdatedRowSource`-Eigenschaft des Einfügebefehls den Wert `UpdateRowSource.FirstReturnedRecord` festlegen.</span><span class="sxs-lookup"><span data-stu-id="1f86a-138">If your insert command executes a batch that includes both an INSERT statement and a SELECT statement that returns the new identity value, then you can retrieve the new value by setting the `UpdatedRowSource` property of the insert command to `UpdateRowSource.FirstReturnedRecord`.</span></span>  
  
 [!code-csharp[DataWorks SqlClient.RetrieveIdentityStoredProcedure#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.RetrieveIdentityStoredProcedure/CS/source.cs#1)]
 [!code-vb[DataWorks SqlClient.RetrieveIdentityStoredProcedure#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.RetrieveIdentityStoredProcedure/VB/source.vb#1)]  
  
## <a name="merging-new-identity-values"></a><span data-ttu-id="1f86a-139">Zusammenführen neuer Identitätswerte</span><span class="sxs-lookup"><span data-stu-id="1f86a-139">Merging New Identity Values</span></span>  
 <span data-ttu-id="1f86a-140">Häufig wird die `GetChanges`-Methode einer `DataTable` verwendet, um eine Kopie zu erstellen, die nur geänderte Zeilen enthält. Beim Aufrufen der `Update`-Methode eines `DataAdapter` kommt dann die neue Kopie zum Einsatz.</span><span class="sxs-lookup"><span data-stu-id="1f86a-140">A common scenario is to call the `GetChanges` method of a `DataTable` to create a copy that contains only changed rows, and to use the new copy when calling the `Update` method of a `DataAdapter`.</span></span> <span data-ttu-id="1f86a-141">Diese Vorgehensweise ist vor allem dann sinnvoll, wenn Sie die geänderten Zeilen in eine separate Komponente marshallen müssen, die das Update ausführt.</span><span class="sxs-lookup"><span data-stu-id="1f86a-141">This is especially useful when you need to marshal the changed rows to a separate component that performs the update.</span></span> <span data-ttu-id="1f86a-142">Im Anschluss an das Update kann die Kopie die neuen Identitätswerte enthalten, die dann in der ursprünglichen `DataTable` wieder zusammengeführt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="1f86a-142">Following the update, the copy can contain new identity values that must then be merged back into the original `DataTable`.</span></span> <span data-ttu-id="1f86a-143">Die neuen Identitätswerte weichen wahrscheinlich von den ursprünglichen Werten in der `DataTable` ab.</span><span class="sxs-lookup"><span data-stu-id="1f86a-143">The new identity values are likely to be different from the original values in the `DataTable`.</span></span> <span data-ttu-id="1f86a-144">Das Zusammenführen, die ursprünglichen Werte der Durchführung der **AutoIncrement** Spalten in der Kopie beibehalten werden müssen, damit Sie zum Auffinden und aktualisieren die vorhandene Zeilen in der ursprünglichen `DataTable`, neue Zeilen mit angehängt die neuen Identitätswerte.</span><span class="sxs-lookup"><span data-stu-id="1f86a-144">To accomplish the merge, the original values of the **AutoIncrement** columns in the copy must be preserved, in order to be able to locate and update existing rows in the original `DataTable`, rather than appending new rows containing the new identity values.</span></span> <span data-ttu-id="1f86a-145">Standardmäßig gehen diese ursprünglichen Werte aber nach einem Aufruf der `Update`-Methode eines `DataAdapter` verloren, weil für jede aktualisierte `AcceptChanges` implizit `DataRow` aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1f86a-145">However, by default those original values are lost after a call to the `Update` method of a `DataAdapter`, because `AcceptChanges` is implicitly called for each updated `DataRow`.</span></span>  
  
 <span data-ttu-id="1f86a-146">Zum Beibehalten der ursprünglichen Werte einer `DataColumn` in einer `DataRow` während eines `DataAdapter`-Updates gibt es die folgenden beiden Möglichkeiten:</span><span class="sxs-lookup"><span data-stu-id="1f86a-146">There are two ways to preserve the original values of a `DataColumn` in a `DataRow` during a `DataAdapter` update:</span></span>  
  
-   <span data-ttu-id="1f86a-147">Die erste Methode besteht darin, für die `AcceptChangesDuringUpdate`-Eigenschaft des `DataAdapter` `false` festzulegen.</span><span class="sxs-lookup"><span data-stu-id="1f86a-147">The first method of preserving the original values is to set the `AcceptChangesDuringUpdate` property of the `DataAdapter` to `false`.</span></span> <span data-ttu-id="1f86a-148">Dies wirkt sich auf jede `DataRow` in der zu aktualisierenden `DataTable` aus.</span><span class="sxs-lookup"><span data-stu-id="1f86a-148">This affects every `DataRow` in the `DataTable` being updated.</span></span> <span data-ttu-id="1f86a-149">Weitere Informationen sowie ein Codebeispiel finden Sie unter <xref:System.Data.Common.DataAdapter.AcceptChangesDuringUpdate%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f86a-149">For more information and a code example, see <xref:System.Data.Common.DataAdapter.AcceptChangesDuringUpdate%2A>.</span></span>  
  
-   <span data-ttu-id="1f86a-150">Die zweite Methode besteht darin, Code im `RowUpdated`-Ereignishandler des `DataAdapter` zu schreiben und damit den <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> auf <xref:System.Data.UpdateStatus.SkipCurrentRow> zu setzen.</span><span class="sxs-lookup"><span data-stu-id="1f86a-150">The second method is to write code in the `RowUpdated` event handler of the `DataAdapter` to set the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> to <xref:System.Data.UpdateStatus.SkipCurrentRow>.</span></span> <span data-ttu-id="1f86a-151">Die `DataRow` wird zwar aktualisiert, aber die einzelnen ursprünglichen `DataColumn`-Werte bleiben erhalten.</span><span class="sxs-lookup"><span data-stu-id="1f86a-151">The `DataRow` is updated but the original value of each `DataColumn` is preserved.</span></span> <span data-ttu-id="1f86a-152">Diese Methode ermöglicht es Ihnen, die ursprünglichen Werte für einige Zeilen beizubehalten und für andere nicht.</span><span class="sxs-lookup"><span data-stu-id="1f86a-152">This method enables you to preserve the original values for some rows and not for others.</span></span> <span data-ttu-id="1f86a-153">Ihr Code kann z. B. die ursprünglichen Werte für hinzugefügte Zeilen beibehalten, während die ursprünglichen Werte für bearbeitete oder gelöschte Zeilen verloren gehen, indem er zunächst den <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> prüft und dann den <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> nur für die Zeilen mit dem <xref:System.Data.UpdateStatus.SkipCurrentRow> `StatementType` auf `Insert` setzt.</span><span class="sxs-lookup"><span data-stu-id="1f86a-153">For example, your code can preserve the original values for added rows and not for edited or deleted rows by first checking the <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> and then setting <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> to <xref:System.Data.UpdateStatus.SkipCurrentRow> only for rows with a `StatementType` of `Insert`.</span></span>  
  
 <span data-ttu-id="1f86a-154">Wenn bei einem `DataRow`-Update eine dieser beiden Methoden zur Beibehaltung von ursprünglichen Werten in einer `DataAdapter` verwendet wird, führt ADO.NET eine Reihe von Aktionen aus, um die aktuellen `DataRow`-Werte auf die neuen Werte zu setzen, die von Ausgabeparametern oder der ersten zurückgegebenen Zeile eines Resultsets zurückgegeben werden. Die einzelnen ursprünglichen `DataColumn`-Werte bleiben dabei erhalten.</span><span class="sxs-lookup"><span data-stu-id="1f86a-154">When either of these methods is used to preserve original values in a `DataRow` during a `DataAdapter` update, ADO.NET performs a series of actions to set the current values of the `DataRow` to new values returned by output parameters or by the first returned row of a result set, while still preserving the original value in each `DataColumn`.</span></span> <span data-ttu-id="1f86a-155">Als Erstes wird die `AcceptChanges`-Methode der `DataRow` aufgerufen, um die aktuellen Werte als ursprüngliche Werte beizubehalten. Anschließend werden die neuen Werte zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="1f86a-155">First, the `AcceptChanges` method of the `DataRow` is called to preserve the current values as original values, and then the new values are assigned.</span></span> <span data-ttu-id="1f86a-156">Als Nächstes wird bei `DataRows`, deren <xref:System.Data.DataRow.RowState%2A>-Eigenschaft den Wert <xref:System.Data.DataRowState.Added> hat, der `RowState`-Wert in <xref:System.Data.DataRowState.Modified> geändert, was u. U. nicht den Erwartungen entspricht.</span><span class="sxs-lookup"><span data-stu-id="1f86a-156">Following these actions, `DataRows` that had their <xref:System.Data.DataRow.RowState%2A> property set to <xref:System.Data.DataRowState.Added> will have their `RowState` property set to <xref:System.Data.DataRowState.Modified>, which may be unexpected.</span></span>  
  
 <span data-ttu-id="1f86a-157">Wie die Befehlsergebnisse auf jede zu aktualisierende <xref:System.Data.DataRow> angewendet werden, richtet sich nach der <xref:System.Data.Common.DbCommand.UpdatedRowSource%2A>-Eigenschaft des jeweiligen <xref:System.Data.Common.DbCommand>.</span><span class="sxs-lookup"><span data-stu-id="1f86a-157">How the command results are applied to each <xref:System.Data.DataRow> being updated is determined by the <xref:System.Data.Common.DbCommand.UpdatedRowSource%2A> property of each <xref:System.Data.Common.DbCommand>.</span></span> <span data-ttu-id="1f86a-158">Diese Eigenschaft wird auf einen Wert aus der `UpdateRowSource`-Enumeration festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1f86a-158">This property is set to a value from the `UpdateRowSource` enumeration.</span></span>  
  
 <span data-ttu-id="1f86a-159">Die folgende Tabelle zeigt, wie sich die `UpdateRowSource`-Enumerationswerte auf die <xref:System.Data.DataRow.RowState%2A>-Eigenschaft aktualisierter Zeilen auswirken.</span><span class="sxs-lookup"><span data-stu-id="1f86a-159">The following table describes how the `UpdateRowSource` enumeration values affect the <xref:System.Data.DataRow.RowState%2A> property of updated rows.</span></span>  
  
|<span data-ttu-id="1f86a-160">Membername</span><span class="sxs-lookup"><span data-stu-id="1f86a-160">Member name</span></span>|<span data-ttu-id="1f86a-161">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="1f86a-161">Description</span></span>|  
|-----------------|-----------------|  
|<xref:System.Data.UpdateRowSource.Both>|<span data-ttu-id="1f86a-162">`AcceptChanges` wird aufgerufen, und die Ausgabeparameterwerte und/oder die Werte der ersten Zeile aller zurückgegebenen Resultsets werden in der zu aktualisierenden `DataRow` platziert.</span><span class="sxs-lookup"><span data-stu-id="1f86a-162">`AcceptChanges` is called and both output parameter values and/or the values in the first row of any returned result set are placed in the `DataRow` being updated.</span></span> <span data-ttu-id="1f86a-163">Wenn es keine zu übernehmenden Werte gibt, lautet der `RowState` <xref:System.Data.DataRowState.Unchanged>.</span><span class="sxs-lookup"><span data-stu-id="1f86a-163">If there are no values to apply, the `RowState` will be <xref:System.Data.DataRowState.Unchanged>.</span></span>|  
|<xref:System.Data.UpdateRowSource.FirstReturnedRecord>|<span data-ttu-id="1f86a-164">Wenn eine Zeile zurückgegeben wurde, wird `AcceptChanges` aufgerufen und die Zeile wird der geänderten Zeile in der `DataTable` zugeordnet, wobei der `RowState` auf `Modified` gesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="1f86a-164">If a row was returned, `AcceptChanges` is called and the row is mapped to the changed row in the `DataTable`, setting the `RowState` to `Modified`.</span></span> <span data-ttu-id="1f86a-165">Wenn keine Zeile zurückgegeben wird, wird `AcceptChanges` nicht aufgerufen, und der `RowState` bleibt `Added`.</span><span class="sxs-lookup"><span data-stu-id="1f86a-165">If no row is returned, then `AcceptChanges` is not called and the `RowState` remains `Added`.</span></span>|  
|<xref:System.Data.UpdateRowSource.None>|<span data-ttu-id="1f86a-166">Alle zurückgegebenen Parameter oder Zeilen werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="1f86a-166">Any returned parameters or rows are ignored.</span></span> <span data-ttu-id="1f86a-167">`AcceptChanges` wird nicht aufgerufen, und der `RowState` bleibt `Added`.</span><span class="sxs-lookup"><span data-stu-id="1f86a-167">There is no call to `AcceptChanges` and the `RowState` remains `Added`.</span></span>|  
|<xref:System.Data.UpdateRowSource.OutputParameters>|<span data-ttu-id="1f86a-168">`AcceptChanges` wird aufgerufen, und alle Ausgabeparameter werden der geänderten Zeile in der `DataTable` zugeordnet, wobei der `RowState` auf `Modified` gesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="1f86a-168">`AcceptChanges` is called and any output parameters are mapped to the changed row in the `DataTable`, setting the `RowState` to `Modified`.</span></span> <span data-ttu-id="1f86a-169">Wenn keine Ausgabeparameter vorhanden sind, lautet der `RowState` `Unchanged`.</span><span class="sxs-lookup"><span data-stu-id="1f86a-169">If there are no output parameters, the `RowState` will be `Unchanged`.</span></span>|  
  
### <a name="example"></a><span data-ttu-id="1f86a-170">Beispiel</span><span class="sxs-lookup"><span data-stu-id="1f86a-170">Example</span></span>  
 <span data-ttu-id="1f86a-171">Dieses Beispiel zeigt das Extrahieren geänderter Zeilen aus einer `DataTable` und das Verwenden eines <xref:System.Data.SqlClient.SqlDataAdapter>, um die Datenquelle zu aktualisieren und einen neuen Wert aus der Identitätsspalte abzurufen.</span><span class="sxs-lookup"><span data-stu-id="1f86a-171">This example demonstrates extracting changed rows from a `DataTable` and using a <xref:System.Data.SqlClient.SqlDataAdapter> to update the data source and retrieve a new identity column value.</span></span> <span data-ttu-id="1f86a-172">Der <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> führt zwei Transact-SQL-Anweisungen aus: Die erste Anweisung ist die INSERT-Anweisung, und die zweite Anweisung ist eine SELECT-Anweisung, die zum Abrufen des Identitätswerts die Funktion SCOPE_IDENTITY verwendet.</span><span class="sxs-lookup"><span data-stu-id="1f86a-172">The <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> executes two Transact-SQL statements; the first one is the INSERT statement, and the second one is a SELECT statement that uses the SCOPE_IDENTITY function to retrieve the identity value.</span></span>  
  
```  
INSERT INTO dbo.Shippers (CompanyName)   
VALUES (@CompanyName);  
SELECT ShipperID, CompanyName FROM dbo.Shippers   
WHERE ShipperID = SCOPE_IDENTITY();  
```  
  
 <span data-ttu-id="1f86a-173">Die `UpdatedRowSource`-Eigenschaft des Einfügebefehls wird auf `UpdateRowSource.FirstReturnedRow` gesetzt, und die <xref:System.Data.MissingSchemaAction>-Eigenschaft des `DataAdapter` wird auf `MissingSchemaAction.AddWithKey` gesetzt.</span><span class="sxs-lookup"><span data-stu-id="1f86a-173">The `UpdatedRowSource` property of the insert command is set to `UpdateRowSource.FirstReturnedRow` and the <xref:System.Data.MissingSchemaAction> property of the `DataAdapter` is set to `MissingSchemaAction.AddWithKey`.</span></span> <span data-ttu-id="1f86a-174">Die `DataTable` wird gefüllt, und der Code fügt der `DataTable` eine neue Zeile hinzu.</span><span class="sxs-lookup"><span data-stu-id="1f86a-174">The `DataTable` is filled and the code adds a new row to the `DataTable`.</span></span> <span data-ttu-id="1f86a-175">Die geänderten Zeilen werden dann in eine neue `DataTable` extrahiert, die an den `DataAdapter` übergeben wird, der dann wiederum den Server aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="1f86a-175">The changed rows are then extracted into a new `DataTable`, which is passed to the `DataAdapter`, which then updates the server.</span></span>  
  
 [!code-csharp[DataWorks SqlClient.MergeIdentity#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/CS/source.cs#1)]
 [!code-vb[DataWorks SqlClient.MergeIdentity#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/VB/source.vb#1)]  
  
 <span data-ttu-id="1f86a-176">Der `OnRowUpdated`-Ereignishandler prüft den <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> der <xref:System.Data.SqlClient.SqlRowUpdatedEventArgs>, um festzustellen, ob es sich bei der Zeile um eine Einfügung handelt.</span><span class="sxs-lookup"><span data-stu-id="1f86a-176">The `OnRowUpdated` event handler checks the <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> of the <xref:System.Data.SqlClient.SqlRowUpdatedEventArgs> to determine if the row is an insert.</span></span> <span data-ttu-id="1f86a-177">Wenn ja, wird die <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>-Eigenschaft auf <xref:System.Data.UpdateStatus.SkipCurrentRow> gesetzt.</span><span class="sxs-lookup"><span data-stu-id="1f86a-177">If it is, then the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> property is set to <xref:System.Data.UpdateStatus.SkipCurrentRow>.</span></span> <span data-ttu-id="1f86a-178">Die Zeile wird aktualisiert, aber die ursprünglichen Werte in der Zeile werden beibehalten.</span><span class="sxs-lookup"><span data-stu-id="1f86a-178">The row is updated, but the original values in the row are preserved.</span></span> <span data-ttu-id="1f86a-179">Im Hauptteil der Prozedur wird die <xref:System.Data.DataSet.Merge%2A>-Methode aufgerufen, um den neuen Identitätswert in der ursprünglichen `DataTable` zusammenzuführen. Zum Schluss wird die `AcceptChanges`-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1f86a-179">In the main body of the procedure, the <xref:System.Data.DataSet.Merge%2A> method is called to merge the new identity value into the original `DataTable`, and finally `AcceptChanges` is called.</span></span>  
  
 [!code-csharp[DataWorks SqlClient.MergeIdentity#2](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/CS/source.cs#2)]
 [!code-vb[DataWorks SqlClient.MergeIdentity#2](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/VB/source.vb#2)]  
  
## <a name="retrieving-microsoft-access-autonumber-values"></a><span data-ttu-id="1f86a-180">Abrufen von Microsoft Access-AutoWert-Werten</span><span class="sxs-lookup"><span data-stu-id="1f86a-180">Retrieving Microsoft Access Autonumber Values</span></span>  
 <span data-ttu-id="1f86a-181">Dieser Abschnitt enthält ein Beispiel, das die Vorgehensweise beim Abrufen von `Autonumber`-Werten aus einer Jet 4.0-Datenbank zeigt.</span><span class="sxs-lookup"><span data-stu-id="1f86a-181">This section includes a sample that shows how to retrieve `Autonumber` values from a Jet 4.0 database.</span></span> <span data-ttu-id="1f86a-182">Das Jet-Datenbankmodul bietet keine Unterstützung für die Ausführung mehrerer Anweisungen in einem Batch oder für die Verwendung von Ausgabeparametern. Es ist daher nicht möglich, mit einer der beiden Möglichkeiten den neuen `Autonumber`-Wert zurückzugeben, der einer eingefügten Zeile zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="1f86a-182">The Jet database engine does not support the execution of multiple statements in a batch or the use of output parameters, so it is not possible to use either of these techniques to return the new `Autonumber` value assigned to an inserted row.</span></span> <span data-ttu-id="1f86a-183">Allerdings können Sie Code zum Hinzufügen der `RowUpdated` Ereignishandler, der eine separate SELECT @ führt@IDENTITY Anweisung zum Abrufen des neuen `Autonumber` Wert.</span><span class="sxs-lookup"><span data-stu-id="1f86a-183">However, you can add code to the `RowUpdated` event handler that executes a separate SELECT @@IDENTITY statement to retrieve the new `Autonumber` value.</span></span>  
  
### <a name="example"></a><span data-ttu-id="1f86a-184">Beispiel</span><span class="sxs-lookup"><span data-stu-id="1f86a-184">Example</span></span>  
 <span data-ttu-id="1f86a-185">Statt mit `MissingSchemaAction.AddWithKey` Schemainformationen hinzuzufügen, konfiguriert dieses Beispiel eine `DataTable` mit dem korrekten Schema, bevor der <xref:System.Data.OleDb.OleDbDataAdapter> zum Füllen der `DataTable` aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1f86a-185">Instead of adding schema information using `MissingSchemaAction.AddWithKey`, this example configures a `DataTable` with the correct schema prior to calling the <xref:System.Data.OleDb.OleDbDataAdapter> to fill the `DataTable`.</span></span> <span data-ttu-id="1f86a-186">In diesem Fall die **CategoryID** Spalte ist so konfiguriert, dass um jede eingefügten Zeile beginnend mit 0 (null), durch Festlegen von zugewiesenen Wert zu verringern <xref:System.Data.DataColumn.AutoIncrement%2A> auf `true`, <xref:System.Data.DataColumn.AutoIncrementSeed%2A> auf 0 (null) und <xref:System.Data.DataColumn.AutoIncrementStep%2A> auf-1 festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1f86a-186">In this case, the **CategoryID** column is configured to decrement the value assigned each inserted row starting from zero, by setting <xref:System.Data.DataColumn.AutoIncrement%2A> to `true`, <xref:System.Data.DataColumn.AutoIncrementSeed%2A> to 0, and <xref:System.Data.DataColumn.AutoIncrementStep%2A> to -1.</span></span> <span data-ttu-id="1f86a-187">Der Code fügt dann zwei neue Zeilen hinzu und verwendet `GetChanges`, um die geänderten Zeilen einer neuen `DataTable` hinzuzufügen, die an die `Update`-Methode übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="1f86a-187">The code then adds two new rows and uses `GetChanges` to add the changed rows to a new `DataTable` that is passed to the `Update` method.</span></span>  
  
 [!code-csharp[DataWorks OleDb.JetAutonumberMerge#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/CS/source.cs#1)]
 [!code-vb[DataWorks OleDb.JetAutonumberMerge#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/VB/source.vb#1)]  
  
 <span data-ttu-id="1f86a-188">Der `RowUpdated`-Ereignishandler verwendet dieselbe geöffnete <xref:System.Data.OleDb.OleDbConnection> wie die `Update`-Anweisung des `OleDbDataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="1f86a-188">The `RowUpdated` event handler uses the same open <xref:System.Data.OleDb.OleDbConnection> as the `Update` statement of the `OleDbDataAdapter`.</span></span> <span data-ttu-id="1f86a-189">Er prüft den `StatementType` der <xref:System.Data.OleDb.OleDbRowUpdatedEventArgs> auf eingefügte Zeilen.</span><span class="sxs-lookup"><span data-stu-id="1f86a-189">It checks the `StatementType` of the <xref:System.Data.OleDb.OleDbRowUpdatedEventArgs> for inserted rows.</span></span> <span data-ttu-id="1f86a-190">Für jede eingefügte Zeile wird ein neuer <xref:System.Data.OleDb.OleDbCommand> wird erstellt, um das Ausführen der SELECT @@IDENTITY -Anweisung für die Verbindung, die neue zurückgeben `Autonumber` -Wert, der in der befindet der **CategoryID** Spalte die `DataRow`.</span><span class="sxs-lookup"><span data-stu-id="1f86a-190">For each inserted row a new <xref:System.Data.OleDb.OleDbCommand> is created to execute the SELECT @@IDENTITY statement on the connection, returning the new `Autonumber` value, which is placed in the **CategoryID** column of the `DataRow`.</span></span> <span data-ttu-id="1f86a-191">Die `Status`-Eigenschaft wird dann auf `UpdateStatus.SkipCurrentRow` gesetzt, um den versteckten Aufruf von `AcceptChanges` zu unterdrücken.</span><span class="sxs-lookup"><span data-stu-id="1f86a-191">The `Status` property is then set to `UpdateStatus.SkipCurrentRow` to suppress the hidden call to `AcceptChanges`.</span></span> <span data-ttu-id="1f86a-192">Im Hauptteil der Prozedur wird die `Merge`-Methode aufgerufen, um die beiden `DataTable`-Objekte zusammenzuführen. Zum Schluss erfolgt ein Aufruf der `AcceptChanges`-Methode.</span><span class="sxs-lookup"><span data-stu-id="1f86a-192">In the main body of the procedure, the `Merge` method is called to merge the two `DataTable` objects, and finally `AcceptChanges` is called.</span></span>  
  
 [!code-csharp[DataWorks OleDb.JetAutonumberMerge#2](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/CS/source.cs#2)]
 [!code-vb[DataWorks OleDb.JetAutonumberMerge#2](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/VB/source.vb#2)]  
  
### <a name="retrieving-identity-values"></a><span data-ttu-id="1f86a-193">Abrufen von Identitätswerten</span><span class="sxs-lookup"><span data-stu-id="1f86a-193">Retrieving Identity Values</span></span>  
 <span data-ttu-id="1f86a-194">Wir legen häufig die Spalte als Identität fest, wenn die Werte in der Spalte eindeutig sein müssen.</span><span class="sxs-lookup"><span data-stu-id="1f86a-194">We often set the column as identity when the values in the column must be unique.</span></span> <span data-ttu-id="1f86a-195">Und manchmal brauchen wir den Identitätswert neuer Daten.</span><span class="sxs-lookup"><span data-stu-id="1f86a-195">And sometimes we need the identity value of new data.</span></span> <span data-ttu-id="1f86a-196">In diesem Beispiel wird veranschaulicht, wie Sie Identitätswerte abrufen:</span><span class="sxs-lookup"><span data-stu-id="1f86a-196">This sample demonstrates how to retrieve identity values:</span></span>  
  
-   <span data-ttu-id="1f86a-197">Erstellt eine gespeichertes Verfahren, um Daten einzufügen und einen Identitätswert zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="1f86a-197">Creates a stored procedure to insert data and return an identity value.</span></span>  
  
-   <span data-ttu-id="1f86a-198">Führt einen Befehl zum Einfügen der neuen Daten und zum Anzeigen des Ergebnisses aus</span><span class="sxs-lookup"><span data-stu-id="1f86a-198">Executes a command to insert the new data and display the result.</span></span>  
  
-   <span data-ttu-id="1f86a-199">Verwendet <xref:System.Data.SqlClient.SqlDataAdapter>, um neue Daten einzufügen und das Ergebnis anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="1f86a-199">Uses <xref:System.Data.SqlClient.SqlDataAdapter> to insert new data and display the result.</span></span>  
  
 <span data-ttu-id="1f86a-200">Vor dem Kompilieren und Ausführen des Beispiels müssen Sie die Beispieldatenbank mithilfe des folgenden Skripts erstellen:</span><span class="sxs-lookup"><span data-stu-id="1f86a-200">Before you compile and run the sample, you must create the sample database, using the following script:</span></span>  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE procedure [dbo].[CourseExtInfo] @CourseId int  
as  
select c.CourseID,c.Title,c.Credits,d.Name as DepartmentName  
from Course as c left outer join Department as d on c.DepartmentID=d.DepartmentID  
where c.CourseID=@CourseId  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
create procedure [dbo].[DepartmentInfo] @DepartmentId int,@CourseCount int output  
as  
select @CourseCount=Count(c.CourseID)  
from course as c  
where c.DepartmentID=@DepartmentId  
  
select d.DepartmentID,d.Name,d.Budget,d.StartDate,d.Administrator  
from Department as d  
where d.DepartmentID=@DepartmentId  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
Create PROCEDURE [dbo].[GetDepartmentsOfSpecifiedYear]   
@Year int,@BudgetSum money output  
AS  
BEGIN  
        SELECT @BudgetSum=SUM([Budget])  
  FROM [MySchool].[dbo].[Department]  
  Where YEAR([StartDate])=@Year   
  
SELECT [DepartmentID]  
      ,[Name]  
      ,[Budget]  
      ,[StartDate]  
      ,[Administrator]  
  FROM [MySchool].[dbo].[Department]  
  Where YEAR([StartDate])=@Year  
  
END  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE PROCEDURE [dbo].[GradeOfStudent]   
-- Add the parameters for the stored procedure here  
@CourseTitle nvarchar(100),@FirstName nvarchar(50),  
@LastName nvarchar(50),@Grade decimal(3,2) output  
AS  
BEGIN  
select @Grade=Max(Grade)  
from [dbo].[StudentGrade] as s join [dbo].[Course] as c on   
s.CourseID=c.CourseID join [dbo].[Person] as p on s.StudentID=p.PersonID  
where c.Title=@CourseTitle and p.FirstName=@FirstName   
and p.LastName= @LastName  
END  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE PROCEDURE [dbo].[InsertPerson]   
-- Add the parameters for the stored procedure here  
@FirstName nvarchar(50),@LastName nvarchar(50),  
@PersonID int output  
AS  
BEGIN  
    insert [dbo].[Person](LastName,FirstName) Values(@LastName,@FirstName)  
  
    set @PersonID=SCOPE_IDENTITY()  
END  
Go  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED  
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED  
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
SET ANSI_PADDING ON  
GO  
CREATE TABLE [dbo].[Person]([PersonID] [int] IDENTITY(1,1) NOT NULL,  
[LastName] [nvarchar](50) NOT NULL,  
[FirstName] [nvarchar](50) NOT NULL,  
[HireDate] [datetime] NULL,  
[EnrollmentDate] [datetime] NULL,  
[Picture] [varbinary](max) NULL,  
 CONSTRAINT [PK_School.Student] PRIMARY KEY CLUSTERED  
(  
[PersonID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[StudentGrade]([EnrollmentID] [int] IDENTITY(1,1) NOT NULL,  
[CourseID] [nvarchar](10) NOT NULL,  
[StudentID] [int] NOT NULL,  
[Grade] [decimal](3, 2) NOT NULL,  
 CONSTRAINT [PK_StudentGrade] PRIMARY KEY CLUSTERED  
(  
[EnrollmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
create view [dbo].[EnglishCourse]  
as  
select c.CourseID,c.Title,c.Credits,c.DepartmentID  
from Course as c join Department as d on c.DepartmentID=d.DepartmentID  
where d.Name=N'English'  
  
GO  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
SET IDENTITY_INSERT [dbo].[Person] ON   
  
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (1, N'Hu', N'Nan', NULL, CAST(0x0000A0BF00000000 AS DateTime))  
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (2, N'Norman', N'Laura', NULL, CAST(0x0000A0BF00000000 AS DateTime))  
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (3, N'Olivotto', N'Nino', NULL, CAST(0x0000A0BF00000000 AS DateTime))  
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (4, N'Anand', N'Arturo', NULL, CAST(0x0000A0BF00000000 AS DateTime))  
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (5, N'Jai', N'Damien', NULL, CAST(0x0000A0BF00000000 AS DateTime))  
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (6, N'Holt', N'Roger', CAST(0x000097F100000000 AS DateTime), NULL)  
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (7, N'Martin', N'Randall', CAST(0x00008B1A00000000 AS DateTime), NULL)  
SET IDENTITY_INSERT [dbo].[Person] OFF  
SET IDENTITY_INSERT [dbo].[StudentGrade] ON   
  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (1, N'C1045', 1, CAST(3.50 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (2, N'C1045', 2, CAST(3.00 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (3, N'C1045', 3, CAST(2.50 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (4, N'C1045', 4, CAST(4.00 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (5, N'C1045', 5, CAST(3.50 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (6, N'C1061', 1, CAST(4.00 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (7, N'C1061', 3, CAST(3.50 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (8, N'C1061', 4, CAST(2.50 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (9, N'C1061', 5, CAST(1.50 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (10, N'C2021', 1, CAST(2.50 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (11, N'C2021', 2, CAST(3.50 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (12, N'C2021', 4, CAST(3.00 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (13, N'C2021', 5, CAST(3.00 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (14, N'C2042', 1, CAST(2.00 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (15, N'C2042', 2, CAST(3.50 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (16, N'C2042', 3, CAST(4.00 AS Decimal(3, 2)))  
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (17, N'C2042', 5, CAST(3.00 AS Decimal(3, 2)))  
SET IDENTITY_INSERT [dbo].[StudentGrade] OFF  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
ALTER TABLE [dbo].[StudentGrade]  WITH CHECK ADD  CONSTRAINT [FK_StudentGrade_Student] FOREIGN KEY([StudentID])  
REFERENCES [dbo].[Person] ([PersonID])  
GO  
ALTER TABLE [dbo].[StudentGrade] CHECK CONSTRAINT [FK_StudentGrade_Student]  
GO  
```  
  
 <span data-ttu-id="1f86a-201">Das Codebeispiel folgt:</span><span class="sxs-lookup"><span data-stu-id="1f86a-201">The code listing follows:</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1f86a-202">Das Codebeispiel bezieht sich auf eine Access-Datenbankdatei namens MySchool.mdb.</span><span class="sxs-lookup"><span data-stu-id="1f86a-202">The code listing refers to an Access database file called MySchool.mdb.</span></span> <span data-ttu-id="1f86a-203">Sie können myschool.mdb (als Teil der vollständigen Beispielprojekts für c# oder Visual Basic) entweder aus der [Visual Studio 2012-Beispiel](http://code.msdn.microsoft.com/How-to-retrieve-the-95b4ee43) oder [Visual Studio 2013-Beispiel](http://code.msdn.microsoft.com/How-to-Retrieve-the-511acece).</span><span class="sxs-lookup"><span data-stu-id="1f86a-203">You can download MySchool.mdb (as part of the full C# or Visual Basic sample project) from either the [Visual Studio 2012 sample](http://code.msdn.microsoft.com/How-to-retrieve-the-95b4ee43) or the [Visual Studio 2013 sample](http://code.msdn.microsoft.com/How-to-Retrieve-the-511acece).</span></span>  
  
```  
using System;  
using System.Data;  
using System.Data.OleDb;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
      String SqlDbConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True;Asynchronous Processing=true;";  
  
      InsertPerson(SqlDbConnectionString, "Janice", "Galvin");  
      Console.WriteLine();  
  
      InsertPersonInAdapter(SqlDbConnectionString, "Peter", "Krebs");  
      Console.WriteLine();  
  
      String oledbConnectionString = "Provider=Microsoft.Jet.OLEDB.4.0; Data Source=Database\\MySchool.mdb";  
      InsertPersonInJet4Database(oledbConnectionString, "Janice", "Galvin");  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit.....");  
      Console.ReadKey();  
   }  
  
   // Using stored procedure to insert a new row and retrieve the identity value  
   static void InsertPerson(String connectionString, String firstName, String lastName) {  
      String commandText = "dbo.InsertPerson";  
  
      using (SqlConnection conn = new SqlConnection(connectionString)) {  
         using (SqlCommand cmd = new SqlCommand(commandText, conn)) {  
            cmd.CommandType = CommandType.StoredProcedure;  
  
            cmd.Parameters.Add(new SqlParameter("@FirstName", firstName));  
            cmd.Parameters.Add(new SqlParameter("@LastName", lastName));  
            SqlParameter personId = new SqlParameter("@PersonID", SqlDbType.Int);  
            personId.Direction = ParameterDirection.Output;  
            cmd.Parameters.Add(personId);  
  
            conn.Open();  
            cmd.ExecuteNonQuery();  
  
            Console.WriteLine("Person Id of new person:{0}", personId.Value);  
         }  
      }  
   }  
  
   // Using stored procedure in adapter to insert new rows and update the identity value.  
   static void InsertPersonInAdapter(String connectionString, String firstName, String lastName) {  
      String commandText = "dbo.InsertPerson";  
      using (SqlConnection conn = new SqlConnection(connectionString)) {  
         SqlDataAdapter mySchool = new SqlDataAdapter("Select PersonID,FirstName,LastName from [dbo].[Person]", conn);  
  
         mySchool.InsertCommand = new SqlCommand(commandText, conn);  
         mySchool.InsertCommand.CommandType = CommandType.StoredProcedure;  
  
         mySchool.InsertCommand.Parameters.Add(  
             new SqlParameter("@FirstName", SqlDbType.NVarChar, 50, "FirstName"));  
         mySchool.InsertCommand.Parameters.Add(  
             new SqlParameter("@LastName", SqlDbType.NVarChar, 50, "LastName"));  
  
         SqlParameter personId = mySchool.InsertCommand.Parameters.Add(new SqlParameter("@PersonID", SqlDbType.Int, 0, "PersonID"));  
         personId.Direction = ParameterDirection.Output;  
  
         DataTable persons = new DataTable();  
         mySchool.Fill(persons);  
  
         DataRow newPerson = persons.NewRow();  
         newPerson["FirstName"] = firstName;  
         newPerson["LastName"] = lastName;  
         persons.Rows.Add(newPerson);  
  
         mySchool.Update(persons);  
         Console.WriteLine("Show all persons:");  
         ShowDataTable(persons, 14);  
      }  
   }  
  
   /// For a Jet 4.0 database, we need use the sigle statement and event handler to insert new rows and retrieve the identity value.  
   static void InsertPersonInJet4Database(String connectionString, String firstName, String lastName) {  
      String commandText = "Insert into Person(FirstName,LastName) Values(?,?)";  
      using (OleDbConnection conn = new OleDbConnection(connectionString)) {  
         OleDbDataAdapter mySchool = new OleDbDataAdapter("Select PersonID,FirstName,LastName from Person", conn);  
  
         // Create Insert Command  
         mySchool.InsertCommand = new OleDbCommand(commandText, conn);  
         mySchool.InsertCommand.CommandType = CommandType.Text;  
  
         mySchool.InsertCommand.Parameters.Add(new OleDbParameter("@FirstName", OleDbType.VarChar, 50, "FirstName"));  
         mySchool.InsertCommand.Parameters.Add(new OleDbParameter("@LastName", OleDbType.VarChar, 50, "LastName"));  
         mySchool.InsertCommand.UpdatedRowSource = UpdateRowSource.Both;  
  
         DataTable persons = CreatePersonsTable();  
  
         mySchool.Fill(persons);  
  
         DataRow newPerson = persons.NewRow();  
         newPerson["FirstName"] = firstName;  
         newPerson["LastName"] = lastName;  
         persons.Rows.Add(newPerson);  
  
         DataTable dataChanges = persons.GetChanges();  
  
         mySchool.RowUpdated += OnRowUpdated;  
  
         mySchool.Update(dataChanges);  
  
         Console.WriteLine("Data before merging:");  
         ShowDataTable(persons, 14);  
         Console.WriteLine();  
  
         persons.Merge(dataChanges);  
         persons.AcceptChanges();  
  
         Console.WriteLine("Data after merging");  
         ShowDataTable(persons, 14);  
      }  
   }  
  
   static void OnRowUpdated(object sender, OleDbRowUpdatedEventArgs e) {  
      if (e.StatementType == StatementType.Insert) {  
         // Retrieve the identity value  
         OleDbCommand cmdNewId = new OleDbCommand("Select @@IDENTITY", e.Command.Connection);  
         e.Row["PersonID"] = (Int32)cmdNewId.ExecuteScalar();  
  
         // After the status is changed, the original values in the row are preserved. And the   
         // Merge method will be called to merge the new identity value into the original DataTable.  
         e.Status = UpdateStatus.SkipCurrentRow;  
      }  
   }  
  
   // Create the Persons table before filling.  
   private static DataTable CreatePersonsTable() {  
      DataTable persons = new DataTable();  
  
      DataColumn personId = new DataColumn();  
      personId.DataType = Type.GetType("System.Int32");  
      personId.ColumnName = "PersonID";  
      personId.AutoIncrement = true;  
      personId.AutoIncrementSeed = 0;  
      personId.AutoIncrementStep = -1;  
      persons.Columns.Add(personId);  
  
      DataColumn firstName = new DataColumn();  
      firstName.DataType = Type.GetType("System.String");  
      firstName.ColumnName = "FirstName";  
      persons.Columns.Add(firstName);  
  
      DataColumn lastName = new DataColumn();  
      lastName.DataType = Type.GetType("System.String");  
      lastName.ColumnName = "LastName";  
      persons.Columns.Add(lastName);  
  
      DataColumn[] pkey = { personId };  
      persons.PrimaryKey = pkey;  
  
      return persons;  
   }  
  
   private static void ShowDataTable(DataTable table, Int32 length) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-" + length + "}", col.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         foreach (DataColumn col in table.Columns) {  
            if (col.DataType.Equals(typeof(DateTime)))  
               Console.Write("{0,-" + length + ":d}", row[col]);  
            else if (col.DataType.Equals(typeof(Decimal)))   
               Console.Write("{0,-" + length + ":C}", row[col]);  
            else  
               Console.Write("{0,-" + length + "}", row[col]);  
         }  
  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="1f86a-204">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="1f86a-204">See Also</span></span>  
 [<span data-ttu-id="1f86a-205">Abrufen und Ändern von Daten in ADO.NET</span><span class="sxs-lookup"><span data-stu-id="1f86a-205">Retrieving and Modifying Data in ADO.NET</span></span>](../../../../docs/framework/data/adonet/retrieving-and-modifying-data.md)  
 [<span data-ttu-id="1f86a-206">DataAdapters und DataReaders</span><span class="sxs-lookup"><span data-stu-id="1f86a-206">DataAdapters and DataReaders</span></span>](../../../../docs/framework/data/adonet/dataadapters-and-datareaders.md)  
 [<span data-ttu-id="1f86a-207">Zeilenstatus und Zeilenversionen</span><span class="sxs-lookup"><span data-stu-id="1f86a-207">Row States and Row Versions</span></span>](../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)  
 [<span data-ttu-id="1f86a-208">AcceptChanges und RejectChanges</span><span class="sxs-lookup"><span data-stu-id="1f86a-208">AcceptChanges and RejectChanges</span></span>](../../../../docs/framework/data/adonet/dataset-datatable-dataview/acceptchanges-and-rejectchanges.md)  
 [<span data-ttu-id="1f86a-209">Merging DataSet Contents (Zusammenführen von DataSet-Inhalten)</span><span class="sxs-lookup"><span data-stu-id="1f86a-209">Merging DataSet Contents</span></span>](../../../../docs/framework/data/adonet/dataset-datatable-dataview/merging-dataset-contents.md)  
 [<span data-ttu-id="1f86a-210">Updating Data Sources with DataAdapters (Aktualisieren von Datenquellen mit DataAdapters)</span><span class="sxs-lookup"><span data-stu-id="1f86a-210">Updating Data Sources with DataAdapters</span></span>](../../../../docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)  
 [<span data-ttu-id="1f86a-211">ADO.NET Managed Provider und DataSet Developer Center</span><span class="sxs-lookup"><span data-stu-id="1f86a-211">ADO.NET Managed Providers and DataSet Developer Center</span></span>](http://go.microsoft.com/fwlink/?LinkId=217917)
