---
title: Auswählen eines Nachrichtenaustauschmusters
ms.date: 03/30/2017
ms.assetid: 0f502ca1-6a8e-4607-ba15-59198c0e6146
ms.openlocfilehash: 22c720beaa8dc70d2916a5b1d38819ad3d333a0f
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/26/2020
ms.locfileid: "96275657"
---
# <a name="choosing-a-message-exchange-pattern"></a><span data-ttu-id="491d3-102">Auswählen eines Nachrichtenaustauschmusters</span><span class="sxs-lookup"><span data-stu-id="491d3-102">Choosing a Message Exchange Pattern</span></span>

<span data-ttu-id="491d3-103">Der erste Schritt beim Schreiben eines benutzerdefinierten Transports besteht darin, zu entscheiden, welche *Nachrichtenaustausch Muster* (oder die einzelnen Kollegen) für den von Ihnen entwickelten Kanal erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="491d3-103">The first step in writing a custom transport is to decide which *message exchange patterns* (or MEPs) are required for the channel you are developing.</span></span> <span data-ttu-id="491d3-104">In diesem Thema werden die verfügbaren Optionen beschrieben und die verschiedenen Anforderungen erläutert.</span><span class="sxs-lookup"><span data-stu-id="491d3-104">This topic describes the options available and discusses the various requirements.</span></span> <span data-ttu-id="491d3-105">Dies ist die erste Aufgabe in der Aufgabenliste für die Kanalentwicklung, die unter [entwickeln von Kanälen](developing-channels.md)beschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="491d3-105">This is the first task in the channel development task list described in [Developing Channels](developing-channels.md).</span></span>  
  
## <a name="six-message-exchange-patterns"></a><span data-ttu-id="491d3-106">Sechs Nachrichtenaustauschmuster</span><span class="sxs-lookup"><span data-stu-id="491d3-106">Six Message Exchange Patterns</span></span>  

 <span data-ttu-id="491d3-107">Es stehen drei Nachrichtenaustauschmuster zur Auswahl:</span><span class="sxs-lookup"><span data-stu-id="491d3-107">There are three MEPs to choose from:</span></span>  
  
- <span data-ttu-id="491d3-108">Datagramm (<xref:System.ServiceModel.Channels.IInputChannel> und <xref:System.ServiceModel.Channels.IOutputChannel>)</span><span class="sxs-lookup"><span data-stu-id="491d3-108">Datagram (<xref:System.ServiceModel.Channels.IInputChannel> and <xref:System.ServiceModel.Channels.IOutputChannel>)</span></span>  
  
     <span data-ttu-id="491d3-109">Wenn ein Datagramm-Nachrichtenaustausch verwendet wird, sendet ein Client eine Nachricht mit einem " *Fire and Forget"-* Austausch.</span><span class="sxs-lookup"><span data-stu-id="491d3-109">When using a datagram MEP, a client sends a message using a *fire and forget* exchange.</span></span> <span data-ttu-id="491d3-110">Ein "fire and forget"-Austausch erfordert eine Out-of-Band-Bestätigung für die erfolgreiche Zustellung.</span><span class="sxs-lookup"><span data-stu-id="491d3-110">A fire and forget exchange is one that requires out-of-band confirmation of successful delivery.</span></span> <span data-ttu-id="491d3-111">Die Nachricht könnte unterwegs verloren gehen und den Dienst nicht erreichen.</span><span class="sxs-lookup"><span data-stu-id="491d3-111">The message might be lost in transit and never reach the service.</span></span> <span data-ttu-id="491d3-112">Wenn der Sendevorgang auf der Clientseite erfolgreich abgeschlossen wird, stellt dies keine Garantie dar, dass der Remoteendpunkt die Nachricht erhalten hat.</span><span class="sxs-lookup"><span data-stu-id="491d3-112">If the send operation completes successfully at the client end, it does not guarantee that the remote endpoint has received the message.</span></span> <span data-ttu-id="491d3-113">Das Datagramm ist ein wesentlicher Baustein für den Nachrichtenaustausch, da Sie eigene Protokolle damit erstellen können, einschließlich zuverlässiger Protokolle und sicherer Protokolle.</span><span class="sxs-lookup"><span data-stu-id="491d3-113">The datagram is a fundamental building block for messaging, as you can build your own protocols on top of it—including reliable protocols and secure protocols.</span></span> <span data-ttu-id="491d3-114">Clientdatagrammkanäle implementieren die <xref:System.ServiceModel.Channels.IOutputChannel>-Schnittstelle, und Dienstdatagrammkanäle implementieren die <xref:System.ServiceModel.Channels.IInputChannel>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="491d3-114">Client datagram channels implement the <xref:System.ServiceModel.Channels.IOutputChannel> interface and service datagram channels implement the <xref:System.ServiceModel.Channels.IInputChannel> interface.</span></span>  
  
- <span data-ttu-id="491d3-115">Anforderung-Antwort (<xref:System.ServiceModel.Channels.IRequestChannel> und <xref:System.ServiceModel.Channels.IReplyChannel>)</span><span class="sxs-lookup"><span data-stu-id="491d3-115">Request-Response (<xref:System.ServiceModel.Channels.IRequestChannel> and <xref:System.ServiceModel.Channels.IReplyChannel>)</span></span>  
  
     <span data-ttu-id="491d3-116">In diesem Nachrichtenaustauschmuster wird eine Nachricht gesendet, und eine Antwort wird empfangen.</span><span class="sxs-lookup"><span data-stu-id="491d3-116">In this MEP, a message is sent, and a reply is received.</span></span> <span data-ttu-id="491d3-117">Das Muster besteht aus Anforderungs-Antwort-Paaren.</span><span class="sxs-lookup"><span data-stu-id="491d3-117">The pattern consists of request-response pairs.</span></span> <span data-ttu-id="491d3-118">Beispiele für Anforderung-Antwort-Aufrufe sind Remoteprozeduraufrufe (RPC) und Browser-GET-Anforderungen.</span><span class="sxs-lookup"><span data-stu-id="491d3-118">Examples of request-response calls are remote procedure calls (RPC) and browser GET requests.</span></span> <span data-ttu-id="491d3-119">Dieses Muster wird auch als Halbduplex bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="491d3-119">This pattern is also known as half-duplex.</span></span> <span data-ttu-id="491d3-120">In diesem Nachrichtenaustauschmuster implementieren Clientkanäle <xref:System.ServiceModel.Channels.IRequestChannel>, und Dienstkanäle implementieren <xref:System.ServiceModel.Channels.IReplyChannel>.</span><span class="sxs-lookup"><span data-stu-id="491d3-120">In this MEP, client channels implement <xref:System.ServiceModel.Channels.IRequestChannel> and service channels implement <xref:System.ServiceModel.Channels.IReplyChannel>.</span></span>  
  
- <span data-ttu-id="491d3-121">Duplex (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span><span class="sxs-lookup"><span data-stu-id="491d3-121">Duplex (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span></span>  
  
     <span data-ttu-id="491d3-122">Das Duplex-Nachrichtenaustauschmuster ermöglicht, dass eine willkürliche Anzahl von Nachrichten von einem Client gesendet und in beliebiger Reihenfolge empfangen wird.</span><span class="sxs-lookup"><span data-stu-id="491d3-122">The duplex MEP allows an arbitrary number of messages to be sent by a client and received in any order.</span></span> <span data-ttu-id="491d3-123">Das Duplex-Nachrichtenaustauschmuster ist mit einem Telefongespräch vergleichbar, bei dem jedes gesprochene Wort einer Nachricht entspricht.</span><span class="sxs-lookup"><span data-stu-id="491d3-123">The duplex MEP is like a phone conversation, where each word being spoken is a message.</span></span> <span data-ttu-id="491d3-124">Da beide Teilnehmer in diesem Nachrichtenaustauschmuster senden und empfangen können, ist die vom Client und von den Dienstkanälen implementierte Schnittstelle <xref:System.ServiceModel.Channels.IDuplexChannel>.</span><span class="sxs-lookup"><span data-stu-id="491d3-124">Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <xref:System.ServiceModel.Channels.IDuplexChannel>.</span></span>  
  
 <span data-ttu-id="491d3-125">![Auswählen eines Nachrichtenaustausch Musters](./media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span><span class="sxs-lookup"><span data-stu-id="491d3-125">![Choosing a message exchange pattern](./media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span></span>  
<span data-ttu-id="491d3-126">Die drei grundlegenden Nachrichtenaustauschmuster</span><span class="sxs-lookup"><span data-stu-id="491d3-126">The three basic message exchange patterns.</span></span> <span data-ttu-id="491d3-127">von oben nach unten: Datagramm, Anforderung-Antwort und Duplex.</span><span class="sxs-lookup"><span data-stu-id="491d3-127">Top to bottom: datagram, request-response, and duplex.</span></span>  
  
 <span data-ttu-id="491d3-128">Alle diese Abgeordneten können auch *Sitzungen* unterstützen.</span><span class="sxs-lookup"><span data-stu-id="491d3-128">Each of these MEPs can also support *sessions*.</span></span> <span data-ttu-id="491d3-129">Eine Sitzung (und Implementierung von <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> des Typs <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) korreliert alle in einem Kanal gesendeten und empfangenen Nachrichten.</span><span class="sxs-lookup"><span data-stu-id="491d3-129">A session (and implementation of <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> of type <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) correlates all messages sent and received on a channel.</span></span> <span data-ttu-id="491d3-130">Das Anforderung-Antwort-Muster ist eine eigenständige, aus zwei Nachrichten bestehende Sitzung, da die Anforderung und die Antwort korreliert werden.</span><span class="sxs-lookup"><span data-stu-id="491d3-130">The request-response pattern is a stand-alone two-message session, as the request and reply are correlated.</span></span> <span data-ttu-id="491d3-131">Demgegenüber impliziert das Anforderung-Antwort-Muster, das Sitzungen unterstützt, dass alle Anforderung/Antwort-Paare in diesem Kanal miteinander korreliert werden.</span><span class="sxs-lookup"><span data-stu-id="491d3-131">In contrast, the request-response pattern that supports sessions implies that all request/response pairs on that channel are correlated with each other.</span></span> <span data-ttu-id="491d3-132">Daher stehen insgesamt sechs Nachrichtenaustauschmuster zur Auswahl:</span><span class="sxs-lookup"><span data-stu-id="491d3-132">This gives you a total of six MEPs to choose from:</span></span>  
  
- <span data-ttu-id="491d3-133">Datagramm</span><span class="sxs-lookup"><span data-stu-id="491d3-133">Datagram</span></span>  
  
- <span data-ttu-id="491d3-134">Anforderung-Antwort</span><span class="sxs-lookup"><span data-stu-id="491d3-134">Request-response</span></span>  
  
- <span data-ttu-id="491d3-135">Duplex</span><span class="sxs-lookup"><span data-stu-id="491d3-135">Duplex</span></span>  
  
- <span data-ttu-id="491d3-136">Datagramm mit Sitzungen</span><span class="sxs-lookup"><span data-stu-id="491d3-136">Datagram with sessions</span></span>  
  
- <span data-ttu-id="491d3-137">Anforderung-Antwort mit Sitzungen</span><span class="sxs-lookup"><span data-stu-id="491d3-137">Request-response with sessions</span></span>  
  
- <span data-ttu-id="491d3-138">Duplex mit Sitzungen</span><span class="sxs-lookup"><span data-stu-id="491d3-138">Duplex with sessions</span></span>  
  
> [!NOTE]
> <span data-ttu-id="491d3-139">Für den UDP-Transport wird nur das Nachrichtenaustauschmuster Datagramm unterstützt, da UDP grundsätzlich ein "fire and forget"-Protokoll ist.</span><span class="sxs-lookup"><span data-stu-id="491d3-139">For the UDP transport, the only MEP that is supported is datagram, because UDP is inherently a fire and forget protocol.</span></span>  
  
## <a name="sessions-and-sessionful-channels"></a><span data-ttu-id="491d3-140">Sitzungen und sitzungsbasierte Kanäle</span><span class="sxs-lookup"><span data-stu-id="491d3-140">Sessions and Sessionful Channels</span></span>  

 <span data-ttu-id="491d3-141">Im Bereich der Netzwerke gibt es verbindungsorientierte Protokolle (z. B. TCP) und verbindungslose Protokolle (z. B. UDP).</span><span class="sxs-lookup"><span data-stu-id="491d3-141">In the networking world, there are connection-oriented protocols (for example, TCP) and connection-less protocols (for example, UDP).</span></span> <span data-ttu-id="491d3-142">WCF verwendet den Begriff Sitzung, um eine Verbindungs ähnliche logische Abstraktion zu bedeuten.</span><span class="sxs-lookup"><span data-stu-id="491d3-142">WCF uses the term session to mean a connection-like logical abstraction.</span></span> <span data-ttu-id="491d3-143">Sitzungsbasierte WCF-Protokolle sind mit verbindungsorientierten Netzwerkprotokollen vergleichbar, und nicht sitzungsbasierte Protokolle entsprechen verbindungslosen Netzwerkprotokollen.</span><span class="sxs-lookup"><span data-stu-id="491d3-143">Sessionful WCF protocols are similar to connection-oriented network protocols and sessionless WCF protocols are similar to connection-less network protocols.</span></span>  
  
 <span data-ttu-id="491d3-144">Im Kanalobjektmodell manifestiert sich jede logische Sitzung als Instanz eines sitzungsbasierten Kanals.</span><span class="sxs-lookup"><span data-stu-id="491d3-144">In the channel object model, each logical session manifests as an instance of a sessionful channel.</span></span> <span data-ttu-id="491d3-145">Daher entspricht jede neue vom Client erstellte und vom Dienst akzeptierte Sitzung einem neuen sitzungsbasierten Kanal auf jeder Seite.</span><span class="sxs-lookup"><span data-stu-id="491d3-145">Therefore every new session created by the client, and accepted on the service, corresponds to a new sessionful channel on each side.</span></span> <span data-ttu-id="491d3-146">Das folgende Diagramm zeigt oben die Struktur nicht sitzungsbasierter Kanäle und unten die Struktur sitzungsbasierter Kanäle.</span><span class="sxs-lookup"><span data-stu-id="491d3-146">The following diagram shows, on the top, the structure of sessionless channels, and on the bottom, the structure of sessionful channels.</span></span>  
  
 <span data-ttu-id="491d3-147">![Auswählen eines Nachrichtenaustausch Musters](./media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span><span class="sxs-lookup"><span data-stu-id="491d3-147">![Choosing a message exchange pattern](./media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span></span>  
  
 <span data-ttu-id="491d3-148">Ein Client erstellt einen neuen sitzungsbasierten Kanal und sendet eine Nachricht.</span><span class="sxs-lookup"><span data-stu-id="491d3-148">A client creates a new sessionful channel and sends a message.</span></span> <span data-ttu-id="491d3-149">Auf der Dienstseite empfängt der Kanallistener diese Nachricht und erkennt, dass sie zu einer neuen Sitzung gehört. Daraufhin erstellt er einen neuen sitzungsbasierten Kanal und übergibt diesen an die Anwendung (als Antwort auf den AcceptChannel-Aufruf der Anwendung im Kanallistener).</span><span class="sxs-lookup"><span data-stu-id="491d3-149">On the service side, the channel listener receives this message and detects that it belongs to a new session so it creates a new sessionful channel and hands it to the application (in response to the application calling AcceptChannel on the channel listener).</span></span> <span data-ttu-id="491d3-150">Die Anwendung empfängt dann diese Nachricht sowie alle nachfolgenden Nachrichten, die in derselben Sitzung über denselben sitzungsbasierten Kanal gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="491d3-150">The application then receives this message and all subsequent messages sent in the same session through the same sessionful channel.</span></span>  
  
 <span data-ttu-id="491d3-151">Ein anderer (oder derselbe) Client erstellt einen neuen sitzungsbasierten Kanal und sendet eine Nachricht.</span><span class="sxs-lookup"><span data-stu-id="491d3-151">Another client (or the same client) creates a new sessionful and sends a message.</span></span> <span data-ttu-id="491d3-152">Der Kanallistener erkennt, dass diese Nachricht in einer neuen Sitzung enthalten ist, und erstellt einen neuen sitzungsbasierten Kanal. Der Vorgang wird wiederholt.</span><span class="sxs-lookup"><span data-stu-id="491d3-152">The channel listener detects this message is in a new session and creates a new sessionful channel and the process repeats.</span></span>  
  
 <span data-ttu-id="491d3-153">Ohne Sitzungen gibt es keine Korrelation zwischen Kanälen und Sitzungen.</span><span class="sxs-lookup"><span data-stu-id="491d3-153">Without sessions, there is no correlation between channels and sessions.</span></span> <span data-ttu-id="491d3-154">Daher erstellt ein Kanallistener nur einen Kanal, über den alle empfangenen Nachrichten der Anwendung zugestellt werden.</span><span class="sxs-lookup"><span data-stu-id="491d3-154">Therefore a channel listener creates only one channel through which all received messages are delivered to the application.</span></span> <span data-ttu-id="491d3-155">Es gibt auch keine Nachrichtenreihenfolge, da es keine Sitzung gibt, in der die Nachrichtenreihenfolge beibehalten werden muss.</span><span class="sxs-lookup"><span data-stu-id="491d3-155">There is also no message ordering because there is no session within which to maintain message order.</span></span> <span data-ttu-id="491d3-156">Der oberste Teil der vorangehenden Grafik illustriert einen nicht sitzungsbasierten Nachrichtenaustausch.</span><span class="sxs-lookup"><span data-stu-id="491d3-156">The top portion of the preceding graphic illustrates a sessionless message exchange.</span></span>  
  
## <a name="starting-and-terminating-sessions"></a><span data-ttu-id="491d3-157">Beginnen und Beenden von Sitzungen</span><span class="sxs-lookup"><span data-stu-id="491d3-157">Starting and Terminating Sessions</span></span>  

 <span data-ttu-id="491d3-158">Sitzungen werden auf dem Client begonnen, indem einfach ein neuer sitzungsbasierter Kanal erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="491d3-158">Sessions are started on the client by simply creating a new sessionful channel.</span></span> <span data-ttu-id="491d3-159">Sie werden im Dienst gestartet, wenn der Dienst eine Nachricht empfängt, die in einer neuen Sitzung gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="491d3-159">They are started on the service when the service receives a message that was sent in a new session.</span></span> <span data-ttu-id="491d3-160">Ebenso werden Sitzungen durch Schließen oder Abbrechen eines sitzungsbasierten Kanals beendet.</span><span class="sxs-lookup"><span data-stu-id="491d3-160">Likewise, sessions are terminated by closing or aborting a sessionful channel.</span></span>  
  
 <span data-ttu-id="491d3-161">Eine Ausnahme hierzu bildet <xref:System.ServiceModel.Channels.IDuplexSessionChannel>, der sowohl zum Senden als auch zum Empfangen von Nachrichten in einem sitzungsbasierten Duplexkommunikationsmuster verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="491d3-161">The exception to this is <xref:System.ServiceModel.Channels.IDuplexSessionChannel> which is used for both sending and receiving messages in a duplex, sessionful communication pattern.</span></span> <span data-ttu-id="491d3-162">Es ist möglich, dass eine Seite das Senden von Nachrichten stoppen, jedoch weiterhin Nachrichten empfangen möchte. Daher gibt es beim Verwenden von <xref:System.ServiceModel.Channels.IDuplexSessionChannel> einen Mechanismus, mit dem Sie die Ausgabesitzung schließen können, was darauf hinweist, dass Sie keine weiteren Nachrichten senden, jedoch die Eingabesitzung geöffnet lassen, sodass Sie weiterhin Nachrichten empfangen können.</span><span class="sxs-lookup"><span data-stu-id="491d3-162">It is possible that one side will want to stop sending messages but continue to receive messages therefore when using <xref:System.ServiceModel.Channels.IDuplexSessionChannel> there is a mechanism that lets you close the output session indicating you will not send any more messages but keep the input session opened allowing you to continue to receive messages.</span></span>  
  
 <span data-ttu-id="491d3-163">Im Allgemeinen werden Sitzungen auf der ausgehenden und nicht auf der eingehenden Seite geschlossen,</span><span class="sxs-lookup"><span data-stu-id="491d3-163">In general, sessions are closed on the outgoing side and not on the incoming side.</span></span> <span data-ttu-id="491d3-164">d. h. sitzungsbasierte Ausgabekanäle können geschlossen werden, und dadurch kann die Sitzung ordnungsgemäß beendet werden.</span><span class="sxs-lookup"><span data-stu-id="491d3-164">That is, sessionful output channels can be closed, thereby cleanly terminating the session.</span></span> <span data-ttu-id="491d3-165">Durch Schließen eines sitzungsbasierten Ausgabekanals gibt der entsprechende sitzungsbasierte Eingabekanal NULL an die Anwendung zurück mit dem Aufruf <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> auf dem <xref:System.ServiceModel.Channels.IDuplexSessionChannel>.</span><span class="sxs-lookup"><span data-stu-id="491d3-165">Closing a sessionful output channel causes the corresponding sessionful input channel to return null to the application calling <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel>.</span></span>  
  
 <span data-ttu-id="491d3-166">Sitzungsbasierte Eingabekanäle sollten jedoch nur geschlossen werden, wenn <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> auf dem <xref:System.ServiceModel.Channels.IDuplexSessionChannel> NULL zurückgibt, was darauf hinweist, dass die Sitzung bereits geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="491d3-166">However sessionful input channels should not be closed unless <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> returns null, indicating that the session is already closed.</span></span> <span data-ttu-id="491d3-167">Wenn <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> auf dem <xref:System.ServiceModel.Channels.IDuplexSessionChannel> nicht NULL zurückgegeben hat, kann das Schließen eines sitzungsbasierten Eingabekanals eine Ausnahme auslösen, da während des Schließens unerwartete Nachrichten empfangen werden können.</span><span class="sxs-lookup"><span data-stu-id="491d3-167">If <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> has not returned null, closing a sessionful input channel may throw an exception because it may receive unexpected messages while closing.</span></span> <span data-ttu-id="491d3-168">Wenn ein Empfänger eine Sitzung beenden möchte, bevor der Absender dies tut, sollte er <xref:System.ServiceModel.ICommunicationObject.Abort%2A> im Eingabekanal aufrufen, wodurch die Sitzung sofort beendet wird.</span><span class="sxs-lookup"><span data-stu-id="491d3-168">If a receiver wishes to terminate a session before the sender does, it should call <xref:System.ServiceModel.ICommunicationObject.Abort%2A> on the input channel, which abruptly terminates the session.</span></span>  
  
## <a name="writing-sessionful-channels"></a><span data-ttu-id="491d3-169">Schreiben von sitzungsbasierten Kanälen</span><span class="sxs-lookup"><span data-stu-id="491d3-169">Writing Sessionful Channels</span></span>  

 <span data-ttu-id="491d3-170">Als sitzungsbasierter Kanalautor muss Ihr Kanal einige Voraussetzungen erfüllen, um Sitzungen bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="491d3-170">As a sessionful channel author, there are a few things your channel must do to provide sessions.</span></span> <span data-ttu-id="491d3-171">Auf der Senderseite muss Ihr Kanal Folgendes erfüllen:</span><span class="sxs-lookup"><span data-stu-id="491d3-171">On the send side, your channel needs to:</span></span>  
  
- <span data-ttu-id="491d3-172">Erstellen Sie für jeden neuen Kanal eine neue Sitzung, und verknüpfen Sie sie mit einer neuen Sitzungs-ID, die einer eindeutigen Zeichenfolge entspricht.</span><span class="sxs-lookup"><span data-stu-id="491d3-172">For each new channel, create a new session and associate it with a new session id which is a unique string.</span></span> <span data-ttu-id="491d3-173">Oder rufen Sie unterhalb im Stapel eine neue Sitzung aus dem sitzungsbasierten Kanal ab.</span><span class="sxs-lookup"><span data-stu-id="491d3-173">Or obtain a new session from the sessionful channel below you in the stack.</span></span>  
  
- <span data-ttu-id="491d3-174">Für jede mit diesem Kanal gesendete Nachricht müssen Sie die Nachricht mit der Sitzung verknüpfen, wenn Ihr Kanal die Sitzung erstellt hat (statt sie von der Ebene unterhalb zu erhalten).</span><span class="sxs-lookup"><span data-stu-id="491d3-174">For each message sent using this channel, if your channel created the session (as opposed to obtaining it from the layer below you), you need to associate the message with the session.</span></span> <span data-ttu-id="491d3-175">Für Protokollkanäle wird dies i. d. R. durch Hinzufügen eines SOAP-Headers ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="491d3-175">For protocol channels, this is typically done by adding a SOAP header.</span></span> <span data-ttu-id="491d3-176">Für Transportkanäle wird dies durch Erstellen einer neuen Transportverbindung oder durch Hinzufügen von Sitzungsinformationen zum Framing-Protokoll ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="491d3-176">For transport channels, this is typically done by creating a new transport connection or adding session information to the framing protocol.</span></span>  
  
- <span data-ttu-id="491d3-177">Für jede über diesen Kanal gesendete Nachricht müssen Sie die oben erwähnten Zustellungsgarantien zur Verfügung stellen.</span><span class="sxs-lookup"><span data-stu-id="491d3-177">For each message sent using this channel, you need to provide the delivery guarantees mentioned above.</span></span> <span data-ttu-id="491d3-178">Wenn Sie den Kanal unterhalb zur Bereitstellung der Sitzung verwenden, stellt dieser Kanal auch die Zustellungsgarantien zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="491d3-178">If you are relying on the channel below you to provide the session, that channel will also provide the delivery guarantees.</span></span> <span data-ttu-id="491d3-179">Wenn Sie die Sitzung selbst zur Verfügung stellen, müssen Sie diese Garantien als Teil des Protokolls implementieren.</span><span class="sxs-lookup"><span data-stu-id="491d3-179">If you’re providing the session yourself, you need to implement those guarantees as part of your protocol.</span></span> <span data-ttu-id="491d3-180">Wenn Sie einen Protokollkanal schreiben, der WCF auf beiden Seiten voraussetzt, benötigen Sie im Allgemeinen den TCP-Transportkanal oder den Kanal für zuverlässiges Messaging und sind auf einen der beiden Kanäle zur Bereitstellung einer Sitzung angewiesen.</span><span class="sxs-lookup"><span data-stu-id="491d3-180">In general, if you are writing a protocol channel that assumes WCF on both sides you may require the TCP transport or the Reliable Messaging channel and rely on either one to provide a session.</span></span>  
  
- <span data-ttu-id="491d3-181">Wenn <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> auf Ihrem Kanal aufgerufen wird, führen Sie die notwendigen Schritte zum Schließen der Sitzung aus, indem Sie entweder den angegebenen Timeout oder den Standardwert verwenden.</span><span class="sxs-lookup"><span data-stu-id="491d3-181">When <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> is called on your channel, perform the necessary work to close the session using either the specified timeout or the default one.</span></span> <span data-ttu-id="491d3-182">Dazu brauchen Sie möglicherweise nur <xref:System.ServiceModel.ICommunicationObject.Close%2A> auf dem Kanal unterhalb aufzurufen (wenn Sie die Sitzung soeben von diesem erhalten haben), eine spezielle SOAP-Nachricht zu senden oder eine Transportverbindung zu schließen.</span><span class="sxs-lookup"><span data-stu-id="491d3-182">This can be as simple as calling <xref:System.ServiceModel.ICommunicationObject.Close%2A> on the channel below you (if you just obtained the session from it) or sending a special SOAP message or closing a transport connection.</span></span>  
  
- <span data-ttu-id="491d3-183">Wenn <xref:System.ServiceModel.ICommunicationObject.Abort%2A> auf dem Kanal aufgerufen wird, beenden Sie die Sitzung unvermittelt, ohne E/A auszuführen.</span><span class="sxs-lookup"><span data-stu-id="491d3-183">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="491d3-184">Dies bedeutet möglicherweise, nichts zu machen oder eine Netzwerkverbindung oder eine andere Ressource abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="491d3-184">This may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
 <span data-ttu-id="491d3-185">Auf der Empfängerseite muss Ihr Kanal Folgendes erfüllen:</span><span class="sxs-lookup"><span data-stu-id="491d3-185">On the receive side, your channel needs to:</span></span>  
  
- <span data-ttu-id="491d3-186">Für jede eingehende Nachricht muss der Kanallistener die Sitzung erkennen, zu der sie gehört.</span><span class="sxs-lookup"><span data-stu-id="491d3-186">For each incoming message, the channel listener must detect the session it belongs to.</span></span> <span data-ttu-id="491d3-187">Wenn es sich dabei um die erste Nachricht in der Sitzung handelt, muss der Kanallistener einen neuen Kanal erstellen und ihn vom Aufruf an <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType> zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="491d3-187">If this is the first message in the session, the channel listener must create a new channel and return it from the call to <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="491d3-188">Andernfalls muss der Kanallistener den vorhandenen Kanal, der der Sitzung entspricht, suchen und die Nachricht über den Kanal zustellen.</span><span class="sxs-lookup"><span data-stu-id="491d3-188">Otherwise the channel listener must find the existing channel that corresponds to the session and deliver the message through that channel.</span></span>  
  
- <span data-ttu-id="491d3-189">Wenn Ihr Kanal die Sitzung (sowie die erforderlichen Zustellungsgarantien) bereitstellt, muss die Empfängerseite möglicherweise einige Aktionen ausführen, wie die Nachrichtenreihenfolge ändern oder Bestätigungen senden.</span><span class="sxs-lookup"><span data-stu-id="491d3-189">If your channel is providing the session (along with the required delivery guarantees) the receive side may be required to perform some actions such as re-order messages or send acknowledgements.</span></span>  
  
- <span data-ttu-id="491d3-190">Wenn <xref:System.ServiceModel.ICommunicationObject.Close%2A> auf Ihrem Kanal aufgerufen wird, führen Sie die notwendigen Schritte zum Schließen der Sitzung aus, indem Sie entweder den angegebenen Timeout oder den Standardwert verwenden.</span><span class="sxs-lookup"><span data-stu-id="491d3-190">When <xref:System.ServiceModel.ICommunicationObject.Close%2A> is called on your channel, perform the necessary work to close the session either the specified timeout or the default one.</span></span> <span data-ttu-id="491d3-191">Es könnten Ausnahmen ausgelöst werden, wenn der Kanal eine Nachricht empfängt, während er darauf wartet, dass der Schließen-Timeout abläuft.</span><span class="sxs-lookup"><span data-stu-id="491d3-191">This could result in exceptions if the channel receives a message while waiting for the close timeout to expire.</span></span> <span data-ttu-id="491d3-192">Der Grund dafür ist, dass sich der Kanal im Schließen-Zustand befindet, wenn er eine Nachricht empfängt. Daher wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="491d3-192">That’s because the channel will be in the Closing state when it receives a message so it would throw.</span></span>  
  
- <span data-ttu-id="491d3-193">Wenn <xref:System.ServiceModel.ICommunicationObject.Abort%2A> auf dem Kanal aufgerufen wird, beenden Sie die Sitzung unvermittelt, ohne E/A auszuführen.</span><span class="sxs-lookup"><span data-stu-id="491d3-193">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="491d3-194">Dies bedeutet möglicherweise, nichts zu machen oder eine Netzwerkverbindung oder eine andere Ressource abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="491d3-194">Again, this may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="491d3-195">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="491d3-195">See also</span></span>

- [<span data-ttu-id="491d3-196">Übersicht über das Kanalmodell</span><span class="sxs-lookup"><span data-stu-id="491d3-196">Channel Model Overview</span></span>](channel-model-overview.md)
