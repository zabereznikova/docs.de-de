---
title: Datenübertragungsarchitektur - Übersicht
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- data transfer [WCF], architectural overview
ms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9
ms.openlocfilehash: efb6933ba90975d5ba35deb2bf22af12fc7c2cdc
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/26/2020
ms.locfileid: "96291686"
---
# <a name="data-transfer-architectural-overview"></a><span data-ttu-id="8b055-102">Datenübertragungsarchitektur - Übersicht</span><span class="sxs-lookup"><span data-stu-id="8b055-102">Data Transfer Architectural Overview</span></span>

<span data-ttu-id="8b055-103">Windows Communication Foundation (WCF) kann als Messaging Infrastruktur betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-103">Windows Communication Foundation (WCF) can be thought of as a messaging infrastructure.</span></span> <span data-ttu-id="8b055-104">Damit können Nachrichten empfangen, verarbeitet und für weitere Aktionen an Benutzercode verteilt werden, oder es können Nachrichten anhand von Daten des Benutzercodes erstellt und an ein Ziel übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-104">It can receive messages, process them, and dispatch them to user code for further action, or it can construct messages from data given by user code and deliver them to a destination.</span></span> <span data-ttu-id="8b055-105">In diesem Thema, das sich an fortgeschrittene Entwickler richtet, wird die Architektur zur Verarbeitung von Nachrichten und der darin enthaltenen Daten beschrieben.</span><span class="sxs-lookup"><span data-stu-id="8b055-105">This topic, which is intended for advanced developers, describes the architecture for handling messages and the contained data.</span></span> <span data-ttu-id="8b055-106">Eine einfachere, funktionsbezogene Betrachtung zum Senden und Empfangen von Daten finden Sie unter [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="8b055-106">For a simpler, task-oriented view of how to send and receive data, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="8b055-107">In diesem Thema werden WCF-Implementierungsdetails erläutert, die durch Untersuchen des WCF-Objektmodells nicht sichtbar sind.</span><span class="sxs-lookup"><span data-stu-id="8b055-107">This topic discusses WCF implementation details that are not visible by examining the WCF object model.</span></span> <span data-ttu-id="8b055-108">Zwei Hinweise im Hinblick auf die dokumentierten Implementierungsdetails sind wichtig.</span><span class="sxs-lookup"><span data-stu-id="8b055-108">Two words of caution are in order with regard to documented implementation details.</span></span> <span data-ttu-id="8b055-109">Zunächst einmal sind die Beschreibungen vereinfacht dargestellt; die tatsächliche Implementierung ist möglicherweise aufgrund von Optimierungen oder aus anderen Gründen komplexer.</span><span class="sxs-lookup"><span data-stu-id="8b055-109">First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons.</span></span> <span data-ttu-id="8b055-110">Zweitens: Sie sollten sich nie auf bestimmte Implementierungsdetails verlassen, auch nicht auf die dokumentierten, da sich diese ohne Vorankündigung von Version zu Version oder sogar innerhalb eines Service Release ändern können.</span><span class="sxs-lookup"><span data-stu-id="8b055-110">Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.</span></span>  
  
## <a name="basic-architecture"></a><span data-ttu-id="8b055-111">Grundlegende Architektur</span><span class="sxs-lookup"><span data-stu-id="8b055-111">Basic Architecture</span></span>  

 <span data-ttu-id="8b055-112">Das Herzstück der WCF-Nachrichten Behandlungs Funktionen ist die- <xref:System.ServiceModel.Channels.Message> Klasse, die ausführlich unter [Verwenden der Message-Klasse](using-the-message-class.md)beschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-112">At the core of WCF message-handling capabilities is the <xref:System.ServiceModel.Channels.Message> class, which is described in detail in [Using the Message Class](using-the-message-class.md).</span></span> <span data-ttu-id="8b055-113">Die Laufzeitkomponenten von WCF können in zwei Hauptteile unterteilt werden: den Kanal Stapel und das Dienst Framework, wobei die <xref:System.ServiceModel.Channels.Message> Klasse der Verbindungspunkt ist.</span><span class="sxs-lookup"><span data-stu-id="8b055-113">The run-time components of WCF can be divided into two major parts: the channel stack and the service framework, with the <xref:System.ServiceModel.Channels.Message> class being the connection point.</span></span>  
  
 <span data-ttu-id="8b055-114">Der Kanalstapel ist für die Konvertierung zwischen einer gültigen <xref:System.ServiceModel.Channels.Message> -Instanz und einer Aktion verantwortlich, die dem Senden und Empfangen von Nachrichtendaten entspricht.</span><span class="sxs-lookup"><span data-stu-id="8b055-114">The channel stack is responsible for converting between a valid <xref:System.ServiceModel.Channels.Message> instance and some action that corresponds to the sending or receiving of message data.</span></span> <span data-ttu-id="8b055-115">Auf der Absenderseite verwendet der Kanalstapel eine gültige <xref:System.ServiceModel.Channels.Message> -Instanz und führt nach einigen Verarbeitungsschritten eine Aktion aus, die logisch dem Senden der Nachricht entspricht.</span><span class="sxs-lookup"><span data-stu-id="8b055-115">On the sending side, the channel stack takes a valid <xref:System.ServiceModel.Channels.Message> instance and, after some processing, performs some action that logically corresponds to sending the message.</span></span> <span data-ttu-id="8b055-116">Bei der Aktion kann es sich um das Senden von TCP- oder HTTP-Paketen, das Senden der Nachricht an die Warteschlange von Message Queuing, das Schreiben der Nachricht in eine Datenbank, das Speichern in einer Dateifreigabe oder, je nach Implementierung, um eine andere Aktion handeln.</span><span class="sxs-lookup"><span data-stu-id="8b055-116">The action may be sending TCP or HTTP packets, queuing the message in Message Queuing, writing the message to a database, saving it to a file share, or any other action, depending on the implementation.</span></span> <span data-ttu-id="8b055-117">Die am häufigsten verwendete Aktion ist das Senden der Nachricht über ein Netzwerkprotokoll.</span><span class="sxs-lookup"><span data-stu-id="8b055-117">The most common action is sending the message over a network protocol.</span></span> <span data-ttu-id="8b055-118">Auf der Empfängerseite geschieht genau das Gegenteil: Eine Aktion wird erkannt (dabei kann es sich um das Eintreffen von TCP- oder HTTP-Paketen oder eine andere Aktion handeln) und nach der Verarbeitung vom Kanalstapel in eine gültige <xref:System.ServiceModel.Channels.Message> -Instanz umgewandelt.</span><span class="sxs-lookup"><span data-stu-id="8b055-118">On the receive side, the opposite happens—an action is detected (which may be TCP or HTTP packets arriving or any other action), and, after processing, the channel stack converts this action into a valid <xref:System.ServiceModel.Channels.Message> instance.</span></span>  
  
 <span data-ttu-id="8b055-119">Sie können WCF verwenden, indem Sie die <xref:System.ServiceModel.Channels.Message> -Klasse und den Kanal Stapel direkt verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b055-119">You can use WCF by using the <xref:System.ServiceModel.Channels.Message> class and the channel stack directly.</span></span> <span data-ttu-id="8b055-120">Dies ist jedoch schwierig und zeitaufwändig.</span><span class="sxs-lookup"><span data-stu-id="8b055-120">However, doing so is difficult and time-consuming.</span></span> <span data-ttu-id="8b055-121">Außerdem bietet das- <xref:System.ServiceModel.Channels.Message> Objekt keine Metadatenunterstützung, sodass Sie keine stark typisierten WCF-Clients generieren können, wenn Sie WCF auf diese Weise verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b055-121">Additionally, the <xref:System.ServiceModel.Channels.Message> object provides no metadata support, so you cannot generate strongly typed WCF clients if you use WCF in this manner.</span></span>  
  
 <span data-ttu-id="8b055-122">WCF enthält daher ein Dienst Framework, das ein benutzerfreundliches Programmiermodell bereitstellt, das Sie zum Erstellen und empfangen von-Objekten verwenden können `Message` .</span><span class="sxs-lookup"><span data-stu-id="8b055-122">Therefore, WCF includes a service framework that provides an easy-to-use programming model that you can use to construct and receive `Message` objects.</span></span> <span data-ttu-id="8b055-123">Das Dienst Framework ordnet Dienste .NET Framework Typen über das Konzept von Dienstverträgen zu und sendet Nachrichten an Benutzer Vorgänge, bei denen es sich einfach um .NET Framework mit dem-Attribut markierten Methoden handelt <xref:System.ServiceModel.OperationContractAttribute> (Weitere Informationen finden Sie unter [Entwerfen von Dienstverträgen](../designing-service-contracts.md)).</span><span class="sxs-lookup"><span data-stu-id="8b055-123">The service framework maps services to .NET Framework types through the notion of service contracts, and dispatches messages to user operations that are simply .NET Framework methods marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute (for more details, see [Designing Service Contracts](../designing-service-contracts.md)).</span></span> <span data-ttu-id="8b055-124">Diese Methoden verwenden möglicherweise Parameter und Rückgabewerte.</span><span class="sxs-lookup"><span data-stu-id="8b055-124">These methods may have parameters and return values.</span></span> <span data-ttu-id="8b055-125">Auf der Dienstseite wandelt das Dienstframework eingehende <xref:System.ServiceModel.Channels.Message> -Instanzen in Parameter um und Rückgabewerte in ausgehende <xref:System.ServiceModel.Channels.Message> -Instanzen.</span><span class="sxs-lookup"><span data-stu-id="8b055-125">On the service side, the service framework converts incoming <xref:System.ServiceModel.Channels.Message> instances into parameters and converts return values into outgoing <xref:System.ServiceModel.Channels.Message> instances.</span></span> <span data-ttu-id="8b055-126">Auf der Clientseite findet das Gegenteil statt.</span><span class="sxs-lookup"><span data-stu-id="8b055-126">On the client side, it does the opposite.</span></span> <span data-ttu-id="8b055-127">Betrachten Sie z.&#160;B. den nachfolgenden `FindAirfare` -Vorgang.</span><span class="sxs-lookup"><span data-stu-id="8b055-127">For example, consider the `FindAirfare` operation below.</span></span>  
  
 [!code-csharp[c_DataArchitecture#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#1)]
 [!code-vb[c_DataArchitecture#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#1)]  
  
 <span data-ttu-id="8b055-128">Nehmen wir an, auf dem Client wird `FindAirfare` aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="8b055-128">Suppose `FindAirfare` is called on the client.</span></span> <span data-ttu-id="8b055-129">Das Dienstframework auf dem Client wandelt die `FromCity` -Parameter und `ToCity` - Parameter in eine ausgehende <xref:System.ServiceModel.Channels.Message> -Instanz um und übergibt diese an den zu sendenden Kanalstapel.</span><span class="sxs-lookup"><span data-stu-id="8b055-129">The service framework on the client converts the `FromCity` and `ToCity` parameters into an outgoing <xref:System.ServiceModel.Channels.Message> instance and passes it to the channel stack to be sent.</span></span>  
  
 <span data-ttu-id="8b055-130">Wenn auf der Dienstseite eine <xref:System.ServiceModel.Channels.Message> -Instanz vom Kanalstapel ankommt, extrahiert das Dienstframework die relevanten Daten aus der Nachricht, um die `FromCity` -Parameter und `ToCity` -Parameter zu füllen, und ruft dann die dienstseitige `FindAirfare` -Methode auf.</span><span class="sxs-lookup"><span data-stu-id="8b055-130">On the service side, when a <xref:System.ServiceModel.Channels.Message> instance arrives from the channel stack, the service framework extracts the relevant data from the message to populate the `FromCity` and `ToCity` parameters and then calls the service-side `FindAirfare` method.</span></span> <span data-ttu-id="8b055-131">Wenn die Methode zurückgegeben wird, verwendet das Dienstframework den zurückgegebenen Ganzzahlwert und den `IsDirectFlight` -Ausgabeparameter und erstellt eine <xref:System.ServiceModel.Channels.Message> -Objektinstanz, die diese Informationen enthält.</span><span class="sxs-lookup"><span data-stu-id="8b055-131">When the method returns, the service framework takes the returned integer value and the `IsDirectFlight` output parameter and creates a <xref:System.ServiceModel.Channels.Message> object instance that contains this information.</span></span> <span data-ttu-id="8b055-132">Es übergibt dann die `Message` -Instanz an den Kanalstapel, damit sie an den Client zurückgesendet wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-132">It then passes the `Message` instance to the channel stack to be sent back to the client.</span></span>  
  
 <span data-ttu-id="8b055-133">Auf der Clientseite entsteht eine <xref:System.ServiceModel.Channels.Message> -Instanz, die die Antwortmeldung vom Kanalstapel enthält.</span><span class="sxs-lookup"><span data-stu-id="8b055-133">On the client side, a <xref:System.ServiceModel.Channels.Message> instance that contains the response message emerges from the channel stack.</span></span> <span data-ttu-id="8b055-134">Das Dienstframework extrahiert den Rückgabewert und den `IsDirectFlight` -Wert und gibt diese an den Aufrufer des Clients zurück.</span><span class="sxs-lookup"><span data-stu-id="8b055-134">The service framework extracts the return value and the `IsDirectFlight` value and returns these to the caller of the client.</span></span>  
  
## <a name="message-class"></a><span data-ttu-id="8b055-135">Nachrichtenklasse</span><span class="sxs-lookup"><span data-stu-id="8b055-135">Message Class</span></span>  

 <span data-ttu-id="8b055-136">Die <xref:System.ServiceModel.Channels.Message> -Klasse soll eine abstrakte Darstellung einer Nachricht sein, ihre Struktur ist jedoch eng mit der SOAP-Nachricht verbunden.</span><span class="sxs-lookup"><span data-stu-id="8b055-136">The <xref:System.ServiceModel.Channels.Message> class is intended to be an abstract representation of a message, but its design is strongly tied to the SOAP message.</span></span> <span data-ttu-id="8b055-137">Eine <xref:System.ServiceModel.Channels.Message> enthält drei Hauptinformationen: einen Nachrichtentext, Nachrichtenheader und Nachrichteneigenschaften.</span><span class="sxs-lookup"><span data-stu-id="8b055-137">A <xref:System.ServiceModel.Channels.Message> contains three major pieces of information: a message body, message headers, and message properties.</span></span>  
  
## <a name="message-body"></a><span data-ttu-id="8b055-138">Nachrichtentext</span><span class="sxs-lookup"><span data-stu-id="8b055-138">Message Body</span></span>  

 <span data-ttu-id="8b055-139">Der Nachrichtentext soll die tatsächliche Datennutzlast der Nachricht darstellen.</span><span class="sxs-lookup"><span data-stu-id="8b055-139">The message body is intended to represent the actual data payload of the message.</span></span> <span data-ttu-id="8b055-140">Der Nachrichtentext wird immer als XML-Infoset dargestellt.</span><span class="sxs-lookup"><span data-stu-id="8b055-140">The message body is always represented as an XML Infoset.</span></span> <span data-ttu-id="8b055-141">Dies bedeutet nicht, dass alle Nachrichten, die in WCF erstellt oder empfangen werden, im XML-Format vorliegen müssen.</span><span class="sxs-lookup"><span data-stu-id="8b055-141">This does not mean that all messages created or received in WCF must be in XML format.</span></span> <span data-ttu-id="8b055-142">Es obliegt dem Kanalstapel, zu entscheiden, wie der Nachrichtentext interpretiert wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-142">It is up to the channel stack to decide how to interpret the message body.</span></span> <span data-ttu-id="8b055-143">Er wird eventuell als XML ausgegeben, in ein anderes Format konvertiert oder sogar ganz weggelassen.</span><span class="sxs-lookup"><span data-stu-id="8b055-143">It may emit it as XML, convert it to some other format, or even omit it entirely.</span></span> <span data-ttu-id="8b055-144">Natürlich wird bei den meisten Bindungen, die WCF bereitstellt, der Nachrichtentext als XML-Inhalt im Textabschnitt eines SOAP-Umschlags dargestellt.</span><span class="sxs-lookup"><span data-stu-id="8b055-144">Of course, with most of the bindings WCF supplies, the message body is represented as XML content in the body section of a SOAP envelope.</span></span>  
  
 <span data-ttu-id="8b055-145">Ihnen sollte auf jeden Fall bewusst sein, dass die `Message` -Klasse nicht unbedingt einen Puffer mit XML-Daten enthält, die den Textkörper darstellen.</span><span class="sxs-lookup"><span data-stu-id="8b055-145">It is important to realize that the `Message` class does not necessarily contain a buffer with XML data representing the body.</span></span> <span data-ttu-id="8b055-146">`Message` enthält zwar ein XML-Infoset, dieser Infoset wurde jedoch eventuell dynamisch erstellt und ist im Speicher gar nicht physisch vorhanden.</span><span class="sxs-lookup"><span data-stu-id="8b055-146">Logically, `Message` contains an XML Infoset, but this Infoset may be dynamically constructed and may never physically exist in memory.</span></span>  
  
### <a name="putting-data-into-the-message-body"></a><span data-ttu-id="8b055-147">Einfügen von Daten in den Nachrichtentext</span><span class="sxs-lookup"><span data-stu-id="8b055-147">Putting Data into the Message Body</span></span>  

 <span data-ttu-id="8b055-148">Es gibt kein einheitliches Verfahren zum Einfügen von Daten in einen Nachrichtentext.</span><span class="sxs-lookup"><span data-stu-id="8b055-148">There is no uniform mechanism to put data into a message body.</span></span> <span data-ttu-id="8b055-149">Die <xref:System.ServiceModel.Channels.Message> -Klasse bietet eine abstrakte Methode, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, die <xref:System.Xml.XmlDictionaryWriter>akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="8b055-149">The <xref:System.ServiceModel.Channels.Message> class has an abstract method, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, which takes an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="8b055-150">Jede Unterklasse der <xref:System.ServiceModel.Channels.Message> -Klasse ist für das Überschreiben dieser Methode und Schreiben ihres eigenen Inhalts verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="8b055-150">Each subclass of the <xref:System.ServiceModel.Channels.Message> class is responsible for overriding this method and writing out its own contents.</span></span> <span data-ttu-id="8b055-151">Der Nachrichtentext enthält den XML-Infoset, der `OnWriteBodyContent` erzeugt, logisch.</span><span class="sxs-lookup"><span data-stu-id="8b055-151">The message body logically contains the XML Infoset that `OnWriteBodyContent` produces.</span></span> <span data-ttu-id="8b055-152">Betrachten Sie beispielsweise die folgende `Message` -Unterklasse:</span><span class="sxs-lookup"><span data-stu-id="8b055-152">For example, consider the following `Message` subclass.</span></span>  
  
 [!code-csharp[c_DataArchitecture#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#2)]
 [!code-vb[c_DataArchitecture#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#2)]  
  
 <span data-ttu-id="8b055-153">Physisch enthält eine `AirfareRequestMessage` -Instanz nur zwei Zeichenfolgen ("fromCity" und "toCity").</span><span class="sxs-lookup"><span data-stu-id="8b055-153">Physically, an `AirfareRequestMessage` instance contains only two strings ("fromCity" and "toCity").</span></span> <span data-ttu-id="8b055-154">Logisch enthält die Nachricht jedoch den folgenden XML-Infoset:</span><span class="sxs-lookup"><span data-stu-id="8b055-154">However, logically the message contains the following XML infoset:</span></span>  
  
```xml  
<airfareRequest>  
    <from>Tokyo</from>  
    <to>London</to>  
</airfareRequest>  
```  
  
 <span data-ttu-id="8b055-155">Selbstverständlich würden Sie im Normalfall keine Nachrichten auf diese Weise erstellen, da Sie zum Erstellen einer Nachricht wie der vorhergehenden aus Vorgangsvertragsparametern das Dienstframework verwenden können.</span><span class="sxs-lookup"><span data-stu-id="8b055-155">Of course, you would normally not create messages in this manner, because you can use the service framework to create a message like the preceding one from operation contract parameters.</span></span> <span data-ttu-id="8b055-156">Darüber hinaus bietet die <xref:System.ServiceModel.Channels.Message> -Klasse statische `CreateMessage` -Methoden, mit denen Sie Nachrichten mit häufig verwendeten Inhaltstypen erstellen können: eine leere Nachricht, eine Nachricht mit einem mit <xref:System.Runtime.Serialization.DataContractSerializer>XML-serialisierten Objekt, eine Nachricht, die einen SOAP-Fehler enthält, eine Nachricht, die durch <xref:System.Xml.XmlReader>dargestelltes XML enthält usw.</span><span class="sxs-lookup"><span data-stu-id="8b055-156">Additionally, the <xref:System.ServiceModel.Channels.Message> class has static `CreateMessage` methods that you can use to create messages with common types of content: an empty message, a message that contains an object serialized to XML with the <xref:System.Runtime.Serialization.DataContractSerializer>, a message that contains a SOAP fault, a message that contains XML represented by an <xref:System.Xml.XmlReader>, and so on.</span></span>  
  
### <a name="getting-data-from-a-message-body"></a><span data-ttu-id="8b055-157">Abrufen von Daten aus einem Nachrichtentext</span><span class="sxs-lookup"><span data-stu-id="8b055-157">Getting Data from a Message Body</span></span>  

 <span data-ttu-id="8b055-158">Sie können die in einem Nachrichtentext gespeicherten Daten auf zwei Arten extrahieren:</span><span class="sxs-lookup"><span data-stu-id="8b055-158">You can extract the data stored in a message body in two main ways:</span></span>  
  
- <span data-ttu-id="8b055-159">Sie können den gesamten Nachrichtentext einmalig abrufen, indem Sie die <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> -Methode aufrufen und einen XML-Writer übergeben.</span><span class="sxs-lookup"><span data-stu-id="8b055-159">You can get the entire message body at one time by calling the <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method and passing in an XML writer.</span></span> <span data-ttu-id="8b055-160">Der vollständige Nachrichtentext wird an diesen Writer ausgeschrieben.</span><span class="sxs-lookup"><span data-stu-id="8b055-160">The complete message body is written out to this writer.</span></span> <span data-ttu-id="8b055-161">Das einmalige Abrufen des gesamten Nachrichtentexts wird auch als *Schreiben einer Nachricht* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="8b055-161">Getting the entire message body at one time is also called *writing a message*.</span></span> <span data-ttu-id="8b055-162">Das Schreiben wird hauptsächlich beim Senden der Nachrichten vom Kanalstapel übernommen. Ein Teil des Kanalstapels erhält in der Regel Zugriff auf den gesamten Nachrichtentext, codiert diesen und sendet ihn.</span><span class="sxs-lookup"><span data-stu-id="8b055-162">Writing is done primarily by the channel stack when sending messages—some part of the channel stack will usually get access to the entire message body, encode it, and send it.</span></span>  
  
- <span data-ttu-id="8b055-163">Eine weitere Methode zum Abrufen von Informationen aus dem Nachrichtentext besteht im Aufrufen von <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> und Abrufen eines XML-Lesers.</span><span class="sxs-lookup"><span data-stu-id="8b055-163">Another way to get information out of the message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> and get an XML reader.</span></span> <span data-ttu-id="8b055-164">Auf den Nachrichtentext kann dann nacheinander nach Bedarf zugegriffen werden, indem Methoden im Reader aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-164">The message body can then be accessed sequentially as needed by calling methods on the reader.</span></span> <span data-ttu-id="8b055-165">Das Abrufen des Nachrichtentexts Stück für Stück wird auch als *Lesen einer Nachricht* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="8b055-165">Getting the message body piece-by-piece is also called *reading a message*.</span></span> <span data-ttu-id="8b055-166">Das Lesen der Nachricht wird hauptsächlich beim Empfangen von Nachrichten vom Dienstframework verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b055-166">Reading the message is primarily used by the service framework when receiving messages.</span></span> <span data-ttu-id="8b055-167">Wenn z.&#160;B. <xref:System.Runtime.Serialization.DataContractSerializer> verwendet wird, lässt das Dienstframework einen XML-Leser über den Nachrichtentext laufen und übergibt ihn dann an die Deserialisierungs-Engine, die dann mit dem Lesen der Nachricht Element für Element und mit dem Erstellen des entsprechenden Objektdiagramms beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b055-167">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use, the service framework will get an XML reader over the body and pass it to the deserialization engine, which will then start reading the message element-by-element and constructing the corresponding object graph.</span></span>  
  
 <span data-ttu-id="8b055-168">Ein Nachrichtentext kann nur einmalig abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-168">A message body can be retrieved only once.</span></span> <span data-ttu-id="8b055-169">Dies macht es möglich, mit Vorwärtsstreams zu arbeiten.</span><span class="sxs-lookup"><span data-stu-id="8b055-169">This makes it possible to work with forward-only streams.</span></span> <span data-ttu-id="8b055-170">So können Sie z.&#160;B. eine <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> -Überschreibung schreiben, die aus <xref:System.IO.FileStream> liest und die Ergebnisse als XML-Infoset zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b055-170">For example, you can write an <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> override that reads from a <xref:System.IO.FileStream> and returns the results as an XML Infoset.</span></span> <span data-ttu-id="8b055-171">Sie müssen niemals an den Anfang der Datei "Zurückspulen".</span><span class="sxs-lookup"><span data-stu-id="8b055-171">You will never need to "rewind" to the beginning of the file.</span></span>  
  
 <span data-ttu-id="8b055-172">Die `WriteBodyContents` -Methode und `GetReaderAtBodyContents` -Methode prüfen einfach, ob der Nachrichtentext schon zuvor einmal abgerufen wurde, und rufen dann `OnWriteBodyContents` oder `OnGetReaderAtBodyContents`auf.</span><span class="sxs-lookup"><span data-stu-id="8b055-172">The `WriteBodyContents` and `GetReaderAtBodyContents` methods simply check that the message body has never been retrieved before, and then call `OnWriteBodyContents` or `OnGetReaderAtBodyContents`, respectively.</span></span>  
  
## <a name="message-usage-in-wcf"></a><span data-ttu-id="8b055-173">Nachrichtenverwendung in WCF</span><span class="sxs-lookup"><span data-stu-id="8b055-173">Message Usage in WCF</span></span>  

 <span data-ttu-id="8b055-174">Die meisten Nachrichten können entweder als *ausgehend* (diejenigen, die vom Dienstframework zum Senden vom Kanalstapel erstellt werden) oder *eingehend* (diejenigen, die vom Kanalstapel eingehen und vom Dienstframework interpretiert werden) klassifiziert werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-174">Most messages can be classified as either *outgoing* (those that are created by the service framework to be sent by the channel stack) or *incoming* (those that arrive from the channel stack and are interpreted by the service framework).</span></span> <span data-ttu-id="8b055-175">Weiterhin kann der Kanalstapel entweder im gepufferten oder Streamingmodus operieren.</span><span class="sxs-lookup"><span data-stu-id="8b055-175">Furthermore, the channel stack can operate in either buffered or streaming mode.</span></span> <span data-ttu-id="8b055-176">Das Dienstframework kann auch ein per Streaming oder nicht per Streaming übertragenes Programmiermodell verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="8b055-176">The service framework may also expose a streamed or nonstreamed programming model.</span></span> <span data-ttu-id="8b055-177">Dies führt zu den in der folgenden Tabelle aufgelisteten Fällen, zusammen mit vereinfachten Details ihrer Implementierung.</span><span class="sxs-lookup"><span data-stu-id="8b055-177">This leads to the cases listed in the following table, along with simplified details of their implementation.</span></span>  
  
|<span data-ttu-id="8b055-178">Nachrichtentyp</span><span class="sxs-lookup"><span data-stu-id="8b055-178">Message type</span></span>|<span data-ttu-id="8b055-179">Textdaten in Nachricht</span><span class="sxs-lookup"><span data-stu-id="8b055-179">Body data in message</span></span>|<span data-ttu-id="8b055-180">Write-Implementierung (OnWriteBodyContents)</span><span class="sxs-lookup"><span data-stu-id="8b055-180">Write (OnWriteBodyContents) implementation</span></span>|<span data-ttu-id="8b055-181">Read-Implementierung (OnGetReaderAtBodyContents)</span><span class="sxs-lookup"><span data-stu-id="8b055-181">Read (OnGetReaderAtBodyContents) Implementation</span></span>|  
|------------------|--------------------------|--------------------------------------------------|-------------------------------------------------------|  
|<span data-ttu-id="8b055-182">Ausgehend, erstellt von nicht per Streaming übertragenem Programmiermodell</span><span class="sxs-lookup"><span data-stu-id="8b055-182">Outgoing, created from nonstreamed programming model</span></span>|<span data-ttu-id="8b055-183">Die zum Schreiben der Nachricht benötigten Daten (z.&#160;B. ein Objekt und die zum Serialisieren benötigte <xref:System.Runtime.Serialization.DataContractSerializer> -Instanz)\*</span><span class="sxs-lookup"><span data-stu-id="8b055-183">The data needed to write the message (for example, an object and the <xref:System.Runtime.Serialization.DataContractSerializer> instance needed to serialize it)\*</span></span>|<span data-ttu-id="8b055-184">Eine benutzerdefinierte Logik zum Schreiben der Nachricht basierend auf den gespeicherten Daten (z. .B Aufruf von `WriteObject` am `DataContractSerializer` , falls dies das verwendete Serialisierungsprogramm ist)\*</span><span class="sxs-lookup"><span data-stu-id="8b055-184">Custom logic to write out the message based on the stored data (for example, call `WriteObject` on the `DataContractSerializer` if that is the serializer in use)\*</span></span>|<span data-ttu-id="8b055-185">Aufrufen von `OnWriteBodyContents`, Puffern der Ergebnisse, Ausgeben eines XML-Lesers über den Puffer</span><span class="sxs-lookup"><span data-stu-id="8b055-185">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="8b055-186">Ausgehend, erstellt von per Streaming übertragenem Programmiermodell</span><span class="sxs-lookup"><span data-stu-id="8b055-186">Outgoing, created from streamed programming model</span></span>|<span data-ttu-id="8b055-187">Der `Stream` mit den zu schreibenden Daten\*</span><span class="sxs-lookup"><span data-stu-id="8b055-187">The `Stream` with the data to be written\*</span></span>|<span data-ttu-id="8b055-188">Schreiben von Daten vom gespeicherten Stream mit dem <xref:System.Xml.IStreamProvider> -Mechanismus \*</span><span class="sxs-lookup"><span data-stu-id="8b055-188">Write out data from the stored stream using the <xref:System.Xml.IStreamProvider> mechanism\*</span></span>|<span data-ttu-id="8b055-189">Aufrufen von `OnWriteBodyContents`, Puffern der Ergebnisse, Ausgeben eines XML-Lesers über den Puffer</span><span class="sxs-lookup"><span data-stu-id="8b055-189">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="8b055-190">Eingehend von Streamingkanalstapel</span><span class="sxs-lookup"><span data-stu-id="8b055-190">Incoming from streaming channel stack</span></span>|<span data-ttu-id="8b055-191">Ein `Stream` -Objekt, das die Daten darstellt, die über das Netzwerk mit einem darauf angewendeten <xref:System.Xml.XmlReader> eingehen</span><span class="sxs-lookup"><span data-stu-id="8b055-191">A `Stream` object that represents the data coming in over the network with an <xref:System.Xml.XmlReader> over it</span></span>|<span data-ttu-id="8b055-192">Ausschreiben des Inhalts aus dem gespeicherten `XmlReader` mit `WriteNode`</span><span class="sxs-lookup"><span data-stu-id="8b055-192">Write out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="8b055-193">Gibt den gespeicherten `XmlReader`zurück</span><span class="sxs-lookup"><span data-stu-id="8b055-193">Returns the stored `XmlReader`</span></span>|  
|<span data-ttu-id="8b055-194">Eingehend von nicht per Streaming übertragenem Kanalstapel</span><span class="sxs-lookup"><span data-stu-id="8b055-194">Incoming from nonstreaming channel stack</span></span>|<span data-ttu-id="8b055-195">Ein Puffer, der Textdaten enthält, mit einem darauf angewendeten `XmlReader`</span><span class="sxs-lookup"><span data-stu-id="8b055-195">A buffer that contains body data with an `XmlReader` over it</span></span>|<span data-ttu-id="8b055-196">Schreibt den Inhalt des gespeicherten `XmlReader` mit `WriteNode`aus</span><span class="sxs-lookup"><span data-stu-id="8b055-196">Writes out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="8b055-197">Gibt die gespeicherte Sprache zurück</span><span class="sxs-lookup"><span data-stu-id="8b055-197">Returns the stored lang</span></span>|  
  
 <span data-ttu-id="8b055-198">\* Diese Elemente werden nicht direkt in `Message` Unterklassen implementiert, sondern in Unterklassen der- <xref:System.ServiceModel.Channels.BodyWriter> Klasse.</span><span class="sxs-lookup"><span data-stu-id="8b055-198">\* These items are not implemented directly in `Message` subclasses, but in subclasses of the <xref:System.ServiceModel.Channels.BodyWriter> class.</span></span> <span data-ttu-id="8b055-199">Weitere Informationen zum <xref:System.ServiceModel.Channels.BodyWriter>finden Sie unter [Using the Message Class](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="8b055-199">For more information about the <xref:System.ServiceModel.Channels.BodyWriter>, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-headers"></a><span data-ttu-id="8b055-200">Nachrichtenheader</span><span class="sxs-lookup"><span data-stu-id="8b055-200">Message Headers</span></span>  

 <span data-ttu-id="8b055-201">Eine Nachricht enthält möglicherweise Header.</span><span class="sxs-lookup"><span data-stu-id="8b055-201">A message may contain headers.</span></span> <span data-ttu-id="8b055-202">Ein Header besteht logisch aus einem XML-Infoset, der einem Namen, einem Namespace und einigen anderen Eigenschaften zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="8b055-202">A header logically consists of an XML Infoset that is associated with a name, a namespace, and a few other properties.</span></span> <span data-ttu-id="8b055-203">Auf Nachrichtenheader wird mit der `Headers` -Eigenschaft auf <xref:System.ServiceModel.Channels.Message>zugegriffen.</span><span class="sxs-lookup"><span data-stu-id="8b055-203">Message headers are accessed using the `Headers` property on <xref:System.ServiceModel.Channels.Message>.</span></span> <span data-ttu-id="8b055-204">Jeder Header wird durch eine <xref:System.ServiceModel.Channels.MessageHeader> -Klasse dargestellt.</span><span class="sxs-lookup"><span data-stu-id="8b055-204">Each header is represented by a <xref:System.ServiceModel.Channels.MessageHeader> class.</span></span> <span data-ttu-id="8b055-205">In der Regel sind Nachrichtenheader SOAP-Nachrichtenheadern zugeordnet, wenn ein Kanalstapel verwendet wird, der für SOAP-Nachrichten konfiguriert ist.</span><span class="sxs-lookup"><span data-stu-id="8b055-205">Normally, message headers are mapped to SOAP message headers when using a channel stack configured to work with SOAP messages.</span></span>  
  
 <span data-ttu-id="8b055-206">Das Einfügen von Informationen in einen Nachrichtenheader und das Extrahieren von Daten daraus ähnelt der Verwendung des Nachrichtentexts.</span><span class="sxs-lookup"><span data-stu-id="8b055-206">Putting information into a message header and extracting information from it is similar to using the message body.</span></span> <span data-ttu-id="8b055-207">Der Prozess wird ein wenig vereinfacht, da das Streaming nicht unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-207">The process is somewhat simplified because streaming is not supported.</span></span> <span data-ttu-id="8b055-208">Es ist möglich, auf den Inhalt desselben Headers mehr als einmal zuzugreifen. Auf die Header kann auch in willkürlicher Reihenfolge zugegriffen werden. Die Header werden dadurch gezwungen, immer gepuffert zu sein.</span><span class="sxs-lookup"><span data-stu-id="8b055-208">It is possible to access the contents of the same header more than once, and headers can be accessed in arbitrary order, forcing headers to always be buffered.</span></span> <span data-ttu-id="8b055-209">Es ist kein allgemeiner Mechanismus verfügbar, um einen XML-Reader über einen Header zu erhalten, aber es gibt eine `MessageHeader` interne Unterklasse von WCF, die einen lesbaren Header mit einer solchen Funktion darstellt.</span><span class="sxs-lookup"><span data-stu-id="8b055-209">There is no general-purpose mechanism available to get an XML reader over a header, but there is a `MessageHeader` subclass internal to WCF that represents a readable header with such a capability.</span></span> <span data-ttu-id="8b055-210">Diese Art von `MessageHeader` wird vom Kanalstapel erstellt, wenn eine Nachricht mit benutzerdefinierten Anwendungsheadern eingeht.</span><span class="sxs-lookup"><span data-stu-id="8b055-210">This type of `MessageHeader` is created by the channel stack when a message with custom application headers comes in.</span></span> <span data-ttu-id="8b055-211">So kann das Dienstframework eine Deserialisierungs-Engine, z.B. den <xref:System.Runtime.Serialization.DataContractSerializer>, zum Interpretieren dieser Header verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b055-211">This enables the service framework to use a deserialization engine, such as the <xref:System.Runtime.Serialization.DataContractSerializer>, to interpret these headers.</span></span>  
  
 <span data-ttu-id="8b055-212">Weitere Informationen finden Sie unter [Verwenden der Message-Klasse](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="8b055-212">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-properties"></a><span data-ttu-id="8b055-213">Nachrichteneigenschaften</span><span class="sxs-lookup"><span data-stu-id="8b055-213">Message Properties</span></span>  

 <span data-ttu-id="8b055-214">Eine Nachricht kann Eigenschaften enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b055-214">A message may contain properties.</span></span> <span data-ttu-id="8b055-215">Eine *Eigenschaft* ist ein beliebiges .NET Framework Objekt, das einem Zeichen folgen Namen zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="8b055-215">A *property* is any .NET Framework object that is associated with a string name.</span></span> <span data-ttu-id="8b055-216">Der Zugriff erfolgt über die `Properties` -Eigenschaft von `Message`.</span><span class="sxs-lookup"><span data-stu-id="8b055-216">Properties are accessed through the `Properties` property on `Message`.</span></span>  
  
 <span data-ttu-id="8b055-217">Im Gegensatz zum Nachrichtentext und den Nachrichtenheadern (die in der Regel dem SOAP-Text und den SOAP-Headern zugeordnet sind) werden Nachrichteneigenschaften in der Regel nicht zusammen mit den Nachrichten gesendet oder empfangen.</span><span class="sxs-lookup"><span data-stu-id="8b055-217">Unlike the message body and message headers (which normally map to the SOAP body and SOAP headers, respectively), message properties are normally not sent or received along with the messages.</span></span> <span data-ttu-id="8b055-218">Nachrichteneigenschaften existieren hauptsächlich als Kommunikationsmechanismus zum Übergeben von Daten über die Nachricht zwischen den verschiedenen Kanälen im Kanalstapel und zwischen dem Kanalstapel und dem Dienstmodell.</span><span class="sxs-lookup"><span data-stu-id="8b055-218">Message properties exist primarily as a communication mechanism to pass data about the message between the various channels in the channel stack, and between the channel stack and the service model.</span></span>  
  
 <span data-ttu-id="8b055-219">Beispielsweise kann der als Teil von WCF enthaltene HTTP-Transport Kanal verschiedene HTTP-Statuscodes erzeugen, z. b. "404 (nicht gefunden)" und "500 (interner Server Fehler)", wenn Antworten an Clients gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-219">For example, the HTTP transport channel included as part of WCF is capable of producing various HTTP status codes, such as "404 (Not Found)" and "500 (Internal Server Error)," when it sends replies to clients.</span></span> <span data-ttu-id="8b055-220">Vor dem Senden einer Antwortnachricht wird überprüft, ob die `Properties` der- `Message` Eigenschaft eine Eigenschaft mit dem Namen "HttpResponse" enthält, die ein Objekt vom Typ enthält <xref:System.ServiceModel.Channels.HttpResponseMessageProperty> .</span><span class="sxs-lookup"><span data-stu-id="8b055-220">Before sending a reply message, it checks to see whether the `Properties` of the `Message` contain a property called "httpResponse" that contains an object of type <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>.</span></span> <span data-ttu-id="8b055-221">Wird eine solche Eigenschaft gefunden, wird die <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> -Eigenschaft geprüft und dieser Statuscode verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b055-221">If such a property is found, it will look at the <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> property and use that status code.</span></span> <span data-ttu-id="8b055-222">Andernfalls wird der Standardcode "200 (OK)" verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b055-222">If it is not found, the default "200 (OK)" code is used.</span></span>  
  
 <span data-ttu-id="8b055-223">Weitere Informationen finden Sie unter [Verwenden der Message-Klasse](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="8b055-223">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
### <a name="the-message-as-a-whole"></a><span data-ttu-id="8b055-224">Die Nachricht als Ganzes</span><span class="sxs-lookup"><span data-stu-id="8b055-224">The Message as a Whole</span></span>  

 <span data-ttu-id="8b055-225">Bis jetzt wurden Methoden für den Zugriff auf die verschiedenen Bestandteile der Nachricht isoliert erläutert.</span><span class="sxs-lookup"><span data-stu-id="8b055-225">So far, we have discussed methods for accessing the various parts of the message in isolation.</span></span> <span data-ttu-id="8b055-226">Die <xref:System.ServiceModel.Channels.Message> -Klasse stellt jedoch auch Methoden bereit, die mit der Nachricht als Ganzes ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-226">However, the <xref:System.ServiceModel.Channels.Message> class also provides methods to work with the entire message as a whole.</span></span> <span data-ttu-id="8b055-227">Die folgende `WriteMessage` -Methode schreibt z. B. die gesamte Nachricht in einen XML-Writer.</span><span class="sxs-lookup"><span data-stu-id="8b055-227">For example, the `WriteMessage` method writes out the entire message to an XML writer.</span></span>  
  
 <span data-ttu-id="8b055-228">Damit dies möglich ist, muss zwischen der gesamten `Message` -Instanz und einem XML-Infoset eine Zuordnung definiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-228">For this to be possible, a mapping must be defined between the entire `Message` instance and an XML Infoset.</span></span> <span data-ttu-id="8b055-229">Eine solche Zuordnung ist tatsächlich vorhanden: WCF verwendet den SOAP-Standard, um diese Zuordnung zu definieren.</span><span class="sxs-lookup"><span data-stu-id="8b055-229">Such a mapping, in fact, exists: WCF uses the SOAP standard to define this mapping.</span></span> <span data-ttu-id="8b055-230">Wenn eine `Message` -Instanz als XML-Infoset geschrieben wird, ist der daraus resultierende Infoset der gültige SOAP-Umschlag, der die Nachricht enthält.</span><span class="sxs-lookup"><span data-stu-id="8b055-230">When a `Message` instance is written out as an XML Infoset, the resulting Infoset is the valid SOAP envelope that contains the message.</span></span> <span data-ttu-id="8b055-231">So würde `WriteMessage` normalerweise die folgenden Schritte ausführen:</span><span class="sxs-lookup"><span data-stu-id="8b055-231">Thus, `WriteMessage` would normally perform the following steps:</span></span>  
  
1. <span data-ttu-id="8b055-232">Schreiben des öffnenden SOAP-Umschlagelementtags.</span><span class="sxs-lookup"><span data-stu-id="8b055-232">Write the SOAP envelope element opening tag.</span></span>  
  
2. <span data-ttu-id="8b055-233">Schreiben des öffnenden SOAP-Headerelementtags, Schreiben aller Header und Schließen des Headerelements.</span><span class="sxs-lookup"><span data-stu-id="8b055-233">Write the SOAP header element opening tag, write out all of the headers, and close the header element.</span></span>  
  
3. <span data-ttu-id="8b055-234">Schreiben des öffnenden SOAP-Textkörperelementtags.</span><span class="sxs-lookup"><span data-stu-id="8b055-234">Write the SOAP body element opening tag.</span></span>  
  
4. <span data-ttu-id="8b055-235">Aufrufen von `WriteBodyContents` oder einer entsprechenden Methode zum Schreiben des Texts.</span><span class="sxs-lookup"><span data-stu-id="8b055-235">Call `WriteBodyContents` or an equivalent method to write out the body.</span></span>  
  
5. <span data-ttu-id="8b055-236">Schließen der Text- und Umschlagelemente.</span><span class="sxs-lookup"><span data-stu-id="8b055-236">Close the body and envelope elements.</span></span>  
  
 <span data-ttu-id="8b055-237">Die vorhergehenden Schritte sind eng an den SOAP-Standard gebunden.</span><span class="sxs-lookup"><span data-stu-id="8b055-237">The preceding steps are closely tied to the SOAP standard.</span></span> <span data-ttu-id="8b055-238">Dies wird durch die Tatsache komplizierter, dass mehrere SOAP-Versionen vorhanden sind. So ist es z.&#160;B. möglich, das SOAP-Umschlagelement richtig zu schreiben, ohne die verwendete SOAP-Version zu kennen.</span><span class="sxs-lookup"><span data-stu-id="8b055-238">This is complicated by the fact that multiple versions of SOAP exist, for example, it is impossible to write out the SOAP envelope element correctly without knowing the SOAP version in use.</span></span> <span data-ttu-id="8b055-239">Auch in einigen Fällen ist es möglicherweise wünschenswert, diese komplexe SOAP-spezifische Zuordnung völlig auszuschalten.</span><span class="sxs-lookup"><span data-stu-id="8b055-239">Also, in some cases, it may be desirable to turn off this complex SOAP-specific mapping completely.</span></span>  
  
 <span data-ttu-id="8b055-240">Für diese Zwecke wird eine `Version` -Eigenschaft für `Message`bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="8b055-240">For these purposes, a `Version` property is provided on `Message`.</span></span> <span data-ttu-id="8b055-241">Sie kann auf die SOAP-Version festgelegt werden, die beim Schreiben der Nachricht verwendet wird, oder sie kann auf `None` festgelegt werden, um SOAP-spezifische Zuordnungen zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="8b055-241">It can be set to the SOAP version to use when writing out the message, or it can be set to `None` to prevent any SOAP-specific mappings.</span></span> <span data-ttu-id="8b055-242">Falls die `Version` -Eigenschaft auf `None`festgelegt ist, funktionieren Methoden, die mit der gesamten Nachricht arbeiten, so, als ob die Nachricht lediglich aus dem Textkörper besteht. So würde z.&#160;B. `WriteMessage` einfach `WriteBodyContents` aufrufen, und die oben beschriebenen Schritte werden nicht ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b055-242">If the `Version` property is set to `None`, methods that work with the entire message act as if the message consisted of its body only, for example, `WriteMessage` would simply call `WriteBodyContents` instead of performing the multiple steps listed above.</span></span> <span data-ttu-id="8b055-243">Es wird erwartet, dass `Version` in eingehenden Nachrichten automatisch erkannt und ordnungsgemäß festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-243">It is expected that on incoming messages, `Version` will be auto-detected and set correctly.</span></span>  
  
## <a name="the-channel-stack"></a><span data-ttu-id="8b055-244">Der Kanalstapel</span><span class="sxs-lookup"><span data-stu-id="8b055-244">The Channel Stack</span></span>  
  
### <a name="channels"></a><span data-ttu-id="8b055-245">Kanäle</span><span class="sxs-lookup"><span data-stu-id="8b055-245">Channels</span></span>  

 <span data-ttu-id="8b055-246">Wie zuvor bereits beschrieben, ist der Kanalstapel für die Umwandlung von ausgehenden <xref:System.ServiceModel.Channels.Message> -Instanzen in eine Aktion (wie Senden von Paketen über das Netzwerk) oder Umwandeln einer Aktion (wie Empfangen von Netzwerkpakten) in eingehende `Message` -Instanzen verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="8b055-246">As stated before, the channel stack is responsible for converting outgoing <xref:System.ServiceModel.Channels.Message> instances into some action (such as sending packets over the network), or converting some action (such as receiving network packets) into incoming `Message` instances.</span></span>  
  
 <span data-ttu-id="8b055-247">Der Kanalstapel besteht aus einem oder aus mehreren Kanälen, die in einer Sequenz angeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="8b055-247">The channel stack is composed of one or more channels ordered in a sequence.</span></span> <span data-ttu-id="8b055-248">Eine ausgehende `Message` -Instanz wird an den ersten Kanal im Stapel (auch als *oberster Kanal* bezeichnet) übergeben, der sie wiederum an den nächsten Kanal im Stapel übergibt usw.</span><span class="sxs-lookup"><span data-stu-id="8b055-248">An outgoing `Message` instance is passed to the first channel in the stack (also called the *topmost channel*), which passes it to the next channel down in stack, and so on.</span></span> <span data-ttu-id="8b055-249">Die Nachricht endet im letzten Kanal, der als *Transportkanal* bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-249">The message terminates in the last channel, which is called the *transport channel*.</span></span> <span data-ttu-id="8b055-250">Eingehende Nachrichten stammen aus dem Transportkanal und werden von Kanal zu Kanal nach oben im Stapel übergeben.</span><span class="sxs-lookup"><span data-stu-id="8b055-250">Incoming messages originate in the transport channel and are passed from channel to channel up the stack.</span></span> <span data-ttu-id="8b055-251">Vom obersten Kanal wird die Nachricht normalerweise in das Dienstframework übergeben.</span><span class="sxs-lookup"><span data-stu-id="8b055-251">From the topmost channel, the message is usually passed into the service framework.</span></span> <span data-ttu-id="8b055-252">Dies ist das Muster für Anwendungsnachrichten, das in der Regel verwendet wird. Einige Kanäle funktionieren eventuell anders. Sie senden z.&#160;B. eigene Infrastrukturnachrichten, ohne eine Nachricht von einem oben beschriebenen Kanal zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="8b055-252">While this is the usual pattern for application messages, some channels may work slightly differently, for example, they may send their own infrastructure messages without being passed a message from a channel above.</span></span>  
  
 <span data-ttu-id="8b055-253">Die Kanäle wirken möglicherweise auf verschiedene Weise auf die Nachricht, die durch den Stapel geleitet wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-253">Channels may operate on the message in various ways as it passes through the stack.</span></span> <span data-ttu-id="8b055-254">Der am häufigsten verwendete Vorgang besteht im Hinzufügen eines Headers zu einer ausgehenden Nachricht sowie im Lesen der Header einer eingehenden Nachricht.</span><span class="sxs-lookup"><span data-stu-id="8b055-254">The most common operation is adding a header to an outgoing message and reading headers on an incoming message.</span></span> <span data-ttu-id="8b055-255">So kann ein Kanal z.&#160;B. die digitale Signatur einer Nachricht berechnen und sie als Header hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="8b055-255">For example, a channel may compute the digital signature of a message and add it as a header.</span></span> <span data-ttu-id="8b055-256">Ein Kanal kann diesen digitalen Signaturheader in eingehenden Nachrichten auch prüfen und Nachrichten, die keine gültige Signatur enthalten, auf ihrem Weg durch den Kanalstapel blockieren.</span><span class="sxs-lookup"><span data-stu-id="8b055-256">A channel may also inspect this digital signature header on incoming messages and block messages that do not have a valid signature from making their way up the channel stack.</span></span> <span data-ttu-id="8b055-257">Kanäle legen auch häufig Nachrichteneigenschaften fest oder prüfen diese.</span><span class="sxs-lookup"><span data-stu-id="8b055-257">Channels also often set or inspect message properties.</span></span> <span data-ttu-id="8b055-258">Der Nachrichtentext wird in der Regel nicht geändert, obwohl dies zulässig ist, z. b. kann der WCF-Sicherheits Kanal den Nachrichtentext verschlüsseln.</span><span class="sxs-lookup"><span data-stu-id="8b055-258">The message body is usually not modified, although this is allowed, for example, the WCF security channel can encrypt the message body.</span></span>  
  
### <a name="transport-channels-and-message-encoders"></a><span data-ttu-id="8b055-259">Transportkanäle und Nachrichtenencoder</span><span class="sxs-lookup"><span data-stu-id="8b055-259">Transport Channels and Message Encoders</span></span>  

 <span data-ttu-id="8b055-260">Der Kanal, der sich im Stapel ganz unten befindet, ist für die Übertragung einer ausgehenden <xref:System.ServiceModel.Channels.Message>-Nachricht, die von anderen Kanälen geändert wurde, in eine Aktion verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="8b055-260">The bottommost channel in the stack is responsible for actually transforming an outgoing <xref:System.ServiceModel.Channels.Message>, as modified by other channels, into some action.</span></span> <span data-ttu-id="8b055-261">Auf Empfängerseite ist dies der Kanal, der eine Aktion in eine `Message` umwandelt, die von anderen Kanälen verarbeitet wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-261">On the receive side, this is the channel that converts some action into a `Message` that other channels process.</span></span>  
  
 <span data-ttu-id="8b055-262">Wie zuvor bereits erläutert kann es sich um verschiedene Aktionen handeln: Senden oder Empfangen von Netzwerkpaketen über verschiedene Protokolle, Lesen und Schreiben der Nachricht in einer Datenbank oder Ablegen oder Abrufen der Nachricht aus einer Warteschlange von Message Queuing, um nur einige Beispiele zu nennen.</span><span class="sxs-lookup"><span data-stu-id="8b055-262">As stated previously, the actions may be varied: sending or receiving network packets over various protocols, reading or writing the message in a database, or queuing or dequeuing the message in a Message Queuing queue, to provide but a few examples.</span></span> <span data-ttu-id="8b055-263">Alle diese Aktionen haben einen gemeinsamen Vorgang: Sie erfordern eine Transformation zwischen der WCF `Message` -Instanz und einer tatsächlichen Gruppe von Bytes, die gesendet, empfangen, gelesen, geschrieben, in Warteschlangen eingereiht oder aus der Warteschlange entfernt werden können.</span><span class="sxs-lookup"><span data-stu-id="8b055-263">All these actions have one thing in common: they require a transformation between the WCF`Message` instance and an actual group of bytes that can be sent, received, read, written, queued, or dequeued.</span></span> <span data-ttu-id="8b055-264">Der Vorgang des Umwandelns einer `Message` in eine Gruppe von Bytes wird als *Codieren* bezeichnet, und der umgekehrte Vorgang des Erstellens einer `Message` aus einer Gruppe von Bytes wird als *Decodieren* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="8b055-264">The process of converting a `Message` into a group of bytes is called *encoding*, and the reverse process of creating a `Message` from a group of bytes is called *decoding*.</span></span>  
  
 <span data-ttu-id="8b055-265">Die meisten Transportkanäle verwenden Komponenten, die als *Nachrichtenencoder* bezeichnet werden, um die Codierung und Decodierung durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="8b055-265">Most transport channels use components called *message encoders* to accomplish the encoding and decoding work.</span></span> <span data-ttu-id="8b055-266">Ein Nachrichtenencoder ist eine Unterklasse der <xref:System.ServiceModel.Channels.MessageEncoder> -Klasse.</span><span class="sxs-lookup"><span data-stu-id="8b055-266">A message encoder is a subclass of the <xref:System.ServiceModel.Channels.MessageEncoder> class.</span></span> <span data-ttu-id="8b055-267">`MessageEncoder` umfasst verschiedene `ReadMessage` - und `WriteMessage` -Methodenüberladungen, um eine Konvertierung zwischen `Message` und Gruppen von Bytes durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="8b055-267">`MessageEncoder` includes various `ReadMessage` and `WriteMessage` method overloads to convert between `Message` and groups of bytes.</span></span>  
  
 <span data-ttu-id="8b055-268">Auf der Absenderseite übergibt ein Puffertransportkanal das `Message` -Objekt, das es von einem Kanal darüber erhalten hat, an `WriteMessage`.</span><span class="sxs-lookup"><span data-stu-id="8b055-268">On the sending side, a buffering transport channel passes the `Message` object that it received from a channel above it to `WriteMessage`.</span></span> <span data-ttu-id="8b055-269">Es erhält ein Bytearray zurück, das zum Durchführen der Aktion (wie Packen dieser Bytes als gültige TCP-Pakete und Senden an das richtige Ziel) verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-269">It gets back an array of bytes, which it then uses to perform its action (such as packaging these bytes as valid TCP packets and sending them to the correct destination).</span></span> <span data-ttu-id="8b055-270">Ein Streaming-Transportkanal erstellt zunächst einen `Stream` (z.&#160;B. für die ausgehende TCP-Verbindung) und übergibt dann sowohl den `Stream` als auch die `Message` an die entsprechende `WriteMessage` -Überladung, welche die Nachricht schreibt.</span><span class="sxs-lookup"><span data-stu-id="8b055-270">A streaming transport channel first creates a `Stream` (for example, over the outgoing TCP connection), and then passes both the `Stream` and the `Message` it needs to send to the appropriate `WriteMessage` overload, which writes out the message.</span></span>  
  
 <span data-ttu-id="8b055-271">Auf der Empfängerseite extrahiert ein Puffertransportkanal eingehende Bytes (z.&#160;B. aus eingehenden TCP-Paketen) in ein Array und ruft `ReadMessage` auf, um ein `Message` -Objekt abzurufen, das im Kanalstapel weiter nach oben übergeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b055-271">On the receiving side, a buffering transport channel extracts incoming bytes (for example, from incoming TCP packets) into an array and calls `ReadMessage` to get a `Message` object that it can pass further up the channel stack.</span></span> <span data-ttu-id="8b055-272">Ein Streamingtransportkanal erstellt ein `Stream` -Objekt (z.&#160;B. einen Netzwerkstream über die eingehende TCP-Verbindung) und übergibt dieses an `ReadMessage` , um ein `Message` -Objekt zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="8b055-272">A streaming transport channel creates a `Stream` object (for example, a network stream over the incoming TCP connection) and passes that to `ReadMessage` to get back a `Message` object.</span></span>  
  
 <span data-ttu-id="8b055-273">Die Trennung zwischen den Transportkanälen und dem Nachrichtenencoder ist nicht erforderlich. Es ist möglich, einen Transportkanal zu schreiben, der keinen Nachrichtenencoder verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b055-273">The separation between the transport channels and the message encoder is not mandatory; it is possible to write a transport channel that does not use a message encoder.</span></span> <span data-ttu-id="8b055-274">Der Vorteil dieser Trennung liegt jedoch in der einfachen Zusammensetzung.</span><span class="sxs-lookup"><span data-stu-id="8b055-274">However, the advantage of this separation is ease of composition.</span></span> <span data-ttu-id="8b055-275">Solange ein Transport Kanal nur den Basis <xref:System.ServiceModel.Channels.MessageEncoder> -verwendet, kann er mit jedem WCF-oder Drittanbieter-Nachrichten Encoder arbeiten.</span><span class="sxs-lookup"><span data-stu-id="8b055-275">As long as a transport channel uses only the base <xref:System.ServiceModel.Channels.MessageEncoder>, it can work with any WCF or third-party message encoder.</span></span> <span data-ttu-id="8b055-276">Ebenso kann der gleiche Encoder normalerweise in jedem Transportkanal verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-276">Likewise, the same encoder can normally be used in any transport channel.</span></span>  
  
### <a name="message-encoder-operation"></a><span data-ttu-id="8b055-277">Nachrichtenencodervorgang</span><span class="sxs-lookup"><span data-stu-id="8b055-277">Message Encoder Operation</span></span>  

 <span data-ttu-id="8b055-278">Um den typischen Vorgang eines Encoders zu beschreiben, ist es nützlich, die folgenden vier Fälle zu betrachten.</span><span class="sxs-lookup"><span data-stu-id="8b055-278">To describe the typical operation of an encoder, it is useful to consider the following four cases.</span></span>  
  
|<span data-ttu-id="8b055-279">Vorgang</span><span class="sxs-lookup"><span data-stu-id="8b055-279">Operation</span></span>|<span data-ttu-id="8b055-280">Kommentar</span><span class="sxs-lookup"><span data-stu-id="8b055-280">Comment</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="8b055-281">Codierung, gepuffert</span><span class="sxs-lookup"><span data-stu-id="8b055-281">Encoding, Buffered</span></span>|<span data-ttu-id="8b055-282">Im gepufferten Modus erstellt der Encoder in der Regel einen Puffer in verschiedenen Größen und dann einen XML-Writer dafür.</span><span class="sxs-lookup"><span data-stu-id="8b055-282">In buffered mode, the encoder normally creates a variable-size buffer and then creates an XML writer over it.</span></span> <span data-ttu-id="8b055-283">Er ruft dann <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> für die codierte Nachricht auf. Dadurch werden die Header ausgeschrieben und anschließend der Textkörper mithilfe von <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, wie im folgenden Abschnitt über `Message` in diesem Thema beschrieben.</span><span class="sxs-lookup"><span data-stu-id="8b055-283">It then calls <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> on the message being encoded, which writes out the headers and then the body using <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, as explained in the preceding section about `Message` in this topic.</span></span> <span data-ttu-id="8b055-284">Der Inhalt des Puffers (dargestellt als Bytearray) wird dann für die Verwendung vom Transportkanal zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b055-284">The contents of the buffer (represented as an array of bytes) are then returned for the transport channel to use.</span></span>|  
|<span data-ttu-id="8b055-285">Codierung, per Streaming übertragen</span><span class="sxs-lookup"><span data-stu-id="8b055-285">Encoding, Streamed</span></span>|<span data-ttu-id="8b055-286">Im Streammodus ist der Vorgang ähnlich wie der oben beschriebene, aber einfacher.</span><span class="sxs-lookup"><span data-stu-id="8b055-286">In streamed mode, the operation is similar to the above, but simpler.</span></span> <span data-ttu-id="8b055-287">Es ist kein Puffer erforderlich.</span><span class="sxs-lookup"><span data-stu-id="8b055-287">There is no need for a buffer.</span></span> <span data-ttu-id="8b055-288">Für den Stream wird in der Regel ein XML-Writer erstellt und <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> für `Message` aufgerufen, um für diesen Writer zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="8b055-288">An XML writer is normally created over the stream and <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> is called on the `Message` to write it out to this writer.</span></span>|  
|<span data-ttu-id="8b055-289">Decodierung, gepuffert</span><span class="sxs-lookup"><span data-stu-id="8b055-289">Decoding, Buffered</span></span>|<span data-ttu-id="8b055-290">Wenn Sie im Puffermodus decodieren, wird eine besondere `Message` -Unterklasse erstellt, die die gepufferten Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="8b055-290">When decoding in buffered mode, a special `Message` subclass that contains the buffered data is normally created.</span></span> <span data-ttu-id="8b055-291">Die Header der Nachricht werden gelesen, und ein XML-Leser, der sich im Nachrichtentext befindet, wird erstellt.</span><span class="sxs-lookup"><span data-stu-id="8b055-291">The headers of the message are read, and an XML reader positioned on the message body is created.</span></span> <span data-ttu-id="8b055-292">Dies ist der Leser, der mit <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-292">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
|<span data-ttu-id="8b055-293">Decodierung, per Streaming übertragen</span><span class="sxs-lookup"><span data-stu-id="8b055-293">Decoding, Streamed</span></span>|<span data-ttu-id="8b055-294">Wenn Sie im Streammodus decodieren, wird in der Regel eine besondere Nachrichtenunterklasse erstellt.</span><span class="sxs-lookup"><span data-stu-id="8b055-294">When decoding in streamed mode, a special Message subclass is normally created.</span></span> <span data-ttu-id="8b055-295">Der Stream wird gerade so weit bewegt, dass alle Header gelesen werden können und er im Nachrichtentext positioniert wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-295">The stream is advanced just enough to read all the headers and position it on the message body.</span></span> <span data-ttu-id="8b055-296">Ein XML-Leser wird dann über dem Datenstrom erstellt.</span><span class="sxs-lookup"><span data-stu-id="8b055-296">An XML reader is then created over the stream.</span></span> <span data-ttu-id="8b055-297">Dies ist der Leser, der mit <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-297">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
  
 <span data-ttu-id="8b055-298">Encoder können auch andere Funktionen ausführen.</span><span class="sxs-lookup"><span data-stu-id="8b055-298">Encoders can perform other functions as well.</span></span> <span data-ttu-id="8b055-299">Zum Beispiel können die Encoder XML-Leser und -Writer zusammenlegen.</span><span class="sxs-lookup"><span data-stu-id="8b055-299">For example, the encoders can pool XML readers and writers.</span></span> <span data-ttu-id="8b055-300">Es ist teuer, jedes Mal einen neuen XML-Leser oder -Writer zu erstellen, wenn einer benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-300">It is expensive to create a new XML reader or writer every time one is needed.</span></span> <span data-ttu-id="8b055-301">Deshalb verwalten Encoder normalerweise einen Pool von Lesern und einen Pool von Writern in konfigurierbaren Größen.</span><span class="sxs-lookup"><span data-stu-id="8b055-301">Therefore, encoders normally maintain a pool of readers and a pool of writers of configurable size.</span></span> <span data-ttu-id="8b055-302">In den zuvor beschriebenen Beschreibungen des Codierungs Vorgangs bedeutet dies, dass immer dann, wenn der Ausdruck "Create a XML Reader/Writer" verwendet wird, normalerweise "nehmen Sie einen aus dem Pool nehmen oder einen erstellen, wenn ein solcher nicht verfügbar ist".</span><span class="sxs-lookup"><span data-stu-id="8b055-302">In the descriptions of encoder operation described previously, whenever the phrase "create an XML reader/writer" is used, it normally means "take one from the pool, or create one if one is not available."</span></span> <span data-ttu-id="8b055-303">Der Encoder (und die `Message` -Unterklassen, die er beim Decodieren erstellt) enthält Logik zum Zurückgeben von Lesern und Schreibern an den Pool, wenn sie nicht mehr benötigt werden (z. B. wenn die `Message` geschlossen wird).</span><span class="sxs-lookup"><span data-stu-id="8b055-303">The encoder (and the `Message` subclasses it creates while decoding) contain logic to return readers and writers to the pools once they are no longer needed (for example, when the `Message` is closed).</span></span>  
  
 <span data-ttu-id="8b055-304">WCF stellt drei Nachrichten Encoder zur Verfügung, obwohl es möglich ist, zusätzliche benutzerdefinierte Typen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="8b055-304">WCF provides three message encoders, although it is possible to create additional custom types.</span></span> <span data-ttu-id="8b055-305">Die angegebenen Typen sind Text, Binärdatei und MTOM (Message Transmission Optimization Mechanism, Nachrichtenübertragungs-Optimierungsmechanismus).</span><span class="sxs-lookup"><span data-stu-id="8b055-305">The supplied types are Text, Binary, and Message Transmission Optimization Mechanism (MTOM).</span></span> <span data-ttu-id="8b055-306">Diese werden detailliert unter [Choosing a Message Encoder](choosing-a-message-encoder.md)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="8b055-306">These are described in detail in [Choosing a Message Encoder](choosing-a-message-encoder.md).</span></span>  
  
### <a name="the-istreamprovider-interface"></a><span data-ttu-id="8b055-307">Die IStreamProvider-Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="8b055-307">The IStreamProvider Interface</span></span>  

 <span data-ttu-id="8b055-308">Wenn eine ausgehende Nachricht, die einen in einem Stream befindlichen Hauptteil enthält, in einen XML-Writer geschrieben wird, verwendet <xref:System.ServiceModel.Channels.Message> eine Aufrufsequenz, die der folgenden Sequenz in ihrer <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> -Implementierung ähnlich ist:</span><span class="sxs-lookup"><span data-stu-id="8b055-308">When writing an outgoing message that contains a streamed body to an XML writer, the <xref:System.ServiceModel.Channels.Message> uses a sequence of calls similar to the following in its <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementation:</span></span>  
  
- <span data-ttu-id="8b055-309">Schreiben Sie alle notwendigen Informationen, die dem Stream vorausgehen (z. B. das öffnende XML-Tag).</span><span class="sxs-lookup"><span data-stu-id="8b055-309">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
- <span data-ttu-id="8b055-310">Schreiben Sie den Stream.</span><span class="sxs-lookup"><span data-stu-id="8b055-310">Write the stream.</span></span>  
  
- <span data-ttu-id="8b055-311">Schreiben Sie alle Informationen, die nach dem Stream folgen (z.&#160;B. das schließende XML-Tag).</span><span class="sxs-lookup"><span data-stu-id="8b055-311">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="8b055-312">Dies funktioniert gut bei Codierungen, die der Text-XML-Codierung ähnlich sind.</span><span class="sxs-lookup"><span data-stu-id="8b055-312">This works well with encodings that are similar to the textual XML encoding.</span></span> <span data-ttu-id="8b055-313">Es gibt jedoch einige Codierungen, bei denen XML-Infosetinformationen (z.&#160;B. Tags für beginnende und endende XML-Elemente) nicht zusammen mit den in den Elementen enthaltenen Daten platziert werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-313">However, some encodings do not place XML Infoset information (for example, tags for starting and ending XML elements) together with the data contained within elements.</span></span> <span data-ttu-id="8b055-314">Zum Beispiel wird bei der MTOM-Codierung die Nachricht in mehrere Teile aufgeteilt.</span><span class="sxs-lookup"><span data-stu-id="8b055-314">For example, in the MTOM encoding, the message is split into multiple parts.</span></span> <span data-ttu-id="8b055-315">Ein Teil enthält den XML-Infoset, der in Bezug auf tatsächlichen Elementinhalt Verweise auf andere Teile enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="8b055-315">One part contains the XML Infoset, which may contain references to other parts for actual element contents.</span></span> <span data-ttu-id="8b055-316">Da der XML-Infoset für gewöhnlich kleiner ist als der im Stream befindliche Inhalt, bietet es sich an, den Infoset zu puffern, ihn auszuschreiben und dann den Inhalt gestreamt zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="8b055-316">The XML Infoset is normally small compared to the streamed contents, so it makes sense to buffer the Infoset, write it out, and then write the contents in a streamed way.</span></span> <span data-ttu-id="8b055-317">Dies bedeutet, dass zu dem Zeitpunkt, zu dem das Tag für das schließende Element geschrieben wird, der Stream noch nicht ausgeschrieben sein sollte.</span><span class="sxs-lookup"><span data-stu-id="8b055-317">This means that by the time the closing element tag is written, the stream should not have been written out yet.</span></span>  
  
 <span data-ttu-id="8b055-318">Zu diesem Zweck wird die <xref:System.Xml.IStreamProvider> -Schnittstelle verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b055-318">For this purpose, the <xref:System.Xml.IStreamProvider> interface is used.</span></span> <span data-ttu-id="8b055-319">Die Schnittstelle verfügt über eine <xref:System.Xml.IStreamProvider.GetStream> -Methode, die den zu schreibenden Stream zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b055-319">The interface has a <xref:System.Xml.IStreamProvider.GetStream> method that returns the stream to be written.</span></span> <span data-ttu-id="8b055-320">Die richtige Vorgehensweise, um einen in einem Stream befindlichen Nachrichtentext in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> auszuschreiben, lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="8b055-320">The correct way to write out a streamed message body in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> is as follows:</span></span>  
  
1. <span data-ttu-id="8b055-321">Schreiben Sie alle notwendigen Informationen, die dem Stream vorausgehen (z. B. das öffnende XML-Tag).</span><span class="sxs-lookup"><span data-stu-id="8b055-321">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
2. <span data-ttu-id="8b055-322">Rufen Sie die `WriteValue` -Überladung in <xref:System.Xml.XmlDictionaryWriter> auf, die <xref:System.Xml.IStreamProvider>mit einer `IStreamProvider` -Implementierung verwendet, die den zu schreibenden Stream zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b055-322">Call the `WriteValue` overload on the <xref:System.Xml.XmlDictionaryWriter> that takes an <xref:System.Xml.IStreamProvider>, with an `IStreamProvider` implementation that returns the stream to be written.</span></span>  
  
3. <span data-ttu-id="8b055-323">Schreiben Sie alle Informationen, die nach dem Stream folgen (z.&#160;B. das schließende XML-Tag).</span><span class="sxs-lookup"><span data-stu-id="8b055-323">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="8b055-324">Auf diese Weise kann der XML-Writer bestimmen, wann <xref:System.Xml.IStreamProvider.GetStream> aufgerufen wird und die im Stream befindlichen Daten ausgeschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-324">With this approach, the XML writer has a choice of when to call <xref:System.Xml.IStreamProvider.GetStream> and write out the streamed data.</span></span> <span data-ttu-id="8b055-325">So rufen die Text-XML-Writer und die binären XML-Writer die Daten zum Beispiel direkt auf und schreiben den im Stream befindlichen Inhalt zwischen die Start- und Endtags.</span><span class="sxs-lookup"><span data-stu-id="8b055-325">For example, the textual and binary XML writers will call it immediately and write out the streamed contents in-between the start and end tags.</span></span> <span data-ttu-id="8b055-326">Der MTOM-Writer ruft <xref:System.Xml.IStreamProvider.GetStream> möglicherweise erst dann auf, wenn er zum Schreiben des entsprechenden Nachrichtenteils bereit ist.</span><span class="sxs-lookup"><span data-stu-id="8b055-326">The MTOM writer may decide to call <xref:System.Xml.IStreamProvider.GetStream> later, when it is ready to write the appropriate part of the message.</span></span>  
  
## <a name="representing-data-in-the-service-framework"></a><span data-ttu-id="8b055-327">Darstellen von Daten im Dienstframework</span><span class="sxs-lookup"><span data-stu-id="8b055-327">Representing Data in the Service Framework</span></span>  

 <span data-ttu-id="8b055-328">Wie im Abschnitt "grundlegende Architektur" in diesem Thema erwähnt, ist das Dienst Framework der Teil von WCF, der unter anderem für die Umstellung zwischen einem benutzerfreundlichen Programmiermodell für Nachrichten Daten und tatsächliche Instanzen zuständig ist `Message` .</span><span class="sxs-lookup"><span data-stu-id="8b055-328">As stated in the "Basic Architecture" section of this topic, the service framework is the part of WCF that, among other things, is responsible for converting between a user-friendly programming model for message data and actual `Message` instances.</span></span> <span data-ttu-id="8b055-329">Normalerweise wird ein Nachrichtenaustausch im Dienst Framework als .NET Framework Methode dargestellt, die mit dem- <xref:System.ServiceModel.OperationContractAttribute> Attribut gekennzeichnet ist.</span><span class="sxs-lookup"><span data-stu-id="8b055-329">Normally, a message exchange is represented in the service framework as a .NET Framework method marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute.</span></span> <span data-ttu-id="8b055-330">Die Methode kann einige Parameter ausführen und einen Rückgabewert oder out-Parameter (oder beides) zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="8b055-330">The method can take in some parameters and can return a return value or out parameters (or both).</span></span> <span data-ttu-id="8b055-331">Auf der Dienstseite stellen die Eingabeparameter die eingehende Nachricht dar. Der Rückgabewert und die out-Parameter stellen die ausgehende Nachricht dar.</span><span class="sxs-lookup"><span data-stu-id="8b055-331">On the service side, the input parameters represent the incoming message, and the return value and out parameters represent the outgoing message.</span></span> <span data-ttu-id="8b055-332">Auf der Clientseite gilt das Gegenteil.</span><span class="sxs-lookup"><span data-stu-id="8b055-332">On the client side, the reverse is true.</span></span> <span data-ttu-id="8b055-333">Das Programmiermodell zum Beschreiben von Nachrichten mithilfe von Parametern und Rückgabewert wird ausführlich unter [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="8b055-333">The programming model for describing messages using parameters and the return value is described in detail in [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span> <span data-ttu-id="8b055-334">Der folgende Abschnitt enthält jedoch eine kurze Übersicht.</span><span class="sxs-lookup"><span data-stu-id="8b055-334">However, this section will provide a brief overview.</span></span>  
  
## <a name="programming-models"></a><span data-ttu-id="8b055-335">Programmiermodelle</span><span class="sxs-lookup"><span data-stu-id="8b055-335">Programming Models</span></span>  

 <span data-ttu-id="8b055-336">Das WCF-Dienst Framework unterstützt fünf verschiedene Programmier Modelle zum Beschreiben von Nachrichten:</span><span class="sxs-lookup"><span data-stu-id="8b055-336">The WCF service framework supports five different programming models for describing messages:</span></span>  
  
### <a name="1-the-empty-message"></a><span data-ttu-id="8b055-337">1. Die leere Nachricht</span><span class="sxs-lookup"><span data-stu-id="8b055-337">1. The Empty Message</span></span>  

 <span data-ttu-id="8b055-338">Dies ist der einfachste Fall.</span><span class="sxs-lookup"><span data-stu-id="8b055-338">This is the simplest case.</span></span> <span data-ttu-id="8b055-339">Um eine leere eingehende Nachricht zu beschreiben, verwenden Sie keine Eingabeparameter.</span><span class="sxs-lookup"><span data-stu-id="8b055-339">To describe an empty incoming message, do not use any input parameters.</span></span>  
  
 [!code-csharp[C_DataArchitecture#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#3)]
 [!code-vb[C_DataArchitecture#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#3)]  
  
 <span data-ttu-id="8b055-340">Um eine leere ausgehende Nachricht zu beschreiben, verwenden Sie einen void-Rückgabewert:</span><span class="sxs-lookup"><span data-stu-id="8b055-340">To describe an empty outgoing message, use a void return value and do not use any out parameters:</span></span>  
  
 [!code-csharp[C_DataArchitecture#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#4)]
 [!code-vb[C_DataArchitecture#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#4)]  
  
 <span data-ttu-id="8b055-341">Beachten Sie, dass sich dies von einem unidirektionalen Vorgangsvertrag unterscheidet:</span><span class="sxs-lookup"><span data-stu-id="8b055-341">Note that this is different from a one-way operation contract:</span></span>  
  
 [!code-csharp[C_DataArchitecture#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#5)]
 [!code-vb[C_DataArchitecture#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#5)]  
  
 <span data-ttu-id="8b055-342">Im `SetDesiredTemperature` -Beispiel wird ein bidirektionales Nachrichtenaustauschmuster beschrieben.</span><span class="sxs-lookup"><span data-stu-id="8b055-342">In the `SetDesiredTemperature` example, a two-way message exchange pattern is described.</span></span> <span data-ttu-id="8b055-343">Eine Nachricht wird vom Vorgang zurückgegeben, ist jedoch leer.</span><span class="sxs-lookup"><span data-stu-id="8b055-343">A message is returned from the operation, but it is empty.</span></span> <span data-ttu-id="8b055-344">Es ist möglich, einen Fehler vom Vorgang zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="8b055-344">It is possible to return a fault from the operation.</span></span> <span data-ttu-id="8b055-345">Im Beispiel "Set Lightbulb" ist das Nachrichtenaustauschmuster unidirektional. Es ist also keine ausgehende Nachricht vorhanden, die beschrieben werden müsste.</span><span class="sxs-lookup"><span data-stu-id="8b055-345">In the "Set Lightbulb" example, the message exchange pattern is one-way, so there is no outgoing message to describe.</span></span> <span data-ttu-id="8b055-346">Der Dienst kann dem Client in diesem Fall keinen Status mitteilen.</span><span class="sxs-lookup"><span data-stu-id="8b055-346">The service cannot communicate any status back to the client in this case.</span></span>  
  
### <a name="2-using-the-message-class-directly"></a><span data-ttu-id="8b055-347">2. Direktes Verwenden der Nachrichtenklasse</span><span class="sxs-lookup"><span data-stu-id="8b055-347">2. Using the Message Class Directly</span></span>  

 <span data-ttu-id="8b055-348">Es ist möglich, die <xref:System.ServiceModel.Channels.Message> -Klasse (oder eine ihrer Unterklassen) direkt in einem Vertrag für einen Vorgang zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b055-348">It is possible to use the <xref:System.ServiceModel.Channels.Message> class (or one of its subclasses) directly in an operation contract.</span></span> <span data-ttu-id="8b055-349">In diesem Fall übergibt das Dienstframework `Message` einfach an den Kanalstapel und umgekehrt, ohne weitere Verarbeitung.</span><span class="sxs-lookup"><span data-stu-id="8b055-349">In this case, the service framework just passes the `Message` from the operation to the channel stack and vice versa, with no further processing.</span></span>  
  
 <span data-ttu-id="8b055-350">Es gibt zwei Hauptanwendungsfälle für das direkte Verwenden von `Message` .</span><span class="sxs-lookup"><span data-stu-id="8b055-350">There are two main use cases for using `Message` directly.</span></span> <span data-ttu-id="8b055-351">Sie können es für erweiterte Szenarien verwenden, wenn keines der anderen Programmiermodelle ausreichende Flexibilität zum Beschreiben Ihrer Nachricht bietet.</span><span class="sxs-lookup"><span data-stu-id="8b055-351">You can use this for advanced scenarios, when none of the other programming models gives you enough flexibility to describe your message.</span></span> <span data-ttu-id="8b055-352">So möchten Sie z.&#160;B. eventuell Dateien auf Festplatte zum Beschreiben einer Nachricht verwenden, wobei die Dateieigenschaften zu Nachrichtenheadern werden und der Dateiinhalt zum Nachrichtentext wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-352">For example, you might want to use files on disk to describe a message, with the file’s properties becoming message headers and the file’s contents becoming the message body.</span></span> <span data-ttu-id="8b055-353">Sie können dann Folgendes erstellen.</span><span class="sxs-lookup"><span data-stu-id="8b055-353">You can then create something similar to the following.</span></span>  
  
 [!code-csharp[C_DataArchitecture#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#6)]
 [!code-vb[C_DataArchitecture#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#6)]  
  
 <span data-ttu-id="8b055-354">Der zweite häufige Anwendungsfall für `Message` in einem Vorgangsvertrag tritt ein, wenn ein Dienst den Inhalt einer bestimmten Nachricht ignoriert und die Nachricht wie eine Blackbox behandelt.</span><span class="sxs-lookup"><span data-stu-id="8b055-354">The second common use for `Message` in an operation contract is when a service does not care about the particular message contents and acts on the message as on a black box.</span></span> <span data-ttu-id="8b055-355">Zum Beispiel könnten Sie über einen Dienst verfügen, der Nachrichten an mehrere andere Empfänger weiterleitet.</span><span class="sxs-lookup"><span data-stu-id="8b055-355">For example, you might have a service that forwards messages to multiple other recipients.</span></span> <span data-ttu-id="8b055-356">Der Vertrag kann wie folgt geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-356">The contract can be written as follows.</span></span>  
  
 [!code-csharp[C_DataArchitecture#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#7)]
 [!code-vb[C_DataArchitecture#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#7)]  
  
 <span data-ttu-id="8b055-357">Die Zeile Action = "\*" deaktiviert das Senden von Nachrichten und stellt sicher, dass alle an den Vertrag gesendeten Nachrichten `IForwardingService` den `ForwardMessage` Vorgang durchführen.</span><span class="sxs-lookup"><span data-stu-id="8b055-357">The Action="\*" line effectively turns off message dispatching and ensures that all messages sent to the `IForwardingService` contract make their way to the `ForwardMessage` operation.</span></span> <span data-ttu-id="8b055-358">(Normalerweise würde der Verteiler den "action"-Header der Nachricht untersuchen, um zu ermitteln, für welchen Vorgang er bestimmt ist.</span><span class="sxs-lookup"><span data-stu-id="8b055-358">(Normally, the dispatcher would examine the message’s "Action" header to determine which operation it is intended for.</span></span> <span data-ttu-id="8b055-359">Action = " \* " bedeutet "alle möglichen Werte des Aktions Headers".) Die Kombination aus Action = " \* " und die Verwendung der Nachricht als Parameter wird als "Universal Contract" bezeichnet, da Sie alle möglichen Nachrichten empfangen kann.</span><span class="sxs-lookup"><span data-stu-id="8b055-359">Action="\*" means "all possible values of the Action header".) The combination of Action="\*" and using Message as a parameter is known as the "universal contract" because it is able to receive all possible messages.</span></span> <span data-ttu-id="8b055-360">Um alle möglichen Nachrichten senden zu können, verwenden Sie Message als Rückgabewert, und legen `ReplyAction` Sie auf " \* " fest.</span><span class="sxs-lookup"><span data-stu-id="8b055-360">To be able to send all possible messages, use Message as the return value and set `ReplyAction` to "\*".</span></span> <span data-ttu-id="8b055-361">Auf diese Weise wird verhindert, dass das Dienstframework einen eigenen Action-Header hinzufügt. So können Sie diesen Header mit dem zurückgegebenen `Message` -Objekt steuern.</span><span class="sxs-lookup"><span data-stu-id="8b055-361">This will prevent the service framework from adding its own Action header, enabling you to control this header using the `Message` object you return.</span></span>  
  
### <a name="3-message-contracts"></a><span data-ttu-id="8b055-362">3. Nachrichtenverträge</span><span class="sxs-lookup"><span data-stu-id="8b055-362">3. Message Contracts</span></span>  

 <span data-ttu-id="8b055-363">WCF stellt ein deklaratives Programmiermodell zum Beschreiben von Nachrichten bereit, die so genannten *Nachrichten Verträge*.</span><span class="sxs-lookup"><span data-stu-id="8b055-363">WCF provides a declarative programming model for describing messages, called *message contracts*.</span></span> <span data-ttu-id="8b055-364">Dieses Modell wird in [Using Message Contracts](using-message-contracts.md)ausführlich beschrieben.</span><span class="sxs-lookup"><span data-stu-id="8b055-364">This model is described in detail in [Using Message Contracts](using-message-contracts.md).</span></span> <span data-ttu-id="8b055-365">Im Wesentlichen wird die gesamte Nachricht durch einen einzelnen .NET Framework Typ dargestellt, der Attribute wie <xref:System.ServiceModel.MessageBodyMemberAttribute> und verwendet <xref:System.ServiceModel.MessageHeaderAttribute> , um zu beschreiben, welche Teile der Nachrichten Vertrags Klasse welchem Teil der Nachricht zugeordnet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b055-365">Essentially, the entire message is represented by a single .NET Framework type that uses attributes like the <xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute> to describe which parts of the message contract class should map to which part of the message.</span></span>  
  
 <span data-ttu-id="8b055-366">Nachrichtenverträge bieten einen hohen Steuerungsgrad hinsichtlich der resultierenden `Message` -Instanzen (obwohl offensichtlich nicht so viel Steuerung wie bei der direkten Verwendung der `Message` -Klasse).</span><span class="sxs-lookup"><span data-stu-id="8b055-366">Message contracts provide a lot of control over the resulting `Message` instances (although obviously not as much control as using the `Message` class directly).</span></span> <span data-ttu-id="8b055-367">So bestehen Nachrichtentexte häufig aus mehreren Informationskomponenten, von denen jede durch ein XML-Element dargestellt ist.</span><span class="sxs-lookup"><span data-stu-id="8b055-367">For example, message bodies are often composed of multiple pieces of information, each represented by its own XML element.</span></span> <span data-ttu-id="8b055-368">Diese Elemente können entweder direkt im Textkörper (*leerer* Modus) vorhanden oder in ein übergeordnetes XML-Element *eingeschlossen* sein.</span><span class="sxs-lookup"><span data-stu-id="8b055-368">These elements can either occur directly in the body (*bare* mode) or can be *wrapped* in an encompassing XML element.</span></span> <span data-ttu-id="8b055-369">Mit dem Programmiermodell für Nachrichtenverträge können Sie zwischen dem leeren und eingeschlossenen Modus wählen und den Wrappernamen und Namespace steuern.</span><span class="sxs-lookup"><span data-stu-id="8b055-369">Using the message contract programming model enables you to make the bare-versus-wrapped decision and control the name of the wrapper name and namespace.</span></span>  
  
 <span data-ttu-id="8b055-370">Im folgenden Codebeispiel eines Nachrichtenvertrags werden diese Funktionen veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b055-370">The following code example of a message contract demonstrates these features.</span></span>  
  
 [!code-csharp[C_DataArchitecture#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#9)]
 [!code-vb[C_DataArchitecture#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#9)]  
  
 <span data-ttu-id="8b055-371">Für die Serialisierung (mit dem Attribut <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>oder anderen verwandten Attributen) gekennzeichnete Elemente müssen serialisierbar sein, um an einem Nachrichtenvertrag teilzunehmen.</span><span class="sxs-lookup"><span data-stu-id="8b055-371">Items marked to be serialized (with the <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, or other related attributes) must be serializable to participate in a message contract.</span></span> <span data-ttu-id="8b055-372">Weitere Informationen finden Sie im Abschnitt "Serialisierung" weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="8b055-372">For more information, see the "Serialization" section later in this topic.</span></span>  
  
### <a name="4-parameters"></a><span data-ttu-id="8b055-373">4. Parameter</span><span class="sxs-lookup"><span data-stu-id="8b055-373">4. Parameters</span></span>  

 <span data-ttu-id="8b055-374">Häufig benötigt ein Entwickler, der einen Vorgang beschreiben möchte, der für mehrere Datenpakete gilt, nicht den Steuerungsgrad, den Nachrichtenverträge bieten.</span><span class="sxs-lookup"><span data-stu-id="8b055-374">Often, a developer who wants to describe an operation that acts on multiple pieces of data does not need the degree of control that message contracts provide.</span></span> <span data-ttu-id="8b055-375">So muss z.&#160;B. beim Erstellen von neuen Diensten keine Entscheidung zwischen leer und eingeschlossen getroffen und kein Name für ein Wrapperelement festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-375">For example, when creating new services, one does not usually want to make the bare-versus-wrapped decision and decide on the wrapper element name.</span></span> <span data-ttu-id="8b055-376">Diese Entscheidungen setzen häufig eine tief greifende Kenntnis von Webdiensten und SOAP voraus.</span><span class="sxs-lookup"><span data-stu-id="8b055-376">Making these decisions often requires deep knowledge of Web services and SOAP.</span></span>  
  
 <span data-ttu-id="8b055-377">Das WCF-Dienst Framework kann die beste und interoperable SOAP-Darstellung zum Senden oder empfangen von mehreren verwandten Informationen automatisch auswählen, ohne diese Optionen für den Benutzer zu erzwingen.</span><span class="sxs-lookup"><span data-stu-id="8b055-377">The WCF service framework can automatically pick the best and most interoperable SOAP representation for sending or receiving multiple related pieces of information, without forcing these choices on the user.</span></span> <span data-ttu-id="8b055-378">Dies wird erreicht, indem diese Informationspakete als Parameter oder Rückgabewerte eines Vorgangsvertrags beschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-378">This is accomplished by simply describing these pieces of information as parameters or return values of an operation contract.</span></span> <span data-ttu-id="8b055-379">Betrachten Sie z.&#160;B. den folgenden Vorgangsvertrag.</span><span class="sxs-lookup"><span data-stu-id="8b055-379">For example, consider the following operation contract.</span></span>  
  
 [!code-csharp[C_DataArchitecture#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#11)]
 [!code-vb[C_DataArchitecture#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#11)]  
  
 <span data-ttu-id="8b055-380">Das Dienstframework entscheidet automatisch, alle drei Informationsabschnitte (`customerID`, `item`und `quantity`) in den Nachrichtentext zu integrieren und sie in ein Wrapper-Element mit dem Namen `SubmitOrderRequest`einzuschließen.</span><span class="sxs-lookup"><span data-stu-id="8b055-380">The service framework automatically decides to put all three pieces of information (`customerID`, `item`, and `quantity`) into the message body and wrap them in a wrapper element named `SubmitOrderRequest`.</span></span>  
  
 <span data-ttu-id="8b055-381">Die Beschreibung der Informationen, die als einfache Liste mit Vorgangsvertragsparametern gesendet oder empfangen werden, ist die empfohlene Methode, falls keine besonderen Gründe für einen Wechsel zu dem komplexeren Nachrichtenvertrag oder `Message`-basierten Programmiermodell vorliegen.</span><span class="sxs-lookup"><span data-stu-id="8b055-381">Describing the information to be sent or received as a simple list of operation contract parameters is the recommended approach, unless special reasons exist to move to the more-complex message contract or `Message`-based programming models.</span></span>  
  
### <a name="5-stream"></a><span data-ttu-id="8b055-382">5. Stream</span><span class="sxs-lookup"><span data-stu-id="8b055-382">5. Stream</span></span>  

 <span data-ttu-id="8b055-383">Die Verwendung eines `Stream` oder einer seiner Unterklassen in einem Vorgangsvertrag oder als einzelner Nachrichtentextteil in einem Nachrichtenvertrag kann als separates Programmiermodell im Gegensatz zu den oben beschriebenen betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-383">Using `Stream` or one of its subclasses in an operation contract or as a sole message body part in a message contract can be considered a separate programming model from the ones described above.</span></span> <span data-ttu-id="8b055-384">Die Verwendung eines `Stream` auf diese Weise ist die einzige Möglichkeit, zu gewährleisten, dass Ihr Vertrag für ein Streamingmodell verwendet werden kann, fast so, als ob Sie eine eigene Streaming-kompatible `Message` -Unterklasse schreiben würden.</span><span class="sxs-lookup"><span data-stu-id="8b055-384">Using `Stream` in this way is the only way to guarantee that your contract will be usable in a streamed fashion, short of writing your own streaming-compatible `Message` subclass.</span></span> <span data-ttu-id="8b055-385">Weitere Informationen finden Sie unter [große Datenmengen und Streaming](large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="8b055-385">For more information, see [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="8b055-386">Wenn der `Stream` oder eine seiner Unterklassen auf diese Art verwendet wird, wird das Serialisierungsprogramm nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="8b055-386">When `Stream` or one of its subclasses is used in this way, the serializer is not invoked.</span></span> <span data-ttu-id="8b055-387">Für ausgehende Nachrichten wird eine besondere `Message` -Streaming-Unterklasse erstellt, und der Stream wird ausgeschrieben, wie im Abschnitt über die <xref:System.Xml.IStreamProvider> -Schnittstelle beschrieben.</span><span class="sxs-lookup"><span data-stu-id="8b055-387">For outgoing messages, a special streaming `Message` subclass is created and the stream is written out as described in the section on the <xref:System.Xml.IStreamProvider> interface.</span></span> <span data-ttu-id="8b055-388">Für eingehende Nachrichten erstellt das Dienstframework eine `Stream` -Unterklasse über der eingehenden Nachricht und übergibt sie an den Vorgang.</span><span class="sxs-lookup"><span data-stu-id="8b055-388">For incoming messages, the service framework creates a `Stream` subclass over the incoming message and provides it to the operation.</span></span>  
  
## <a name="programming-model-restrictions"></a><span data-ttu-id="8b055-389">Einschränkungen des Programmiermodells</span><span class="sxs-lookup"><span data-stu-id="8b055-389">Programming Model Restrictions</span></span>  

 <span data-ttu-id="8b055-390">Die oben beschriebenen Programmiermodelle können nicht willkürlich kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-390">The programming models described above cannot be arbitrarily combined.</span></span> <span data-ttu-id="8b055-391">Wenn ein Vorgang beispielsweise einen Nachrichtenvertragstyp akzeptiert, muss der Nachrichtenvertrag der einzige Eingabeparameter sein.</span><span class="sxs-lookup"><span data-stu-id="8b055-391">For example, if an operation accepts a message contract type, the message contract must be its only input parameter.</span></span> <span data-ttu-id="8b055-392">Darüber hinaus muss der Vorgang dann entweder eine leere Nachricht (ungültiger Rückgabewert) oder einen anderen Nachrichtenvertrag zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="8b055-392">Furthermore, the operation must then either return an empty message (return type of void) or another message contract.</span></span> <span data-ttu-id="8b055-393">Diese Einschränkungen des Programmiermodells werden in den Themen für jedes einzelne Programmiermodell beschrieben: [Using Message Contracts](using-message-contracts.md), [Using the Message Class](using-the-message-class.md)und [Large Data and Streaming](large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="8b055-393">These programming model restrictions are described in the topics for each specific programming model: [Using Message Contracts](using-message-contracts.md), [Using the Message Class](using-the-message-class.md), and [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
## <a name="message-formatters"></a><span data-ttu-id="8b055-394">Nachrichtenformatierungsprogramme</span><span class="sxs-lookup"><span data-stu-id="8b055-394">Message Formatters</span></span>  

 <span data-ttu-id="8b055-395">Die oben beschriebenen Programmiermodelle werden von Plug-In-Komponenten, so genannten *Nachrichtenformatierungsprogrammen* , in das Dienstframework unterstützt.</span><span class="sxs-lookup"><span data-stu-id="8b055-395">The programming models described above are supported by plugging in components called *message formatters* into the service framework.</span></span> <span data-ttu-id="8b055-396">Nachrichtenformatierer sind Typen, die die <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> - <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> Schnittstelle oder die-Schnittstelle implementieren, bzw. beides für die Verwendung in Clients bzw. Dienst-WCF-Clients.</span><span class="sxs-lookup"><span data-stu-id="8b055-396">Message formatters are types that implement the <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> or <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interface, or both, for use in clients and service WCF clients, respectively.</span></span>  
  
 <span data-ttu-id="8b055-397">Nachrichtenformatierungsprogramme werden normalerweise über bestimmte Verhalten implementiert.</span><span class="sxs-lookup"><span data-stu-id="8b055-397">Message formatters are normally plugged in by behaviors.</span></span> <span data-ttu-id="8b055-398">Zum Beispiel implementiert <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> das Daten-Vertragsnachrichten-Formatierungsprogramm.</span><span class="sxs-lookup"><span data-stu-id="8b055-398">For example, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> plugs in the data contract message formatter.</span></span> <span data-ttu-id="8b055-399">Dies geschieht auf der Dienstseite, indem <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> auf das richtige Formatierungsprogramm der <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> -Methode festgelegt wird, oder auf der Clientseite, indem <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> auf das richtige Formatierungsprogramm der <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> -Methode festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-399">This is done on the service side by setting <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> method, or on the client side by setting <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> method.</span></span>  
  
 <span data-ttu-id="8b055-400">Die folgenden Tabellen listen die Methoden auf, die ein Nachrichtenformatierungsprogramm möglicherweise implementiert.</span><span class="sxs-lookup"><span data-stu-id="8b055-400">The following tables lists the methods that a message formatter may implement.</span></span>  
  
|<span data-ttu-id="8b055-401">Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="8b055-401">Interface</span></span>|<span data-ttu-id="8b055-402">Methode</span><span class="sxs-lookup"><span data-stu-id="8b055-402">Method</span></span>|<span data-ttu-id="8b055-403">Aktion</span><span class="sxs-lookup"><span data-stu-id="8b055-403">Action</span></span>|  
|---------------|------------|------------|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.DeserializeRequest%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="8b055-404">Konvertiert eine eingehende `Message` in Vorgangsparameter</span><span class="sxs-lookup"><span data-stu-id="8b055-404">Converts an incoming `Message` to operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.SerializeReply%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%2CSystem.Object%29>|<span data-ttu-id="8b055-405">Erstellt eine ausgehende `Message` aus Vorgangsrückgabewert/out-Parametern</span><span class="sxs-lookup"><span data-stu-id="8b055-405">Creates an outgoing `Message` from operation return value/out parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.SerializeRequest%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%29>|<span data-ttu-id="8b055-406">Erstellt eine ausgehende `Message` aus Vorgangsparametern</span><span class="sxs-lookup"><span data-stu-id="8b055-406">Creates an outgoing `Message` from operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.DeserializeReply%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="8b055-407">Konvertiert eine eingehende `Message` in einen Rückgabewert/out-Parameter</span><span class="sxs-lookup"><span data-stu-id="8b055-407">Converts an incoming `Message` to a return value/out parameters</span></span>|  
  
## <a name="serialization"></a><span data-ttu-id="8b055-408">Serialisierung</span><span class="sxs-lookup"><span data-stu-id="8b055-408">Serialization</span></span>  

 <span data-ttu-id="8b055-409">Wenn Sie Nachrichten Verträge oder Parameter zum Beschreiben des Nachrichten Inhalts verwenden, müssen Sie die Serialisierung verwenden, um zwischen .NET Framework Typen und der XML-infosetdarstellung zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="8b055-409">Whenever you use message contracts or parameters to describe message contents, you must use serialization to convert between .NET Framework types and XML Infoset representation.</span></span> <span data-ttu-id="8b055-410">Die Serialisierung wird an anderen Stellen in WCF verwendet, z. b. mit <xref:System.ServiceModel.Channels.Message> einer generischen Methode, die <xref:System.ServiceModel.Channels.Message.GetBody%2A> Sie verwenden können, um den gesamten Text der Nachricht zu lesen, die in ein-Objekt deserialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-410">Serialization is used in other places in WCF, for example, <xref:System.ServiceModel.Channels.Message> has a Generic <xref:System.ServiceModel.Channels.Message.GetBody%2A> method that you can use to read the entire body of the message deserialized into an object.</span></span>  
  
 <span data-ttu-id="8b055-411">WCF unterstützt zwei Serialisierungstechnologien (standardmäßig) zum Serialisieren und Deserialisieren von Parametern und Nachrichten Teilen: <xref:System.Runtime.Serialization.DataContractSerializer> und `XmlSerializer` .</span><span class="sxs-lookup"><span data-stu-id="8b055-411">WCF supports two serialization technologies "out of the box" for serializing and deserializing parameters and message parts: the <xref:System.Runtime.Serialization.DataContractSerializer> and the `XmlSerializer`.</span></span> <span data-ttu-id="8b055-412">Darüber hinaus können Sie benutzerdefinierte Serialisierungsprogramme schreiben.</span><span class="sxs-lookup"><span data-stu-id="8b055-412">Additionally, you can write custom serializers.</span></span> <span data-ttu-id="8b055-413">Allerdings können andere Teile von WCF (z. b. die generische- `GetBody` Methode oder die SOAP-Fehlerserialisierung) darauf beschränkt werden, nur die <xref:System.Runtime.Serialization.XmlObjectSerializer> -Unterklassen ( <xref:System.Runtime.Serialization.DataContractSerializer> und <xref:System.Runtime.Serialization.NetDataContractSerializer> , aber nicht die) zu verwenden <xref:System.Xml.Serialization.XmlSerializer> , oder Sie können sogar hart codiert werden, um nur die zu verwenden <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="8b055-413">However, other parts of WCF (such as the Generic `GetBody` method or SOAP fault serialization) may be restricted to use only the <xref:System.Runtime.Serialization.XmlObjectSerializer> subclasses (<xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>, but not the <xref:System.Xml.Serialization.XmlSerializer>), or may even be hard-coded to use only the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span>  
  
 <span data-ttu-id="8b055-414">Der `XmlSerializer` ist das Serialisierungsmodul, das in ASP.NET-Webdiensten verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8b055-414">The `XmlSerializer` is the serialization engine used in ASP.NET Web services.</span></span> <span data-ttu-id="8b055-415">ph x="1" /&gt; ist die neue Serialisierungs-Engine, die das neue Datenvertrags-Programmiermodell versteht.</span><span class="sxs-lookup"><span data-stu-id="8b055-415">The `DataContractSerializer` is the new serialization engine that understands the new data contract programming model.</span></span> <span data-ttu-id="8b055-416">`DataContractSerializer` ist die Standardauswahl. Die Entscheidung für die Verwendung von `XmlSerializer` kann mit dem <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> für einzelne Vorgänge getroffen werden.</span><span class="sxs-lookup"><span data-stu-id="8b055-416">`DataContractSerializer` is the default choice, and the choice to use the `XmlSerializer` can be made on a per-operation basis using the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> attribute.</span></span>  
  
 <span data-ttu-id="8b055-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> und <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> sind die Vorgangsverhalten, die für das Plug-In der Nachrichtenformatierungsprogramme für `DataContractSerializer` und `XmlSerializer`verantwortlich sind.</span><span class="sxs-lookup"><span data-stu-id="8b055-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> are the operation behaviors responsible for plugging in the message formatters for the `DataContractSerializer` and the `XmlSerializer`, respectively.</span></span> <span data-ttu-id="8b055-418">Das <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> -Verhalten kann mit jedem Serialisierungsprogramm funktionieren, das von <xref:System.Runtime.Serialization.XmlObjectSerializer>abgeleitet wird, u.&#160;a. <xref:System.Runtime.Serialization.NetDataContractSerializer> (ausführlich beschrieben unter "Verwenden der eigenständigen Serialisierung").</span><span class="sxs-lookup"><span data-stu-id="8b055-418">The <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior can actually operate with any serializer that derives from <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.NetDataContractSerializer> (described in detail in Using Stand-Alone Serialization).</span></span> <span data-ttu-id="8b055-419">Das Verhalten ruft eine der virtuellen `CreateSerializer` -Methodenüberladungen auf, um das Serialisierungsprogramm zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="8b055-419">The behavior calls one of the `CreateSerializer` virtual method overloads to obtain the serializer.</span></span> <span data-ttu-id="8b055-420">Um ein anderes Serialisierungsprogramm zu verwenden, erstellen Sie eine neue <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> -Unterklasse und überschreiben beide `CreateSerializer` -Überladungen.</span><span class="sxs-lookup"><span data-stu-id="8b055-420">To plug in a different serializer, create a new <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> subclass and override both `CreateSerializer` overloads.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8b055-421">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="8b055-421">See also</span></span>

- [<span data-ttu-id="8b055-422">Angeben von Datenübertragung in Dienstverträgen</span><span class="sxs-lookup"><span data-stu-id="8b055-422">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
