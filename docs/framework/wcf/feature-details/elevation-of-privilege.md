---
title: Angriffe durch Rechteerweiterung
ms.date: 03/30/2017
helpviewer_keywords:
- elevation of privilege [WCF]
- security [WCF], elevation of privilege
ms.assetid: 146e1c66-2a76-4ed3-98a5-fd77851a06d9
ms.openlocfilehash: 823b41f86080d4802f76fe69865279a7c3506238
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 06/09/2020
ms.locfileid: "84597409"
---
# <a name="elevation-of-privilege"></a><span data-ttu-id="86070-102">Angriffe durch Rechteerweiterung</span><span class="sxs-lookup"><span data-stu-id="86070-102">Elevation of Privilege</span></span>
<span data-ttu-id="86070-103">Die *Erhöhung der* Berechtigungen führt dazu, dass einem Angreifer über die ursprünglich gewährten Autorisierungs Berechtigungen hinausgehen.</span><span class="sxs-lookup"><span data-stu-id="86070-103">*Elevation of privilege* results from giving an attacker authorization permissions beyond those initially granted.</span></span> <span data-ttu-id="86070-104">Dies ist zum Beispiel der Fall, wenn einem Angreifer mit einem Berechtigungssatz von "Nur-Lesen"-Berechtigungen es irgendwie gelingt, "Lesen-und-Schreiben"-Berechtigungen in seinen Berechtigungssatz aufzunehmen.</span><span class="sxs-lookup"><span data-stu-id="86070-104">For example, an attacker with a privilege set of "read only" permissions somehow elevates the set to include "read and write."</span></span>  
  
## <a name="trusted-sts-should-sign-saml-token-claims"></a><span data-ttu-id="86070-105">Vertrauenswürdige STS sollten SAML-Tokenansprüche signieren</span><span class="sxs-lookup"><span data-stu-id="86070-105">Trusted STS Should Sign SAML Token Claims</span></span>  
 <span data-ttu-id="86070-106">Ein SAML (Security Assertions Markup Language)-Token ist ein generisches XML-Token, das den Standardtyp für ausgestellte Token darstellt.</span><span class="sxs-lookup"><span data-stu-id="86070-106">A Security Assertions Markup Language (SAML) token is a generic XML token that is the default type for issued tokens.</span></span> <span data-ttu-id="86070-107">SAML-Token können von einem Sicherheitstokendienst (Security Token Service, STS) erstellt werden, der für den empfangenden Webdienst in einem typischen Datenaustausch als vertrauenswürdig gilt.</span><span class="sxs-lookup"><span data-stu-id="86070-107">A SAML token can be constructed by a Security Token Service (STS) that the end Web service trusts in a typical exchange.</span></span> <span data-ttu-id="86070-108">SAML-Token enthalten Ansprüche in Form von Anweisungen.</span><span class="sxs-lookup"><span data-stu-id="86070-108">SAML tokens contain claims in statements.</span></span> <span data-ttu-id="86070-109">Ein Angreifer kann die Ansprüche aus einem gültigen Token kopieren, ein neues SAML-Token erstellen und mit einem anderen Aussteller signieren.</span><span class="sxs-lookup"><span data-stu-id="86070-109">An attacker may copy the claims from a valid token, create a new SAML token, and sign it with a different issuer.</span></span> <span data-ttu-id="86070-110">Das Ziel ist hierbei, festzustellen, ob der Server Aussteller validiert, und wenn nicht, diese Schwäche zum Erstellen von SAML-Token auszunutzen, die Berechtigungen über die von einem vertrauenswürdigen STS beabsichtigten hinaus gewähren.</span><span class="sxs-lookup"><span data-stu-id="86070-110">The intent is to determine whether the server is validating issuers and, if not, utilize the weakness to construct SAML tokens that allow privileges beyond those intended by a trusted STS.</span></span>  
  
 <span data-ttu-id="86070-111">Die <xref:System.IdentityModel.Tokens.SamlAssertion>-Klasse überprüft die digitale Signatur, die in einem SAML-Token enthalten ist, und der Standard-<xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> erfordert, dass SAML-Token mit einem X.509-Zertifikat signiert sind, das gültig ist, wenn <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> der <xref:System.ServiceModel.Security.IssuedTokenServiceCredential>-Klasse auf <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust> festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="86070-111">The <xref:System.IdentityModel.Tokens.SamlAssertion> class verifies the digital signature contained within a SAML token, and the default <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> requires that SAML tokens be signed by an X.509 certificate that is valid when the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> of the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> class is set to <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span></span> <span data-ttu-id="86070-112">Mithilfe des `ChainTrust`-Modus allein kann nicht bestimmt werden, ob der Aussteller des SAML-Tokens vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="86070-112">`ChainTrust` mode alone is insufficient to determine whether the issuer of the SAML token is trusted.</span></span> <span data-ttu-id="86070-113">Dienste, die ein stärker granuliertes Vertrauenswürdigkeitsmodell erfordern, können entweder mithilfe von Autorisierungs- oder Durchsetzungsrichtlinien den Aussteller der erzeugten Anspruchssätze durch die Authentifizierung der Token überprüfen oder die X.509-Validierungseinstellungen für <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> verwenden, um den Satz zulässiger Signaturzertifikate einzuschränken.</span><span class="sxs-lookup"><span data-stu-id="86070-113">Services that require a more granular trust model can either use authorization and enforcement policies to check the issuer of the claim sets produced by issued token authentication or use the X.509 validation settings on <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> to restrict the set of allowed signing certificates.</span></span> <span data-ttu-id="86070-114">Weitere Informationen finden Sie unter [Verwalten von Ansprüchen und Autorisierung mit dem Identitäts Modell](managing-claims-and-authorization-with-the-identity-model.md) und Verbund [Token und ausgestellte Token](federation-and-issued-tokens.md).</span><span class="sxs-lookup"><span data-stu-id="86070-114">For more information, see [Managing Claims and Authorization with the Identity Model](managing-claims-and-authorization-with-the-identity-model.md) and [Federation and Issued Tokens](federation-and-issued-tokens.md).</span></span>  
  
## <a name="switching-identity-without-a-security-context"></a><span data-ttu-id="86070-115">Wechseln der Identität ohne Sicherheitskontext</span><span class="sxs-lookup"><span data-stu-id="86070-115">Switching Identity Without a Security Context</span></span>  
 <span data-ttu-id="86070-116">Folgendes gilt nur für WinFX.</span><span class="sxs-lookup"><span data-stu-id="86070-116">The following applies only to WinFX.</span></span>  
  
 <span data-ttu-id="86070-117">Wenn eine Verbindung zwischen einem Client und einem Server hergestellt wird, ändert sich die Identität des Clients nicht, es sei denn, es besteht eine Situation: Nachdem der WCF-Client geöffnet wurde, sind alle folgenden Bedingungen erfüllt:</span><span class="sxs-lookup"><span data-stu-id="86070-117">When a connection is established between a client and server, the identity of the client does not change, except in one situation: after the WCF client is opened, if all of the following conditions are true:</span></span>  
  
- <span data-ttu-id="86070-118">Die Verfahren zum Einrichten eines Sicherheits Kontexts (über eine Transport Sicherheits Sitzung oder eine Nachrichten Sicherheits Sitzung) werden deaktiviert (die- <xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> Eigenschaft ist auf festgelegt, `false` Wenn die Nachrichten Sicherheit oder der Transport, der keine Sicherheits Sitzungen einrichten kann, bei der Transportsicherheit verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="86070-118">The procedures to establish a security context (using a transport security session or message security session) is switched off (<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> property is set to `false` in case of message security or transport not capable of establishing security sessions is used in transport security case.</span></span> <span data-ttu-id="86070-119">HTTPS ist ein Beispiel für ein solches Transportprotokoll).</span><span class="sxs-lookup"><span data-stu-id="86070-119">HTTPS is one example of such transport).</span></span>  
  
- <span data-ttu-id="86070-120">Sie verwenden die Windows-Authentifizierung.</span><span class="sxs-lookup"><span data-stu-id="86070-120">You are using Windows authentication.</span></span>  
  
- <span data-ttu-id="86070-121">Sie legen die Anmeldeinformationen nicht explizit fest.</span><span class="sxs-lookup"><span data-stu-id="86070-121">You do not explicitly set the credential.</span></span>  
  
- <span data-ttu-id="86070-122">Sie rufen den Dienst unter dem Identitätswechsel-Sicherheitskontext auf.</span><span class="sxs-lookup"><span data-stu-id="86070-122">You are calling the service under the impersonated security context.</span></span>  
  
 <span data-ttu-id="86070-123">Wenn diese Bedingungen zutreffen, kann sich die Identität, die zum Authentifizieren des Clients beim Dienst verwendet wird, möglicherweise ändern (es kann sich dabei nicht um die Identitäts Identitäts Identität, sondern um die Prozess Identität handeln), nachdem der WCF-Client geöffnet wurde.</span><span class="sxs-lookup"><span data-stu-id="86070-123">If these conditions are true, the identity used to authenticate the client to the service might change (it might not be the impersonated identity but the process identity instead) after the WCF client is opened.</span></span> <span data-ttu-id="86070-124">Dies geschieht, weil die Windows-Anmeldeinformationen, mit denen der Client für den Dienst authentifiziert wird, mit jeder Nachricht übermittelt werden, und die zur Authentifizierung verwendeten Anmeldeinformationen von der Windows-Identität des aktuellen Threads bezogen werden.</span><span class="sxs-lookup"><span data-stu-id="86070-124">This occurs because the Windows credential used to authenticate the client to the service is transmitted with every message, and the credential used for authentication is obtained from the current thread's Windows identity.</span></span> <span data-ttu-id="86070-125">Wenn sich die Windows-Identität des aktuellen Threads ändert (beispielsweise durch einen Identitätswechsel, mit dem ein anderer Aufrufer imitiert wird), dann können sich auch die Anmeldeinformationen ändern, die an die Nachricht angefügt sind und die zur Authentifizierung des Clients gegenüber dem Dienst verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="86070-125">If the Windows identity of the current thread changes (for example, by impersonating a different caller), the credential that is attached to the message and used to authenticate the client to the service might also change.</span></span>  
  
 <span data-ttu-id="86070-126">Wenn das Verhalten beim Einsatz der Windows-Authentifizierung in Verbindung mit dem Identitätswechsel deterministisch sein soll, müssen Sie die Windows-Anmeldeinformationen explizit festlegen, oder Sie müssen einen Sicherheitskontext für den Dienst einrichten.</span><span class="sxs-lookup"><span data-stu-id="86070-126">If you want to have deterministic behavior when using Windows authentication together with impersonation you need to explicitly set the Windows credential or you need to establish a security context with the service.</span></span> <span data-ttu-id="86070-127">Hierzu verwenden Sie eine Nachrichtensicherheitssitzung oder eine Transportsicherheitssitzung.</span><span class="sxs-lookup"><span data-stu-id="86070-127">To do this, use a message security session or a transport security session.</span></span> <span data-ttu-id="86070-128">Zum Beispiel kann der net.tcp-Transport eine Transportsicherheitssitzung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="86070-128">For example, the net.tcp transport can provide a transport security session.</span></span> <span data-ttu-id="86070-129">Darüber hinaus dürfen Sie in Aufrufen des Diensts nur die synchrone Version von Clientvorgängen verwenden.</span><span class="sxs-lookup"><span data-stu-id="86070-129">Additionally, you must use only a synchronous version of client operations when calling the service.</span></span> <span data-ttu-id="86070-130">Wenn Sie einen Nachrichtensicherheitskontext einrichten, sollten Sie die Verbindung mit dem Dienst nicht länger als den für die Sitzung konfigurierten Erneuerungszeitraum geöffnet halten, weil sich die Identität auch während des Sitzungserneuerungsprozesses ändern kann.</span><span class="sxs-lookup"><span data-stu-id="86070-130">If you establish a message security context, you should not keep the connection to the service open longer than the configured session renewal period, because the identity can also change during the session renewal process.</span></span>  
  
### <a name="credentials-capture"></a><span data-ttu-id="86070-131">Aufzeichnung der Anmeldeinformationen</span><span class="sxs-lookup"><span data-stu-id="86070-131">Credentials Capture</span></span>  
 <span data-ttu-id="86070-132">Folgendes gilt für .NET Framework 3,5 und nachfolgende Versionen.</span><span class="sxs-lookup"><span data-stu-id="86070-132">The following applies to .NET Framework 3.5, and subsequent versions.</span></span>  
  
 <span data-ttu-id="86070-133">Die vom Client oder Dienst verwendeten Anmeldeinformationen basieren auf dem aktuellen Kontextthread.</span><span class="sxs-lookup"><span data-stu-id="86070-133">Credentials used by the client or the service are based on the current context thread.</span></span> <span data-ttu-id="86070-134">Die Anmeldeinformationen werden durch einen Aufruf der `Open`-Methode (bzw. `BeginOpen` für asynchrone Aufrufe) des Clients oder Diensts bezogen.</span><span class="sxs-lookup"><span data-stu-id="86070-134">The credentials are obtained when the `Open` method (or `BeginOpen`, for asynchronous calls) of the client or service is called.</span></span> <span data-ttu-id="86070-135">Sowohl für die <xref:System.ServiceModel.ServiceHost>-Klasse als auch für die <xref:System.ServiceModel.ClientBase%601>-Klasse gilt, dass die `Open`-Methode bzw. die `BeginOpen`-Methode von der <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A>-Methode bzw. der <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A>-Methode der <xref:System.ServiceModel.Channels.CommunicationObject>-Klasse abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="86070-135">For both the <xref:System.ServiceModel.ServiceHost> and <xref:System.ServiceModel.ClientBase%601> classes, the `Open` and `BeginOpen` methods inherit from the <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> methods of the <xref:System.ServiceModel.Channels.CommunicationObject> class.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="86070-136">Bei Verwendung der `BeginOpen`-Methode kann nicht garantiert werden, dass es sich bei den aufgezeichneten Anmeldeinformationen um die Anmeldeinformationen des Prozesses handelt, von dem die Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="86070-136">When using the `BeginOpen` method, the credentials captured cannot be guaranteed to be the credentials of the process that calls the method.</span></span>  
  
## <a name="token-caches-allow-replay-using-obsolete-data"></a><span data-ttu-id="86070-137">Tokenzwischenspeicher ermöglichen Wiederholungen mit veralteten Daten</span><span class="sxs-lookup"><span data-stu-id="86070-137">Token Caches Allow Replay Using Obsolete Data</span></span>  
 <span data-ttu-id="86070-138">WCF verwendet die Funktion der lokalen Sicherheits Autorität (Local Security Authority, LSA) `LogonUser` zum Authentifizieren von Benutzern anhand von Benutzername und Kennwort.</span><span class="sxs-lookup"><span data-stu-id="86070-138">WCF uses the local security authority (LSA) `LogonUser` function to authenticate users by user name and password.</span></span> <span data-ttu-id="86070-139">Da die LOGON-Funktion ein kostspieliger Vorgang ist, ermöglicht Ihnen WCF das Zwischenspeichern von Token, die authentifizierte Benutzer darstellen, um die Leistung zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="86070-139">Because the logon function is a costly operation, WCF allows you to cache tokens that represent authenticated users to increase performance.</span></span> <span data-ttu-id="86070-140">Mit dem Zwischenspeichermechanismus werden die Ergebnisse von `LogonUser` für die spätere Verwendung gespeichert.</span><span class="sxs-lookup"><span data-stu-id="86070-140">The caching mechanism saves the results from `LogonUser` for subsequent uses.</span></span> <span data-ttu-id="86070-141">Dieser Mechanismus ist standardmäßig deaktiviert. um es zu aktivieren, legen Sie die- <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> Eigenschaft auf fest `true` , oder verwenden Sie das- `cacheLogonTokens` Attribut von [\<userNameAuthentication>](../../configure-apps/file-schema/wcf/usernameauthentication.md) .</span><span class="sxs-lookup"><span data-stu-id="86070-141">This mechanism is disabled by default; to enable it, set the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> property to `true`, or use the `cacheLogonTokens` attribute of the [\<userNameAuthentication>](../../configure-apps/file-schema/wcf/usernameauthentication.md).</span></span>  
  
 <span data-ttu-id="86070-142">Sie können eine Gültigkeitsdauer (Time to Live, TTL) für die zwischengespeicherten Token festlegen, indem Sie <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A>-Eigenschaft auf eine <xref:System.TimeSpan>-Zeitspanne festlegen oder das `cachedLogonTokenLifetime`-Attribut des `userNameAuthentication`-Elements verwenden. Der Standardwert beträgt 15 Minuten.</span><span class="sxs-lookup"><span data-stu-id="86070-142">You can set a Time to Live (TTL) for the cached tokens by setting the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> property to a <xref:System.TimeSpan>, or use the `cachedLogonTokenLifetime` attribute of the `userNameAuthentication` element; the default is 15 minutes.</span></span> <span data-ttu-id="86070-143">Beachten Sie Folgendes: Solange ein Token zwischengespeichert ist, kann jeder Client, der den gleichen Benutzernamen und das gleiche Kennwort angibt, das Token nutzen, auch wenn das betreffende Benutzerkonto in Windows gelöscht oder dessen Kennwort geändert wurde.</span><span class="sxs-lookup"><span data-stu-id="86070-143">Note that while a token is cached, any client that presents the same user name and password can use the token, even if the user account is deleted from Windows or if its password has been changed.</span></span> <span data-ttu-id="86070-144">Bis die Gültigkeitsdauer abläuft und das Token aus dem Cache entfernt wird, ermöglicht WCF dem (möglicherweise böswilligen) Benutzer, sich zu authentifizieren.</span><span class="sxs-lookup"><span data-stu-id="86070-144">Until the TTL expires and the token is removed from the cache, WCF allows the (possibly malicious) user to authenticate.</span></span>  
  
 <span data-ttu-id="86070-145">So lässt sich dieses Problem abschwächen: Verkleinern Sie die Angriffsfläche, indem Sie den `cachedLogonTokenLifetime`-Wert auf die kürzeste Zeitspanne festlegen, die von den Benutzern benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="86070-145">To mitigate this: Decrease the attack window by setting the `cachedLogonTokenLifetime` value to the shortest time span your users need.</span></span>  
  
## <a name="issued-token-authorization-expiration-reset-to-large-value"></a><span data-ttu-id="86070-146">Ausgestellte Tokenautorisierung: Ablaufzeit auf großem Wert zurückgesetzt</span><span class="sxs-lookup"><span data-stu-id="86070-146">Issued Token Authorization: Expiration Reset to Large Value</span></span>  
 <span data-ttu-id="86070-147">Unter bestimmten Bedingungen kann die <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A>-Eigenschaft des <xref:System.IdentityModel.Policy.AuthorizationContext>-Objekts auf einen unerwartet großen Wert (z.&#160;B. der Wert des <xref:System.DateTime.MaxValue>-Felds minus einem Tag oder der 20. Dezember 9999) festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="86070-147">Under certain conditions, the <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> property of the <xref:System.IdentityModel.Policy.AuthorizationContext> may be set to an unexpectedly larger value (the <xref:System.DateTime.MaxValue> field value minus one day, or December 20, 9999).</span></span>  
  
 <span data-ttu-id="86070-148">Dieser Fall tritt ein, wenn <xref:System.ServiceModel.WSFederationHttpBinding> und eine der vom System bereitgestellten Bindungen verwendet werden, für die ausgestellte Token als Clientanmeldeinformationen zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="86070-148">This occurs when using the <xref:System.ServiceModel.WSFederationHttpBinding> and any of the system-provided bindings that have an issued token as the client credential type.</span></span>  
  
 <span data-ttu-id="86070-149">Dieser Fall tritt auch ein, wenn Sie mit einer der folgenden Methoden benutzerdefinierte Bindungen erstellen:</span><span class="sxs-lookup"><span data-stu-id="86070-149">This also occurs when you create custom bindings by using one of the following methods:</span></span>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement%2A>  
  
 <span data-ttu-id="86070-150">Um dem entgegenzuwirken, muss die Autorisierungsrichtlinie die Aktion und Gültigkeitsdauer jeder Autorisierungsrichtlinie überprüfen.</span><span class="sxs-lookup"><span data-stu-id="86070-150">To mitigate this, the authorization policy must check the action and the expiration time of each authorization policy.</span></span>  
  
## <a name="the-service-uses-a-different-certificate-than-the-client-intended"></a><span data-ttu-id="86070-151">Der Dienst verwendet ein anderes Zertifikat, als das vom Client beabsichtigte</span><span class="sxs-lookup"><span data-stu-id="86070-151">The Service Uses a Different Certificate Than the Client Intended</span></span>  
 <span data-ttu-id="86070-152">Unter bestimmten Umständen kann ein Client eine Nachricht mit einem X.509-Zertifikat signieren und den Dienst ein anderes als das vorgesehene Zertifikat abrufen lassen.</span><span class="sxs-lookup"><span data-stu-id="86070-152">Under certain conditions, a client can digitally sign a message with an X.509 certificate and have the service retrieve a different certificate than the intended one.</span></span>  
  
 <span data-ttu-id="86070-153">Dieser Fall kann unter den folgenden Umständen eintreten:</span><span class="sxs-lookup"><span data-stu-id="86070-153">This can occur under the following circumstances:</span></span>  
  
- <span data-ttu-id="86070-154">Der Client signiert eine Nachricht mit einem X.509-Zertifikat und fügt das X.509-Zertifikat nicht an die Nachricht an, sondern verweist über dessen Subjektschlüsselbezeichner darauf.</span><span class="sxs-lookup"><span data-stu-id="86070-154">The client digitally signs a message using an X.509 certificate and does not attach the X.509 certificate to the message, but rather just references the certificate using its subject key identifier.</span></span>  
  
- <span data-ttu-id="86070-155">Auf dem Computer, auf dem der Dienst ausgeführt wird, sind zwei oder mehr Zertifikate mit dem gleichen öffentlichen Schlüssel vorhanden, die jedoch unterschiedliche Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="86070-155">The service's computer contains two or more certificates with the same public key, but they contain different information.</span></span>  
  
- <span data-ttu-id="86070-156">Der Dienst ruft ein Zertifikat ab, das zwar den gleichen Subjektschlüsselbezeichner aufweist, aber nicht das vom Client für die Verwendung vorgesehene Zertifikat ist.</span><span class="sxs-lookup"><span data-stu-id="86070-156">The service retrieves a certificate that matches the subject key identifier, but it is not the one the client intended to use.</span></span> <span data-ttu-id="86070-157">Wenn WCF die Nachricht empfängt und die Signatur überprüft, ordnet WCF die Informationen im unbeabsichtigten X. 509-Zertifikat einem Satz von Ansprüchen zu, die sich unterscheiden und möglicherweise von dem vom Client erwarteten Wert herauf gestuft werden.</span><span class="sxs-lookup"><span data-stu-id="86070-157">When WCF receives the message and verifies the signature, WCF maps the information in the unintended X.509 certificate to a set of claims that are different and potentially elevated from what the client expected.</span></span>  
  
 <span data-ttu-id="86070-158">Um dieses Problem zu entschärfen, verweisen Sie auf eine andere Art auf das X.509-Zertifikat, z.&#160;B. mithilfe von <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span><span class="sxs-lookup"><span data-stu-id="86070-158">To mitigate this, reference the X.509 certificate another way, such as using <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="86070-159">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="86070-159">See also</span></span>

- [<span data-ttu-id="86070-160">Sicherheitshinweise</span><span class="sxs-lookup"><span data-stu-id="86070-160">Security Considerations</span></span>](security-considerations-in-wcf.md)
- [<span data-ttu-id="86070-161">Offenlegung von Informationen</span><span class="sxs-lookup"><span data-stu-id="86070-161">Information Disclosure</span></span>](information-disclosure.md)
- [<span data-ttu-id="86070-162">Denial of Service</span><span class="sxs-lookup"><span data-stu-id="86070-162">Denial of Service</span></span>](denial-of-service.md)
- [<span data-ttu-id="86070-163">Wiederholungsangriffe</span><span class="sxs-lookup"><span data-stu-id="86070-163">Replay Attacks</span></span>](replay-attacks.md)
- [<span data-ttu-id="86070-164">Manipulation</span><span class="sxs-lookup"><span data-stu-id="86070-164">Tampering</span></span>](tampering.md)
- [<span data-ttu-id="86070-165">Nicht unterstützte Szenarien</span><span class="sxs-lookup"><span data-stu-id="86070-165">Unsupported Scenarios</span></span>](unsupported-scenarios.md)
