---
title: XML- und ADO.NET-Typen in Datenverträgen
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6
ms.openlocfilehash: ae21174d19ad69f87165427cf5a0bfd29ac872db
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 05/04/2018
ms.locfileid: "33509099"
---
# <a name="xml-and-adonet-types-in-data-contracts"></a><span data-ttu-id="dc388-102">XML- und ADO.NET-Typen in Datenverträgen</span><span class="sxs-lookup"><span data-stu-id="dc388-102">XML and ADO.NET Types in Data Contracts</span></span>
<span data-ttu-id="dc388-103">Der Windows Communication Foundation (WCF)--datenvertragsmodell unterstützt bestimmte Typen, die XML direkt darstellen.</span><span class="sxs-lookup"><span data-stu-id="dc388-103">The Windows Communication Foundation (WCF) data contract model supports certain types that represent XML directly.</span></span> <span data-ttu-id="dc388-104">Wenn diese Typen in XML serialisiert werden, schreibt das Serialisierungsprogramm den XML-Inhalt dieser Typen ohne weitere Verarbeitung.</span><span class="sxs-lookup"><span data-stu-id="dc388-104">When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.</span></span> <span data-ttu-id="dc388-105">Unterstützte Typen sind <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode>-Arrays (jedoch nicht der `XmlNode`-Typ selbst) sowie Typen, die <xref:System.Xml.Serialization.IXmlSerializable> implementieren.</span><span class="sxs-lookup"><span data-stu-id="dc388-105">Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span> <span data-ttu-id="dc388-106">Der <xref:System.Data.DataSet>- und <xref:System.Data.DataTable>-Typ sowie typisierte Datasets werden häufig bei der Datenbankprogrammierung verwendet.</span><span class="sxs-lookup"><span data-stu-id="dc388-106">The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming.</span></span> <span data-ttu-id="dc388-107">Diese Typen implementieren die `IXmlSerializable`-Schnittstelle und sind deshalb im Datenvertragsmodell serialisierbar.</span><span class="sxs-lookup"><span data-stu-id="dc388-107">These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model.</span></span> <span data-ttu-id="dc388-108">Einige besondere Überlegungen zu diesen Typen sind am Ende dieses Themas aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="dc388-108">Some special considerations for these types are listed at the end of this topic.</span></span>  
  
## <a name="xml-types"></a><span data-ttu-id="dc388-109">XML-Typen</span><span class="sxs-lookup"><span data-stu-id="dc388-109">XML Types</span></span>  
  
### <a name="xml-element"></a><span data-ttu-id="dc388-110">XML-Element</span><span class="sxs-lookup"><span data-stu-id="dc388-110">Xml Element</span></span>  
 <span data-ttu-id="dc388-111">Der `XmlElement`-Typ wird mit seinem XML-Inhalt serialisiert.</span><span class="sxs-lookup"><span data-stu-id="dc388-111">The `XmlElement` type is serialized using its XML contents.</span></span> <span data-ttu-id="dc388-112">Verwenden Sie z.&#160;B. den folgenden Typ:</span><span class="sxs-lookup"><span data-stu-id="dc388-112">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#4)]
 [!code-vb[DataContractAttribute#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#4)]  
  
 <span data-ttu-id="dc388-113">Die Serialisierung in XML wird wie folgt durchgeführt:</span><span class="sxs-lookup"><span data-stu-id="dc388-113">This is serialized to XML as follows:</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
    <myDataMember>  
        <myElement xmlns="" myAttribute="myValue">  
            myContents  
        </myElement>  
    </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="dc388-114">Beachten Sie, dass immer noch das Wrapper-Datenmemberelement `<myDataMember>` vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dc388-114">Notice that a wrapper data member element `<myDataMember>` is still present.</span></span> <span data-ttu-id="dc388-115">Es gibt keine Möglichkeit, dieses Element im Datenvertragsmodell zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="dc388-115">There is no way of removing this element in the data contract model.</span></span> <span data-ttu-id="dc388-116">Die Serialisierungsprogramme, die dieses Modell verarbeiten (<xref:System.Runtime.Serialization.DataContractSerializer> und <xref:System.Runtime.Serialization.NetDataContractSerializer>), können spezielle Attribute in dieses Wrapperelement einfügen.</span><span class="sxs-lookup"><span data-stu-id="dc388-116">The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element.</span></span> <span data-ttu-id="dc388-117">Diese Attribute enthalten das standardmäßige XML-Schemainstanzattribut "nil" (damit das `XmlElement``null` sein kann) und das Attribut "type" (damit das `XmlElement` polymorph verwendet werden kann).</span><span class="sxs-lookup"><span data-stu-id="dc388-117">These attributes include the standard XML Schema Instance "nil" attribute (allowing the `XmlElement` to be `null`) and the "type" attribute (allowing `XmlElement` to be used polymorphically).</span></span> <span data-ttu-id="dc388-118">Darüber hinaus sind die folgenden XML-Attribute spezifisch für WCF: "Id", "Ref", "Type" und "Assembly".</span><span class="sxs-lookup"><span data-stu-id="dc388-118">Also, the following XML attributes are specific to WCF: "Id", "Ref", "Type" and "Assembly".</span></span> <span data-ttu-id="dc388-119">Diese Attribute können ausgegeben werden, um die Verwendung von `XmlElement` bei aktiviertem Objektdiagramm-Beibehaltungsmodus zu unterstützen, oder indem <xref:System.Runtime.Serialization.NetDataContractSerializer> verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dc388-119">These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="dc388-120">(Weitere Informationen zu den Objektdiagramm-beibehaltungsmodus, finden Sie unter [Serialisierung und Deserialisierung](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span><span class="sxs-lookup"><span data-stu-id="dc388-120">(For more information about the object graph preservation mode, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span></span>  
  
 <span data-ttu-id="dc388-121">Arrays oder Auflistungen von `XmlElement` sind zulässig und werden wie andere Arrays oder Auflistungen behandelt.</span><span class="sxs-lookup"><span data-stu-id="dc388-121">Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection.</span></span> <span data-ttu-id="dc388-122">Es wird ein Wrapperelement für die gesamte Auflistung und ein separates Wrapperelement (auf ähnliche Weise wie `<myDataMember>` im vorherigen Beispiel) für jedes `XmlElement` im Array verwendet.</span><span class="sxs-lookup"><span data-stu-id="dc388-122">That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array.</span></span>  
  
 <span data-ttu-id="dc388-123">Bei der Deserialisierung erstellt das Deserialisierungsprogramm aus den eingehenden XML-Daten ein `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="dc388-123">On deserialization, an `XmlElement` is created by the deserializer from the incoming XML.</span></span> <span data-ttu-id="dc388-124">Ein gültiges übergeordnetes <xref:System.Xml.XmlDocument> wird vom Deserialisierungsprogramm bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="dc388-124">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span>  
  
 <span data-ttu-id="dc388-125">Stellen Sie sicher, dass für das XML-Fragment, das in ein `XmlElement` deserialisiert wird, alle verwendeten Präfixe definiert sind, und dass es nicht von den Präfixdefinitionen übergeordneter Elemente abhängig ist.</span><span class="sxs-lookup"><span data-stu-id="dc388-125">Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.</span></span> <span data-ttu-id="dc388-126">Dies ist nur von Bedeutung, wenn Sie `DataContractSerializer` verwenden, um auf XML von einer anderen Quelle (als `DataContractSerializer`) zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="dc388-126">This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source.</span></span>  
  
 <span data-ttu-id="dc388-127">Bei Verwendung mit der `DataContractSerializer`, `XmlElement` möglicherweise polymorph zugewiesen werden, jedoch nur auf einen Datenmember vom Typ <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="dc388-127">When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>.</span></span> <span data-ttu-id="dc388-128">Auch wenn es <xref:System.Collections.IEnumerable> implementiert, kann ein `XmlElement` nicht als Auflistungstyp verwendet und keinem <xref:System.Collections.IEnumerable>-Datenmember zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="dc388-128">Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member.</span></span> <span data-ttu-id="dc388-129">Wie bei allen polymorphen Zuweisungen der `DataContractSerializer` ausgibt, den den Datenvertragsnamen in der resultierenden XML – in diesem Fall ist "XmlElement" in der "http://schemas.datacontract.org/2004/07/System.Xml" Namespace.</span><span class="sxs-lookup"><span data-stu-id="dc388-129">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "XmlElement" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span>  
  
 <span data-ttu-id="dc388-130">Mit `NetDataContractSerializer` wird jede gültige polymorphe Zuweisung von `XmlElement` (zu `Object` oder `IEnumerable`) unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dc388-130">With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported.</span></span>  
  
 <span data-ttu-id="dc388-131">Versuchen Sie nicht, eines der Serialisierungsprogramme in Verbindung mit Typen zu verwenden, die von `XmlElement` abgeleitet sind, ob polymorph oder auf andere Weise.</span><span class="sxs-lookup"><span data-stu-id="dc388-131">Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not.</span></span>  
  
### <a name="array-of-xmlnode"></a><span data-ttu-id="dc388-132">XmlNode-Array</span><span class="sxs-lookup"><span data-stu-id="dc388-132">Array of XmlNode</span></span>  
 <span data-ttu-id="dc388-133">Das Verwenden von <xref:System.Xml.XmlNode>-Arrays ähnelt stark der Verwendung von `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="dc388-133">Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`.</span></span> <span data-ttu-id="dc388-134">Wenn Sie `XmlNode`-Arrays verwenden, können Sie flexibler arbeiten, als wenn Sie `XmlElement` verwenden.</span><span class="sxs-lookup"><span data-stu-id="dc388-134">Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`.</span></span> <span data-ttu-id="dc388-135">Sie können innerhalb des Datenmember-Wrapperelements mehrere Elemente schreiben.</span><span class="sxs-lookup"><span data-stu-id="dc388-135">You can write multiple elements inside the data member wrapping element.</span></span> <span data-ttu-id="dc388-136">Neben Elementen können Sie auch andere Inhalte in das Datenmember-Wrapperelement einfügen, zum Beispiel XML-Kommentare.</span><span class="sxs-lookup"><span data-stu-id="dc388-136">You can also inject content other than elements inside of the data member wrapping element, such as XML comments.</span></span> <span data-ttu-id="dc388-137">Außerdem können Sie bei Bedarf Attribute in das Datenmember-Wrapperelement einfügen.</span><span class="sxs-lookup"><span data-stu-id="dc388-137">Finally, you can put attributes into the wrapping data member element.</span></span> <span data-ttu-id="dc388-138">Sie können diese Schritte ausführen, indem Sie das `XmlNode`-Array mit spezifischen von `XmlNode` abgeleiteten Klassen auffüllen, zum Beispiel mit <xref:System.Xml.XmlAttribute>, `XmlElement` oder <xref:System.Xml.XmlComment>.</span><span class="sxs-lookup"><span data-stu-id="dc388-138">All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>.</span></span> <span data-ttu-id="dc388-139">Verwenden Sie z.&#160;B. den folgenden Typ:</span><span class="sxs-lookup"><span data-stu-id="dc388-139">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#5)]
 [!code-vb[DataContractAttribute#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#5)]  
  
 <span data-ttu-id="dc388-140">Nach der Serialisierung sind die sich ergebenden XML-Daten folgendem Code ähnlich:</span><span class="sxs-lookup"><span data-stu-id="dc388-140">When serialized, the resulting XML is similar to the following code.</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
  <myDataMember myAttribute="myValue">  
     <!--myComment-->  
     <myElement xmlns="" myAttribute="myValue">  
 myContents  
     </myElement>  
     <myElement xmlns="" myAttribute="myValue">  
       myContents  
     </myElement>  
  </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="dc388-141">Beachten Sie, dass das Datenmember-Wrapperelement `<myDataMember>` ein Attribut, einen Kommentar und zwei Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="dc388-141">Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements.</span></span> <span data-ttu-id="dc388-142">Dies sind die vier `XmlNode`-Instanzen, die serialisiert wurden.</span><span class="sxs-lookup"><span data-stu-id="dc388-142">These are the four `XmlNode` instances that were serialized.</span></span>  
  
 <span data-ttu-id="dc388-143">Ein `XmlNode`-Array, das zu ungültigen XML-Daten führen würde, kann nicht serialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="dc388-143">An array of `XmlNode` that results in invalid XML cannot be serialized.</span></span> <span data-ttu-id="dc388-144">Ein Array mit zwei `XmlNode`-Instanzen, von der die erste ein `XmlElement` und die zweite ein <xref:System.Xml.XmlAttribute> ist, ist zum Beispiel ungültig, da diese Folge keiner gültigen XML-Instanz entspricht (es gibt keine Möglichkeit, das Attribut anzufügen).</span><span class="sxs-lookup"><span data-stu-id="dc388-144">For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).</span></span>  
  
 <span data-ttu-id="dc388-145">Bei der Deserialisierung eines `XmlNode`-Arrays werden Knoten erstellt und mit den Informationen aus den eingehenden XML-Daten aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="dc388-145">On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML.</span></span> <span data-ttu-id="dc388-146">Ein gültiges übergeordnetes <xref:System.Xml.XmlDocument> wird vom Deserialisierungsprogramm bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="dc388-146">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span> <span data-ttu-id="dc388-147">Alle Knoten deserialisiert werden, sowie alle Attribute in das Datenmember-Wrapperelement, jedoch nicht die Attribute dort abgelegt wurden von den WCF-Serialisierungsprogrammen (z. B. die Attribute, die zum Angeben der polymorphen Zuweisung verwendet wird).</span><span class="sxs-lookup"><span data-stu-id="dc388-147">All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the WCF serializers (such as the attributes used to indicate polymorphic assignment).</span></span> <span data-ttu-id="dc388-148">Die Einschränkung in Bezug auf die Definition aller Namespacepräfixe im XML-Fragment gilt für die Deserialisierung von `XmlNode`-Arrays genauso, wie sie für die Deserialisierung von `XmlElement` gilt.</span><span class="sxs-lookup"><span data-stu-id="dc388-148">The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`.</span></span>  
  
 <span data-ttu-id="dc388-149">Wenn Sie die Serialisierungsprogramme bei aktivierter Objektdiagrammbeibehaltung verwenden, wird die Objektgleichheit nur auf der Ebene der `XmlNode`-Arrays beibehalten, nicht für die einzelnen `XmlNode`-Instanzen.</span><span class="sxs-lookup"><span data-stu-id="dc388-149">When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances.</span></span>  
  
 <span data-ttu-id="dc388-150">Versuchen Sie nicht, ein `XmlNode`-Array zu serialisieren, wenn einer oder mehrere Knoten auf `null` festgelegt sind.</span><span class="sxs-lookup"><span data-stu-id="dc388-150">Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`.</span></span> <span data-ttu-id="dc388-151">Es ist zulässig, dass das gesamte Array `null` ist, nicht jedoch ein einzelner `XmlNode` im Array.</span><span class="sxs-lookup"><span data-stu-id="dc388-151">It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array.</span></span> <span data-ttu-id="dc388-152">Wenn der gesamte Arraymember 0 ist, enthält das Datenmember-Wrapperelement ein spezielles Attribut, das diesen Nullwert angibt.</span><span class="sxs-lookup"><span data-stu-id="dc388-152">If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.</span></span> <span data-ttu-id="dc388-153">Bei der Deserialisierung wird auch der ganze Arraymember 0.</span><span class="sxs-lookup"><span data-stu-id="dc388-153">On deserialization, the entire array member also becomes null.</span></span>  
  
 <span data-ttu-id="dc388-154">Nur normale `XmlNode`-Arrays werden vom Serialisierungsprogramm besonders behandelt.</span><span class="sxs-lookup"><span data-stu-id="dc388-154">Only regular arrays of `XmlNode` are treated specially by the serializer.</span></span> <span data-ttu-id="dc388-155">Datenmember, die als andere, `XmlNode` enthaltende Auflistungstypen deklariert sind, oder Datenmember, die als Arrays von Typen deklariert sind, die von `XmlNode` abgeleitet sind, werden nicht besonders behandelt.</span><span class="sxs-lookup"><span data-stu-id="dc388-155">Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially.</span></span> <span data-ttu-id="dc388-156">Aus diesem Grund sind sie normalerweise nicht serialisierbar, es sei denn, sie erfüllen auch eines der Kriterien für die Serialisierbarkeit.</span><span class="sxs-lookup"><span data-stu-id="dc388-156">Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.</span></span>  
  
 <span data-ttu-id="dc388-157">Arrays oder Auflistungen von Arrays von `XmlNode` sind zulässig.</span><span class="sxs-lookup"><span data-stu-id="dc388-157">Arrays or collections of arrays of `XmlNode` are allowed.</span></span> <span data-ttu-id="dc388-158">Es wird ein Wrapperelement für die gesamte Auflistung und ein separates Wrapperelement (auf ähnliche Weise wie `<myDataMember>` im Beispiel oben) für jedes `XmlNode`-Array im äußeren Array bzw. in der äußeren Auflistung verwendet.</span><span class="sxs-lookup"><span data-stu-id="dc388-158">There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection.</span></span>  
  
 <span data-ttu-id="dc388-159">Das Auffüllen eines Datenmembers vom Typ <xref:System.Array> von `Object` oder `Array` von `IEnumerable` mit `XmlNode`-Instanzen führt nicht dazu, dass der Datenmember als `Array` mit `XmlNode`-Instanzen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="dc388-159">Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances.</span></span> <span data-ttu-id="dc388-160">Jeder Arraymember wird getrennt serialisiert.</span><span class="sxs-lookup"><span data-stu-id="dc388-160">Each array member is serialized separately.</span></span>  
  
 <span data-ttu-id="dc388-161">Bei der Verwendung mit `DataContractSerializer` können `XmlNode`-Arrays polymorph zugewiesen werden, jedoch nur für einen Datenmember vom Typ `Object`.</span><span class="sxs-lookup"><span data-stu-id="dc388-161">When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`.</span></span> <span data-ttu-id="dc388-162">Auch wenn es `IEnumerable` implementiert, kann ein `XmlNode`-Array nicht als Auflistungstyp verwendet und keinem `IEnumerable`-Datenmember zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="dc388-162">Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member.</span></span> <span data-ttu-id="dc388-163">Wie bei allen polymorphen Zuweisungen der `DataContractSerializer` ausgibt, den den Datenvertragsnamen in der resultierenden XML – in diesem Fall ist "ArrayOfXmlNode" in der "http://schemas.datacontract.org/2004/07/System.Xml" Namespace.</span><span class="sxs-lookup"><span data-stu-id="dc388-163">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "ArrayOfXmlNode" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span> <span data-ttu-id="dc388-164">Bei Verwendung mit der `NetDataContractSerializer`, jede gültige Zuweisung einer `XmlNode` Arrays werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dc388-164">When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported.</span></span>  
  
### <a name="schema-considerations"></a><span data-ttu-id="dc388-165">Schemaüberlegungen</span><span class="sxs-lookup"><span data-stu-id="dc388-165">Schema Considerations</span></span>  
 <span data-ttu-id="dc388-166">Informationen zum Schema Zuordnen von XML-Typen finden Sie unter [Datenvertrags-Schemareferenz](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="dc388-166">For details about the schema mapping of XML types, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="dc388-167">Dieser Abschnitt enthält eine Zusammenfassung der wichtigen Punkte.</span><span class="sxs-lookup"><span data-stu-id="dc388-167">This section provides a summary of the important points.</span></span>  
  
 <span data-ttu-id="dc388-168">Ein Datenmember vom Typ `XmlElement` wird einem Element zugeordnet, das mithilfe des folgenden anonymen Typs definiert wurde.</span><span class="sxs-lookup"><span data-stu-id="dc388-168">A data member of type `XmlElement` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType>  
   <xsd:sequence>  
      <xsd:any minOccurs="0" processContents="lax" />  
   </xsd:sequence>  
</xsd:complexType>  
```  
  
 <span data-ttu-id="dc388-169">Ein Datenmember vom Typ `XmlNode`-Array wird einem Element zugeordnet, das mithilfe des folgenden anonymen Typs definiert wurde.</span><span class="sxs-lookup"><span data-stu-id="dc388-169">A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType mixed="true">  
   <xsd:sequence>  
      <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax" />  
   </xsd:sequence>  
   <xsd:anyAttribute/>  
</xsd:complexType>  
```  
  
## <a name="types-implementing-the-ixmlserializable-interface"></a><span data-ttu-id="dc388-170">Typen, die die IXmlSerializable-Schnittstelle implementieren</span><span class="sxs-lookup"><span data-stu-id="dc388-170">Types Implementing the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="dc388-171">Typen, die die `IXmlSerializable`-Schnittstelle implementieren, werden von `DataContractSerializer` vollständig unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dc388-171">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="dc388-172">Sie sollten das <xref:System.Xml.Serialization.XmlSchemaProviderAttribute>-Attribut immer auf diese Typen anwenden, um das dazugehörige Schema zu steuern.</span><span class="sxs-lookup"><span data-stu-id="dc388-172">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
 <span data-ttu-id="dc388-173">Es gibt drei Varianten von Typen, die `IXmlSerializable` implementieren: Typen, die beliebigen Inhalt darstellen, Typen, die ein einzelnes Element darstellen, und ältere <xref:System.Data.DataSet>-Typen.</span><span class="sxs-lookup"><span data-stu-id="dc388-173">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
-   <span data-ttu-id="dc388-174">Inhaltstypen verwenden eine vom `XmlSchemaProviderAttribute`-Attribut angegebene Schemaanbietermethode.</span><span class="sxs-lookup"><span data-stu-id="dc388-174">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="dc388-175">Die Methode gibt nicht `null` zurück, und die <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A>-Eigenschaft des Attributs wird auf ihrem Standardwert `false` belassen.</span><span class="sxs-lookup"><span data-stu-id="dc388-175">The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="dc388-176">Dies ist die häufigste Verwendung von `IXmlSerializable`-Typen.</span><span class="sxs-lookup"><span data-stu-id="dc388-176">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
-   <span data-ttu-id="dc388-177">Elementtypen werden verwendet, wenn ein `IXmlSerializable`-Typ seinen eigenen Stammelementnamen kontrollieren muss.</span><span class="sxs-lookup"><span data-stu-id="dc388-177">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="dc388-178">Um einen Typ als Elementtyp zu kennzeichnen, legen Sie entweder die <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A>-Eigenschaft des <xref:System.Xml.Serialization.XmlSchemaProviderAttribute>-Attributs auf `true` fest, oder geben Sie über die Schemaanbietermethode 0 zurück.</span><span class="sxs-lookup"><span data-stu-id="dc388-178">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method.</span></span> <span data-ttu-id="dc388-179">Die Verwendung einer Schemaanbietermethode ist für Elementtypen optional. Sie können unter `XmlSchemaProviderAttribute` anstatt des Methodennamens auch NULL angeben.</span><span class="sxs-lookup"><span data-stu-id="dc388-179">Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="dc388-180">Wenn `IsAny` jedoch `true` ist und eine Schemaanbietermethode angegeben ist, muss die Methode NULL zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="dc388-180">However, if `IsAny` is `true` and a schema provider method is specified, the method must return null.</span></span>  
  
-   <span data-ttu-id="dc388-181">Bei älteren <xref:System.Data.DataSet>-Typen handelt es sich um `IXmlSerializable`-Typen, die nicht mit dem `XmlSchemaProviderAttribute`-Attribut gekennzeichnet sind.</span><span class="sxs-lookup"><span data-stu-id="dc388-181">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="dc388-182">Stattdessen verwenden sie zur Schemagenerierung die <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="dc388-182">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="dc388-183">Dieses Muster wird für den `DataSet`-Typ und seine von ihm abgeleiteten typisierten Dataset-Klassen in älteren Versionen von .NET Framework verwendet. Es ist jedoch veraltet und wird nur aus Legacygründen noch unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dc388-183">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="dc388-184">Verlassen Sie sich nicht auf dieses Muster, und wenden Sie immer das `XmlSchemaProviderAttribute` auf Ihre `IXmlSerializable`-Typen an.</span><span class="sxs-lookup"><span data-stu-id="dc388-184">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="dc388-185">IXmlSerializable-Inhaltstypen</span><span class="sxs-lookup"><span data-stu-id="dc388-185">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="dc388-186">Wenn Sie einen Datenmember eines Typs serialisieren, der `IXmlSerializable` implementiert und ein wie vorher definierter Inhaltstyp ist, schreibt das Serialisierungsprogramm das Wrapperelement für den Datenmember und übergibt die Steuerung an die <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="dc388-186">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="dc388-187">Die <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A>-Implementierung kann beliebige XML-Daten schreiben, auch zum Hinzufügen der Attribute zum Wrapperelement.</span><span class="sxs-lookup"><span data-stu-id="dc388-187">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element.</span></span> <span data-ttu-id="dc388-188">Nachdem `WriteXml` abgeschlossen ist, schließt das Serialisierungsprogramm das Element.</span><span class="sxs-lookup"><span data-stu-id="dc388-188">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="dc388-189">Wenn Sie einen Datenmember eines Typs deserialisieren, der `IXmlSerializable` implementiert und ein wie vorher definierter Inhaltstyp ist, ordnet das Deserialisierungsprogramm den XML-Reader im Wrapperelement für den Datenmember an und übergibt die Steuerung an die <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="dc388-189">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="dc388-190">Die Methode muss das ganze Element lesen, einschließlich des Start- und Endtags.</span><span class="sxs-lookup"><span data-stu-id="dc388-190">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="dc388-191">Stellen Sie sicher, dass der `ReadXml`-Code auch den Fall verarbeitet, in dem das Element leer ist.</span><span class="sxs-lookup"><span data-stu-id="dc388-191">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="dc388-192">Außerdem sollte sich Ihre `ReadXml`-Implementierung nicht darauf verlassen, dass das Wrapperelement einen bestimmten Namen aufweist.</span><span class="sxs-lookup"><span data-stu-id="dc388-192">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="dc388-193">Der Name wird vom Serialisierungsprogramm ausgewählt und kann variieren.</span><span class="sxs-lookup"><span data-stu-id="dc388-193">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="dc388-194">Es ist zulässig, `IXmlSerializable`-Inhaltstypen polymorph zuzuweisen, zum Beispiel zu Datenmembern vom Typ <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="dc388-194">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="dc388-195">Es ist auch zulässig, dass die Typinstanzen NULL sind.</span><span class="sxs-lookup"><span data-stu-id="dc388-195">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="dc388-196">Außerdem ist es möglich, `IXmlSerializable`-Typen bei aktivierter Objektdiagrammbeibehaltung und mit <xref:System.Runtime.Serialization.NetDataContractSerializer> zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="dc388-196">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="dc388-197">Alle diese Features erfordern die WCF-Serialisierungsprogramm bestimmte Attribute in das Wrapperelement einfügt ("nil" und "Type" im XML-schemainstanznamespace und "Id", "Ref", "Type" und "Assembly" in einem WCF-spezifische-Namespace).</span><span class="sxs-lookup"><span data-stu-id="dc388-197">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="dc388-198">Bei der Implementierung von ReadXml zu ignorierende Attribute</span><span class="sxs-lookup"><span data-stu-id="dc388-198">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="dc388-199">Bevor die Steuerung an Ihren `ReadXml`-Code übergeben wird, untersucht das Deserialisierungsprogramm das XML-Element, erkennt diese speziellen XML-Attribute und führt die erforderlichen Aktionen aus.</span><span class="sxs-lookup"><span data-stu-id="dc388-199">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="dc388-200">Wenn "nil" zum Beispiel `true` ist, wird ein Nullwert deserialisiert, und `ReadXml` wird nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dc388-200">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="dc388-201">Falls Polymorphie erkannt wird, wird der Inhalt des Elements deserialisiert, als ob es sich um einen anderen Typ handeln würde.</span><span class="sxs-lookup"><span data-stu-id="dc388-201">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="dc388-202">Die `ReadXml`-Implementierung des polymorph zugewiesenen Typs wird aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dc388-202">The polymorphically assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="dc388-203">Eine `ReadXml`-Implementierung sollte diese speziellen Attribute auf jeden Fall ignorieren, da sie vom Deserialisierungsprogramm verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="dc388-203">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="dc388-204">Schemaüberlegungen für IXmlSerializable-Inhaltstypen</span><span class="sxs-lookup"><span data-stu-id="dc388-204">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="dc388-205">Beim Exportieren eines Schemas aus einem `IXmlSerializable`-Inhaltstyp wird die Schemaanbietermethode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dc388-205">When exporting schema an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="dc388-206">Ein <xref:System.Xml.Schema.XmlSchemaSet> wird an die Schemaanbietermethode übergeben.</span><span class="sxs-lookup"><span data-stu-id="dc388-206">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="dc388-207">Die Methode kann dem Schemasatz gültige Schemas hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="dc388-207">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="dc388-208">Der Schemasatz enthält das Schema, das zum Zeitpunkt des Schemaexports bereits bekannt ist.</span><span class="sxs-lookup"><span data-stu-id="dc388-208">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="dc388-209">Wenn die Schemaanbietermethode dem Schemasatz ein Element hinzufügen muss, muss sie ermitteln, ob ein <xref:System.Xml.Schema.XmlSchema> mit dem geeigneten Namespace im Satz bereits vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dc388-209">When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="dc388-210">Falls dies der Fall ist, muss die Schemaanbietermethode das neue Element dem vorhandenen `XmlSchema` hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="dc388-210">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="dc388-211">Andernfalls muss sie eine neue `XmlSchema`-Instanz erstellen.</span><span class="sxs-lookup"><span data-stu-id="dc388-211">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="dc388-212">Dies ist wichtig, wenn Arrays mit `IXmlSerializable`-Typen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dc388-212">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="dc388-213">Wenn Sie zum Beispiel über einen `IXmlSerializable`-Typ verfügen, der als Typ "A" in Namespace "B" exportiert wird, ist es möglich, dass der Schemasatz beim Aufrufen der Schemaanbietermethode das Schema "B" bereits enthält, um den Typ "ArrayOfA" aufzunehmen.</span><span class="sxs-lookup"><span data-stu-id="dc388-213">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="dc388-214">Zusätzlich zum Hinzufügen von Typen zum <xref:System.Xml.Schema.XmlSchemaSet> muss die Schemaanbietermethode für Inhaltstypen einen anderen Wert als NULL zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="dc388-214">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="dc388-215">Sie kann ein <xref:System.Xml.XmlQualifiedName>-Element zurückgeben, das den Namen des Schematyps angibt, der für den jeweiligen `IXmlSerializable`-Typ verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dc388-215">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="dc388-216">Dieser qualifizierte Name dient auch als Datenvertragsname und Namespace für den Typ.</span><span class="sxs-lookup"><span data-stu-id="dc388-216">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="dc388-217">Es ist zulässig, einen Typ zurückzugeben, der nicht im Schemasatz vorhanden ist, wenn dies direkt nach der Rückgabe der Schemaanbietermethode erfolgt.</span><span class="sxs-lookup"><span data-stu-id="dc388-217">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="dc388-218">Es wird jedoch vorausgesetzt, dass der Typ nach dem Export aller verwandten Typen (die <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A>-Methode wird für alle relevanten Typen von <xref:System.Runtime.Serialization.XsdDataContractExporter> aufgerufen, und es wird auf die <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A>-Eigenschaft zugegriffen) im Schemasatz vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dc388-218">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="dc388-219">Das Zugreifen auf die `Schemas`-Eigenschaft, bevor alle relevanten `Export`-Aufrufe durchgeführt wurden, kann zu einer <xref:System.Xml.Schema.XmlSchemaException> führen.</span><span class="sxs-lookup"><span data-stu-id="dc388-219">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="dc388-220">Weitere Informationen zu den Exportprozess, finden Sie unter [Exportieren von Schemas aus Klassen](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="dc388-220">For more information about the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="dc388-221">Die Schemaanbietermethode kann auch den zu verwendenden <xref:System.Xml.Schema.XmlSchemaType> zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="dc388-221">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="dc388-222">Der Typ kann anonym oder nicht anonym sein.</span><span class="sxs-lookup"><span data-stu-id="dc388-222">The type may or may not be anonymous.</span></span> <span data-ttu-id="dc388-223">Wenn er anonym ist, wird das Schema für den `IXmlSerializable`-Typ jeweils als anonymer Typ exportiert, wenn der `IXmlSerializable`-Typ als Datenmember verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dc388-223">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="dc388-224">Der `IXmlSerializable`-Typ verfügt trotzdem noch über einen Datenvertragsnamen und einen Namespace.</span><span class="sxs-lookup"><span data-stu-id="dc388-224">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="dc388-225">(Dies wird bestimmt, wie in beschrieben [Datenvertragsnamen](../../../../docs/framework/wcf/feature-details/data-contract-names.md) mit dem Unterschied, dass die <xref:System.Runtime.Serialization.DataContractAttribute> Attribut kann nicht zum Anpassen des Namens verwendet werden.) Wenn er nicht anonym ist, muss es sich um einen der Typen im `XmlSchemaSet` handeln.</span><span class="sxs-lookup"><span data-stu-id="dc388-225">(This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="dc388-226">Dies entspricht dem Zurückgeben von `XmlQualifiedName` für den Typ.</span><span class="sxs-lookup"><span data-stu-id="dc388-226">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="dc388-227">Zusätzlich wird für den Typ eine globale Elementdeklaration exportiert.</span><span class="sxs-lookup"><span data-stu-id="dc388-227">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="dc388-228">Wenn auf den Typ nicht das <xref:System.Xml.Serialization.XmlRootAttribute>-Attribut angewendet wurde, weist das Element denselben Namen und Namespace wie der Datenvertrag auf, und seine "nil"-fähige Eigenschaft ist "true".</span><span class="sxs-lookup"><span data-stu-id="dc388-228">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is true.</span></span> <span data-ttu-id="dc388-229">Die einzige Ausnahme hierbei ist der Schemanamespace ("http://www.w3.org/2001/XMLSchema") – Wenn Datenvertrag des Typs in diesem Namespace ist, ist das entsprechende globale Element im leeren Namespace, da es nicht zulässig ist, auf den Schemanamespace neue Elemente hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="dc388-229">The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="dc388-230">Wenn auf den Typ das `XmlRootAttribute`-Attribut angewendet wurde, wird die globale Elementdeklaration exportiert, indem Folgendes verwendet wird: die Eigenschaften <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> und <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A>.</span><span class="sxs-lookup"><span data-stu-id="dc388-230">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="dc388-231">Die bei angewendetem `XmlRootAttribute` geltenden Standardeinstellungen sind der Datenvertragsname, ein leerer Namespace und der Wert "true" für die Nullfähigkeit ("nillable").</span><span class="sxs-lookup"><span data-stu-id="dc388-231">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being true.</span></span>  
  
 <span data-ttu-id="dc388-232">Die gleichen Regeln für die globale Elementdeklaration gelten für Legacy-Datasettypen.</span><span class="sxs-lookup"><span data-stu-id="dc388-232">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="dc388-233">Beachten Sie, dass das `XmlRootAttribute` keine globalen Elementdeklarationen überschreiben kann, die mithilfe von benutzerdefiniertem Code hinzugefügt wurden. Diese können mithilfe der Schemaanbietermethode dem `XmlSchemaSet` oder über `GetSchema` für Legacy-Datasettypen hinzugefügt worden sein.</span><span class="sxs-lookup"><span data-stu-id="dc388-233">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="dc388-234">IXmlSerializable-Elementtypen</span><span class="sxs-lookup"><span data-stu-id="dc388-234">IXmlSerializable Element Types</span></span>  
 <span data-ttu-id="dc388-235">Für `IXmlSerializable`-Elementtypen ist entweder die `IsAny`-Eigenschaft auf `true` festgelegt, oder ihre Schemaanbietermethode gibt `null` zurück.</span><span class="sxs-lookup"><span data-stu-id="dc388-235">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="dc388-236">Das Serialisieren und Deserialisieren eines Elementtyps ähnelt stark dem Serialisieren und Deserialisieren eines Inhaltstyps.</span><span class="sxs-lookup"><span data-stu-id="dc388-236">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="dc388-237">Es gibt jedoch einige wichtige Unterschiede:</span><span class="sxs-lookup"><span data-stu-id="dc388-237">However, there are some important differences:</span></span>  
  
-   <span data-ttu-id="dc388-238">Von der `WriteXml`-Implementierung wird erwartet, dass sie genau ein Element schreibt (das natürlich mehrere untergeordnete Elemente enthalten kann).</span><span class="sxs-lookup"><span data-stu-id="dc388-238">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="dc388-239">Sie sollte keine Attribute außerhalb dieses einzelnen Elements, mehrerer gleichgeordneter Elemente oder gemischten Inhalts schreiben.</span><span class="sxs-lookup"><span data-stu-id="dc388-239">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="dc388-240">Das Element ist ggf. leer.</span><span class="sxs-lookup"><span data-stu-id="dc388-240">The element may be empty.</span></span>  
  
-   <span data-ttu-id="dc388-241">Die `ReadXml`-Implementierung sollte das Wrapperelement nicht lesen.</span><span class="sxs-lookup"><span data-stu-id="dc388-241">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="dc388-242">Es wird erwartet, dass sie das einzelne Element liest, das von `WriteXml` erzeugt wird.</span><span class="sxs-lookup"><span data-stu-id="dc388-242">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
-   <span data-ttu-id="dc388-243">Wenn das Serialisierungsprogramm regelmäßig einen Elementtyp serialisiert (zum Beispiel als Datenmember in einem Datenvertrag), gibt das Serialisierungsprogramm ein Wrapperelement aus, bevor `WriteXml` aufgerufen wird. Dies entspricht der Vorgehensweise bei Inhaltstypen.</span><span class="sxs-lookup"><span data-stu-id="dc388-243">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="dc388-244">Bei der Serialisierung eines Elementtyps auf der obersten Ebene gibt das Serialisierungsprogramm normalerweise jedoch kein Wrapperelement für das Element aus, das `WriteXml` schreibt. Dies ist nur der Fall, wenn beim Erstellen des Serialisierungsprogramms in den Konstruktoren `DataContractSerializer` oder `NetDataContractSerializer` explizit ein Stammname und ein Namespace angegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="dc388-244">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="dc388-245">Weitere Informationen finden Sie unter [Serialisierung und Deserialisierung](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="dc388-245">For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
-   <span data-ttu-id="dc388-246">Beim Serialisieren eines Elementtyps auf der obersten Ebene, ohne zur Entwurfszeit den Stammnamen und einen Namespace anzugeben, führen <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> und <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> im Wesentlichen keine Aktionen aus, und <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> ruft einfach `WriteXml` auf.</span><span class="sxs-lookup"><span data-stu-id="dc388-246">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="dc388-247">In diesem Modus kann das Objekt, das serialisiert wird, nicht NULL sein und nicht polymorph zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="dc388-247">In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.</span></span> <span data-ttu-id="dc388-248">Außerdem kann die Objektdiagrammbeibehaltung nicht aktiviert und `NetDataContractSerializer` kann nicht verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dc388-248">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
-   <span data-ttu-id="dc388-249">Beim Deserialisieren eines Elementtyps auf der obersten Ebene, ohne zur Entwurfszeit den Stammnamen und den Namespace anzugeben, gibt <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> den Wert `true` zurück, wenn der Anfang eines beliebigen Elements gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="dc388-249">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="dc388-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> mit auf `verifyObjectName` festgelegtem `true`-Parameter verhält sich genau so wie `IsStartObject`, bevor das Objekt gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="dc388-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="dc388-251">`ReadObject` übergibt das Steuerelement dann an die `ReadXml`-Methode.</span><span class="sxs-lookup"><span data-stu-id="dc388-251">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="dc388-252">Das Schema, das für die Elementtypen exportiert wird, entspricht dem Schema für den `XmlElement`-Typ, wie in einem Abschnitt weiter oben beschrieben. Es gilt jedoch die Ausnahme, dass die Schemaanbietermethode wie bei Inhaltstypen dem <xref:System.Xml.Schema.XmlSchemaSet> zusätzliche Schemas hinzufügen kann.</span><span class="sxs-lookup"><span data-stu-id="dc388-252">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="dc388-253">Das Verwenden des `XmlRootAttribute`-Attributs mit Elementtypen ist nicht zulässig, und globale Elementdeklarationen werden für diese Typen nicht ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="dc388-253">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="dc388-254">Unterschiede zu XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="dc388-254">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="dc388-255">Die `IXmlSerializable`-Schnittstelle und das `XmlSchemaProviderAttribute`- und `XmlRootAttribute`-Attribut werden vom <xref:System.Xml.Serialization.XmlSerializer> auch verstanden.</span><span class="sxs-lookup"><span data-stu-id="dc388-255">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="dc388-256">Aber es gibt einige Unterschiede dabei, wie diese Elemente im Datenvertragsmodell behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="dc388-256">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="dc388-257">Die wichtigsten Unterschiede werden im Folgenden zusammengefasst:</span><span class="sxs-lookup"><span data-stu-id="dc388-257">The important differences are summarized in the following:</span></span>  
  
-   <span data-ttu-id="dc388-258">Die Schemaanbietermethode muss öffentlich sein, um im `XmlSerializer` verwendet werden zu können. Sie muss jedoch nicht öffentlich sein, um im Datenvertragsmodell verwendet werden zu können.</span><span class="sxs-lookup"><span data-stu-id="dc388-258">The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model.</span></span>  
  
-   <span data-ttu-id="dc388-259">Die Schemaanbietermethode wird aufgerufen, wenn für `IsAny` im Datenvertragsmodell "true" gilt, jedoch nicht für den `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="dc388-259">The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="dc388-260">Wenn das `XmlRootAttribute`-Attribut für Inhalts- oder Legacy-Datasettypen nicht vorhanden ist, exportiert der `XmlSerializer` eine globale Elementdeklaration in den leeren Namespace.</span><span class="sxs-lookup"><span data-stu-id="dc388-260">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="dc388-261">Im Datenvertragsmodell ist der verwendete Namespace normalerweise der Datenvertragsnamespace, wie bereits beschrieben.</span><span class="sxs-lookup"><span data-stu-id="dc388-261">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="dc388-262">Beachten Sie diese Unterschiede, wenn Sie Typen erstellen, die mit beiden Serialisierungstechnologien verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dc388-262">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="dc388-263">Importieren von IXmlSerializable-Schemas</span><span class="sxs-lookup"><span data-stu-id="dc388-263">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="dc388-264">Beim Importieren eines Schemas, das aus `IXmlSerializable`-Typen generiert wurde, gibt es verschiedene Möglichkeiten:</span><span class="sxs-lookup"><span data-stu-id="dc388-264">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
-   <span data-ttu-id="dc388-265">Dem generierten Schema kann ein gültiges datenvertragsschema handeln, wie in beschrieben [Datenvertrags-Schemareferenz](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="dc388-265">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="dc388-266">In diesem Fall kann das Schema auf die übliche Weise importiert werden, und es werden normale Datenvertragstypen generiert.</span><span class="sxs-lookup"><span data-stu-id="dc388-266">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
-   <span data-ttu-id="dc388-267">Bei dem generierten Schema kann es sich auch um ein nicht gültiges Datenvertragsschema handeln.</span><span class="sxs-lookup"><span data-stu-id="dc388-267">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="dc388-268">Ihre Schemaanbietermethode kann zum Beispiel Schemas mit XML-Attributen generieren, die im Datenvertragsmodell nicht unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="dc388-268">For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.</span></span> <span data-ttu-id="dc388-269">In diesem Fall können Sie das Schema als `IXmlSerializable`-Typen importieren.</span><span class="sxs-lookup"><span data-stu-id="dc388-269">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="dc388-270">Dieser Modus "Import" ist nicht standardmäßig aktiviert, jedoch kann problemlos mit aktiviert werden – z. B. die `/importXmlTypes` Befehlszeilenoption, um die [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="dc388-270">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="dc388-271">Dies wird ausführlich beschrieben unter der [Importieren von Schemas zum Generieren von Klassen](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="dc388-271">This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="dc388-272">Beachten Sie, dass Sie für die Typinstanzen direkt mit den XML-Daten arbeiten müssen.</span><span class="sxs-lookup"><span data-stu-id="dc388-272">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="dc388-273">Sie können auch erwägen, eine andere Serialisierungstechnologie zu verwenden, die einen größeren Schemabereich unterstützt. Weitere Informationen finden Sie im Thema zur Verwendung von `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="dc388-273">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="dc388-274">Es ist ratsam, Ihre vorhandenen `IXmlSerializable`-Typen im Proxy wiederzuverwenden, anstatt neue zu generieren.</span><span class="sxs-lookup"><span data-stu-id="dc388-274">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="dc388-275">In diesem Fall können Sie die Funktion mit den referenzierten Typen verwenden, die im Thema zum Importieren von Schemas zum Generieren von Typen beschrieben ist, um den wiederzuverwendenden Typ anzugeben.</span><span class="sxs-lookup"><span data-stu-id="dc388-275">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="dc388-276">Dies entspricht dem Verwenden der `/reference` Schalters von svcutil.exe, der die Assembly angibt, die die wiederzuverwendenden Typen enthält.</span><span class="sxs-lookup"><span data-stu-id="dc388-276">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
## <a name="representing-arbitrary-xml-in-data-contracts"></a><span data-ttu-id="dc388-277">Darstellen von beliebigen XML-Daten in Datenverträgen</span><span class="sxs-lookup"><span data-stu-id="dc388-277">Representing Arbitrary XML in Data Contracts</span></span>  
 <span data-ttu-id="dc388-278">Mithilfe der Typen `XmlElement`, `XmlNode`-Array und `IXmlSerializable` können Sie beliebige XML-Daten in das Datenvertragsmodell einfügen.</span><span class="sxs-lookup"><span data-stu-id="dc388-278">The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model.</span></span> <span data-ttu-id="dc388-279">`DataContractSerializer` und `NetDataContractSerializer` übergeben diesen XML-Inhalt an den verwendeten XML-Writer, ohne dabei den Prozess zu beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="dc388-279">The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process.</span></span> <span data-ttu-id="dc388-280">Die XML-Writer können jedoch bestimmte Einschränkungen für die XML-Daten erzwingen, die sie schreiben.</span><span class="sxs-lookup"><span data-stu-id="dc388-280">However, the XML writers may enforce certain restrictions on the XML that they write.</span></span> <span data-ttu-id="dc388-281">Unten sind einige wichtige Beispiele aufgeführt:</span><span class="sxs-lookup"><span data-stu-id="dc388-281">Specifically, here are some important examples:</span></span>  
  
-   <span data-ttu-id="dc388-282">Die XML-Writer nicht in der Regel eine XML-Dokumentdeklaration zulassen (z. B. \<? Xml Version = "1.0'? >) in der Mitte, schreiben ein anderes Dokument.</span><span class="sxs-lookup"><span data-stu-id="dc388-282">The XML writers do not typically allow an XML document declaration (for example, \<?xml version=’1.0’ ?>) in the middle of writing another document.</span></span> <span data-ttu-id="dc388-283">Sie können kein vollständiges XML-Dokument als `Array`-`XmlNode` für einen Datenmember serialisieren.</span><span class="sxs-lookup"><span data-stu-id="dc388-283">You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member.</span></span> <span data-ttu-id="dc388-284">Dazu müssen Sie entweder die Dokumentdeklaration entfernen oder Ihr eigenes Codierungsschema für die Darstellung verwenden.</span><span class="sxs-lookup"><span data-stu-id="dc388-284">To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.</span></span>  
  
-   <span data-ttu-id="dc388-285">Alle mit WCF bereitgestellten XML-Writer weisen XML-verarbeitungsanweisungen (\<?</span><span class="sxs-lookup"><span data-stu-id="dc388-285">All of the XML writers supplied with WCF reject XML processing instructions (\<?</span></span> <span data-ttu-id="dc388-286">…</span><span class="sxs-lookup"><span data-stu-id="dc388-286">…</span></span> <span data-ttu-id="dc388-287">? >) und Dokumenttypdefinitionen (\<!</span><span class="sxs-lookup"><span data-stu-id="dc388-287">?>) and document type definitions (\<!</span></span> <span data-ttu-id="dc388-288">…</span><span class="sxs-lookup"><span data-stu-id="dc388-288">…</span></span> <span data-ttu-id="dc388-289">>), da sie in der SOAP-Nachrichten nicht zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="dc388-289">>), because they are not allowed in SOAP messages.</span></span> <span data-ttu-id="dc388-290">Auch hier können Sie Ihren eigenen Codierungsmechanismus verwenden, um diese Einschränkung zu umgehen.</span><span class="sxs-lookup"><span data-stu-id="dc388-290">Again, you can use your own encoding mechanism to get around this restriction.</span></span> <span data-ttu-id="dc388-291">Wenn Sie dies in die sich ergebenden XML-Daten einfügen müssen, können Sie einen benutzerdefinierten Encoder schreiben, der XML-Writer mit der entsprechenden Unterstützung verwendet.</span><span class="sxs-lookup"><span data-stu-id="dc388-291">If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.</span></span>  
  
-   <span data-ttu-id="dc388-292">Wenn Sie `WriteXml` implementieren, sollten Sie es vermeiden, die <xref:System.Xml.XmlWriter.WriteRaw%2A>-Methode für den XML-Writer aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dc388-292">When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer.</span></span> <span data-ttu-id="dc388-293">WCF verwendet eine Vielzahl von XML-Codierungstypen (einschließlich binär), ist es sehr schwierig oder unmöglich ist, verwenden Sie `WriteRaw` , dass das Ergebnis jede Codierung verwendbar ist.</span><span class="sxs-lookup"><span data-stu-id="dc388-293">WCF uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding.</span></span>  
  
-   <span data-ttu-id="dc388-294">Bei der Implementierung `WriteXml`, vermeiden Sie die Verwendung der <xref:System.Xml.XmlWriter.WriteEntityRef%2A> und <xref:System.Xml.XmlWriter.WriteNmToken%2A> Methoden, die auf die XML-Writer Lieferumfang von WCF nicht unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="dc388-294">When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with WCF.</span></span>  
  
## <a name="using-dataset-typed-dataset-and-datatable"></a><span data-ttu-id="dc388-295">Verwenden von DataSet, typisiertem DataSet und DataTable</span><span class="sxs-lookup"><span data-stu-id="dc388-295">Using DataSet, Typed DataSet and DataTable</span></span>  
 <span data-ttu-id="dc388-296">Die Verwendung dieser Typen wird im Datenvertragsmodell vollständig unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dc388-296">Using these types is fully supported in the data contract model.</span></span> <span data-ttu-id="dc388-297">Beachten Sie beim Verwenden dieser Typen die folgenden Punkte:</span><span class="sxs-lookup"><span data-stu-id="dc388-297">When using these types, consider the following points:</span></span>  
  
-   <span data-ttu-id="dc388-298">Das Schema für diese Typen (insbesondere <xref:System.Data.DataSet> und die zugehörigen abgeleiteten typisierten Klassen) möglicherweise nicht interoperabel mit einigen nicht-WCF-Plattformen oder möglicherweise schlechter benutzerfreundlichkeit bei der Verwendung mit diesen Plattformen.</span><span class="sxs-lookup"><span data-stu-id="dc388-298">The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-WCF platforms, or may result in poor usability when used with these platforms.</span></span> <span data-ttu-id="dc388-299">Außerdem kann die Verwendung des `DataSet`-Typs zu Leistungseinbußen führen.</span><span class="sxs-lookup"><span data-stu-id="dc388-299">Additionally, using the `DataSet` type may have performance implications.</span></span> <span data-ttu-id="dc388-300">Zudem kann es das Versehen Ihrer Anwendung mit einer Versionsangabe erschweren.</span><span class="sxs-lookup"><span data-stu-id="dc388-300">Finally, it may make it more difficult for you to version your application in the future.</span></span> <span data-ttu-id="dc388-301">Sie können erwägen, anstelle von `DataSet`-Typen in Ihren Verträgen explizit definierte Datenvertragstypen zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="dc388-301">Consider using explicitly defined data contract types instead of `DataSet` types in your contracts.</span></span>  
  
-   <span data-ttu-id="dc388-302">Beim Importieren von `DataSet`- oder `DataTable`-Schemas ist es wichtig, auf diese Typen zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="dc388-302">When importing `DataSet` or `DataTable` schema, it is important to reference these types.</span></span> <span data-ttu-id="dc388-303">Mit dem Befehlszeilentool Svcutil.exe, dies geschieht durch Übergeben der Assemblyname "System.Data.dll", um die `/reference` wechseln.</span><span class="sxs-lookup"><span data-stu-id="dc388-303">With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch.</span></span> <span data-ttu-id="dc388-304">Wenn Sie typisierte Datasetschemas importieren, müssen Sie auf den Typ des typisierten Datasets verweisen.</span><span class="sxs-lookup"><span data-stu-id="dc388-304">If importing typed dataset schema, you must reference the typed dataset’s type.</span></span> <span data-ttu-id="dc388-305">Mit Svcutil.exe, übergeben Sie den Speicherort der Assembly das typisierte Dataset, um die `/reference` wechseln.</span><span class="sxs-lookup"><span data-stu-id="dc388-305">With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch.</span></span> <span data-ttu-id="dc388-306">Weitere Informationen zum Verweisen auf Typen, finden Sie unter der [Importieren von Schemas zum Generieren von Klassen](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="dc388-306">For more information about referencing types, see the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span>  
  
 <span data-ttu-id="dc388-307">Die Unterstützung typisierter DataSets im Datenvertragsmodell ist beschränkt.</span><span class="sxs-lookup"><span data-stu-id="dc388-307">Support for typed DataSets in the data contract model is limited.</span></span> <span data-ttu-id="dc388-308">Typisierte DataSets können serialisiert und deserialisiert werden und können ihr Schema exportieren.</span><span class="sxs-lookup"><span data-stu-id="dc388-308">Typed DataSets can be serialized and deserialized and can export their schema.</span></span> <span data-ttu-id="dc388-309">Jedoch kann der Datenvertragsschemaimport keine neuen typisierte Dataset-Typen aus dem Schema generieren, sondern nur schon vorhandene wiederverwenden.</span><span class="sxs-lookup"><span data-stu-id="dc388-309">However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.</span></span> <span data-ttu-id="dc388-310">Sie können mithilfe des `/r`-Schalters von Svcutil.exe auf ein vorhandenes typisiertes DataSet verweisen.</span><span class="sxs-lookup"><span data-stu-id="dc388-310">You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe.</span></span> <span data-ttu-id="dc388-311">Wenn Sie versuchen, Svcutil.exe ohne den `/r`-Schalter für einen Dienst einzusetzen, der ein typisiertes DataSet verwendet, wird automatisch ein alternatives Serialisierungsprogramm (XmlSerializer) ausgewählt.</span><span class="sxs-lookup"><span data-stu-id="dc388-311">If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.</span></span> <span data-ttu-id="dc388-312">Wenn Sie den DataContractSerializer verwenden und DataSets aus dem Schema generieren müssen, können Sie zu dem folgenden Verfahren greifen: Generieren Sie die typisierten DataSet-Typen (indem Sie das Tool Xsd.exe mit dem Schalter `/d` für den Dienst verwenden), kompilieren Sie die Typen, und verweisen Sie dann mithilfe des `/r`-Schalters von Svcutil.exe auf diese Typen.</span><span class="sxs-lookup"><span data-stu-id="dc388-312">If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="dc388-313">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="dc388-313">See Also</span></span>  
 <xref:System.Runtime.Serialization.DataContractSerializer>  
 <xref:System.Xml.Serialization.IXmlSerializable>  
 [<span data-ttu-id="dc388-314">Verwenden von Datenverträgen</span><span class="sxs-lookup"><span data-stu-id="dc388-314">Using Data Contracts</span></span>](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)  
 [<span data-ttu-id="dc388-315">Vom Datenvertragsserialisierer unterstützte Typen</span><span class="sxs-lookup"><span data-stu-id="dc388-315">Types Supported by the Data Contract Serializer</span></span>](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)
