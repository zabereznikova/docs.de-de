---
title: Beispiel zur schwach typisierten JSON-Serialisierung
ms.date: 03/30/2017
ms.assetid: 0b30e501-4ef5-474d-9fad-a9d559cf9c52
ms.openlocfilehash: 65330e77622920f02b12bd69348aa635529e030e
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/26/2020
ms.locfileid: "96244430"
---
# <a name="weakly-typed-json-serialization-sample"></a><span data-ttu-id="b1a3e-102">Beispiel zur schwach typisierten JSON-Serialisierung</span><span class="sxs-lookup"><span data-stu-id="b1a3e-102">Weakly-typed JSON Serialization Sample</span></span>

<span data-ttu-id="b1a3e-103">Beim Serialisieren eines benutzerdefinierten Typs in ein bestimmtes Übertragungsformat oder beim Deserialisieren eines Übertragungsformats zurück in einen benutzerdefinierten Typ muss der jeweilige benutzerdefinierte Typ für den Dienst und den Client verfügbar sein.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-103">When serializing a user-defined type to a given wire format, or deserializing a wire format back into a user-defined type, the given user-defined type must be available on both the service and the client.</span></span> <span data-ttu-id="b1a3e-104">Hierzu wird normalerweise das <xref:System.Runtime.Serialization.DataContractAttribute> -Attribut auf diese benutzerdefinierten Typen angewendet, und das <xref:System.Runtime.Serialization.DataMemberAttribute> -Attribut wird auf ihre Member angewendet.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-104">Usually to accomplish this, the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to these user-defined types and the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute is applied to their members.</span></span> <span data-ttu-id="b1a3e-105">Dieser Mechanismus wird auch beim Arbeiten mit JavaScript Object Notation (JSON)-Objekten verwendet, wie im Thema [How to: Serialize and Deserialize JSON Data](../feature-details/how-to-serialize-and-deserialize-json-data.md)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-105">This mechanism also applies when working with JavaScript Object Notation (JSON) objects, as described in the topic [How to: Serialize and Deserialize JSON Data](../feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>  
  
 <span data-ttu-id="b1a3e-106">In einigen Szenarios muss ein Windows Communication Foundation (WCF)-Dienst oder-Client auf JSON-Objekte zugreifen, die von einem Dienst oder Client generiert werden, der sich außerhalb der Kontrolle des Entwicklers befindet.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-106">In some scenarios, a Windows Communication Foundation (WCF) service or client must access JSON objects generated by a service or client that is outside of the control of the developer.</span></span> <span data-ttu-id="b1a3e-107">Da mehr Webdienste JSON-APIs öffentlich verfügbar machen, kann es für den WCF-Entwickler unpraktisch werden, lokale benutzerdefinierte Typen zu erstellen, in die beliebige JSON-Objekte deserialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-107">As more Web services publicly expose JSON APIs, it can become impractical for the WCF developer to construct local user-defined types into which to deserialize arbitrary JSON objects.</span></span> <span data-ttu-id="b1a3e-108">Dieses Beispiel stellt einen Mechanismus bereit, mit dem WCF-Entwickler mit deserialisierten, beliebigen JSON-Objekten arbeiten können, ohne benutzerdefinierte Typen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-108">This sample provides a mechanism that enables WCF developers to work with deserialized, arbitrary JSON objects, without creating user-defined types.</span></span> <span data-ttu-id="b1a3e-109">Dies wird als *schwach typisierte Deserialisierung* von JSON-Objekten bezeichnet, da der Typ, in den ein JSON-Objekt deserialisiert wird, zum Zeitpunkt der Kompilierung nicht bekannt ist.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-109">This is known as *weakly-typed serialization* of JSON objects, because the type into which a JSON object deserializes is not known at compile time.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b1a3e-110">Die Setupprozedur und die Buildanweisungen für dieses Beispiel befinden sich am Ende dieses Themas.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-110">The setup procedure and build instructions for this sample are located at the end of this topic.</span></span>  
  
 <span data-ttu-id="b1a3e-111">Beispielsweise gibt eine öffentliche Webdienst-API das folgende JSON-Objekt zurück, das Informationen zu einem Benutzer des Diensts enthält.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-111">For example, a public Web service API returns the following JSON object, which describes some information about a user of the service.</span></span>  
  
```json  
{"personal": {"name": "Paul", "age": 23, "height": 1.7, "isSingle": true, "luckyNumbers": [5,17,21]}, "favoriteBands": ["Band ABC", "Band XYZ"]}  
```  
  
 <span data-ttu-id="b1a3e-112">Zum Deserialisieren dieses Objekts muss ein WCF-Client die folgenden benutzerdefinierten Typen implementieren.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-112">To deserialize this object, a WCF client must implement the following user-defined types.</span></span>  
  
```csharp  
[DataContract]  
 public class MemberProfile  
 {  
     [DataMember]  
     public PersonalInfo personal;  
  
     [DataMember]  
     public string[] favoriteBands;  
 }  
  
 [DataContract]  
 public class PersonalInfo  
 {  
     [DataMember]  
     public string name;  
  
     [DataMember]  
     public int age;  
  
     [DataMember]  
     public double height;  
  
     [DataMember]  
     public bool isSingle;  
  
     [DataMember]  
     public int[] luckyNumbers;  
 }  
```  
  
 <span data-ttu-id="b1a3e-113">Dies kann aufwändig sein, insbesondere, wenn der Client mehrere Typen von JSON-Objekten behandeln muss.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-113">This can be cumbersome, especially if the client has to handle more than one type of JSON object.</span></span>  
  
 <span data-ttu-id="b1a3e-114">Der in diesem Beispiel bereitgestellte `JsonObject` -Typ führt eine schwach typisierte Darstellung des deserialisierten JSON-Objekts ein.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-114">The `JsonObject` type provided by this sample introduces a weakly-typed representation of the deserialized JSON object.</span></span> <span data-ttu-id="b1a3e-115">`JsonObject` basiert auf der natürlichen Zuordnung zwischen JSON-Objekten und .NET Framework Wörterbüchern und der Zuordnung zwischen JSON-Arrays und .NET Framework Arrays.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-115">`JsonObject` relies on the natural mapping between JSON objects and .NET Framework dictionaries, and the mapping between JSON arrays and .NET Framework arrays.</span></span> <span data-ttu-id="b1a3e-116">Der folgende Code veranschaulicht den `JsonObject` -Typ:</span><span class="sxs-lookup"><span data-stu-id="b1a3e-116">The following code shows the `JsonObject` type.</span></span>  
  
```csharp  
// Instantiation of JsonObject json omitted  
  
string name = json["root"]["personal"]["name"];  
int age = json["root"]["personal"]["age"];  
double height = json["root"]["personal"]["height"];  
bool isSingle = json["root"]["personal"]["isSingle"];  
int[] luckyNumbers = {  
                                     json["root"]["personal"]["luckyNumbers"][0],  
                                     json["root"]["personal"]["luckyNumbers"][1],  
                                     json["root"]["personal"]["luckyNumbers"][2]
                                 };  
string[] favoriteBands = {  
                                        json["root"]["favoriteBands"][0],  
                                        json["root"]["favoriteBands"][1]  
                                    };  
```  
  
 <span data-ttu-id="b1a3e-117">Sie können JSON-Objekte und -Arrays "durchsuchen", ohne ihren Typ zum Zeitpunkt der Kompilierung deklarieren zu müssen.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-117">Note that you can "browse" JSON objects and arrays without the need to declare their type at compile time.</span></span> <span data-ttu-id="b1a3e-118">Eine Erläuterung der Anforderungen für das `["root"]` -Objekt der obersten Ebene finden Sie im Thema [Mapping Between JSON and XML](../feature-details/mapping-between-json-and-xml.md)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-118">For an explanation of the requirement for the top-level `["root"]` object, see the topic [Mapping Between JSON and XML](../feature-details/mapping-between-json-and-xml.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b1a3e-119">Die `JsonObject` -Klasse wird nur als Beispiel bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-119">The `JsonObject` class is provided as an example only.</span></span> <span data-ttu-id="b1a3e-120">Sie wurde nicht gründlich getestet und sollte nicht in Produktionsumgebungen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-120">It has not been thoroughly tested, and should not be used in production environments.</span></span> <span data-ttu-id="b1a3e-121">Eine offensichtliche Implikation der schwach typisierten JSON-Serialisierung ist der Mangel an Typsicherheit beim Arbeiten mit `JsonObject`.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-121">An obvious implication of weakly-typed JSON serialization is the lack of type-safety when working with `JsonObject`.</span></span>  
  
 <span data-ttu-id="b1a3e-122">Damit der `JsonObject` -Typ verwendet werden kann, muss der Clientvorgangsvertrag <xref:System.ServiceModel.Channels.Message> als Rückgabetyp verwenden.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-122">To use the `JsonObject` type, the client operation contract must use <xref:System.ServiceModel.Channels.Message> as its return type.</span></span>  
  
```csharp  
[ServiceContract]  
    interface IClientSideProfileService  
    {  
        // There is no need to write a DataContract for the complex type returned by the service.  
        // The client will use a JsonObject to browse the JSON in the received message.  
  
        [OperationContract]  
        [WebGet(ResponseFormat = WebMessageFormat.Json)]  
        Message GetMemberProfile();  
    }  
```  
  
 <span data-ttu-id="b1a3e-123">`JsonObject` wird dann instanziiert, wie im folgenden Code dargestellt.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-123">The `JsonObject` is then instantiated as shown in the following code.</span></span>  
  
```csharp  
// Code to instantiate IClientSideProfileService channel omitted…  
  
// Make a request to the service and obtain the Json response  
XmlDictionaryReader reader = channel.GetMemberProfile().GetReaderAtBodyContents();  
  
// Go through the Json as though it is a dictionary. There is no need to map it to a .NET CLR type.  
JsonObject json = new JsonObject(reader);  
```  
  
 <span data-ttu-id="b1a3e-124">Der `JsonObject` -Konstruktor nimmt einen <xref:System.Xml.XmlDictionaryReader>an, der durch die <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> -Methode abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-124">The `JsonObject` constructor takes a <xref:System.Xml.XmlDictionaryReader>, which is obtained through the <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> method.</span></span> <span data-ttu-id="b1a3e-125">Der Reader enthält eine XML-Darstellung der vom Client empfangenen JSON-Nachricht.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-125">The reader contains an XML representation of the JSON message received by the client.</span></span> <span data-ttu-id="b1a3e-126">Weitere Informationen finden Sie im Thema [Mapping zwischen JSON und XML](../feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="b1a3e-126">For more information, see the topic [Mapping Between JSON and XML](../feature-details/mapping-between-json-and-xml.md).</span></span>  
  
 <span data-ttu-id="b1a3e-127">Das Programm erzeugt die folgende Ausgabe:</span><span class="sxs-lookup"><span data-stu-id="b1a3e-127">The program produces the following output:</span></span>  
  
```console  
Service listening at http://localhost:8000/.  
To view the JSON output from the sample, navigate to http://localhost:8000/GetMemberProfile  
This is Paul's page. I am 23 years old and I am 1.7 meters tall.  
I am single.  
My lucky numbers are 5, 17, and 21.  
My favorite bands are Band ABC and Band XYZ.  
```  
  
### <a name="to-set-up-build-and-run-the-sample"></a><span data-ttu-id="b1a3e-128">So können Sie das Beispiel einrichten, erstellen und ausführen</span><span class="sxs-lookup"><span data-stu-id="b1a3e-128">To set up, build, and run the sample</span></span>  
  
1. <span data-ttu-id="b1a3e-129">Stellen Sie sicher, dass Sie das [einmalige Setup Verfahren für die Windows Communication Foundation Beispiele](one-time-setup-procedure-for-the-wcf-samples.md)ausgeführt haben.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-129">Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](one-time-setup-procedure-for-the-wcf-samples.md).</span></span>  
  
2. <span data-ttu-id="b1a3e-130">Erstellen Sie die Projektmappe "WeaklyTypedJson.sln", wie in [Building the Windows Communication Foundation Samples](building-the-samples.md)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-130">Build the solution WeaklyTypedJson.sln as described in [Building the Windows Communication Foundation Samples](building-the-samples.md).</span></span>  
  
3. <span data-ttu-id="b1a3e-131">Führen Sie die Lösung aus.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-131">Run the solution.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="b1a3e-132">Die Beispiele sind möglicherweise bereits auf dem Computer installiert.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-132">The samples may already be installed on your machine.</span></span> <span data-ttu-id="b1a3e-133">Suchen Sie nach dem folgenden Verzeichnis (Standardverzeichnis), bevor Sie fortfahren.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-133">Check for the following (default) directory before continuing.</span></span>  
>
> `<InstallDrive>:\WF_WCF_Samples`  
>
> <span data-ttu-id="b1a3e-134">Wenn dieses Verzeichnis nicht vorhanden ist, wechseln Sie zu [Windows Communication Foundation (WCF) und Windows Workflow Foundation (WF)-Beispiele für .NET Framework 4](https://www.microsoft.com/download/details.aspx?id=21459) , um alle Windows Communication Foundation (WCF) und Beispiele herunterzuladen [!INCLUDE[wf1](../../../../includes/wf1-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="b1a3e-134">If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://www.microsoft.com/download/details.aspx?id=21459) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples.</span></span> <span data-ttu-id="b1a3e-135">Dieses Beispiel befindet sich im folgenden Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="b1a3e-135">This sample is located in the following directory.</span></span>  
>
> `<InstallDrive>:\WF_WCF_Samples\WCF\Scenario\Ajax\WeaklyTypedJson`  
