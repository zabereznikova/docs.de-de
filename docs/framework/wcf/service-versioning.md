---
title: Dienstversionsverwaltung
ms.date: 03/30/2017
ms.assetid: 37575ead-d820-4a67-8059-da11a2ab48e2
ms.openlocfilehash: fae0a5eca5737c3d7885cbe6c678678adabbea01
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/26/2020
ms.locfileid: "96245344"
---
# <a name="service-versioning"></a><span data-ttu-id="872e1-102">Dienstversionsverwaltung</span><span class="sxs-lookup"><span data-stu-id="872e1-102">Service Versioning</span></span>

<span data-ttu-id="872e1-103">Nach der ursprünglichen Bereitstellung und möglicherweise mehreren Bereitstellungen während ihrer Lebensdauer müssen die Dienste (und die Endpunkte, die sie verfügbar machen) eventuell geändert werden. Dafür kann es verschiedene Gründe geben, z.&#160;B. veränderte Geschäftsanforderungen, Anforderungen an die Informationstechnologie oder andere Themen, die in die Dienste integriert werden müssen.</span><span class="sxs-lookup"><span data-stu-id="872e1-103">After initial deployment, and potentially several times during their lifetime, services (and the endpoints they expose) may need to be changed for a variety of reasons, such as changing business needs, information technology requirements, or to address other issues.</span></span> <span data-ttu-id="872e1-104">Jede Änderung führt zu einer neuen Version des Diensts.</span><span class="sxs-lookup"><span data-stu-id="872e1-104">Each change introduces a new version of the service.</span></span> <span data-ttu-id="872e1-105">In diesem Thema wird erläutert, wie Sie die Versionsverwaltung in Windows Communication Foundation (WCF) in Erwägung gezogen.</span><span class="sxs-lookup"><span data-stu-id="872e1-105">This topic explains how to consider versioning in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="four-categories-of-service-changes"></a><span data-ttu-id="872e1-106">Vier Kategorien von Dienständerungen</span><span class="sxs-lookup"><span data-stu-id="872e1-106">Four Categories of Service Changes</span></span>  

 <span data-ttu-id="872e1-107">Die Änderungen von Diensten, die eventuell erforderlich sind, können in vier Kategorien unterteilt werden:</span><span class="sxs-lookup"><span data-stu-id="872e1-107">The changes to services that may be required can be classified into four categories:</span></span>  
  
- <span data-ttu-id="872e1-108">Vertragsänderungen: Ein Vorgang wird z.&#160;B. hinzugefügt, oder ein Datenelement in einer Nachricht wird hinzugefügt oder geändert.</span><span class="sxs-lookup"><span data-stu-id="872e1-108">Contract changes: For example, an operation might be added, or a data element in a message might be added or changed.</span></span>  
  
- <span data-ttu-id="872e1-109">Adressänderungen: Ein Dienst wird z.&#160;B. an einen anderen Speicherort verschoben, an dem die Endpunkte neue Adressen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="872e1-109">Address changes: For example, a service moves to a different location where endpoints have new addresses.</span></span>  
  
- <span data-ttu-id="872e1-110">Bindungsänderungen: Ein Sicherheitsmechanismus oder seine Einstellungen werden z.&#160;B. geändert.</span><span class="sxs-lookup"><span data-stu-id="872e1-110">Binding changes: For example, a security mechanism changes or its settings change.</span></span>  
  
- <span data-ttu-id="872e1-111">Implementierungsänderungen: Wenn sich z.&#160;B. eine interne Methodenimplementierung ändert.</span><span class="sxs-lookup"><span data-stu-id="872e1-111">Implementation changes: For example, when an internal method implementation changes.</span></span>  
  
 <span data-ttu-id="872e1-112">Einige dieser Änderungen werden als "unterbrechend" und andere als "nicht unterbrechend" bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="872e1-112">Some of these changes are called "breaking" and others are "nonbreaking."</span></span> <span data-ttu-id="872e1-113">Eine Änderung ist *nicht unterbrechend* , wenn alle Nachrichten, die in der vorherigen Version erfolgreich verarbeitet worden wären, in der neuen Version erfolgreich verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="872e1-113">A change is *nonbreaking* if all messages that would have been processed successfully in the previous version are processed successfully in the new version.</span></span> <span data-ttu-id="872e1-114">Jede Änderung, die dieses Kriterium nicht erfüllt, ist *eine wichtige* Änderung.</span><span class="sxs-lookup"><span data-stu-id="872e1-114">Any change that does not meet that criterion is a *breaking* change.</span></span>  
  
## <a name="service-orientation-and-versioning"></a><span data-ttu-id="872e1-115">Dienstausrichtung und Versionsverwaltung</span><span class="sxs-lookup"><span data-stu-id="872e1-115">Service Orientation and Versioning</span></span>  

 <span data-ttu-id="872e1-116">Einer der Grundsätze der Dienstausrichtung ist, dass die Dienste und Clients autonom (oder unabhängig) sind.</span><span class="sxs-lookup"><span data-stu-id="872e1-116">One of the tenets of service orientation is that services and clients are autonomous (or independent).</span></span> <span data-ttu-id="872e1-117">Unter anderem impliziert dies, dass die Dienstentwickler nicht davon ausgehen können, dass sie alle Dienstclients steuern oder sogar kennen.</span><span class="sxs-lookup"><span data-stu-id="872e1-117">Among other things, this implies that service developers cannot assume that they control or even know about all service clients.</span></span> <span data-ttu-id="872e1-118">Dies beeinträchtigt die Möglichkeit, alle Clients neu zu erstellen und neu bereitzustellen, wenn die Version eines Diensts geändert wird.</span><span class="sxs-lookup"><span data-stu-id="872e1-118">This eliminates the option of rebuilding and redeploying all clients when a service changes versions.</span></span> <span data-ttu-id="872e1-119">In diesem Thema wird davon ausgegangen, dass der Dienst diesem Grundsatz folgt und daher unabhängig von den Clients geändert oder "versionsverwaltet" werden muss.</span><span class="sxs-lookup"><span data-stu-id="872e1-119">This topic assumes the service adheres to this tenet and therefore must be changed or "versioned" independent of its clients.</span></span>  
  
 <span data-ttu-id="872e1-120">In den Fällen, in denen keine unterbrechende Änderung erwartet wird und diese nicht verhindert werden kann, kann dieser Grundsatz von einer Anwendung ignoriert werden. Dadurch wird es dann erforderlich, dass die Clients neu erstellt und mit einer neueren Version des Diensts bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="872e1-120">In cases where a breaking change is unexpected and cannot be avoided, an application may choose to ignore this tenet and require that clients be rebuilt and redeployed with a new version of the service.</span></span>  
  
## <a name="contract-versioning"></a><span data-ttu-id="872e1-121">Vertragsversionsverwaltung</span><span class="sxs-lookup"><span data-stu-id="872e1-121">Contract Versioning</span></span>  

 <span data-ttu-id="872e1-122">Von einem Client verwendete Verträge müssen nicht dem Vertrag entsprechen, der vom Dienst verwendet wird. Sie müssen lediglich kompatibel sein.</span><span class="sxs-lookup"><span data-stu-id="872e1-122">Contracts used by a client do not need to be the same as the contract used by the service; they need only to be compatible.</span></span>  
  
 <span data-ttu-id="872e1-123">Für Dienstverträge bedeutet Kompatibilität, dass neue, vom Dienst verfügbar gemachte Vorgänge hinzugefügt, vorhandene Vorgänge jedoch nicht entfernt oder semantisch geändert werden können.</span><span class="sxs-lookup"><span data-stu-id="872e1-123">For service contracts, compatibility means new operations exposed by the service can be added but existing operations cannot be removed or changed semantically.</span></span>  
  
 <span data-ttu-id="872e1-124">Für Datenverträge bedeutet Kompatibilität, dass neue Schematypdefinitionen hinzugefügt, vorhandene Schematypdefinitionen jedoch nicht auf die unterbrechende Art geändert werden können.</span><span class="sxs-lookup"><span data-stu-id="872e1-124">For data contracts, compatibility means new schema type definitions can be added but existing schema type definitions cannot be changed in breaking ways.</span></span> <span data-ttu-id="872e1-125">Zu den unterbrechenden Änderungen können das Entfernen von Datenmembern oder das Ändern ihrer Datentypinkompatibilität gehören.</span><span class="sxs-lookup"><span data-stu-id="872e1-125">Breaking changes might include removing data members or changing their data type incompatibly.</span></span> <span data-ttu-id="872e1-126">Diese Funktion bietet dem Dienst einigen Spielraum zum Ändern seiner Vertragsversionen, ohne Clients zu unterbrechen.</span><span class="sxs-lookup"><span data-stu-id="872e1-126">This feature allows the service some latitude in changing the version of its contracts without breaking clients.</span></span> <span data-ttu-id="872e1-127">In den nächsten beiden Abschnitten werden nicht unterbrechende und wichtige Änderungen erläutert, die an WCF-Daten und-Dienstverträgen vorgenommen werden können.</span><span class="sxs-lookup"><span data-stu-id="872e1-127">The next two sections explain nonbreaking and breaking changes that can be made to WCF data and service contracts.</span></span>  
  
## <a name="data-contract-versioning"></a><span data-ttu-id="872e1-128">Datenvertragsversionsverwaltung</span><span class="sxs-lookup"><span data-stu-id="872e1-128">Data Contract Versioning</span></span>  

 <span data-ttu-id="872e1-129">In diesem Abschnitt wird die Datenversionsverwaltung für die <xref:System.Runtime.Serialization.DataContractSerializer>-Klasse und die <xref:System.Runtime.Serialization.DataContractAttribute>-Klasse beschrieben.</span><span class="sxs-lookup"><span data-stu-id="872e1-129">This section deals with data versioning when using the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.DataContractAttribute> classes.</span></span>  
  
### <a name="strict-versioning"></a><span data-ttu-id="872e1-130">Strenge Versionsverwaltung</span><span class="sxs-lookup"><span data-stu-id="872e1-130">Strict Versioning</span></span>  

 <span data-ttu-id="872e1-131">In vielen Szenarien, in denen das Ändern der Versionen ein Problem darstellt, hat der Dienstentwickler keine Kontrolle über die Clients und kann deshalb keine Annahmen darüber abgeben, wie sie auf Änderungen in der Nachrichten-XML oder im Schema reagieren würden.</span><span class="sxs-lookup"><span data-stu-id="872e1-131">In many scenarios when changing versions is an issue, the service developer does not have control over the clients and therefore cannot make assumptions about how they would react to changes in the message XML or schema.</span></span> <span data-ttu-id="872e1-132">In diesen Fällen müssen Sie sicherstellen, dass die neuen Nachrichten aus zwei Gründen anhand des alten Schemas überprüft werden:</span><span class="sxs-lookup"><span data-stu-id="872e1-132">In these cases, you must guarantee that the new messages will validate against the old schema, for two reasons:</span></span>  
  
- <span data-ttu-id="872e1-133">Die alten Clients wurden mit der Annahme entwickelt, dass sich das Schema nicht ändert.</span><span class="sxs-lookup"><span data-stu-id="872e1-133">The old clients were developed with the assumption that the schema will not change.</span></span> <span data-ttu-id="872e1-134">Sie können eventuell keine Nachrichten verarbeiten, für die sie nicht vorgesehen waren.</span><span class="sxs-lookup"><span data-stu-id="872e1-134">They may fail to process messages that they were never designed for.</span></span>  
  
- <span data-ttu-id="872e1-135">Die alten Clients können eventuell anhand des alten Schemas eine tatsächliche Schemavalidierung durchführen, bevor sie versuchen, die Nachrichten zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="872e1-135">The old clients may perform actual schema validation against the old schema before even attempting to process the messages.</span></span>  
  
 <span data-ttu-id="872e1-136">Die empfohlene Methode in solchen Szenarien besteht darin, vorhandene Datenverträge als unveränderlich zu behandeln und neue Verträge mit eindeutigen qualifizierten XML-Namen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="872e1-136">The recommended approach in such scenarios is to treat existing data contracts as immutable and create new ones with unique XML qualified names.</span></span> <span data-ttu-id="872e1-137">Der Dienstentwickler würde dann entweder einem bereits vorhandenen Dienstvertrag neue Methoden hinzufügen oder einen neuen Dienstvertrag mit Methoden erstellen, die den neuen Datenvertrag verwenden.</span><span class="sxs-lookup"><span data-stu-id="872e1-137">The service developer would then either add new methods to an existing service contract or create a new service contract with methods that use the new data contract.</span></span>  
  
 <span data-ttu-id="872e1-138">Es wird häufig der Fall sein, dass ein Dienstentwickler einen Teil der Geschäftslogik schreiben muss, der in allen Versionen eines Datenvertrags ausgeführt werden sollte, sowie zusätzlich versionsspezifischen Geschäftscode für jede Version des Datenvertrags.</span><span class="sxs-lookup"><span data-stu-id="872e1-138">It will often be the case that a service developer needs to write some business logic that should run within all versions of a data contract plus version-specific business code for each version of the data contract.</span></span> <span data-ttu-id="872e1-139">Im Anhang am Ende dieses Themas wird erläutert, wie die Schnittstellen verwendet werden können, um diese Anforderung zu erfüllen.</span><span class="sxs-lookup"><span data-stu-id="872e1-139">The appendix at the end of this topic explains how interfaces can be used to satisfy this need.</span></span>  
  
### <a name="lax-versioning"></a><span data-ttu-id="872e1-140">Weniger strenge Versionsverwaltung</span><span class="sxs-lookup"><span data-stu-id="872e1-140">Lax Versioning</span></span>  

 <span data-ttu-id="872e1-141">In vielen anderen Szenarien kann der Dienstentwickler davon ausgehen, dass das Hinzufügen eines neuen, optionalen Members zum Datenvertrag keine vorhandenen Clients unterbricht.</span><span class="sxs-lookup"><span data-stu-id="872e1-141">In many other scenarios, the service developer can make the assumption that adding a new, optional member to the data contract will not break existing clients.</span></span> <span data-ttu-id="872e1-142">Dazu muss der Dienstentwickler überprüfen, ob die vorhandenen Clients keine Schemavalidierung durchführen und dass sie unbekannte Datenmember ignorieren.</span><span class="sxs-lookup"><span data-stu-id="872e1-142">This requires the service developer to investigate whether existing clients are not performing schema validation and that they ignore unknown data members.</span></span> <span data-ttu-id="872e1-143">In diesen Szenarien ist es möglich, die Datenvertragsfunktionen zum Hinzufügen neuer Member auf eine nicht unterbrechende Weise zu nutzen.</span><span class="sxs-lookup"><span data-stu-id="872e1-143">In these scenarios, it is possible to take advantage of data contract features for adding new members in a nonbreaking way.</span></span> <span data-ttu-id="872e1-144">Der Dienstentwickler kann diese Annahme machen, wenn die Datenvertragsfunktionen für die Versionsverwaltung bereits für die erste Version des Diensts verwendet wurden.</span><span class="sxs-lookup"><span data-stu-id="872e1-144">The service developer can make this assumption with confidence if the data contract features for versioning were already used for the first version of the service.</span></span>  
  
 <span data-ttu-id="872e1-145">WCF, ASP.NET-Webdienste und viele andere Webdienst Stapel unterstützen die *Lax-Versions* Verwaltung, d. h., Sie lösen keine Ausnahmen für neue unbekannte Datenmember in empfangenen Daten aus.</span><span class="sxs-lookup"><span data-stu-id="872e1-145">WCF, ASP.NET Web Services, and many other Web service stacks support *lax versioning*: that is, they do not throw exceptions for new unknown data members in received data.</span></span>  
  
 <span data-ttu-id="872e1-146">Häufig wird fälschlicherweise angenommen, dass die vorhandenen Clients durch das Hinzufügen eines neuen Members nicht unterbrochen werden können.</span><span class="sxs-lookup"><span data-stu-id="872e1-146">It is easy to mistakenly believe that adding a new member will not break existing clients.</span></span> <span data-ttu-id="872e1-147">Falls Sie sich nicht sicher sind, ob alle Clients für die weniger strenge Versionsverwaltung ausgerichtet sind, wird empfohlen, die strengen Richtlinien zur Versionsverwaltung zu verwenden und die Datenverträge als unveränderlich zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="872e1-147">If you are unsure that all clients can handle lax versioning, the recommendation is to use the strict versioning guidelines and treat data contracts as immutable.</span></span>  
  
 <span data-ttu-id="872e1-148">Ausführliche Richtlinien für die Lax-und strikte Versionsverwaltung von Daten Verträgen finden Sie unter [bewährte Methoden: Versions](best-practices-data-contract-versioning.md)Verwaltung von Daten Verträgen.</span><span class="sxs-lookup"><span data-stu-id="872e1-148">For detailed guidelines for both lax and strict versioning of data contracts, see [Best Practices: Data Contract Versioning](best-practices-data-contract-versioning.md).</span></span>  
  
### <a name="distinguishing-between-data-contract-and-net-types"></a><span data-ttu-id="872e1-149">Unterscheidung zwischen Datenvertrags- und .NET-Typen</span><span class="sxs-lookup"><span data-stu-id="872e1-149">Distinguishing Between Data Contract and .NET Types</span></span>  

 <span data-ttu-id="872e1-150">Eine .NET-Klasse oder eine Struktur kann als Datenvertrag projiziert werden, indem Sie der Klasse das <xref:System.Runtime.Serialization.DataContractAttribute>-Attribut hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="872e1-150">A .NET class or structure can be projected as a data contract by applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class.</span></span> <span data-ttu-id="872e1-151">Der .NET-Typ und seine Datenvertragsprojektionen sind zwei verschiedene Dinge.</span><span class="sxs-lookup"><span data-stu-id="872e1-151">The .NET type and its data contract projections are two distinct matters.</span></span> <span data-ttu-id="872e1-152">Es können mehrere .NET-Typen mit derselben Datenvertragsprojektion vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="872e1-152">It is possible to have multiple .NET types with the same data contract projection.</span></span> <span data-ttu-id="872e1-153">Diese Unterscheidung ist besonders nützlich, wenn Sie den .NET-Typ ändern und gleichzeitig den projizierten Datenvertrag beibehalten möchten, wobei Sie gleichzeitig die Kompatibilität mit den bereits vorhandenen Clients bewahren.</span><span class="sxs-lookup"><span data-stu-id="872e1-153">This distinction is especially useful in allowing you to change the .NET type while maintaining the projected data contract, thereby maintaining compatibility with existing clients even in the strict sense of the word.</span></span> <span data-ttu-id="872e1-154">Sie sollten immer die folgenden beiden Maßnahmen ergreifen, um diese Unterscheidung zwischen .NET-Typ und Datenvertrag beizubehalten:</span><span class="sxs-lookup"><span data-stu-id="872e1-154">There are two things you should always do to maintain this distinction between .NET type and data contract:</span></span>  
  
- <span data-ttu-id="872e1-155">Geben Sie einen <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> und einen <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A> an.</span><span class="sxs-lookup"><span data-stu-id="872e1-155">Specify a <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> and <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span></span> <span data-ttu-id="872e1-156">Sie sollten immer den Namen und den Namespace Ihres Datenvertrags angeben, um zu verhindern, dass der Name und der Namespace Ihres .NET-Typs im Vertrag verfügbar gemacht wird.</span><span class="sxs-lookup"><span data-stu-id="872e1-156">You should always specify the name and namespace of your data contract to prevent your .NET type’s name and namespace from being exposed in the contract.</span></span> <span data-ttu-id="872e1-157">Auf diese Weise bleibt der Datenvertrag derselbe, wenn Sie den .NET-Namespace oder -Typnamen zu einem späteren Zeitpunkt ändern möchten.</span><span class="sxs-lookup"><span data-stu-id="872e1-157">This way, if you decide later to change the .NET namespace or type name, your data contract remains the same.</span></span>  
  
- <span data-ttu-id="872e1-158">Geben Sie <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>an.</span><span class="sxs-lookup"><span data-stu-id="872e1-158">Specify <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span></span> <span data-ttu-id="872e1-159">Sie sollten immer den Namen Ihrer Datenmember angeben, um zu verhindern, dass der Name des .NET-Members im Vertrag verfügbar gemacht wird.</span><span class="sxs-lookup"><span data-stu-id="872e1-159">You should always specify the name of your data members to prevent your .NET member name from being exposed in the contract.</span></span> <span data-ttu-id="872e1-160">Auf diese Weise bleibt der Datenvertrag derselbe, wenn Sie den .NET-Namen des Members zu einem späteren Zeitpunkt ändern möchten.</span><span class="sxs-lookup"><span data-stu-id="872e1-160">This way, if you decide later to change the .NET name of the member, your data contract remains the same.</span></span>  
  
### <a name="changing-or-removing-members"></a><span data-ttu-id="872e1-161">Ändern oder Entfernen von Membern</span><span class="sxs-lookup"><span data-stu-id="872e1-161">Changing or Removing Members</span></span>  

 <span data-ttu-id="872e1-162">Wenn Sie den Namen oder Datentyp eines Members ändern oder Datenmember entfernen, ist dies eine unterbrechende Änderung, auch wenn die weniger strenge Versionsverwaltung zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="872e1-162">Changing the name or data type of a member, or removing data members is a breaking change even if lax versioning is allowed.</span></span> <span data-ttu-id="872e1-163">Falls dies erforderlich ist, müssen Sie einen neuen Datenvertrag erstellen.</span><span class="sxs-lookup"><span data-stu-id="872e1-163">If this is necessary, create a new data contract.</span></span>  
  
 <span data-ttu-id="872e1-164">Falls die Dienstkompatibilität von hoher Wichtigkeit ist, sollten Sie die nicht verwendeten Datenmember in Ihrem Code ignorieren und sie unverändert lassen.</span><span class="sxs-lookup"><span data-stu-id="872e1-164">If service compatibility is of high importance, you might consider ignoring unused data members in your code and leave them in place.</span></span> <span data-ttu-id="872e1-165">Falls Sie einen Datenmember in mehrere Member aufteilen, sollten Sie erwägen, den vorhandenen Member als eine Eigenschaft unverändert zu lassen, mit der die erforderliche Aufteilung und erneute Aggregation für Clients auf niedrigeren Ebenen (Clients ohne Upgrade auf die neueste Version) durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="872e1-165">If you are splitting up a data member into multiple members, you might consider leaving the existing member in place as a property that can perform the required splitting and re-aggregation for down-level clients (clients that are not upgraded to the latest version).</span></span>  
  
 <span data-ttu-id="872e1-166">Ähnlich verhält es sich mit Änderungen des Namens oder Namespace eines Datenvertrags, bei denen es sich ebenfalls um unterbrechende Änderungen handelt.</span><span class="sxs-lookup"><span data-stu-id="872e1-166">Similarly, changes to the data contract’s name or namespace are breaking changes.</span></span>  
  
### <a name="round-trips-of-unknown-data"></a><span data-ttu-id="872e1-167">Round-Trips von unbekannten Daten</span><span class="sxs-lookup"><span data-stu-id="872e1-167">Round-Trips of Unknown Data</span></span>  

 <span data-ttu-id="872e1-168">In einigen Szenarien muss ein "Round-Trip" von unbekannten Daten stattfinden, die aus Membern stammen, die einer neuen Version hinzugefügt wurden.</span><span class="sxs-lookup"><span data-stu-id="872e1-168">In some scenarios, there is a need to "round-trip" unknown data that comes from members added in a new version.</span></span> <span data-ttu-id="872e1-169">So sendet z.&#160;B. ein "versionNew"-Dienst Daten mit einigen neu hinzugefügten Membern an einen "versionOld"-Client.</span><span class="sxs-lookup"><span data-stu-id="872e1-169">For example, a "versionNew" service sends data with some newly added members to a "versionOld" client.</span></span> <span data-ttu-id="872e1-170">Der Client ignoriert die neu hinzugefügten Member beim Verarbeiten der Nachricht, sendet dann jedoch diese Daten, einschließlich der neu hinzugefügten Member, erneut zurück an den versionNew-Dienst.</span><span class="sxs-lookup"><span data-stu-id="872e1-170">The client ignores the newly added members when processing the message, but it resends that same data, including the newly added members, back to the versionNew service.</span></span> <span data-ttu-id="872e1-171">Das typische Szenario dafür sind Datenupdates, bei denen Daten aus dem Dienst entfernt, geändert und zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="872e1-171">The typical scenario for this is data updates where data is retrieved from the service, changed, and returned.</span></span>  
  
 <span data-ttu-id="872e1-172">Um die Roundtrip-Funktion für einen bestimmten Typ zu aktivieren, muss der Typ die <xref:System.Runtime.Serialization.IExtensibleDataObject>-Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="872e1-172">To enable round-tripping for a particular type, the type must implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="872e1-173">Die Schnittstelle enthält die <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>-Eigenschaft, die den <xref:System.Runtime.Serialization.ExtensionDataObject>-Typ zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="872e1-173">The interface contains one property, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> that returns the <xref:System.Runtime.Serialization.ExtensionDataObject> type.</span></span> <span data-ttu-id="872e1-174">In der Eigenschaft werden alle Daten aus zukünftigen Versionen des Datenvertrags gespeichert, der in der aktuellen Version unbekannt ist.</span><span class="sxs-lookup"><span data-stu-id="872e1-174">The property is used to store any data from future versions of the data contract that is unknown to the current version.</span></span> <span data-ttu-id="872e1-175">Diese Daten sind für den Client nicht transparent. Wenn jedoch die Instanz serialisiert wird, wird der Inhalt der <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>-Eigenschaft mit den restlichen Daten der Datenvertragsmember geschrieben.</span><span class="sxs-lookup"><span data-stu-id="872e1-175">This data is opaque to the client, but when the instance is serialized, the content of the <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> property is written with the rest of the data contract members' data.</span></span>  
  
 <span data-ttu-id="872e1-176">Es wird empfohlen, dass alle Typen diese Schnittstelle implementieren, um neue und unbekannte zukünftige Member aufzunehmen.</span><span class="sxs-lookup"><span data-stu-id="872e1-176">It is recommended that all your types implement this interface to accommodate new and unknown future members.</span></span>  
  
### <a name="data-contract-libraries"></a><span data-ttu-id="872e1-177">Datenvertragsbibliotheken</span><span class="sxs-lookup"><span data-stu-id="872e1-177">Data Contract Libraries</span></span>  

 <span data-ttu-id="872e1-178">Es können Bibliotheken mit Datenverträgen vorhanden sein, für die ein Vertrag in einem zentralen Repository veröffentlicht wird. Die Dienst- und Typimplementierer implementieren Datenverträge aus diesem Repository und machen diese so verfügbar.</span><span class="sxs-lookup"><span data-stu-id="872e1-178">There may be libraries of data contracts where a contract is published to a central repository, and service and type implementers implement and expose data contracts from that repository.</span></span> <span data-ttu-id="872e1-179">In diesem Fall können Sie beim Veröffentlichen eines Datenvertrags im Repository nicht steuern, wer Typen erstellt, die ihn implementieren.</span><span class="sxs-lookup"><span data-stu-id="872e1-179">In that case, when you publish a data contract to the repository, you have no control over who creates types that implement it.</span></span> <span data-ttu-id="872e1-180">Sie können also den Vertrag nicht ändern, wenn er erst einmal veröffentlicht wurde, da er dadurch unveränderlich geworden ist.</span><span class="sxs-lookup"><span data-stu-id="872e1-180">Thus, you cannot modify the contract once it is published, rendering it effectively immutable.</span></span>  
  
### <a name="when-using-the-xmlserializer"></a><span data-ttu-id="872e1-181">Verwenden des XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="872e1-181">When Using the XmlSerializer</span></span>  

 <span data-ttu-id="872e1-182">Dieselben Versionsverwaltungsgrundlagen gelten, wenn Sie die <xref:System.Xml.Serialization.XmlSerializer>-Klasse verwenden.</span><span class="sxs-lookup"><span data-stu-id="872e1-182">The same versioning principles apply when using the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="872e1-183">Wenn die strenge Versionsverwaltung erforderlich ist, sollten Sie die Datenverträge als unveränderlich behandeln und neue Datenverträge mit eindeutigen, qualifizierten Namen für die neuen Versionen erstellen.</span><span class="sxs-lookup"><span data-stu-id="872e1-183">When strict versioning is required, treat data contracts as immutable and create new data contracts with unique, qualified names for the new versions.</span></span> <span data-ttu-id="872e1-184">Wenn Sie sicher sind, dass die weniger strenge Versionsverwaltung verwendet werden kann, können Sie neue serialisierbare Member in neuen Versionen hinzufügen, bereits vorhandene Member jedoch nicht ändern oder entfernen.</span><span class="sxs-lookup"><span data-stu-id="872e1-184">When you are sure that lax versioning can be used, you can add new serializable members in new versions but not change or remove existing members.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="872e1-185">Der <xref:System.Xml.Serialization.XmlSerializer> verwendet das <xref:System.Xml.Serialization.XmlAnyElementAttribute>-Attribut und das <xref:System.Xml.Serialization.XmlAnyAttributeAttribute>-Attribut, um Round-Trips von unbekannten Daten zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="872e1-185">The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data.</span></span>  
  
## <a name="message-contract-versioning"></a><span data-ttu-id="872e1-186">Versionsverwaltung für Nachrichtenverträge</span><span class="sxs-lookup"><span data-stu-id="872e1-186">Message Contract Versioning</span></span>  

 <span data-ttu-id="872e1-187">Die Richtlinien für die Versionsverwaltung von Nachrichtenverträgen sind ähnlich wie diejenigen für die Versionsverwaltung von Datenverträgen.</span><span class="sxs-lookup"><span data-stu-id="872e1-187">The guidelines for message contract versioning are very similar to versioning data contracts.</span></span> <span data-ttu-id="872e1-188">Falls eine strenge Versionsverwaltung erforderlich ist, sollten Sie den Nachrichtentext nicht ändern, sondern stattdessen einen neuen Nachrichtenvertrag mit einem eindeutig qualifizierten Namen erstellen.</span><span class="sxs-lookup"><span data-stu-id="872e1-188">If strict versioning is required, you should not change your message body but instead create a new message contract with a unique qualified name.</span></span> <span data-ttu-id="872e1-189">Wenn Sie sicher sind, dass Sie die weniger strenge Versionsverwaltung verwenden können, können Sie neue Teile des Nachrichtentexts hinzufügen, die bereits vorhandenen jedoch nicht ändern oder entfernen.</span><span class="sxs-lookup"><span data-stu-id="872e1-189">If you know that you can use lax versioning, you can add new message body parts but not change or remove existing ones.</span></span> <span data-ttu-id="872e1-190">Diese Richtlinie gilt sowohl für reine als auch für eingeschlossene Nachrichtenverträge.</span><span class="sxs-lookup"><span data-stu-id="872e1-190">This guidance applies both to bare and wrapped message contracts.</span></span>  
  
 <span data-ttu-id="872e1-191">Nachrichtenheader können immer hinzugefügt werden, auch wenn die strenge Versionsverwaltung verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="872e1-191">Message headers can always be added, even if strict versioning is in use.</span></span> <span data-ttu-id="872e1-192">Das MustUnderstand-Flag kann sich auf die Versionsverwaltung auswirken.</span><span class="sxs-lookup"><span data-stu-id="872e1-192">The MustUnderstand flag may affect versioning.</span></span> <span data-ttu-id="872e1-193">Im Allgemeinen ist das Versions Verwaltungsmodell für Header in WCF wie in der SOAP-Spezifikation beschrieben.</span><span class="sxs-lookup"><span data-stu-id="872e1-193">In general, the versioning model for headers in WCF is as described in the SOAP specification.</span></span>  
  
## <a name="service-contract-versioning"></a><span data-ttu-id="872e1-194">Versionsverwaltung für Dienstverträge</span><span class="sxs-lookup"><span data-stu-id="872e1-194">Service Contract Versioning</span></span>  

 <span data-ttu-id="872e1-195">Ähnlich wie bei der Versionsverwaltung für Datenverträge umfasst die Versionsverwaltung für Dienstverträge auch das Hinzufügen, Ändern und Entfernen von Vorgängen.</span><span class="sxs-lookup"><span data-stu-id="872e1-195">Similar to data contract versioning, service contract versioning also involves adding, changing, and removing operations.</span></span>  
  
### <a name="specifying-name-namespace-and-action"></a><span data-ttu-id="872e1-196">Angeben von Name, Namespace und Aktion</span><span class="sxs-lookup"><span data-stu-id="872e1-196">Specifying Name, Namespace, and Action</span></span>  

 <span data-ttu-id="872e1-197">Standardmäßig entspricht der Name eines Dienstvertrags dem Namen der Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="872e1-197">By default, the name of a service contract is the name of the interface.</span></span> <span data-ttu-id="872e1-198">Der Standard Namespace ist " http://tempuri.org ", und jede Aktion ist " http://tempuri.org/contractname/methodname ".</span><span class="sxs-lookup"><span data-stu-id="872e1-198">Its default namespace is "http://tempuri.org", and each operation’s action is "http://tempuri.org/contractname/methodname".</span></span> <span data-ttu-id="872e1-199">Es wird empfohlen, explizit einen Namen und einen Namespace für den Dienstvertrag anzugeben, und eine Aktion für jeden Vorgang, um zu vermeiden, dass " http://tempuri.org " verwendet wird, und um zu verhindern, dass Schnittstellen-und Methodennamen im Dienstvertrag verfügbar gemacht werden.</span><span class="sxs-lookup"><span data-stu-id="872e1-199">It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using "http://tempuri.org" and to prevent interface and method names from being exposed in the service’s contract.</span></span>  
  
### <a name="adding-parameters-and-operations"></a><span data-ttu-id="872e1-200">Hinzufügen von Parametern und Vorgängen</span><span class="sxs-lookup"><span data-stu-id="872e1-200">Adding Parameters and Operations</span></span>  

 <span data-ttu-id="872e1-201">Beim Hinzufügen von Vorgängen, die vom Dienst verfügbar gemacht werden, handelt es sich um eine nicht unterbrechende Änderung, da die vorhandenen Clients diese neuen Vorgänge nicht berücksichtigen müssen.</span><span class="sxs-lookup"><span data-stu-id="872e1-201">Adding service operations exposed by the service is a nonbreaking change because existing clients need not be concerned about those new operations.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="872e1-202">Beim Hinzufügen von Vorgängen zu einem Duplexrückrufvertrag handelt es sich um eine unterbrechende Änderung.</span><span class="sxs-lookup"><span data-stu-id="872e1-202">Adding operations to a duplex callback contract is a breaking change.</span></span>  
  
### <a name="changing-operation-parameter-or-return-types"></a><span data-ttu-id="872e1-203">Ändern von Vorgangsparametern oder Rückgabetypen</span><span class="sxs-lookup"><span data-stu-id="872e1-203">Changing Operation Parameter or Return Types</span></span>  

 <span data-ttu-id="872e1-204">Beim Ändern von Parametern oder Rückgabetypen handelt es sich im Allgemeinen um eine unterbrechende Änderung, solange der neue Typ denselben Datenvertrag implementiert wie dies beim alten Typ der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="872e1-204">Changing parameter or return types generally is a breaking change unless the new type implements the same data contract implemented by the old type.</span></span> <span data-ttu-id="872e1-205">Um eine solche Änderung durchzuführen, fügen Sie dem Dienstvertrag einen neuen Vorgang hinzu oder definieren einen neuen Dienstvertrag.</span><span class="sxs-lookup"><span data-stu-id="872e1-205">To make such a change, add a new operation to the service contract or define a new service contract.</span></span>  
  
### <a name="removing-operations"></a><span data-ttu-id="872e1-206">Entfernen von Vorgängen</span><span class="sxs-lookup"><span data-stu-id="872e1-206">Removing Operations</span></span>  

 <span data-ttu-id="872e1-207">Beim Entfernen von Vorgängen handelt es sich ebenfalls um eine unterbrechende Änderung.</span><span class="sxs-lookup"><span data-stu-id="872e1-207">Removing operations is also a breaking change.</span></span> <span data-ttu-id="872e1-208">Um eine solche Änderung durchzuführen, definieren Sie einen neuen Dienstvertrag und machen ihn einem neuen Endpunkt verfügbar.</span><span class="sxs-lookup"><span data-stu-id="872e1-208">To make such a change, define a new service contract and expose it on a new endpoint.</span></span>  
  
### <a name="fault-contracts"></a><span data-ttu-id="872e1-209">Fehlerverträge</span><span class="sxs-lookup"><span data-stu-id="872e1-209">Fault Contracts</span></span>  

 <span data-ttu-id="872e1-210">Mit dem <xref:System.ServiceModel.FaultContractAttribute>-Attribut kann ein Dienstvertragentwickler Informationen über Fehler angeben, die von den Vertragsvorgängen zurückgegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="872e1-210">The <xref:System.ServiceModel.FaultContractAttribute> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations.</span></span>  
  
 <span data-ttu-id="872e1-211">Die Liste der in einem Dienstvertrag beschriebenen Fehler wird nicht als vollständig betrachtet.</span><span class="sxs-lookup"><span data-stu-id="872e1-211">The list of faults described in a service's contract is not considered exhaustive.</span></span> <span data-ttu-id="872e1-212">Ein Vorgang kann jederzeit Fehler zurückgeben, die in seinem Vertrag nicht beschrieben sind.</span><span class="sxs-lookup"><span data-stu-id="872e1-212">At any time, an operation may return faults that are not described in its contract.</span></span> <span data-ttu-id="872e1-213">Deshalb werden Änderungen der im Vertrag beschriebenen Fehler nicht als unterbrechend betrachtet.</span><span class="sxs-lookup"><span data-stu-id="872e1-213">Therefore changing the set of faults described in the contract is not considered breaking.</span></span> <span data-ttu-id="872e1-214">Beispielsweise das Hinzufügen eines neuen Fehlers zum Vertrag mithilfe von <xref:System.ServiceModel.FaultContractAttribute> oder das Entfernen eines vorhandenen Fehlers aus dem Vertrag.</span><span class="sxs-lookup"><span data-stu-id="872e1-214">For example, adding a new fault to the contract using the <xref:System.ServiceModel.FaultContractAttribute> or removing an existing fault from the contract.</span></span>  
  
### <a name="service-contract-libraries"></a><span data-ttu-id="872e1-215">Dienstvertragsbibliotheken</span><span class="sxs-lookup"><span data-stu-id="872e1-215">Service Contract Libraries</span></span>  

 <span data-ttu-id="872e1-216">In Organisationen können Bibliotheken mit Verträgen vorhanden sein. Dabei wird ein Vertrag in einem zentralen Repository veröffentlicht, und die Dienstimplementierer implementieren Datenverträge aus diesem Repository.</span><span class="sxs-lookup"><span data-stu-id="872e1-216">Organizations may have libraries of contracts where a contract is published to a central repository and service implementers implement contracts from that repository.</span></span> <span data-ttu-id="872e1-217">In diesem Fall können Sie beim Veröffentlichen eines Dienstvertrags im Repository nicht steuern, wer Dienste erstellt, die ihn implementieren.</span><span class="sxs-lookup"><span data-stu-id="872e1-217">In this case, when you publish a service contract to the repository you have no control over who creates services that implement it.</span></span> <span data-ttu-id="872e1-218">Sie können daher den Dienstvertrag nicht ändern, nachdem er veröffentlicht wurde, da er dadurch unveränderlich wird.</span><span class="sxs-lookup"><span data-stu-id="872e1-218">Therefore, you cannot modify the service contract once published, rendering it effectively immutable.</span></span> <span data-ttu-id="872e1-219">WCF unterstützt die Vertrags Vererbung, die verwendet werden kann, um einen neuen Vertrag zu erstellen, der vorhandene Verträge erweitert.</span><span class="sxs-lookup"><span data-stu-id="872e1-219">WCF supports contract inheritance, which can be used to create a new contract that extends existing contracts.</span></span> <span data-ttu-id="872e1-220">Wenn Sie diese Funktion verwenden möchten, müssen Sie eine neue Dienstvertragsschnittstelle definieren, die von der alten Dienstvertragsschnittstelle erbt, und dann der neuen Schnittstelle Methoden hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="872e1-220">To use this feature, define a new service contract interface that inherits from the old service contract interface, then add methods to the new interface.</span></span> <span data-ttu-id="872e1-221">Anschließend ändern Sie den Dienst, der den alten Vertrag implementiert, um den neuen Vertrag zu implementieren, und ändern die "versionOld"-Endpunktdefinition für die Verwendung des neuen Vertrags.</span><span class="sxs-lookup"><span data-stu-id="872e1-221">You then change the service that implements the old contract to implement the new contract and change the "versionOld" endpoint definition to use the new contract.</span></span> <span data-ttu-id="872e1-222">Für "versionOld"-Clients erscheint der Endpunkt weiterhin als "versionOld"-Vertrag; für "versionNew"-Clients erscheint der Endpunkt als "versionNew"-Vertrag.</span><span class="sxs-lookup"><span data-stu-id="872e1-222">To "versionOld" clients, the endpoint will continue to appear as exposing the "versionOld" contract; to "versionNew" clients, the endpoint will appear to expose the "versionNew" contract.</span></span>  
  
## <a name="address-and-binding-versioning"></a><span data-ttu-id="872e1-223">Versionsverwaltung von Adressen und Bindungen</span><span class="sxs-lookup"><span data-stu-id="872e1-223">Address and Binding Versioning</span></span>  

 <span data-ttu-id="872e1-224">Bei Änderungen an der Endpunktadresse und -bindung handelt es sich um unterbrechende Änderungen, solange die Clients die neue Endpunktadresse oder -bindung nicht dynamisch erkennen können.</span><span class="sxs-lookup"><span data-stu-id="872e1-224">Changes to endpoint address and binding are breaking changes unless clients are capable of dynamically discovering the new endpoint address or binding.</span></span> <span data-ttu-id="872e1-225">Ein Mechanismus zur Implementierung dieser Funktion ist die Verwendung einer UDDI-Registrierung sowie des UDDI-Aufrufmusters, bei der ein Client versucht, mit einem Endpunkt zu kommunizieren und im Falle eines Scheiterns eine bekannte UDDI-Registrierung für die aktuellen Endpunktdaten abfragt.</span><span class="sxs-lookup"><span data-stu-id="872e1-225">One mechanism for implementing this capability is by using a Universal Discovery Description and Integration (UDDI) registry and the UDDI Invocation Pattern where a client attempts to communicate with an endpoint and, upon failure, queries a well-known UDDI registry for the current endpoint metadata.</span></span> <span data-ttu-id="872e1-226">Der Client verwendet dann die Adresse und die Bindung aus diesen Metadaten, um mit dem Endpunkt zu kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="872e1-226">The client then uses the address and binding from this metadata to communicate with the endpoint.</span></span> <span data-ttu-id="872e1-227">Wenn diese Kommunikation erfolgreich ist, speichert der Client die Adress- und Bindungsinformationen für eine spätere Verwendung zwischen.</span><span class="sxs-lookup"><span data-stu-id="872e1-227">If this communication succeeds, the client caches the address and binding information for future use.</span></span>  
  
## <a name="routing-service-and-versioning"></a><span data-ttu-id="872e1-228">Routingdienst und Versionsverwaltung</span><span class="sxs-lookup"><span data-stu-id="872e1-228">Routing Service and Versioning</span></span>  

 <span data-ttu-id="872e1-229">Wenn es sich bei an einem Dienst vorgenommenen Änderungen um unterbrechende Änderungen handelt und Sie zwei oder mehr verschiedene Versionen eines Diensts gleichzeitig ausführen müssen, können Sie mit dem WCF-Routingdienst Meldungen an die entsprechende Dienstinstanz weiterleiten.</span><span class="sxs-lookup"><span data-stu-id="872e1-229">If the changes made to a service are breaking changes and you need to have two or more different versions of a service running simultaneously you can use the WCF Routing Service to route messages to the appropriate service instance.</span></span> <span data-ttu-id="872e1-230">Der WCF-Routingdienst führt inhaltsbasiertes Routing aus. Mit anderen Worten: Anhand von Informationen innerhalb der Nachricht wird bestimmt, an welches Ziel die Nachricht weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="872e1-230">The WCF Routing Service uses content-based routing, in other words, it uses information within the message to determine where to route the message.</span></span> <span data-ttu-id="872e1-231">Weitere Informationen zum WCF-Routing Dienst finden Sie unter [Routing Dienst](./feature-details/routing-service.md).</span><span class="sxs-lookup"><span data-stu-id="872e1-231">For more information about the WCF Routing Service see [Routing Service](./feature-details/routing-service.md).</span></span> <span data-ttu-id="872e1-232">Ein Beispiel für die Verwendung des WCF-Routing diensdienstanbieter für die Dienst Versionsverwaltung finden Sie unter Gewusst [wie: Dienst Versionsverwaltung](./feature-details/how-to-service-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="872e1-232">For an example of how to use the WCF Routing Service for service versioning see [How To: Service Versioning](./feature-details/how-to-service-versioning.md).</span></span>  
  
## <a name="appendix"></a><span data-ttu-id="872e1-233">Anhang</span><span class="sxs-lookup"><span data-stu-id="872e1-233">Appendix</span></span>  

 <span data-ttu-id="872e1-234">Die allgemeine Richtlinie für die Datenvertrags-Versionsverwaltung im Falle der strengen Versionsverwaltung besagt, dass Datenverträge als unveränderlich behandelt werden und neue Verträge erstellt werden, wenn Änderungen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="872e1-234">The general data contract versioning guidance when strict versioning is needed is to treat data contracts as immutable and create new ones when changes are required.</span></span> <span data-ttu-id="872e1-235">Für jeden neuen Datenvertrag muss eine neue Klasse erstellt werden. Deshalb ist ein Mechanismus erforderlich, mit dem vermieden wird, dass bereits vorhandener Code, der für die alte Datenvertragsklasse geschrieben wurde, für die neue Datenvertragsklasse neu geschrieben werden muss.</span><span class="sxs-lookup"><span data-stu-id="872e1-235">A new class needs to be created for each new data contract, so a mechanism is needed to avoid having to take existing code that was written in terms of the old data contract class and rewrite it in terms of the new data contract class.</span></span>  
  
 <span data-ttu-id="872e1-236">Ein solcher Mechanismus besteht z.&#160;B. in der Verwendung der Schnittstellen für die Definition der Member eines Datenvertrags und im Schreiben eines internen Implementierungscodes für die Schnittstellen anstatt der Datenvertragsklassen, mit denen die Schnittstellen implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="872e1-236">One such mechanism is to use interfaces to define the members of each data contract and write internal implementation code in terms of the interfaces rather than the data contract classes that implement the interfaces.</span></span> <span data-ttu-id="872e1-237">Im folgenden Code für Version 1 eines Diensts werden eine `IPurchaseOrderV1`-Schnittstelle und eine `PurchaseOrderV1`-Schnittstelle dargestellt:</span><span class="sxs-lookup"><span data-stu-id="872e1-237">The following code for version 1 of a service shows an `IPurchaseOrderV1` interface and a `PurchaseOrderV1`:</span></span>  
  
```csharp  
public interface IPurchaseOrderV1  
{  
    string OrderId { get; set; }  
    string CustomerId { get; set; }  
}  
  
[DataContract(  
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2005/10/PurchaseOrder")]  
public class PurchaseOrderV1 : IPurchaseOrderV1  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
}  
```  
  
 <span data-ttu-id="872e1-238">Während die Vorgänge des Dienstvertrags im Sinne von `PurchaseOrderV1` geschrieben werden würden, würde die tatsächliche Geschäftslogik `IPurchaseOrderV1` entsprechen.</span><span class="sxs-lookup"><span data-stu-id="872e1-238">While the service contract’s operations would be written in terms of `PurchaseOrderV1`, the actual business logic would be in terms of `IPurchaseOrderV1`.</span></span> <span data-ttu-id="872e1-239">In Version 2 würde es dann eine neue `IPurchaseOrderV2`-Schnittstelle und eine neue `PurchaseOrderV2`-Klasse geben, wie im folgenden Code dargestellt:</span><span class="sxs-lookup"><span data-stu-id="872e1-239">Then, in version 2, there would be a new `IPurchaseOrderV2` interface and a new `PurchaseOrderV2` class as shown in the following code:</span></span>  
  
```csharp
public interface IPurchaseOrderV2  
{  
    DateTime OrderDate { get; set; }  
}

[DataContract(
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2006/02/PurchaseOrder")]  
public class PurchaseOrderV2 : IPurchaseOrderV1, IPurchaseOrderV2  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
    [DataMember(...)]  
    public DateTime OrderDate { ... }  
}  
```  
  
 <span data-ttu-id="872e1-240">Der Dienstvertrag würde aktualisiert werden, um neue Vorgänge für `PurchaseOrderV2` zu berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="872e1-240">The service contract would be updated to include new operations that are written in terms of `PurchaseOrderV2`.</span></span> <span data-ttu-id="872e1-241">Die vorhandene Geschäftslogik für `IPurchaseOrderV1` würde weiterhin für `PurchaseOrderV2` funktionieren. Es würde eine neue Geschäftslogik für `OrderDate` geschrieben, die die `IPurchaseOrderV2`-Eigenschaft benötigt.</span><span class="sxs-lookup"><span data-stu-id="872e1-241">Existing business logic written in terms of `IPurchaseOrderV1` would continue to work for `PurchaseOrderV2` and new business logic that needs the `OrderDate` property would be written in terms of `IPurchaseOrderV2`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="872e1-242">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="872e1-242">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.DataContractAttribute>
- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>
- <xref:System.Runtime.Serialization.IExtensibleDataObject>
- <xref:System.Runtime.Serialization.ExtensionDataObject>
- <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="872e1-243">Datenvertragsäquivalenz</span><span class="sxs-lookup"><span data-stu-id="872e1-243">Data Contract Equivalence</span></span>](./feature-details/data-contract-equivalence.md)
- [<span data-ttu-id="872e1-244">Versionstolerante Serialisierungsrückrufe</span><span class="sxs-lookup"><span data-stu-id="872e1-244">Version-Tolerant Serialization Callbacks</span></span>](./feature-details/version-tolerant-serialization-callbacks.md)
