---
title: ReleaseHandleFailed-MDA
description: Überprüfen Sie den ReleaseHandleFailed-MDA (Managed Debugging Assistant), der aufgrund von Ressourcen-oder Speicher Verlusten in .NET aktiviert werden kann.
ms.date: 03/30/2017
helpviewer_keywords:
- managed debugging assistants (MDAs), handles
- release handle failed
- CriticalHandle class, run-time errors
- releaseHandleFailed MDA
- ReleaseHandle method
- SafeHandle class, run-time errors
- MDAs (managed debugging assistants), handles
ms.assetid: 44cd98ba-95e5-40a1-874d-e8e163612c51
ms.openlocfilehash: b337a7283e961d0fae2b51d92a21fa77f7249250
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/26/2020
ms.locfileid: "96267129"
---
# <a name="releasehandlefailed-mda"></a><span data-ttu-id="30cb1-103">ReleaseHandleFailed-MDA</span><span class="sxs-lookup"><span data-stu-id="30cb1-103">releaseHandleFailed MDA</span></span>

<span data-ttu-id="30cb1-104">Der `releaseHandleFailed`-MDA (Managed Debugging Assistant, Assistent für verwaltetes Debuggen) wird aktiviert, um einen Entwickler zu benachrichtigen, wenn die <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>-Methode einer Klasse, die aus <xref:System.Runtime.InteropServices.SafeHandle> oder <xref:System.Runtime.InteropServices.CriticalHandle> abgeleitet wurde, `false` zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="30cb1-104">The `releaseHandleFailed` managed debugging assistant (MDA) is activated is to notify developers when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of a class derived from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> returns `false`.</span></span>  
  
## <a name="symptoms"></a><span data-ttu-id="30cb1-105">Symptome</span><span class="sxs-lookup"><span data-stu-id="30cb1-105">Symptoms</span></span>  

 <span data-ttu-id="30cb1-106">Ressourcen- oder Arbeitsspeicherverluste.</span><span class="sxs-lookup"><span data-stu-id="30cb1-106">Resource or memory leaks.</span></span>  <span data-ttu-id="30cb1-107">Wenn die <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>-Methode der aus <xref:System.Runtime.InteropServices.SafeHandle> oder <xref:System.Runtime.InteropServices.CriticalHandle> abgeleiteten Klasse fehlschlägt, wurde die durch die Klasse gekapselte Ressource möglicherweise nicht freigegeben oder bereinigt.</span><span class="sxs-lookup"><span data-stu-id="30cb1-107">If the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of the class deriving from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> fails, then the resource encapsulated by the class might not have been released or cleaned up.</span></span>  
  
## <a name="cause"></a><span data-ttu-id="30cb1-108">Ursache</span><span class="sxs-lookup"><span data-stu-id="30cb1-108">Cause</span></span>  

 <span data-ttu-id="30cb1-109">Benutzer müssen die Implementierung der <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>-Methode bereitstellen, wenn sie Klassen erstellen, die aus <xref:System.Runtime.InteropServices.SafeHandle> oder <xref:System.Runtime.InteropServices.CriticalHandle> abgeleitet sind. Daher hängen die Umstände von der jeweiligen Ressource ab.</span><span class="sxs-lookup"><span data-stu-id="30cb1-109">Users must provide the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method if they create classes that derive from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle>; thus, the circumstances are specific to the individual resource.</span></span> <span data-ttu-id="30cb1-110">Die Anforderungen sehen jedoch wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="30cb1-110">However, the requirements are as follows:</span></span>  
  
- <span data-ttu-id="30cb1-111"><xref:System.Runtime.InteropServices.SafeHandle>- und <xref:System.Runtime.InteropServices.CriticalHandle>-Typen sind Wrapper für entscheidende Prozessressourcen.</span><span class="sxs-lookup"><span data-stu-id="30cb1-111"><xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> types represent wrappers around vital process resources.</span></span> <span data-ttu-id="30cb1-112">Ein Arbeitsspeicherverlust würde den Prozess im Lauf der Zeit unbrauchbar machen.</span><span class="sxs-lookup"><span data-stu-id="30cb1-112">A memory leak would make the process unusable over time.</span></span>  
  
- <span data-ttu-id="30cb1-113">Die <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>-Methode darf beim Ausführen ihrer Funktion nicht fehlschlagen.</span><span class="sxs-lookup"><span data-stu-id="30cb1-113">The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method must not fail to perform its function.</span></span> <span data-ttu-id="30cb1-114">Sobald ein Prozess eine solche Ressource abgerufen hat, ist <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> die einzige Möglichkeit, diese freizugeben.</span><span class="sxs-lookup"><span data-stu-id="30cb1-114">Once the process acquires such a resource, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is the only way to release it.</span></span> <span data-ttu-id="30cb1-115">Ein Fehlschlagen bedeutet deshalb Ressourcenverluste.</span><span class="sxs-lookup"><span data-stu-id="30cb1-115">Therefore, failure implies resource leaks.</span></span>  
  
- <span data-ttu-id="30cb1-116">Jeder Fehler, der während der Ausführung von <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> auftritt und die Freigabe der Ressource verhindert, ist ein Fehler in der Implementierung der <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="30cb1-116">Any failure that does occur during the execution of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, impeding the release of the resource, is a bug in the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method itself.</span></span> <span data-ttu-id="30cb1-117">Es liegt in der Verantwortung des Programmierers, die Erfüllung des Vertrags sicherzustellen, selbst wenn im Code anderer Code aufgerufen wird, für den eine andere Person die Autorisierung erteilt hat, dessen Funktion auszuführen.</span><span class="sxs-lookup"><span data-stu-id="30cb1-117">It is the responsibility of the programmer to ensure that the contract is fulfilled, even if that code calls code authored by someone else to perform its function.</span></span>  
  
## <a name="resolution"></a><span data-ttu-id="30cb1-118">Lösung</span><span class="sxs-lookup"><span data-stu-id="30cb1-118">Resolution</span></span>  

 <span data-ttu-id="30cb1-119">Überprüfen Sie den Code, in dem der spezielle <xref:System.Runtime.InteropServices.SafeHandle>-Typ (oder <xref:System.Runtime.InteropServices.CriticalHandle>-Typ) verwendet wird, der die MDA-Benachrichtigung ausgelöst hat. Suchen Sie nach Stellen, an denen der unformatierte Handlewert aus dem <xref:System.Runtime.InteropServices.SafeHandle>-Objekt extrahiert und an eine andere Stelle Ort kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="30cb1-119">The code that uses the specific <xref:System.Runtime.InteropServices.SafeHandle> (or <xref:System.Runtime.InteropServices.CriticalHandle>) type that raised the MDA notification should be reviewed, looking for places where the raw handle value is extracted from the <xref:System.Runtime.InteropServices.SafeHandle> and copied elsewhere.</span></span> <span data-ttu-id="30cb1-120">Hier liegt meist der Grund für Fehler in <xref:System.Runtime.InteropServices.SafeHandle>- oder <xref:System.Runtime.InteropServices.CriticalHandle>-Implementierungen, denn die Verwendung des unformatierten Handlewerts wird dann nicht mehr von der Laufzeitumgebung verfolgt.</span><span class="sxs-lookup"><span data-stu-id="30cb1-120">This is the usual cause of failures within <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> implementations, because the usage of the raw handle value is then no longer tracked by the runtime.</span></span> <span data-ttu-id="30cb1-121">Wenn die Kopie des unformatierten Handles anschließend geschlossen wird, kann dies dazu führen, dass ein späterer <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>-Aufruf fehlschlägt, weil versucht wird, dasselbe Handle zu schließen, das jetzt ungültig ist.</span><span class="sxs-lookup"><span data-stu-id="30cb1-121">If the raw handle copy is subsequently closed, it can cause a later <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> call to fail because the close is attempted on the same handle, which is now invalid.</span></span>  
  
 <span data-ttu-id="30cb1-122">Es gibt eine Reihe von Möglichkeiten, die in denen eine fehlerhafte Handleduplizierung auftreten kann:</span><span class="sxs-lookup"><span data-stu-id="30cb1-122">There are a number of ways in which incorrect handle duplication can occur:</span></span>  
  
- <span data-ttu-id="30cb1-123">Suchen Sie nach Aufrufen der <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="30cb1-123">Look for calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.</span></span> <span data-ttu-id="30cb1-124">Diese Methode sollte äußerst selten aufgerufen werden, und jeder Aufruf muss durch Aufrufe der <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>- und der <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>-Methode umschlossen sein.</span><span class="sxs-lookup"><span data-stu-id="30cb1-124">Calls to this method should be exceedingly rare, and any that you find should be surrounded by calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods.</span></span> <span data-ttu-id="30cb1-125">Diese beiden Methoden geben den Codebereich an, in dem der unformatierte Handlewert sicher verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="30cb1-125">These latter methods specify the region of code in which the raw handle value may be safely used.</span></span> <span data-ttu-id="30cb1-126">Außerhalb dieses Bereichs, oder wenn die Verweisanzahl nie von vornherein erhöht wird, kann der Handlewert jederzeit durch einen Aufruf von <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> oder <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> in einem anderen Thread ungültig gemacht werden.</span><span class="sxs-lookup"><span data-stu-id="30cb1-126">Outside this region, or if the reference count is never incremented in the first place, the handle value can be invalidated at any time by a call to <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> on another thread.</span></span> <span data-ttu-id="30cb1-127">Nachdem Sie alle Vorkommen von <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> ermittelt haben, folgen Sie dem Weg des unformatierten Handles, um sich zu vergewissern, dass es nicht an eine Komponente übergeben wird, die später `CloseHandle` oder eine andere systemnahe Methode aufruft, in der das Handle freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="30cb1-127">Once all uses of <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> have been tracked down, you should follow the path the raw handle takes to ensure it is not handed off to some component that will eventually call `CloseHandle` or another low-level native method that will release the handle.</span></span>  
  
- <span data-ttu-id="30cb1-128">Vergewissern Sie sich, dass der Code, mit dem das <xref:System.Runtime.InteropServices.SafeHandle>-Objekt mit einem gültigen unformatierten Handlewert initialisiert wird, das Handle besitzt.</span><span class="sxs-lookup"><span data-stu-id="30cb1-128">Ensure that the code that is used to initialize the <xref:System.Runtime.InteropServices.SafeHandle> with a valid raw handle value owns the handle.</span></span> <span data-ttu-id="30cb1-129">Wenn Sie ein <xref:System.Runtime.InteropServices.SafeHandle>-Objekt um ein Handle herum erstellen, das sich nicht im Besitz des Codes befindet, und wenn Sie den `ownsHandle`-Parameter im Basiskonstruktor nicht auf `false` festlegen, können sowohl das <xref:System.Runtime.InteropServices.SafeHandle>-Objekt als auch der tatsächliche Handlebesitzer versuchen, das Handle zu schließen. Dies führt dann zu einem Fehler im <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>-Objekt, wenn das <xref:System.Runtime.InteropServices.SafeHandle>-Objekt das Rennen verliert.</span><span class="sxs-lookup"><span data-stu-id="30cb1-129">If you form a <xref:System.Runtime.InteropServices.SafeHandle> around a handle your code does not own without setting the `ownsHandle` parameter to `false` in the base constructor, then both the <xref:System.Runtime.InteropServices.SafeHandle> and the real handle owner can try to close the handle, leading to an error in <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> if the <xref:System.Runtime.InteropServices.SafeHandle> loses the race.</span></span>  
  
- <span data-ttu-id="30cb1-130">Wenn ein <xref:System.Runtime.InteropServices.SafeHandle>-Objekt zwischen Anwendungsdomänen gemarshallt wird, müssen Sie vergewissern, dass die verwendete <xref:System.Runtime.InteropServices.SafeHandle>-Ableitung als serialisierbar gekennzeichnet wurde.</span><span class="sxs-lookup"><span data-stu-id="30cb1-130">When a <xref:System.Runtime.InteropServices.SafeHandle> is marshaled between application domains, confirm the <xref:System.Runtime.InteropServices.SafeHandle> derivation being used has been marked as serializable.</span></span> <span data-ttu-id="30cb1-131">In den seltenen Fällen, in denen eine aus <xref:System.Runtime.InteropServices.SafeHandle> abgeleitete Klasse serialisierbar gemacht wurde, muss sie die <xref:System.Runtime.Serialization.ISerializable>-Schnittstelle implementieren oder eines der anderen Verfahren zum manuellen Steuern der Serialisierung und Deserialisierung verwenden.</span><span class="sxs-lookup"><span data-stu-id="30cb1-131">In the rare cases where a class derived from <xref:System.Runtime.InteropServices.SafeHandle> has been made serializable, it should implement the <xref:System.Runtime.Serialization.ISerializable> interface or use one of the other techniques for controlling the serialization and deserialization process manually.</span></span> <span data-ttu-id="30cb1-132">Dies ist erforderlich, weil bei der standardmäßigen Serialisierungsaktion ein bitweiser Klon des eingeschlossenen unformatierten Handlewerts erstellt wird, was dazu führt, dass für zwei <xref:System.Runtime.InteropServices.SafeHandle>-Instanzen angenommen wird, dass sie dasselbe Handle besitzen.</span><span class="sxs-lookup"><span data-stu-id="30cb1-132">This is required because the default serialization action is to create a bitwise clone of the enclosed raw handle value, resulting in two <xref:System.Runtime.InteropServices.SafeHandle> instances thinking they own the same handle.</span></span> <span data-ttu-id="30cb1-133">Beide Instanzen werden irgendwann versuchen, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> für dasselbe Handle aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="30cb1-133">Both will try to call <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> on the same handle at some point.</span></span> <span data-ttu-id="30cb1-134">Das zweite <xref:System.Runtime.InteropServices.SafeHandle>-Objekt, das dies versucht, schlägt dann fehl.</span><span class="sxs-lookup"><span data-stu-id="30cb1-134">The second <xref:System.Runtime.InteropServices.SafeHandle> to do this will fail.</span></span> <span data-ttu-id="30cb1-135">Das richtige Vorgehen beim Serialisieren eines <xref:System.Runtime.InteropServices.SafeHandle>-Objekts besteht darin, für den systemeigenen Handletyp die `DuplicateHandle`-Funktion oder eine ähnliche Funktion aufzurufen, damit eine unabhängige gültige Handlekopie erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="30cb1-135">The correct course of action when serializing a <xref:System.Runtime.InteropServices.SafeHandle> is to call the `DuplicateHandle` function or a similar function for your native handle type to make a distinct legal handle copy.</span></span> <span data-ttu-id="30cb1-136">Wenn Ihr Handletyp dies nicht unterstützt, kann der <xref:System.Runtime.InteropServices.SafeHandle>-Typ, der ihn umschließt, nicht serialisierbar gemacht werden.</span><span class="sxs-lookup"><span data-stu-id="30cb1-136">If your handle type does not support this then the <xref:System.Runtime.InteropServices.SafeHandle> type wrapping it cannot be made serializable.</span></span>  
  
- <span data-ttu-id="30cb1-137">Möglicherweise können Sie verfolgen, wo ein Handle vorzeitig geschlossen wird, wodurch sich ein Fehler ergibt, wenn schließlich die <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>-Methode aufgerufen wird. Platzieren Sie dazu einen Debuggerhaltepunkt in dernativen Routine, in der das Handle freigegeben wird, also z. B. in der `CloseHandle`-Funktion.</span><span class="sxs-lookup"><span data-stu-id="30cb1-137">It may be possible to track where a handle is being closed early, leading to a failure when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is finally called, by placing a debugger breakpoint on the native routine used to release the handle, for example the `CloseHandle` function.</span></span> <span data-ttu-id="30cb1-138">Dies ist möglicherweise für Belastungsszenarios oder sogar für mittelgroße Funktionstests wegen des umfangreichen Datenverkehrs nicht möglich, den solche Routinen oft verarbeiten müssen.</span><span class="sxs-lookup"><span data-stu-id="30cb1-138">This may not be possible for stress scenarios or even medium-sized functional tests due to the heavy traffic such routines often deal with.</span></span> <span data-ttu-id="30cb1-139">Es kann nützlich sein, den Code zu instrumentieren, der die systemeigene Freigabemethode aufruft. So lässt sich die Identität des Aufrufers oder möglicherweise eine vollständige Stapelüberwachung sowie der Wert des Handles erfassen, das freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="30cb1-139">It may help to instrument the code that calls the native release method, in order to capture the identity of the caller, or possibly a full stack trace, and the value of the handle being released.</span></span>  <span data-ttu-id="30cb1-140">Der Handlewert kann mit dem von diesem MDA gemeldeten Wert verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="30cb1-140">The handle value can be compared with the value reported by this MDA.</span></span>  
  
- <span data-ttu-id="30cb1-141">Beachten Sie, dass für einige systemeigene Handletypen, z. B. alle Win32-Handles, die über die `CloseHandle`-Funktion freigegeben werden können, derselbe Handlenamespace verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="30cb1-141">Note that some native handle types, such as all the Win32 handles that can be released via the `CloseHandle` function, share the same handle namespace.</span></span> <span data-ttu-id="30cb1-142">Eine fehlerhafte Freigabe eines Handletyps kann zu Problemen mit einem anderen Handletyp führen.</span><span class="sxs-lookup"><span data-stu-id="30cb1-142">An erroneous release of one handle type can cause problems with another.</span></span> <span data-ttu-id="30cb1-143">Wird beispielsweise ein Win32-Ereignishandle versehentlich zweimal geschlossen, kann die Folge sein, dass ein davon anscheinend unabhängiges Dateihandle vorzeitig geschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="30cb1-143">For instance, accidentally closing a Win32 event handle twice might lead to an apparently unrelated file handle being closed prematurely.</span></span> <span data-ttu-id="30cb1-144">Dies geschieht, wenn das Handle freigegeben und der Handlewert verfügbar wird, um eine andere Ressource zu verfolgen, die möglicherweise einen anderen Typ hat.</span><span class="sxs-lookup"><span data-stu-id="30cb1-144">This happens when the handle is released and the handle value becomes available for use to track another resource, potentially of another type.</span></span> <span data-ttu-id="30cb1-145">Falls dies passiert und eine fehlerhafte zweite Freigabe erfolgt, wird möglicherweise das Handle eines unabhängigen Threads ungültig gemacht.</span><span class="sxs-lookup"><span data-stu-id="30cb1-145">If this happens and is followed by an erroneous second release, the handle of an unrelated thread might be invalidated.</span></span>  
  
## <a name="effect-on-the-runtime"></a><span data-ttu-id="30cb1-146">Auswirkungen auf die Laufzeit</span><span class="sxs-lookup"><span data-stu-id="30cb1-146">Effect on the Runtime</span></span>  

 <span data-ttu-id="30cb1-147">Dieser MDA hat keine Auswirkungen auf die CLR.</span><span class="sxs-lookup"><span data-stu-id="30cb1-147">This MDA has no effect on the CLR.</span></span>  
  
## <a name="output"></a><span data-ttu-id="30cb1-148">Ausgabe</span><span class="sxs-lookup"><span data-stu-id="30cb1-148">Output</span></span>  

 <span data-ttu-id="30cb1-149">Eine Meldung, die angibt, dass ein <xref:System.Runtime.InteropServices.SafeHandle> oder ein <xref:System.Runtime.InteropServices.CriticalHandle> das Handle nicht ordnungsgemäß freigegeben hat.</span><span class="sxs-lookup"><span data-stu-id="30cb1-149">A message indicating that a <xref:System.Runtime.InteropServices.SafeHandle> or a <xref:System.Runtime.InteropServices.CriticalHandle> failed to properly release the handle.</span></span> <span data-ttu-id="30cb1-150">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="30cb1-150">For example:</span></span>  
  
```output
"A SafeHandle or CriticalHandle of type 'MyBrokenSafeHandle'
failed to properly release the handle with value 0x0000BEEF. This
usually indicates that the handle was released incorrectly via
another means (such as extracting the handle using DangerousGetHandle
and closing it directly or building another SafeHandle around it."  
```  
  
## <a name="configuration"></a><span data-ttu-id="30cb1-151">Konfiguration</span><span class="sxs-lookup"><span data-stu-id="30cb1-151">Configuration</span></span>  
  
```xml  
<mdaConfig>  
  <assistants>  
    <releaseHandleFailed/>  
  </assistants>  
</mdaConfig>  
```  
  
## <a name="example"></a><span data-ttu-id="30cb1-152">Beispiel</span><span class="sxs-lookup"><span data-stu-id="30cb1-152">Example</span></span>  

 <span data-ttu-id="30cb1-153">Das Folgende ist ein Codebeispiel, in dem der `releaseHandleFailed`-MDA aktiviert werden kann.</span><span class="sxs-lookup"><span data-stu-id="30cb1-153">The following is a code example that can activate the `releaseHandleFailed` MDA.</span></span>  
  
```csharp
bool ReleaseHandle()  
{  
    // Calling the Win32 CloseHandle function to release the
    // native handle wrapped by this SafeHandle. This method returns
    // false on failure, but should only fail if the input is invalid
    // (which should not happen here). The method specifically must not
    // fail simply because of lack of resources or other transient
    // failures beyond the user’s control. That would make it unacceptable
    // to call CloseHandle as part of the implementation of this method.  
    return CloseHandle(handle);  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="30cb1-154">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="30cb1-154">See also</span></span>

- <xref:System.Runtime.InteropServices.MarshalAsAttribute>
- [<span data-ttu-id="30cb1-155">Diagnostizieren von Fehlern mit Assistenten für verwaltetes Debuggen</span><span class="sxs-lookup"><span data-stu-id="30cb1-155">Diagnosing Errors with Managed Debugging Assistants</span></span>](diagnosing-errors-with-managed-debugging-assistants.md)
- [<span data-ttu-id="30cb1-156">Interop Marshaling (Interop-Marshalling)</span><span class="sxs-lookup"><span data-stu-id="30cb1-156">Interop Marshaling</span></span>](../interop/interop-marshaling.md)
