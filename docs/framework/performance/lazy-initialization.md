---
title: Verzögerte Initialisierung
description: Untersuchen Sie die verzögerte Initialisierung in .net, eine Leistungsverbesserung, die bedeutet, dass eine Objekt Erstellung verzögert wird, bis das Objekt zum ersten Mal verwendet wird.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
ms.openlocfilehash: 355fa326fc19e9a50a74e21ace0a6353f5c740c5
ms.sourcegitcommit: 3824ff187947572b274b9715b60c11269335c181
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 06/17/2020
ms.locfileid: "84904233"
---
# <a name="lazy-initialization"></a><span data-ttu-id="880e5-103">Verzögerte Initialisierung</span><span class="sxs-lookup"><span data-stu-id="880e5-103">Lazy Initialization</span></span>
<span data-ttu-id="880e5-104">*Verzögerte Initialisierung* eines Objekts bedeutet, dass seine Erstellung bis zur ersten Verwendung verzögert wird.</span><span class="sxs-lookup"><span data-stu-id="880e5-104">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="880e5-105">(In diesem Thema sind die Begriffe " *Lazy Initialisierung* " und " *Lazy Instantiierung* " gleichbedeutend). Verzögerte Initialisierung wird hauptsächlich verwendet, um die Leistung zu verbessern, eine Verschwendung von Berechnungen zu vermeiden und die Programmspeicher Anforderungen zu reduzieren</span><span class="sxs-lookup"><span data-stu-id="880e5-105">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="880e5-106">Die folgenden Szenarios sind die häufigsten:</span><span class="sxs-lookup"><span data-stu-id="880e5-106">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="880e5-107">Sie verfügen über ein Objekt, dessen Erstellung teuer ist und das möglicherweise nicht vom Programm verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="880e5-107">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="880e5-108">Angenommen, in Ihrem Speicher befindet sich ein `Customer`-Objekt mit einer `Orders`-Eigenschaft, die ein großes Array aus `Order`-Objekten enthält, das zur Initialisierung eine Datenbankverbindung benötigt.</span><span class="sxs-lookup"><span data-stu-id="880e5-108">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="880e5-109">Fordert der Benutzer nie die Anzeige des Orders-Objekts oder die Verwendung der Daten in einer Berechnung an, ist es nicht notwendig, Systemspeicher oder Berechnungszyklen für seine Erstellung zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="880e5-109">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="880e5-110">Systemressourcen können geschont werden, wenn Sie die verzögerte Initialisierung für das `Orders`-Objekt mithilfe von `Lazy<Orders>` deklarieren, solange das Objekt nicht verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="880e5-110">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="880e5-111">Sie verfügen über ein Objekt, dessen Erstellung teuer ist und das daher erst erstellt werden soll, wenn andere teure Vorgänge abgeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="880e5-111">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="880e5-112">Angenommen, das Programm lädt beim Start mehrere Objektinstanzen, von denen allerdings nur einige sofort benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="880e5-112">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="880e5-113">Hier kann die Startleistung des Programms verbessert werden, indem die Initialisierung der nicht benötigten Objekte verzögert wird, bis die benötigten Objekte erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="880e5-113">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="880e5-114">Sie können für die verzögerte Initialisierung Ihren eigenen Code schreiben. Es ist jedoch empfehlenswert, stattdessen <xref:System.Lazy%601> zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="880e5-114">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="880e5-115"><xref:System.Lazy%601> und die zugehörigen verwandten Typen unterstützen auch die Threadsicherheit und stellen eine konsistente Richtlinie zur Ausnahmeweitergabe bereit.</span><span class="sxs-lookup"><span data-stu-id="880e5-115"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="880e5-116">In der folgenden Tabelle werden die Typen aufgelistet, die .NET Framework Version 4 bereitstellt, um die verzögerte Initialisierung in verschiedenen Szenarios zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="880e5-116">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="880e5-117">type</span><span class="sxs-lookup"><span data-stu-id="880e5-117">Type</span></span>|<span data-ttu-id="880e5-118">BESCHREIBUNG</span><span class="sxs-lookup"><span data-stu-id="880e5-118">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="880e5-119">Eine Wrapperklasse, die die Semantik für verzögerte Initialisierung für jeden Klassenbibliotheks- oder benutzerdefinierten Typ bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="880e5-119">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="880e5-120">Ähnlich wie <xref:System.Lazy%601>, außer dass die Semantik für verzögerte Initialisierung threadlokal bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="880e5-120">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="880e5-121">Jeder Thread hat Zugriff auf seinen eigenen eindeutigen Wert.</span><span class="sxs-lookup"><span data-stu-id="880e5-121">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="880e5-122">Stellt erweiterte `static`-Methoden (`Shared` in Visual Basic) für die verzögerte Initialisierung von Objekten bereit ohne den Mehraufwand einer Klasse.</span><span class="sxs-lookup"><span data-stu-id="880e5-122">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="880e5-123">Grundlegende verzögerte Initialisierung</span><span class="sxs-lookup"><span data-stu-id="880e5-123">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="880e5-124">Verwenden Sie `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic) wie in folgendem Beispiel gezeigt, um einen Typ mit verzögerter Initialisierung, z.B. `MyType`, zu definieren.</span><span class="sxs-lookup"><span data-stu-id="880e5-124">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="880e5-125">Wird im <xref:System.Lazy%601>-Konstruktor kein Delegat übergeben, wird der umschlossene Typ mithilfe von <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> beim ersten Zugriff auf die Value-Eigenschaft erstellt.</span><span class="sxs-lookup"><span data-stu-id="880e5-125">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="880e5-126">Wenn der Typ nicht über einen Parameter losen Konstruktor verfügt, wird eine Lauf Zeit Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="880e5-126">If the type does not have a parameterless constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="880e5-127">Im folgenden Beispiel wird angenommen, dass `Orders` eine Klasse mit einem Array aus `Order`-Objekten ist, die aus einer Datenbank abgerufen wurden.</span><span class="sxs-lookup"><span data-stu-id="880e5-127">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="880e5-128">Ein `Customer`-Objekt enthält eine Instanz von `Orders`, je nach Benutzeraktion werden die Daten aus dem `Orders`-Objekt jedoch möglicherweise nicht benötigt.</span><span class="sxs-lookup"><span data-stu-id="880e5-128">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="880e5-129">Sie können im <xref:System.Lazy%601>-Konstruktor auch einen Delegaten übergeben, der bei der Erstellung eine bestimmte Konstruktorüberladung für den umschlossenen Typ aufruft. Außerdem können Sie die weiteren erforderlichen Initialisierungsschritte wie im folgenden Beispiel gezeigt ausführen.</span><span class="sxs-lookup"><span data-stu-id="880e5-129">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="880e5-130">Nachdem das Lazy-Objekt erstellt wurde, wird erst eine Instanz von `Orders` erstellt, wenn auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft der Lazy-Variable zum ersten Mal zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="880e5-130">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="880e5-131">Beim ersten Zugriff wird der umschlossene Typ erstellt, zurückgegeben und für einen späteren Zugriff gespeichert.</span><span class="sxs-lookup"><span data-stu-id="880e5-131">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="880e5-132">Ein <xref:System.Lazy%601>-Objekt gibt immer das gleiche Objekt oder den gleichen Wert zurück, mit dem es initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="880e5-132">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="880e5-133">Daher besitzt die <xref:System.Lazy%601.Value%2A>-Eigenschaft nur einen Lesezugriff.</span><span class="sxs-lookup"><span data-stu-id="880e5-133">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="880e5-134">Wenn <xref:System.Lazy%601.Value%2A> einen Verweistyp speichert, können Sie ihm kein neues Objekt zuweisen.</span><span class="sxs-lookup"><span data-stu-id="880e5-134">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="880e5-135">(Sie können jedoch den Wert der einsetzbaren öffentlichen Felder und Eigenschaften ändern.) Wenn <xref:System.Lazy%601.Value%2A> einen Werttyp speichert, können Sie dessen Wert nicht ändern.</span><span class="sxs-lookup"><span data-stu-id="880e5-135">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="880e5-136">Sie können jedoch eine neue Variable erstellen, indem Sie den Variablenkonstruktor erneut mit neuen Argumenten aufrufen.</span><span class="sxs-lookup"><span data-stu-id="880e5-136">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="880e5-137">Die neue verzögerte Instanz instanziiert das `Orders`-Objekt wie die vorherige erst, wenn auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft erstmals zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="880e5-137">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="880e5-138">Threadsichere Initialisierung</span><span class="sxs-lookup"><span data-stu-id="880e5-138">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="880e5-139">Standardmäßig sind <xref:System.Lazy%601>-Objekte threadsicher.</span><span class="sxs-lookup"><span data-stu-id="880e5-139">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="880e5-140">Wird im Konstruktor die Art der Threadsicherheit nicht angegeben, sind die erstellten <xref:System.Lazy%601>-Objekte daher threadsicher.</span><span class="sxs-lookup"><span data-stu-id="880e5-140">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="880e5-141">In Multithreadszenarios initialisiert der erste Thread, der auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft eines threadsicheren <xref:System.Lazy%601>-Objekts zugreift, die Eigenschaft für jeden nachfolgenden Zugriff auf allen Threads. Alle Threads nutzen dieselben Daten.</span><span class="sxs-lookup"><span data-stu-id="880e5-141">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="880e5-142">Daher spielt es keine Rolle, welcher Thread das Objekt initialisiert. Auch Racebedingungen haben keine Auswirkung.</span><span class="sxs-lookup"><span data-stu-id="880e5-142">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="880e5-143">Diese Konsistenz kann durch das Zwischenspeichern von Ausnahmen auf Fehlerbedingungen erweitert werden.</span><span class="sxs-lookup"><span data-stu-id="880e5-143">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="880e5-144">Weitere Informationen finden Sie im folgenden Abschnitt [Ausnahmen bei verzögerten Objekten](lazy-initialization.md#ExceptionsInLazyObjects).</span><span class="sxs-lookup"><span data-stu-id="880e5-144">For more information, see the next section, [Exceptions in Lazy Objects](lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="880e5-145">Das folgende Beispiel verdeutlicht, dass die gleiche `Lazy<int>`-Instanz über den gleichen Wert für drei separate Threads verfügt.</span><span class="sxs-lookup"><span data-stu-id="880e5-145">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="880e5-146">Wenn Sie separate Daten für jeden Thread benötigen, verwenden Sie wie weiter unten beschrieben den <xref:System.Threading.ThreadLocal%601>-Typ.</span><span class="sxs-lookup"><span data-stu-id="880e5-146">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="880e5-147">Einige <xref:System.Lazy%601>-Konstruktoren verfügen über einen booleschen Parameter mit dem Namen `isThreadSafe`, der angibt, ob auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft von mehreren Threads zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="880e5-147">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="880e5-148">Wenn Sie von nur einem Thread auf die Eigenschaft zugreifen möchten, übergeben Sie `false` für einen moderaten Leistungsvorteil.</span><span class="sxs-lookup"><span data-stu-id="880e5-148">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="880e5-149">Wenn Sie von mehreren Threads auf die Eigenschaft zugreifen möchten, übergeben Sie `true`, um die <xref:System.Lazy%601>-Instanz anzuweisen, die Racebedingungen ordnungsgemäß zu behandeln, von denen ein Thread bei der Initialisierung eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="880e5-149">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="880e5-150">Einige <xref:System.Lazy%601>-Konstruktoren verfügen über einen <xref:System.Threading.LazyThreadSafetyMode>-Parameter mit dem Namen `mode`.</span><span class="sxs-lookup"><span data-stu-id="880e5-150">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="880e5-151">Diese Konstruktoren stellen einen zusätzlichen Threadsicherheitsmodus bereit.</span><span class="sxs-lookup"><span data-stu-id="880e5-151">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="880e5-152">Entnehmen Sie der folgenden Tabelle, wie die Threadsicherheit eines <xref:System.Lazy%601>-Objekts von den Konstruktorparametern beeinflusst wird, die die Threadsicherheit angeben.</span><span class="sxs-lookup"><span data-stu-id="880e5-152">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="880e5-153">Jeder Konstruktor verfügt über höchstens einen solchen Parameter.</span><span class="sxs-lookup"><span data-stu-id="880e5-153">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="880e5-154">Threadsicherheit des Objekts</span><span class="sxs-lookup"><span data-stu-id="880e5-154">Thread safety of the object</span></span>|<span data-ttu-id="880e5-155">`LazyThreadSafetyMode``mode`Parameter</span><span class="sxs-lookup"><span data-stu-id="880e5-155">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="880e5-156">Boolescher Parameter `isThreadSafe`</span><span class="sxs-lookup"><span data-stu-id="880e5-156">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="880e5-157">Keine Threadsicherheitsparameter</span><span class="sxs-lookup"><span data-stu-id="880e5-157">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="880e5-158">Vollständig threadsicher; nur ein Thread versucht jeweils, den Wert zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="880e5-158">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="880e5-159">Ja.</span><span class="sxs-lookup"><span data-stu-id="880e5-159">Yes.</span></span>|  
|<span data-ttu-id="880e5-160">Nicht threadsicher.</span><span class="sxs-lookup"><span data-stu-id="880e5-160">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="880e5-161">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="880e5-161">Not applicable.</span></span>|  
|<span data-ttu-id="880e5-162">Vollständig threadsicher; Threads befinden sich im Race, um den Wert zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="880e5-162">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="880e5-163">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="880e5-163">Not applicable.</span></span>|<span data-ttu-id="880e5-164">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="880e5-164">Not applicable.</span></span>|  
  
 <span data-ttu-id="880e5-165">Die Tabelle verdeutlicht, dass die Angabe von <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für den `mode`-Parameter der Angabe von `true` für den `isThreadSafe`-Parameter entspricht, ebenso wie die Angabe von <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> der Angabe von `false`.</span><span class="sxs-lookup"><span data-stu-id="880e5-165">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="880e5-166">Die Angabe von <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> ermöglicht mehreren Threads, die Initialisierung der <xref:System.Lazy%601>-Instanz zu versuchen.</span><span class="sxs-lookup"><span data-stu-id="880e5-166">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="880e5-167">Nur ein Thread kann unter dieser Racebedingung gewinnen. Alle anderen Threads empfangen den Wert, der vom erfolgreichen Thread initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="880e5-167">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="880e5-168">Wird während der Initialisierung für einen Thread eine Ausnahme ausgelöst, empfängt dieser Thread nicht den vom erfolgreichen Thread festgelegten Wert.</span><span class="sxs-lookup"><span data-stu-id="880e5-168">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="880e5-169">Da Ausnahmen nicht zwischengespeichert werden, kann ein nachfolgender Versuch, auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft zuzugreifen, zu einer erfolgreichen Initialisierung führen.</span><span class="sxs-lookup"><span data-stu-id="880e5-169">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="880e5-170">Darin besteht ein Unterschied zur Behandlung von Ausnahmen in anderen Modi, die im folgenden Abschnitt beschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="880e5-170">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="880e5-171">Weitere Informationen finden Sie unter der <xref:System.Threading.LazyThreadSafetyMode>-Enumeration.</span><span class="sxs-lookup"><span data-stu-id="880e5-171">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="880e5-172">Ausnahmen bei verzögerten Objekten</span><span class="sxs-lookup"><span data-stu-id="880e5-172">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="880e5-173">Wie weiter oben erwähnt gibt ein <xref:System.Lazy%601>-Objekt immer das gleiche Objekt oder den gleichen Wert zurück, mit dem es initialisiert wurde. Daher verfügt die <xref:System.Lazy%601.Value%2A>-Eigenschaft nur über einen Lesezugriff.</span><span class="sxs-lookup"><span data-stu-id="880e5-173">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="880e5-174">Wird das Zwischenspeichern von Ausnahmen aktiviert, wird diese Unveränderlichkeit auch auf das Ausnahmeverhalten erweitert.</span><span class="sxs-lookup"><span data-stu-id="880e5-174">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="880e5-175">Wenn für ein verzögertes initialisiertes Objekt das Zwischenspeichern von Ausnahmen aktiviert ist und beim ersten Zugriff auf die Eigenschaft eine Ausnahme von der Initialisierungs Methode ausgelöst wird <xref:System.Lazy%601.Value%2A> , wird bei jedem nachfolgenden Versuch, auf die Eigenschaft zuzugreifen, dieselbe Ausnahme ausgelöst <xref:System.Lazy%601.Value%2A> .</span><span class="sxs-lookup"><span data-stu-id="880e5-175">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="880e5-176">Anders ausgedrückt wird der Konstruktor des umschlossenen Typs selbst in Multithreadszenarios niemals erneut aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="880e5-176">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="880e5-177">Aus diesem Grund kann das <xref:System.Lazy%601>-Objekt nicht bei einem Zugriff eine Ausnahme auslösen und bei einem nachfolgenden Zugriff einen Wert zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="880e5-177">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="880e5-178">Das Zwischenspeichern von Ausnahmen wird bei der Verwendung eines beliebigen <xref:System.Lazy%601?displayProperty=nameWithType>-Konstruktors aktiviert, der eine Initialisierungsmethode erfordert (`valueFactory`-Parameter). So wird es beispielsweise aktiviert, wenn Sie den `Lazy(T)(Func(T))`-Konstruktor verwenden.</span><span class="sxs-lookup"><span data-stu-id="880e5-178">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="880e5-179">Erfordert der Konstruktor auch einen <xref:System.Threading.LazyThreadSafetyMode>-Wert (`mode`-Parameter), geben Sie <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> oder <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> an.</span><span class="sxs-lookup"><span data-stu-id="880e5-179">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="880e5-180">Durch die Angabe einer Initialisierungsmethode wird das Zwischenspeichern von Ausnahmen für diese beiden Modi aktiviert.</span><span class="sxs-lookup"><span data-stu-id="880e5-180">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="880e5-181">Die Initialisierungsmethode kann sehr einfach sein.</span><span class="sxs-lookup"><span data-stu-id="880e5-181">The initialization method can be very simple.</span></span> <span data-ttu-id="880e5-182">Beispielsweise kann der Parameter lose Konstruktor für `T` : `new Lazy<Contents>(() => new Contents(), mode)` in c# oder `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="880e5-182">For example, it might call the parameterless constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="880e5-183">Wenn Sie einen <xref:System.Lazy%601?displayProperty=nameWithType>-Konstruktor verwenden, der keine Initialisierungsmethode angibt, werden vom parameterlosen Konstruktor für `T` ausgelöste Ausnahmen nicht zwischengespeichert.</span><span class="sxs-lookup"><span data-stu-id="880e5-183">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the parameterless constructor for `T` are not cached.</span></span> <span data-ttu-id="880e5-184">Weitere Informationen finden Sie unter der <xref:System.Threading.LazyThreadSafetyMode>-Enumeration.</span><span class="sxs-lookup"><span data-stu-id="880e5-184">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="880e5-185">Wenn der `isThreadSafe`-Konstruktorparameter beim Erstellen eines <xref:System.Lazy%601>-Objekts auf `false` festgelegt ist oder der `mode`-Konstruktorparameter auf <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, müssen Sie auf das <xref:System.Lazy%601>-Objekt von einem einzelnen Thread zugreifen oder eine eigene Synchronisierung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="880e5-185">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="880e5-186">Dies gilt für alle Aspekte des Objekts, einschließlich dem Zwischenspeichern von Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="880e5-186">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="880e5-187">Wie im vorherigen Abschnitt erwähnt, behandeln durch Angabe von <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> erstellte <xref:System.Lazy%601>-Objekte Ausnahmen unterschiedlich.</span><span class="sxs-lookup"><span data-stu-id="880e5-187">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="880e5-188">Mit <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> können mehrere Threads um die Initialisierung der <xref:System.Lazy%601>-Instanz konkurrieren.</span><span class="sxs-lookup"><span data-stu-id="880e5-188">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="880e5-189">In diesem Fall werden Ausnahmen nicht zwischengespeichert. Die Versuche, auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft zuzugreifen, können fortgesetzt werden, bis die Initialisierung erfolgreich ist.</span><span class="sxs-lookup"><span data-stu-id="880e5-189">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="880e5-190">In der folgenden Tabelle werden die Steuerungsmethoden für das Zwischenspeichern von Ausnahmen durch <xref:System.Lazy%601>-Konstruktoren zusammengefasst.</span><span class="sxs-lookup"><span data-stu-id="880e5-190">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="880e5-191">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="880e5-191">Constructor</span></span>|<span data-ttu-id="880e5-192">Threadsicherheitsmodus</span><span class="sxs-lookup"><span data-stu-id="880e5-192">Thread safety mode</span></span>|<span data-ttu-id="880e5-193">Verwendet die Initialisierungsmethode</span><span class="sxs-lookup"><span data-stu-id="880e5-193">Uses initialization method</span></span>|<span data-ttu-id="880e5-194">Ausnahmen werden zwischengespeichert</span><span class="sxs-lookup"><span data-stu-id="880e5-194">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="880e5-195">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="880e5-195">Lazy(T)()</span></span>|<span data-ttu-id="880e5-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="880e5-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="880e5-197">Nein</span><span class="sxs-lookup"><span data-stu-id="880e5-197">No</span></span>|<span data-ttu-id="880e5-198">Nein</span><span class="sxs-lookup"><span data-stu-id="880e5-198">No</span></span>|  
|<span data-ttu-id="880e5-199">Lazy(T)(Func(T))</span><span class="sxs-lookup"><span data-stu-id="880e5-199">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="880e5-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="880e5-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="880e5-201">Ja</span><span class="sxs-lookup"><span data-stu-id="880e5-201">Yes</span></span>|<span data-ttu-id="880e5-202">Ja</span><span class="sxs-lookup"><span data-stu-id="880e5-202">Yes</span></span>|  
|<span data-ttu-id="880e5-203">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="880e5-203">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="880e5-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) oder `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="880e5-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="880e5-205">Nein</span><span class="sxs-lookup"><span data-stu-id="880e5-205">No</span></span>|<span data-ttu-id="880e5-206">Nein</span><span class="sxs-lookup"><span data-stu-id="880e5-206">No</span></span>|  
|<span data-ttu-id="880e5-207">Lazy(T)(Func(T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="880e5-207">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="880e5-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) oder `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="880e5-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="880e5-209">Ja</span><span class="sxs-lookup"><span data-stu-id="880e5-209">Yes</span></span>|<span data-ttu-id="880e5-210">Ja</span><span class="sxs-lookup"><span data-stu-id="880e5-210">Yes</span></span>|  
|<span data-ttu-id="880e5-211">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="880e5-211">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="880e5-212">Vom Benutzer angegeben</span><span class="sxs-lookup"><span data-stu-id="880e5-212">User-specified</span></span>|<span data-ttu-id="880e5-213">Nein</span><span class="sxs-lookup"><span data-stu-id="880e5-213">No</span></span>|<span data-ttu-id="880e5-214">Nein</span><span class="sxs-lookup"><span data-stu-id="880e5-214">No</span></span>|  
|<span data-ttu-id="880e5-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="880e5-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="880e5-216">Vom Benutzer angegeben</span><span class="sxs-lookup"><span data-stu-id="880e5-216">User-specified</span></span>|<span data-ttu-id="880e5-217">Ja</span><span class="sxs-lookup"><span data-stu-id="880e5-217">Yes</span></span>|<span data-ttu-id="880e5-218">Nein, wenn der Benutzer <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> angibt; andernfalls ja.</span><span class="sxs-lookup"><span data-stu-id="880e5-218">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="880e5-219">Implementieren einer Eigenschaft mit verzögerter Initialisierung</span><span class="sxs-lookup"><span data-stu-id="880e5-219">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="880e5-220">Definieren Sie zum Implementieren einer öffentlichen Eigenschaft mit der verzögerten Initialisierung das Unterstützungsfeld der Eigenschaft als <xref:System.Lazy%601>, und geben Sie die <xref:System.Lazy%601.Value%2A>-Eigenschaft des `get`-Accessors der Eigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="880e5-220">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="880e5-221">Die <xref:System.Lazy%601.Value%2A>-Eigenschaft besitzt nur Lesezugriff. Daher verfügt die Eigenschaft, die sie verfügbar macht, über keinen `set`-Accessor.</span><span class="sxs-lookup"><span data-stu-id="880e5-221">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="880e5-222">Ist eine Lese-/Schreibeigenschaft erforderlich, die durch ein <xref:System.Lazy%601>-Objekt gesichert wird, muss der `set`-Accessor ein neues <xref:System.Lazy%601>-Objekt erstellen und dem Sicherungsspeicher zuweisen.</span><span class="sxs-lookup"><span data-stu-id="880e5-222">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="880e5-223">Der `set`-Accessor muss einen Lambdaausdruck erstellen, der den an den `set`-Accessor übergebenen neuen Eigenschaftswert zurückgibt. Dieser Lambdaausdruck muss anschließend an den Konstruktor für das neue <xref:System.Lazy%601>-Objekt übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="880e5-223">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="880e5-224">Der nächste Zugriff auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft führt zur Initialisierung des neuen <xref:System.Lazy%601>. Die zugehörige <xref:System.Lazy%601.Value%2A>-Eigenschaft gibt danach den neuen Wert zurück, der der Eigenschaft zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="880e5-224">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="880e5-225">Der Grund für diese komplizierte Gestaltung besteht darin, dass der in <xref:System.Lazy%601> integrierte Multithreadingschutz beibehalten werden soll.</span><span class="sxs-lookup"><span data-stu-id="880e5-225">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="880e5-226">Andernfalls müssten die Eigenschaftenaccessoren den ersten von der <xref:System.Lazy%601.Value%2A>-Eigenschaft zurückgegebenen Wert zwischenspeichern und nur den zwischengespeicherten Wert ändern. Dafür müssten Sie Ihren eigenen threadsicheren Code schreiben.</span><span class="sxs-lookup"><span data-stu-id="880e5-226">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="880e5-227">Aufgrund der zusätzlichen Initialisierungen, die von einer durch ein <xref:System.Lazy%601>-Objekt gesicherten Lese-/Schreibeigenschaft angefordert werden, ist die Leistung möglicherweise nicht akzeptabel.</span><span class="sxs-lookup"><span data-stu-id="880e5-227">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="880e5-228">Darüber hinaus kann je nach Szenario eine zusätzliche Koordinierung erforderlich sein, um Racebedingungen zwischen Setter und Getter zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="880e5-228">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="880e5-229">Threadlokale verzögerte Initialisierung</span><span class="sxs-lookup"><span data-stu-id="880e5-229">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="880e5-230">In einigen Multithreadszenarios möchten Sie jedem Thread möglicherweise eigene private Daten zuweisen.</span><span class="sxs-lookup"><span data-stu-id="880e5-230">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="880e5-231">Diese Daten werden *threadlokale Daten* genannt.</span><span class="sxs-lookup"><span data-stu-id="880e5-231">Such data is called *thread-local data*.</span></span> <span data-ttu-id="880e5-232">Bis .NET Framework Version 3.5 konnte das `ThreadStatic`-Attribut auf eine statische Variable angewendet werden, um aus ihr eine threadlokale Variable zu machen.</span><span class="sxs-lookup"><span data-stu-id="880e5-232">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="880e5-233">Die Anwendung des `ThreadStatic`-Attributs kann jedoch geringfügige Fehler verursachen.</span><span class="sxs-lookup"><span data-stu-id="880e5-233">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="880e5-234">Selbst grundlegende Initialisierungsanweisungen führen z.B. dazu, dass die Variable wie im folgenden Beispiel gezeigt nur für den ersten Thread initialisiert wird, der auf sie zugreift.</span><span class="sxs-lookup"><span data-stu-id="880e5-234">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="880e5-235">Für alle anderen Threads wird die Variable mit ihrem Standardwert (0) initialisiert.</span><span class="sxs-lookup"><span data-stu-id="880e5-235">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="880e5-236">In .NET Framework Version 4 kann der <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>-Typ alternativ dazu zum Erstellen einer instanzbasierten, threadlokalen Variable verwendet werden, die für alle Threads mit dem von Ihnen bereitgestellten <xref:System.Action%601>-Delegaten initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="880e5-236">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="880e5-237">Im folgenden Beispiel erhalten alle Threads, die auf `counter` zugreifen, den Startwert 1.</span><span class="sxs-lookup"><span data-stu-id="880e5-237">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="880e5-238"><xref:System.Threading.ThreadLocal%601> umschließt sein Objekt auf fast die gleiche Weise wie <xref:System.Lazy%601>, mit folgenden entscheidenden Unterschieden:</span><span class="sxs-lookup"><span data-stu-id="880e5-238"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="880e5-239">Jeder Thread initialisiert die threadlokale Variable mit seinen eigenen privaten Daten, auf die von anderen Threads nicht zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="880e5-239">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="880e5-240">Die <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType>-Eigenschaft verfügt über Lese-/Schreibzugriff und kann beliebig oft geändert werden.</span><span class="sxs-lookup"><span data-stu-id="880e5-240">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="880e5-241">Dies kann sich auf die Ausnahmeweitergabe auswirken: So kann ein `get`-Vorgang z.B. eine Ausnahme auslösen, während der nächste den Wert erfolgreich initialisiert.</span><span class="sxs-lookup"><span data-stu-id="880e5-241">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="880e5-242"><xref:System.Threading.ThreadLocal%601> initialisiert seinen umschlossenen Typ mit dem Standardwert des Typs, wenn kein Initialisierungsdelegat bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="880e5-242">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="880e5-243">In dieser Hinsicht ist <xref:System.Threading.ThreadLocal%601> mit dem <xref:System.ThreadStaticAttribute>-Attribut konsistent.</span><span class="sxs-lookup"><span data-stu-id="880e5-243">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="880e5-244">Das folgende Beispiel verdeutlicht, dass jeder auf die `ThreadLocal<int>`-Instanz zugreifende Thread eine eigene eindeutige Kopie der Daten erhält.</span><span class="sxs-lookup"><span data-stu-id="880e5-244">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="880e5-245">Threadlokale Variablen in Parallel.For und ForEach</span><span class="sxs-lookup"><span data-stu-id="880e5-245">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="880e5-246">Beim parallelen Durchlaufen von Datenquellen mit den Methoden <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> oder <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> können Sie Überladungen mit integrierter Unterstützung für threadlokale Daten verwenden.</span><span class="sxs-lookup"><span data-stu-id="880e5-246">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="880e5-247">Bei diesen Methoden wird die Threadlokalität mithilfe von lokalen Delegaten erzielt, um die Daten zu erstellen, auf sie zuzugreifen und sie zu bereinigen.</span><span class="sxs-lookup"><span data-stu-id="880e5-247">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="880e5-248">Weitere Informationen finden Sie unter [How to: Write a Parallel.For Loop with Thread-Local Variables (Vorgehensweise: Schreiben einer Parallel.For-Schleife mit threadlokalen Variablen)](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) und [How to: Write a Parallel.ForEach Loop with Partition-Local Variables (Vorgehensweise: Schreiben einer Parallel.ForEach-Schleife mit partitionslokalen Variablen)](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="880e5-248">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="880e5-249">Verwenden der verzögerten Initialisierung für Szenarios mit geringem Mehraufwand</span><span class="sxs-lookup"><span data-stu-id="880e5-249">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="880e5-250">In Szenarios mit einer großen Anzahl von Objekten, die verzögert initialisiert werden sollen, würde das Umschließen jedes einzelnen Objekts mit einem <xref:System.Lazy%601> möglicherweise zu viel Arbeitsspeicher oder zu viele Computerressourcen erfordern.</span><span class="sxs-lookup"><span data-stu-id="880e5-250">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="880e5-251">Möglicherweise bestehen auch strenge Anforderungen an die Art, wie die verzögerte Initialisierung verfügbar gemacht wird.</span><span class="sxs-lookup"><span data-stu-id="880e5-251">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="880e5-252">In diesen Fällen können Sie die `static`-Methoden (`Shared` in Visual Basic) der <xref:System.Threading.LazyInitializer?displayProperty=nameWithType>-Klasse zur Initialisierung jedes Objekts verwenden, ohne es mit einer Instanz von <xref:System.Lazy%601> zu umschließen.</span><span class="sxs-lookup"><span data-stu-id="880e5-252">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="880e5-253">Im folgenden Beispiel wird angenommen, dass einzelne `Order`-Objekte nur nach Bedarf verzögert initialisiert werden, anstatt ein ganzes `Orders`-Objekt mit einem <xref:System.Lazy%601>-Objekt zu umschließen.</span><span class="sxs-lookup"><span data-stu-id="880e5-253">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="880e5-254">Beachten Sie, dass in diesem Beispiel die Initialisierungsprozedur bei jeder Iteration der Schleife aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="880e5-254">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="880e5-255">In Multithreadszenarios ist der erste Thread, der die Initialisierungsprozedur aufruft, derjenige, dessen Wert für alle Threads sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="880e5-255">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="880e5-256">Zwar rufen auch spätere Threads die Initialisierungsprozedur auf, doch werden ihre Ergebnisse nicht verwendet.</span><span class="sxs-lookup"><span data-stu-id="880e5-256">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="880e5-257">Ist diese Art von potenzieller Racebedingung nicht akzeptabel, verwenden Sie die Überladung von <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType>, die ein boolesches Argument und ein Synchronisierungsobjekt erfordert.</span><span class="sxs-lookup"><span data-stu-id="880e5-257">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="880e5-258">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="880e5-258">See also</span></span>

- [<span data-ttu-id="880e5-259">Grundlagen des verwalteten Threadings</span><span class="sxs-lookup"><span data-stu-id="880e5-259">Managed Threading Basics</span></span>](../../standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="880e5-260">Threads and Threading (Threads und Threading)</span><span class="sxs-lookup"><span data-stu-id="880e5-260">Threads and Threading</span></span>](../../standard/threading/threads-and-threading.md)
- [<span data-ttu-id="880e5-261">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="880e5-261">Task Parallel Library (TPL)</span></span>](../../standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="880e5-262">Vorgehensweise: Verzögerte Initialisierung von Objekten</span><span class="sxs-lookup"><span data-stu-id="880e5-262">How to: Perform Lazy Initialization of Objects</span></span>](how-to-perform-lazy-initialization-of-objects.md)
