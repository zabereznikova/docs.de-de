---
title: Verzögerte Initialisierung
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
ms.openlocfilehash: 4f2b585dded6e20bb604f623217c6d1f1505c097
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/12/2020
ms.locfileid: "79180569"
---
# <a name="lazy-initialization"></a><span data-ttu-id="a6d4f-102">Verzögerte Initialisierung</span><span class="sxs-lookup"><span data-stu-id="a6d4f-102">Lazy Initialization</span></span>
<span data-ttu-id="a6d4f-103">*Verzögerte Initialisierung* eines Objekts bedeutet, dass seine Erstellung bis zur ersten Verwendung verzögert wird.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-103">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="a6d4f-104">(Für dieses Thema sind die Begriffe *verzögerte Initialisierung* und *verzögerte Instanziierung* gleichbedeutend.) Die verzögerte Initialisierung wird in erster Linie verwendet, um die Leistung zu verbessern, verschwenderische Berechnungen zu vermeiden und den Programmspeicherbedarf zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-104">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="a6d4f-105">Die folgenden Szenarios sind die häufigsten:</span><span class="sxs-lookup"><span data-stu-id="a6d4f-105">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="a6d4f-106">Sie verfügen über ein Objekt, dessen Erstellung teuer ist und das möglicherweise nicht vom Programm verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-106">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="a6d4f-107">Angenommen, in Ihrem Speicher befindet sich ein `Customer`-Objekt mit einer `Orders`-Eigenschaft, die ein großes Array aus `Order`-Objekten enthält, das zur Initialisierung eine Datenbankverbindung benötigt.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-107">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="a6d4f-108">Fordert der Benutzer nie die Anzeige des Orders-Objekts oder die Verwendung der Daten in einer Berechnung an, ist es nicht notwendig, Systemspeicher oder Berechnungszyklen für seine Erstellung zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-108">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="a6d4f-109">Systemressourcen können geschont werden, wenn Sie die verzögerte Initialisierung für das `Orders`-Objekt mithilfe von `Lazy<Orders>` deklarieren, solange das Objekt nicht verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-109">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="a6d4f-110">Sie verfügen über ein Objekt, dessen Erstellung teuer ist und das daher erst erstellt werden soll, wenn andere teure Vorgänge abgeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-110">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="a6d4f-111">Angenommen, das Programm lädt beim Start mehrere Objektinstanzen, von denen allerdings nur einige sofort benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-111">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="a6d4f-112">Hier kann die Startleistung des Programms verbessert werden, indem die Initialisierung der nicht benötigten Objekte verzögert wird, bis die benötigten Objekte erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-112">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="a6d4f-113">Sie können für die verzögerte Initialisierung Ihren eigenen Code schreiben. Es ist jedoch empfehlenswert, stattdessen <xref:System.Lazy%601> zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-113">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="a6d4f-114"><xref:System.Lazy%601> und die zugehörigen verwandten Typen unterstützen auch die Threadsicherheit und stellen eine konsistente Richtlinie zur Ausnahmeweitergabe bereit.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-114"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="a6d4f-115">In der folgenden Tabelle werden die Typen aufgelistet, die .NET Framework Version 4 bereitstellt, um die verzögerte Initialisierung in verschiedenen Szenarios zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-115">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="a6d4f-116">type</span><span class="sxs-lookup"><span data-stu-id="a6d4f-116">Type</span></span>|<span data-ttu-id="a6d4f-117">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="a6d4f-117">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="a6d4f-118">Eine Wrapperklasse, die die Semantik für verzögerte Initialisierung für jeden Klassenbibliotheks- oder benutzerdefinierten Typ bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-118">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="a6d4f-119">Ähnlich wie <xref:System.Lazy%601>, außer dass die Semantik für verzögerte Initialisierung threadlokal bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-119">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="a6d4f-120">Jeder Thread hat Zugriff auf seinen eigenen eindeutigen Wert.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-120">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="a6d4f-121">Stellt erweiterte `static`-Methoden (`Shared` in Visual Basic) für die verzögerte Initialisierung von Objekten bereit ohne den Mehraufwand einer Klasse.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-121">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="a6d4f-122">Grundlegende verzögerte Initialisierung</span><span class="sxs-lookup"><span data-stu-id="a6d4f-122">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="a6d4f-123">Verwenden Sie `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic) wie in folgendem Beispiel gezeigt, um einen Typ mit verzögerter Initialisierung, z.B. `MyType`, zu definieren.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-123">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="a6d4f-124">Wird im <xref:System.Lazy%601>-Konstruktor kein Delegat übergeben, wird der umschlossene Typ mithilfe von <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> beim ersten Zugriff auf die Value-Eigenschaft erstellt.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-124">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="a6d4f-125">Wenn der Typ keinen parameterlosen Konstruktor hat, wird eine Laufzeitausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-125">If the type does not have a parameterless constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="a6d4f-126">Im folgenden Beispiel wird angenommen, dass `Orders` eine Klasse mit einem Array aus `Order`-Objekten ist, die aus einer Datenbank abgerufen wurden.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-126">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="a6d4f-127">Ein `Customer`-Objekt enthält eine Instanz von `Orders`, je nach Benutzeraktion werden die Daten aus dem `Orders`-Objekt jedoch möglicherweise nicht benötigt.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-127">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="a6d4f-128">Sie können im <xref:System.Lazy%601>-Konstruktor auch einen Delegaten übergeben, der bei der Erstellung eine bestimmte Konstruktorüberladung für den umschlossenen Typ aufruft. Außerdem können Sie die weiteren erforderlichen Initialisierungsschritte wie im folgenden Beispiel gezeigt ausführen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-128">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="a6d4f-129">Nachdem das Lazy-Objekt erstellt wurde, wird erst eine Instanz von `Orders` erstellt, wenn auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft der Lazy-Variable zum ersten Mal zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-129">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="a6d4f-130">Beim ersten Zugriff wird der umschlossene Typ erstellt, zurückgegeben und für einen späteren Zugriff gespeichert.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-130">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="a6d4f-131">Ein <xref:System.Lazy%601>-Objekt gibt immer das gleiche Objekt oder den gleichen Wert zurück, mit dem es initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-131">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="a6d4f-132">Daher besitzt die <xref:System.Lazy%601.Value%2A>-Eigenschaft nur einen Lesezugriff.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-132">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="a6d4f-133">Wenn <xref:System.Lazy%601.Value%2A> einen Verweistyp speichert, können Sie ihm kein neues Objekt zuweisen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-133">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="a6d4f-134">(Sie können jedoch den Wert der festsetzbaren öffentlichen Felder und Eigenschaften ändern.) Wenn <xref:System.Lazy%601.Value%2A> ein Werttyp gespeichert wird, können Sie dessen Wert nicht ändern.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-134">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="a6d4f-135">Sie können jedoch eine neue Variable erstellen, indem Sie den Variablenkonstruktor erneut mit neuen Argumenten aufrufen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-135">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="a6d4f-136">Die neue verzögerte Instanz instanziiert das `Orders`-Objekt wie die vorherige erst, wenn auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft erstmals zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-136">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="a6d4f-137">Threadsichere Initialisierung</span><span class="sxs-lookup"><span data-stu-id="a6d4f-137">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="a6d4f-138">Standardmäßig sind <xref:System.Lazy%601>-Objekte threadsicher.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-138">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="a6d4f-139">Wird im Konstruktor die Art der Threadsicherheit nicht angegeben, sind die erstellten <xref:System.Lazy%601>-Objekte daher threadsicher.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-139">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="a6d4f-140">In Multithreadszenarios initialisiert der erste Thread, der auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft eines threadsicheren <xref:System.Lazy%601>-Objekts zugreift, die Eigenschaft für jeden nachfolgenden Zugriff auf allen Threads. Alle Threads nutzen dieselben Daten.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-140">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="a6d4f-141">Daher spielt es keine Rolle, welcher Thread das Objekt initialisiert. Auch Racebedingungen haben keine Auswirkung.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-141">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="a6d4f-142">Diese Konsistenz kann durch das Zwischenspeichern von Ausnahmen auf Fehlerbedingungen erweitert werden.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-142">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="a6d4f-143">Weitere Informationen finden Sie im folgenden Abschnitt [Ausnahmen bei verzögerten Objekten](lazy-initialization.md#ExceptionsInLazyObjects).</span><span class="sxs-lookup"><span data-stu-id="a6d4f-143">For more information, see the next section, [Exceptions in Lazy Objects](lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="a6d4f-144">Das folgende Beispiel verdeutlicht, dass die gleiche `Lazy<int>`-Instanz über den gleichen Wert für drei separate Threads verfügt.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-144">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="a6d4f-145">Wenn Sie separate Daten für jeden Thread benötigen, verwenden Sie wie weiter unten beschrieben den <xref:System.Threading.ThreadLocal%601>-Typ.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-145">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="a6d4f-146">Einige <xref:System.Lazy%601>-Konstruktoren verfügen über einen booleschen Parameter mit dem Namen `isThreadSafe`, der angibt, ob auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft von mehreren Threads zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-146">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="a6d4f-147">Wenn Sie von nur einem Thread auf die Eigenschaft zugreifen möchten, übergeben Sie `false` für einen moderaten Leistungsvorteil.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-147">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="a6d4f-148">Wenn Sie von mehreren Threads auf die Eigenschaft zugreifen möchten, übergeben Sie `true`, um die <xref:System.Lazy%601>-Instanz anzuweisen, die Racebedingungen ordnungsgemäß zu behandeln, von denen ein Thread bei der Initialisierung eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-148">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="a6d4f-149">Einige <xref:System.Lazy%601>-Konstruktoren verfügen über einen <xref:System.Threading.LazyThreadSafetyMode>-Parameter mit dem Namen `mode`.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-149">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="a6d4f-150">Diese Konstruktoren stellen einen zusätzlichen Threadsicherheitsmodus bereit.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-150">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="a6d4f-151">Entnehmen Sie der folgenden Tabelle, wie die Threadsicherheit eines <xref:System.Lazy%601>-Objekts von den Konstruktorparametern beeinflusst wird, die die Threadsicherheit angeben.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-151">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="a6d4f-152">Jeder Konstruktor verfügt über höchstens einen solchen Parameter.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-152">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="a6d4f-153">Threadsicherheit des Objekts</span><span class="sxs-lookup"><span data-stu-id="a6d4f-153">Thread safety of the object</span></span>|<span data-ttu-id="a6d4f-154">`LazyThreadSafetyMode``mode` Parameter</span><span class="sxs-lookup"><span data-stu-id="a6d4f-154">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="a6d4f-155">Boolescher Parameter `isThreadSafe`</span><span class="sxs-lookup"><span data-stu-id="a6d4f-155">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="a6d4f-156">Keine Threadsicherheitsparameter</span><span class="sxs-lookup"><span data-stu-id="a6d4f-156">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="a6d4f-157">Vollständig threadsicher; nur ein Thread versucht jeweils, den Wert zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-157">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="a6d4f-158">Ja.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-158">Yes.</span></span>|  
|<span data-ttu-id="a6d4f-159">Nicht threadsicher.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-159">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="a6d4f-160">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="a6d4f-160">Not applicable.</span></span>|  
|<span data-ttu-id="a6d4f-161">Vollständig threadsicher; Threads befinden sich im Race, um den Wert zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-161">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="a6d4f-162">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="a6d4f-162">Not applicable.</span></span>|<span data-ttu-id="a6d4f-163">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="a6d4f-163">Not applicable.</span></span>|  
  
 <span data-ttu-id="a6d4f-164">Die Tabelle verdeutlicht, dass die Angabe von <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für den `mode`-Parameter der Angabe von `true` für den `isThreadSafe`-Parameter entspricht, ebenso wie die Angabe von <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> der Angabe von `false`.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-164">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="a6d4f-165">Die Angabe von <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> ermöglicht mehreren Threads, die Initialisierung der <xref:System.Lazy%601>-Instanz zu versuchen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-165">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="a6d4f-166">Nur ein Thread kann unter dieser Racebedingung gewinnen. Alle anderen Threads empfangen den Wert, der vom erfolgreichen Thread initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-166">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="a6d4f-167">Wird während der Initialisierung für einen Thread eine Ausnahme ausgelöst, empfängt dieser Thread nicht den vom erfolgreichen Thread festgelegten Wert.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-167">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="a6d4f-168">Da Ausnahmen nicht zwischengespeichert werden, kann ein nachfolgender Versuch, auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft zuzugreifen, zu einer erfolgreichen Initialisierung führen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-168">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="a6d4f-169">Darin besteht ein Unterschied zur Behandlung von Ausnahmen in anderen Modi, die im folgenden Abschnitt beschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-169">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="a6d4f-170">Weitere Informationen finden Sie unter der <xref:System.Threading.LazyThreadSafetyMode>-Enumeration.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-170">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="a6d4f-171">Ausnahmen bei verzögerten Objekten</span><span class="sxs-lookup"><span data-stu-id="a6d4f-171">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="a6d4f-172">Wie weiter oben erwähnt gibt ein <xref:System.Lazy%601>-Objekt immer das gleiche Objekt oder den gleichen Wert zurück, mit dem es initialisiert wurde. Daher verfügt die <xref:System.Lazy%601.Value%2A>-Eigenschaft nur über einen Lesezugriff.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-172">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="a6d4f-173">Wird das Zwischenspeichern von Ausnahmen aktiviert, wird diese Unveränderlichkeit auch auf das Ausnahmeverhalten erweitert.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-173">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="a6d4f-174">Wenn für ein lazy-initialisiertes Objekt die Ausnahmezwischenspeicherung aktiviert ist <xref:System.Lazy%601.Value%2A> und beim ersten Zugriff auf die Eigenschaft eine <xref:System.Lazy%601.Value%2A> Ausnahme von der Initialisierungsmethode ausgelöst wird, wird dieselbe Ausnahme bei jedem nachfolgenden Versuch, auf die Eigenschaft zuzugreifen, ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-174">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="a6d4f-175">Anders ausgedrückt wird der Konstruktor des umschlossenen Typs selbst in Multithreadszenarios niemals erneut aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-175">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="a6d4f-176">Aus diesem Grund kann das <xref:System.Lazy%601>-Objekt nicht bei einem Zugriff eine Ausnahme auslösen und bei einem nachfolgenden Zugriff einen Wert zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-176">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="a6d4f-177">Das Zwischenspeichern von Ausnahmen wird bei der Verwendung eines beliebigen <xref:System.Lazy%601?displayProperty=nameWithType>-Konstruktors aktiviert, der eine Initialisierungsmethode erfordert (`valueFactory`-Parameter). So wird es beispielsweise aktiviert, wenn Sie den `Lazy(T)(Func(T))`-Konstruktor verwenden.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-177">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="a6d4f-178">Erfordert der Konstruktor auch einen <xref:System.Threading.LazyThreadSafetyMode>-Wert (`mode`-Parameter), geben Sie <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> oder <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> an.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-178">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a6d4f-179">Durch die Angabe einer Initialisierungsmethode wird das Zwischenspeichern von Ausnahmen für diese beiden Modi aktiviert.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-179">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="a6d4f-180">Die Initialisierungsmethode kann sehr einfach sein.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-180">The initialization method can be very simple.</span></span> <span data-ttu-id="a6d4f-181">Es kann z. B. den `T`parameterlosen Konstruktor für : `new Lazy<Contents>(() => new Contents(), mode)` in C- oder `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic aufrufen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-181">For example, it might call the parameterless constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="a6d4f-182">Wenn Sie einen <xref:System.Lazy%601?displayProperty=nameWithType>-Konstruktor verwenden, der keine Initialisierungsmethode angibt, werden vom parameterlosen Konstruktor für `T` ausgelöste Ausnahmen nicht zwischengespeichert.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-182">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the parameterless constructor for `T` are not cached.</span></span> <span data-ttu-id="a6d4f-183">Weitere Informationen finden Sie unter der <xref:System.Threading.LazyThreadSafetyMode>-Enumeration.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-183">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="a6d4f-184">Wenn der `isThreadSafe`-Konstruktorparameter beim Erstellen eines <xref:System.Lazy%601>-Objekts auf `false` festgelegt ist oder der `mode`-Konstruktorparameter auf <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, müssen Sie auf das <xref:System.Lazy%601>-Objekt von einem einzelnen Thread zugreifen oder eine eigene Synchronisierung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-184">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="a6d4f-185">Dies gilt für alle Aspekte des Objekts, einschließlich dem Zwischenspeichern von Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-185">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="a6d4f-186">Wie im vorherigen Abschnitt erwähnt, behandeln durch Angabe von <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> erstellte <xref:System.Lazy%601>-Objekte Ausnahmen unterschiedlich.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-186">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="a6d4f-187">Mit <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> können mehrere Threads um die Initialisierung der <xref:System.Lazy%601>-Instanz konkurrieren.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-187">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="a6d4f-188">In diesem Fall werden Ausnahmen nicht zwischengespeichert. Die Versuche, auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft zuzugreifen, können fortgesetzt werden, bis die Initialisierung erfolgreich ist.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-188">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="a6d4f-189">In der folgenden Tabelle werden die Steuerungsmethoden für das Zwischenspeichern von Ausnahmen durch <xref:System.Lazy%601>-Konstruktoren zusammengefasst.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-189">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="a6d4f-190">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="a6d4f-190">Constructor</span></span>|<span data-ttu-id="a6d4f-191">Threadsicherheitsmodus</span><span class="sxs-lookup"><span data-stu-id="a6d4f-191">Thread safety mode</span></span>|<span data-ttu-id="a6d4f-192">Verwendet die Initialisierungsmethode</span><span class="sxs-lookup"><span data-stu-id="a6d4f-192">Uses initialization method</span></span>|<span data-ttu-id="a6d4f-193">Ausnahmen werden zwischengespeichert</span><span class="sxs-lookup"><span data-stu-id="a6d4f-193">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="a6d4f-194">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="a6d4f-194">Lazy(T)()</span></span>|<span data-ttu-id="a6d4f-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="a6d4f-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="a6d4f-196">Nein </span><span class="sxs-lookup"><span data-stu-id="a6d4f-196">No</span></span>|<span data-ttu-id="a6d4f-197">Nein </span><span class="sxs-lookup"><span data-stu-id="a6d4f-197">No</span></span>|  
|<span data-ttu-id="a6d4f-198">Lazy(T)(Func(T))</span><span class="sxs-lookup"><span data-stu-id="a6d4f-198">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="a6d4f-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="a6d4f-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="a6d4f-200">Ja</span><span class="sxs-lookup"><span data-stu-id="a6d4f-200">Yes</span></span>|<span data-ttu-id="a6d4f-201">Ja</span><span class="sxs-lookup"><span data-stu-id="a6d4f-201">Yes</span></span>|  
|<span data-ttu-id="a6d4f-202">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="a6d4f-202">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="a6d4f-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) oder `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="a6d4f-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="a6d4f-204">Nein </span><span class="sxs-lookup"><span data-stu-id="a6d4f-204">No</span></span>|<span data-ttu-id="a6d4f-205">Nein </span><span class="sxs-lookup"><span data-stu-id="a6d4f-205">No</span></span>|  
|<span data-ttu-id="a6d4f-206">Lazy(T)(Func(T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="a6d4f-206">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="a6d4f-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) oder `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="a6d4f-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="a6d4f-208">Ja</span><span class="sxs-lookup"><span data-stu-id="a6d4f-208">Yes</span></span>|<span data-ttu-id="a6d4f-209">Ja</span><span class="sxs-lookup"><span data-stu-id="a6d4f-209">Yes</span></span>|  
|<span data-ttu-id="a6d4f-210">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="a6d4f-210">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="a6d4f-211">Vom Benutzer angegeben</span><span class="sxs-lookup"><span data-stu-id="a6d4f-211">User-specified</span></span>|<span data-ttu-id="a6d4f-212">Nein </span><span class="sxs-lookup"><span data-stu-id="a6d4f-212">No</span></span>|<span data-ttu-id="a6d4f-213">Nein </span><span class="sxs-lookup"><span data-stu-id="a6d4f-213">No</span></span>|  
|<span data-ttu-id="a6d4f-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="a6d4f-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="a6d4f-215">Vom Benutzer angegeben</span><span class="sxs-lookup"><span data-stu-id="a6d4f-215">User-specified</span></span>|<span data-ttu-id="a6d4f-216">Ja</span><span class="sxs-lookup"><span data-stu-id="a6d4f-216">Yes</span></span>|<span data-ttu-id="a6d4f-217">Nein, wenn der Benutzer <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> angibt; andernfalls ja.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-217">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="a6d4f-218">Implementieren einer Eigenschaft mit verzögerter Initialisierung</span><span class="sxs-lookup"><span data-stu-id="a6d4f-218">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="a6d4f-219">Definieren Sie zum Implementieren einer öffentlichen Eigenschaft mit der verzögerten Initialisierung das Unterstützungsfeld der Eigenschaft als <xref:System.Lazy%601>, und geben Sie die <xref:System.Lazy%601.Value%2A>-Eigenschaft des `get`-Accessors der Eigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-219">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="a6d4f-220">Die <xref:System.Lazy%601.Value%2A>-Eigenschaft besitzt nur Lesezugriff. Daher verfügt die Eigenschaft, die sie verfügbar macht, über keinen `set`-Accessor.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-220">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="a6d4f-221">Ist eine Lese-/Schreibeigenschaft erforderlich, die durch ein <xref:System.Lazy%601>-Objekt gesichert wird, muss der `set`-Accessor ein neues <xref:System.Lazy%601>-Objekt erstellen und dem Sicherungsspeicher zuweisen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-221">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="a6d4f-222">Der `set`-Accessor muss einen Lambdaausdruck erstellen, der den an den `set`-Accessor übergebenen neuen Eigenschaftswert zurückgibt. Dieser Lambdaausdruck muss anschließend an den Konstruktor für das neue <xref:System.Lazy%601>-Objekt übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-222">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="a6d4f-223">Der nächste Zugriff auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft führt zur Initialisierung des neuen <xref:System.Lazy%601>. Die zugehörige <xref:System.Lazy%601.Value%2A>-Eigenschaft gibt danach den neuen Wert zurück, der der Eigenschaft zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-223">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="a6d4f-224">Der Grund für diese komplizierte Gestaltung besteht darin, dass der in <xref:System.Lazy%601> integrierte Multithreadingschutz beibehalten werden soll.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-224">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="a6d4f-225">Andernfalls müssten die Eigenschaftenaccessoren den ersten von der <xref:System.Lazy%601.Value%2A>-Eigenschaft zurückgegebenen Wert zwischenspeichern und nur den zwischengespeicherten Wert ändern. Dafür müssten Sie Ihren eigenen threadsicheren Code schreiben.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-225">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="a6d4f-226">Aufgrund der zusätzlichen Initialisierungen, die von einer durch ein <xref:System.Lazy%601>-Objekt gesicherten Lese-/Schreibeigenschaft angefordert werden, ist die Leistung möglicherweise nicht akzeptabel.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-226">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="a6d4f-227">Darüber hinaus kann je nach Szenario eine zusätzliche Koordinierung erforderlich sein, um Racebedingungen zwischen Setter und Getter zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-227">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="a6d4f-228">Threadlokale verzögerte Initialisierung</span><span class="sxs-lookup"><span data-stu-id="a6d4f-228">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="a6d4f-229">In einigen Multithreadszenarios möchten Sie jedem Thread möglicherweise eigene private Daten zuweisen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-229">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="a6d4f-230">Diese Daten werden *threadlokale Daten* genannt.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-230">Such data is called *thread-local data*.</span></span> <span data-ttu-id="a6d4f-231">Bis .NET Framework Version 3.5 konnte das `ThreadStatic`-Attribut auf eine statische Variable angewendet werden, um aus ihr eine threadlokale Variable zu machen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-231">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="a6d4f-232">Die Anwendung des `ThreadStatic`-Attributs kann jedoch geringfügige Fehler verursachen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-232">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="a6d4f-233">Selbst grundlegende Initialisierungsanweisungen führen z.B. dazu, dass die Variable wie im folgenden Beispiel gezeigt nur für den ersten Thread initialisiert wird, der auf sie zugreift.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-233">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="a6d4f-234">Für alle anderen Threads wird die Variable mit ihrem Standardwert (0) initialisiert.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-234">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="a6d4f-235">In .NET Framework Version 4 kann der <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>-Typ alternativ dazu zum Erstellen einer instanzbasierten, threadlokalen Variable verwendet werden, die für alle Threads mit dem von Ihnen bereitgestellten <xref:System.Action%601>-Delegaten initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-235">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="a6d4f-236">Im folgenden Beispiel erhalten alle Threads, die auf `counter` zugreifen, den Startwert 1.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-236">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="a6d4f-237"><xref:System.Threading.ThreadLocal%601> umschließt sein Objekt auf fast die gleiche Weise wie <xref:System.Lazy%601>, mit folgenden entscheidenden Unterschieden:</span><span class="sxs-lookup"><span data-stu-id="a6d4f-237"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="a6d4f-238">Jeder Thread initialisiert die threadlokale Variable mit seinen eigenen privaten Daten, auf die von anderen Threads nicht zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-238">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="a6d4f-239">Die <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType>-Eigenschaft verfügt über Lese-/Schreibzugriff und kann beliebig oft geändert werden.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-239">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="a6d4f-240">Dies kann sich auf die Ausnahmeweitergabe auswirken: So kann ein `get`-Vorgang z.B. eine Ausnahme auslösen, während der nächste den Wert erfolgreich initialisiert.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-240">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="a6d4f-241"><xref:System.Threading.ThreadLocal%601> initialisiert seinen umschlossenen Typ mit dem Standardwert des Typs, wenn kein Initialisierungsdelegat bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-241">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="a6d4f-242">In dieser Hinsicht ist <xref:System.Threading.ThreadLocal%601> mit dem <xref:System.ThreadStaticAttribute>-Attribut konsistent.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-242">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="a6d4f-243">Das folgende Beispiel verdeutlicht, dass jeder auf die `ThreadLocal<int>`-Instanz zugreifende Thread eine eigene eindeutige Kopie der Daten erhält.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-243">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="a6d4f-244">Threadlokale Variablen in Parallel.For und ForEach</span><span class="sxs-lookup"><span data-stu-id="a6d4f-244">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="a6d4f-245">Beim parallelen Durchlaufen von Datenquellen mit den Methoden <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> oder <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> können Sie Überladungen mit integrierter Unterstützung für threadlokale Daten verwenden.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-245">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="a6d4f-246">Bei diesen Methoden wird die Threadlokalität mithilfe von lokalen Delegaten erzielt, um die Daten zu erstellen, auf sie zuzugreifen und sie zu bereinigen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-246">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="a6d4f-247">Weitere Informationen finden Sie unter [How to: Write a Parallel.For Loop with Thread-Local Variables (Vorgehensweise: Schreiben einer Parallel.For-Schleife mit threadlokalen Variablen)](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) und [How to: Write a Parallel.ForEach Loop with Partition-Local Variables (Vorgehensweise: Schreiben einer Parallel.ForEach-Schleife mit partitionslokalen Variablen)](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="a6d4f-247">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="a6d4f-248">Verwenden der verzögerten Initialisierung für Szenarios mit geringem Mehraufwand</span><span class="sxs-lookup"><span data-stu-id="a6d4f-248">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="a6d4f-249">In Szenarios mit einer großen Anzahl von Objekten, die verzögert initialisiert werden sollen, würde das Umschließen jedes einzelnen Objekts mit einem <xref:System.Lazy%601> möglicherweise zu viel Arbeitsspeicher oder zu viele Computerressourcen erfordern.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-249">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="a6d4f-250">Möglicherweise bestehen auch strenge Anforderungen an die Art, wie die verzögerte Initialisierung verfügbar gemacht wird.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-250">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="a6d4f-251">In diesen Fällen können Sie die `static`-Methoden (`Shared` in Visual Basic) der <xref:System.Threading.LazyInitializer?displayProperty=nameWithType>-Klasse zur Initialisierung jedes Objekts verwenden, ohne es mit einer Instanz von <xref:System.Lazy%601> zu umschließen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-251">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="a6d4f-252">Im folgenden Beispiel wird angenommen, dass einzelne `Order`-Objekte nur nach Bedarf verzögert initialisiert werden, anstatt ein ganzes `Orders`-Objekt mit einem <xref:System.Lazy%601>-Objekt zu umschließen.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-252">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="a6d4f-253">Beachten Sie, dass in diesem Beispiel die Initialisierungsprozedur bei jeder Iteration der Schleife aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-253">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="a6d4f-254">In Multithreadszenarios ist der erste Thread, der die Initialisierungsprozedur aufruft, derjenige, dessen Wert für alle Threads sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-254">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="a6d4f-255">Zwar rufen auch spätere Threads die Initialisierungsprozedur auf, doch werden ihre Ergebnisse nicht verwendet.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-255">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="a6d4f-256">Ist diese Art von potenzieller Racebedingung nicht akzeptabel, verwenden Sie die Überladung von <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType>, die ein boolesches Argument und ein Synchronisierungsobjekt erfordert.</span><span class="sxs-lookup"><span data-stu-id="a6d4f-256">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a6d4f-257">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="a6d4f-257">See also</span></span>

- [<span data-ttu-id="a6d4f-258">Grundlagen des verwalteten Threadings</span><span class="sxs-lookup"><span data-stu-id="a6d4f-258">Managed Threading Basics</span></span>](../../standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="a6d4f-259">Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="a6d4f-259">Threads and Threading</span></span>](../../standard/threading/threads-and-threading.md)
- [<span data-ttu-id="a6d4f-260">Task Parallel Library (TPL)</span><span class="sxs-lookup"><span data-stu-id="a6d4f-260">Task Parallel Library (TPL)</span></span>](../../standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="a6d4f-261">How to: Perform Lazy Initialization of Objects (Vorgehensweise: Verzögerte Initialisierung von Objekten)</span><span class="sxs-lookup"><span data-stu-id="a6d4f-261">How to: Perform Lazy Initialization of Objects</span></span>](how-to-perform-lazy-initialization-of-objects.md)
