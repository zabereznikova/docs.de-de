---
title: Markieren von Routingereignissen als behandelt und Klassenbehandlung
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 55ed91a848ce69fa6ce3e69a654a56d7875912b5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401040"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a><span data-ttu-id="a2d4d-102">Markieren von Routingereignissen als behandelt und Klassenbehandlung</span><span class="sxs-lookup"><span data-stu-id="a2d4d-102">Marking Routed Events as Handled, and Class Handling</span></span>
<span data-ttu-id="a2d4d-103">Handler für ein Routingereignis können das Ereignis innerhalb der Ereignisdaten als behandelt markieren.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-103">Handlers for a routed event can mark the event handled within the event data.</span></span> <span data-ttu-id="a2d4d-104">Das Behandeln des Ereignisses verkürzt die Route.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-104">Handling the event will effectively shorten the route.</span></span> <span data-ttu-id="a2d4d-105">Die Klassenbehandlung ist ein Programmierkonzept, das von Routingereignissen unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-105">Class handling is a programming concept that is supported by routed events.</span></span> <span data-ttu-id="a2d4d-106">Ein Klassenhandler hat die Möglichkeit, ein bestimmtes Routingereignis auf Klassenebene mit einem Ereignishandler zu verarbeiten, der vor jedem Instanzenhandler auf jeder Instanz der Klasse aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-106">A class handler has the opportunity to handle a particular routed event at a class level with a handler that is invoked before any instance handler on any instance of the class.</span></span>  

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="a2d4d-107">Voraussetzungen</span><span class="sxs-lookup"><span data-stu-id="a2d4d-107">Prerequisites</span></span>  
 <span data-ttu-id="a2d4d-108">In diesem Thema werden unter [Übersicht über Routingereignisse](routed-events-overview.md) eingeführte Konzepte näher erläutert.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-108">This topic elaborates on concepts introduced in the [Routed Events Overview](routed-events-overview.md).</span></span>  
  
<a name="When_to_Mark_Events_as_Handled"></a>
## <a name="when-to-mark-events-as-handled"></a><span data-ttu-id="a2d4d-109">Markieren von Ereignissen als behandelt</span><span class="sxs-lookup"><span data-stu-id="a2d4d-109">When to Mark Events as Handled</span></span>  
 <span data-ttu-id="a2d4d-110">Wenn Sie den Wert <xref:System.Windows.RoutedEventArgs.Handled%2A> der `true` Eigenschaft in den Ereignisdaten für ein routingiertes Ereignis festlegen, wird dies als "Markieren des behandelten Ereignisses" bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-110">When you set the value of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data for a routed event, this is referred to as "marking the event handled".</span></span> <span data-ttu-id="a2d4d-111">Es gibt keine absolute Regel dafür, wann Sie Routingereignisse als Anwendungsentwickler oder als Autor von Steuerelementen, der auf vorhandenen Routingereignisse reagiert oder neue Routingereignisse implementiert, als behandelt markieren sollten.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-111">There is no absolute rule for when you should mark routed events as handled, either as an application author, or as a control author who responds to existing routed events or implements new routed events.</span></span> <span data-ttu-id="a2d4d-112">Das Konzept des "behandelt" in den Ereignisdaten des gerouteten Ereignisses sollte größtenteils als begrenztes Protokoll für die Antworten Ihrer eigenen [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Anwendung auf die verschiedenen gerouteten Ereignisse verwendet werden, die in APIs verfügbar gemacht werden, sowie für alle benutzerdefinierten gerouteten Ereignisse.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-112">For the most part, the concept of "handled" as carried in the routed event's event data should be used as a limited protocol for your own application's responses to the various routed events exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs as well as for any custom routed events.</span></span> <span data-ttu-id="a2d4d-113">Eine weitere Möglichkeit, das Problem als „behandelt“ zu markieren ist, wenn Code auf eine Weise signifikant und relativ vollständig auf das Routingereignis geantwortet hat.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-113">Another way to consider the "handled" issue is that you should generally mark a routed event handled if your code responded to the routed event in a significant and relatively complete way.</span></span> <span data-ttu-id="a2d4d-114">In der Regel sollte es nicht mehr als eine signifikante Antwort geben, die separate Handlerimplementierungen für Routingereignisse erfordern muss.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-114">Typically, there should not be more than one significant response that requires separate handler implementations for any single routed event occurrence.</span></span> <span data-ttu-id="a2d4d-115">Wenn mehr Antworten erforderlich sind, sollte der erforderliche Code über Anwendungslogik implementiert werden, die in einem einzelnen Handler, nicht mithilfe des Weiterleitungssystems des Routingereignisses verkettet ist.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-115">If more responses are needed, then the necessary code should be implemented through application logic that is chained within a single handler rather than by using the routed event system for forwarding.</span></span> <span data-ttu-id="a2d4d-116">Das Konzept von „erheblich“ ist ebenfalls subjektiv und hängt von der Anwendung oder dem Code ab.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-116">The concept of what is "significant" is also subjective, and depends on your application or code.</span></span> <span data-ttu-id="a2d4d-117">„Signifikante Antworten“ sind z.B.: das Festlegen des Fokus, die Änderung des öffentlichen Zustands, das Festlegen von Eigenschaften, die sich auf die visuelle Darstellung auswirken, und das Auslösen neuer Ereignisse.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-117">As general guidance, some "significant response" examples include: setting focus, modifying public state, setting properties that affect the visual representation, and raising other new events.</span></span> <span data-ttu-id="a2d4d-118">Beispiele für nicht signifikante Antworten sind: die Änderung des privaten Status (mit keiner visuellen Auswirkung oder eine programmgesteuerte Darstellung), das Protokollieren von Ereignissen, oder das Anzeigen eines Ereignisses und die Wahl, nicht darauf zu reagieren.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-118">Examples of nonsignificant responses include: modifying private state (with no visual impact, or programmatic representation), logging of events, or looking at arguments of an event and choosing not to respond to it.</span></span>  
  
 <span data-ttu-id="a2d4d-119">Das Verhalten des gerouteten Ereignissystems verstärkt dieses "signifikante Antwortmodell" für die Verwendung [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] des behandelten <xref:System.Windows.UIElement.AddHandler%2A> Zustands eines gerouteten Ereignisses, da die in oder die gemeinsame Signatur von hinzugefügten Handler nicht als Reaktion auf ein geroutetes Ereignis aufgerufen werden, bei dem die Ereignisdaten bereits als behandelt markiert sind.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-119">The routed event system behavior reinforces this "significant response" model for using handled state of a routed event, because handlers added in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or the common signature of <xref:System.Windows.UIElement.AddHandler%2A> are not invoked in response to a routed event where the event data is already marked handled.</span></span> <span data-ttu-id="a2d4d-120">Sie müssen den zusätzlichen Aufwand durchlaufen, `handledEventsToo` einen Handler<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>mit der Parameterversion ( ) hinzuzufügen, um geroutete Ereignisse zu verarbeiten, die von früheren Teilnehmern der Ereignisroute behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-120">You must go through the extra effort of adding a handler with the `handledEventsToo` parameter version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) in order to handle routed events that are marked handled by earlier participants in the event route.</span></span>  
  
 <span data-ttu-id="a2d4d-121">In einigen Fällen markieren Steuerelemente selbst bestimmte Routingereignisse als behandelt.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-121">In some circumstances, controls themselves mark certain routed events as handled.</span></span> <span data-ttu-id="a2d4d-122">Mit einem behandelten Rountingereignis gibt der Autor eines [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Steuerelements zu verstehen, dass die Antwort des Steuerelements auf das Routingereignis signifikant bzw. im Rahmen der Implementierung vollständig ist und dass das Ereignis keine weitere Behandelung benötigt.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-122">A handled routed event represents a decision by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control authors that the control's actions in response to the routed event are significant or complete as part of the control implementation, and the event needs no further handling.</span></span> <span data-ttu-id="a2d4d-123">Dies erfolgt normalerweise durch Hinzufügen eines Klassenhandlers für ein Ereignis oder durch Überschreiben eines der virtuellen Klassenhandler, die in einer Basisklasse vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-123">Usually this is done by adding a class handler for an event, or by overriding one of the class handler virtuals that exist on a base class.</span></span> <span data-ttu-id="a2d4d-124">Sie können dieses Ereignisbehandlung, wenn notwendig, umgehen. Informationen dazu finden Sie weiter unten im Abschnitt [Umgehen der Ereignisunterdrückung von Steuerelementen](#WorkingAroundEventSuppressionByControls) in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-124">You can still work around this event handling if necessary; see [Working Around Event Suppression by Controls](#WorkingAroundEventSuppressionByControls) later in this topic.</span></span>  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a><span data-ttu-id="a2d4d-125">"Vorschau" (Tunneling)-Ereignisse im Vergleich zu Bubbling-Ereignissen und Ereignisbehandlung</span><span class="sxs-lookup"><span data-stu-id="a2d4d-125">"Preview" (Tunneling) Events vs. Bubbling Events, and Event Handling</span></span>  
 <span data-ttu-id="a2d4d-126">Vorschaurountingereignisse sind Ereignisse, die einer Tunnelingroute in der Elementstruktur folgen.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-126">Preview routed events are events that follow a tunneling route through the element tree.</span></span> <span data-ttu-id="a2d4d-127">Die „Vorschau“ in der Benennungskonvention weist auf das allgemeine Prinzip bei Eingabeereignissen hin, nach dem Vorschau-/ Tunneling-Routingereignisse vor den entsprechenden Bubbling-Rountingereignissen ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-127">The "Preview" expressed in the naming convention is indicative of the general principle for input events that preview (tunneling) routed events are raised prior to the equivalent bubbling routed event.</span></span> <span data-ttu-id="a2d4d-128">Außerdem haben Eingaberountingereignisse mit einem Tunneling- und einem Bubblingereignis eine andere Behandlungslogik.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-128">Also, input routed events that have a tunneling and bubbling pair have a distinct handling logic.</span></span> <span data-ttu-id="a2d4d-129">Wenn das Tunneling-/ Vorschauroutingereignis von einem Ereignislistener als behandelt markiert wurde, dann wird das Bubblingereignis als behandelt markiert, noch bevor alle Listener des Bubblingereignisses es erhalten.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-129">If the tunneling/preview routed event is marked as handled by an event listener, then the bubbling routed event will be marked handled even before any listeners of the bubbling routed event receive it.</span></span> <span data-ttu-id="a2d4d-130">Die Tunneling- und Bubblingroutingereignisse sind technisch separate Ereignisse. Sie teilen sich aber absichtlich dieselbe Ereignisdateninstanz, um dieses Verhalten zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-130">The tunneling and bubbling routed events are technically separate events, but they deliberately share the same instance of event data to enable this behavior.</span></span>  
  
 <span data-ttu-id="a2d4d-131">Die Verbindung zwischen Tunneling- und Bubbling-Rountingereignissen wird mithilfe der internen Implementierung erreicht, die angibt, wie jede gegebene [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Klasse die eigenen deklarierten Routingereignisse auslöst. Dies gilt für alle gekoppelten Eingaberountingereignisse.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-131">The connection between the tunneling and bubbling routed events is accomplished by the internal implementation of how any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class raises its own declared routed events, and this is true of the paired input routed events.</span></span> <span data-ttu-id="a2d4d-132">Es besteht keine Verbindung zwischen einem Tunneling- und einem Bubbling-Routnigereignis, die dasselbe Benennungsschema nutzen, wenn diese Implementierung auf Klassenebene nicht vorhanden: Ohne diese Implementierung wären beide Routingereignisse zwei vollständig getrennt und würden weder in der Sequenz ausgelöst werden, noch dieselben Ereignisdaten haben.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-132">But unless this class-level implementation exists, there is no connection between a tunneling routed event and a bubbling routed event that share the naming scheme: without such implementation they would be two entirely separate routed events and would not be raised in sequence or share event data.</span></span>  
  
 <span data-ttu-id="a2d4d-133">Weitere Informationen dazu, wie Sie Tunneling-/Bubbling-Eingabeereignispaare in einer benutzerdefinierten Klasse implementieren, finden Sie unter [Erstellen eines benutzerdefinierten Routingereignisses](how-to-create-a-custom-routed-event.md).</span><span class="sxs-lookup"><span data-stu-id="a2d4d-133">For more information about how to implement tunnel/bubble input routed event pairs in a custom class, see [Create a Custom Routed Event](how-to-create-a-custom-routed-event.md).</span></span>  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>
## <a name="class-handlers-and-instance-handlers"></a><span data-ttu-id="a2d4d-134">Klassenhandler und Instanzhandler</span><span class="sxs-lookup"><span data-stu-id="a2d4d-134">Class Handlers and Instance Handlers</span></span>  
 <span data-ttu-id="a2d4d-135">Rountingereignisse sollten Sie zwei verschiedene Arten von Ereignislistenern beachten: Klassenlistener und Instanzlistener.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-135">Routed events consider two different types of listeners to the event: class listeners and instance listeners.</span></span> <span data-ttu-id="a2d4d-136">Klassenlistener sind vorhanden, <xref:System.Windows.EventManager> weil<xref:System.Windows.EventManager.RegisterClassHandler%2A>Typen eine bestimmte API aufgerufen haben , , in ihrem statischen Konstruktor oder eine virtuelle Klassenhandlermethode aus einer Elementbasisklasse überschrieben haben.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-136">Class listeners exist because types have called a particular <xref:System.Windows.EventManager> API ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in their static constructor, or have overridden a class handler virtual method from an element base class.</span></span> <span data-ttu-id="a2d4d-137">Instanzlistener sind bestimmte Klasseninstanzen/-elemente, bei denen ein oder mehrere <xref:System.Windows.UIElement.AddHandler%2A>Handler für dieses routingierte Ereignis durch einen Aufruf von angefügt wurden.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-137">Instance listeners are particular class instances/elements where one or more handlers have been attached for that routed event by a call to <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="a2d4d-138">Vorhandene [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] geroutete Ereignisse <xref:System.Windows.UIElement.AddHandler%2A> führen Aufrufe zu als Teil der Common Language{} Runtime (CLR) Ereigniswrapper hinzufügen und entfernen{} Implementierungen des Ereignisses, was auch der einfache [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] Mechanismus des Anfügens von Ereignishandlern über eine Attributsyntax ist.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-138">Existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events make calls to <xref:System.Windows.UIElement.AddHandler%2A> as part of the common language runtime (CLR) event wrapper add{} and remove{} implementations of the event, which is also how the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanism of attaching event handlers via an attribute syntax is enabled.</span></span> <span data-ttu-id="a2d4d-139">Daher ist [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] auch die einfache <xref:System.Windows.UIElement.AddHandler%2A> Verwendung letztlich gleichbedeutend mit einem Anruf.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-139">Therefore even the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] usage ultimately equates to an <xref:System.Windows.UIElement.AddHandler%2A> call.</span></span>  
  
 <span data-ttu-id="a2d4d-140">Elemente innerhalb der visuellen Struktur werden auf registrierte Handlerimplementierungen überprüft.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-140">Elements within the visual tree are checked for registered handler implementations.</span></span> <span data-ttu-id="a2d4d-141">Handler werden möglicherweise in der gesamten Route aufgerufen, und zwar in der Reihenfolge, die im Typ der Routingstrategie für das Routingereignis inhärent ist.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-141">Handlers are potentially invoked throughout the route, in the order that is inherent in the type of the routing strategy for that routed event.</span></span> <span data-ttu-id="a2d4d-142">Bubbling-Routingereignisse rufen z.B. zuerst die Handler auf, die dem gleichen Element zugeordnet sind, das das Routingereignis ausgelöst hat.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-142">For instance, bubbling routed events will first invoke those handlers that are attached to the same element that raised the routed event.</span></span> <span data-ttu-id="a2d4d-143">Das Routingereignis bubblet dann zu dem nächsten übergeordneten Element und so weiter, bis das Stammelement der Anwendung erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-143">Then the routed event "bubbles" to the next parent element and so on until the application root element is reached.</span></span>  
  
 <span data-ttu-id="a2d4d-144">Wenn aus der Perspektive des Stammelements in einer Bubblingroute die Klassenbehandlung oder ein beliebiges Element, das sich näher an der Quelle des Routingereignisses befindet, Handler aufrufen, die die Ereignisargumente als behandelt markieren, werden Handler in den Stammelementen nicht aufgerufen, und die Ereignisroute wird effektiv verkürzt, bevor das Stammelement erreicht wird.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-144">From the perspective of the root element in a bubbling route, if class handling or any element closer to the source of the routed event invoke handlers that mark the event arguments as being handled, then handlers on the root elements are not invoked, and the event route is effectively shortened before reaching that root element.</span></span> <span data-ttu-id="a2d4d-145">Die Route wird jedoch nicht vollständig angehalten, da Handler mithilfe der bestimmten Bedingung hinzugefügt werden können, dass sie trotzdem noch aufgerufen werden sollen, auch wenn ein Klassen- oder Instanzhandler das Routingereignis als behandelt markiert hat.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-145">However, the route is not completely halted, because handlers can be added using a special conditional that they should still be invoked, even if a class handler or instance handler has marked the routed event as handled.</span></span> <span data-ttu-id="a2d4d-146">Informationen hierzu finden Sie im Abschnitt [Hinzufügen von Instanzhandlern, die ausgelöst werden, obwohl Ereignisse als behandelt markiert wurden](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled) weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-146">This is explained in [Adding Instance Handlers That Are Raised Even When Events Are Marked Handled](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), later in this topic.</span></span>  
  
 <span data-ttu-id="a2d4d-147">Auf einer tieferen Ebene als die Ereignisroute operieren möglicherweise mehrere Klassenhandler auf jeder gegebenen Instanz einer Klasse.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-147">At a deeper level than the event route, there are also potentially multiple class handlers acting on any given instance of a class.</span></span> <span data-ttu-id="a2d4d-148">Das liegt daran, dass das Klassenbehandlungsmodell für Routingereignisse es allen möglichen Klassen in einer Klassenhierarchie ermöglicht, einen eigenen Klassenhandler für jedes Routingereignis zu registrieren.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-148">This is because the class handling model for routed events enables all possible classes in a class hierarchy to each register its own class handler for each routed event.</span></span> <span data-ttu-id="a2d4d-149">Jeder Klassenhandler wird einem internen Speicher hinzugefügt, und wenn die Ereignisroute für eine Anwendung erstellt wird, werden die Klassenhandler werden alle der Ereignisroute hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-149">Each class handler is added to an internal store, and when the event route for an application is constructed, the class handlers are all added to the event route.</span></span> <span data-ttu-id="a2d4d-150">Klassenhandler werden der Route so hinzugefügt, dass der am stärksten abgeleitete Klassenhandler zuerst und die Klassenhandler aus jeder nachfolgenden Basisklasse im Anschluss aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-150">Class handlers are added to the route such that the most-derived class handler is invoked first, and class handlers from each successive base class are invoked next.</span></span> <span data-ttu-id="a2d4d-151">Klassenhandler werden im Allgemeinen nicht registriert, sodass sie auch auf Routingereignisse reagieren, die bereits als behandelt markiert wurden.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-151">Generally, class handlers are not registered such that they also respond to routed events that were already marked handled.</span></span> <span data-ttu-id="a2d4d-152">Dieser Mechanismus zur Klassenbehandlung ermöglicht eine dieser zwei Optionen:</span><span class="sxs-lookup"><span data-stu-id="a2d4d-152">Therefore, this class handling mechanism enables one of two choices:</span></span>  
  
- <span data-ttu-id="a2d4d-153">Abgeleitete Klassen können die Klassenbehandlung ergänzen, die von der Basisklasse geerbt wird, indem ein Handler hinzugefügt wird, der das Routingereignis nicht als behandelt markiert, da der Basisklassenhandler nach dem Handler der abgeleiteten Klasse aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-153">Derived classes can supplement the class handling that is inherited from the base class by adding a handler that does not mark the routed event handled, because the base class handler will be invoked sometime after the derived class handler.</span></span>  
  
- <span data-ttu-id="a2d4d-154">Abgeleitete Klassen können die Klassenbehandlung der Basisklasse ersetzen, indem ein Klassenhandler hinzugefügt wird, der das Routingereignis als behandelt markiert.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-154">Derived classes can replace the class handling from the base class by adding a class handler that marks the routed event handled.</span></span> <span data-ttu-id="a2d4d-155">Bei diesem Ansatz sollten Sie sorgfältig vorgehen, da er möglicherweise das vorgesehene Design des Basissteuerelements in Bereichen wie der visuelle Darstellung, der Zustandslogik, der Eingabeverarbeitung und der Befehlsbehandlung ändert.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-155">You should be cautious with this approach, because it will potentially change the intended base control design in areas such as visual appearance, state logic, input handling, and command handling.</span></span>  
  
<a name="Class_Handling_of_Routed_Events"></a>
## <a name="class-handling-of-routed-events-by-control-base-classes"></a><span data-ttu-id="a2d4d-156">Klassenbehandlung von Routingereignissen durch Steuerelementbasisklassen</span><span class="sxs-lookup"><span data-stu-id="a2d4d-156">Class Handling of Routed Events by Control Base Classes</span></span>  
 <span data-ttu-id="a2d4d-157">Auf jedem gegebene Elementknoten in einer Ereignisroute haben Klassenlistener die Möglichkeit, vor jedem Instanzlistener auf dem Element auf das Routingereignis zu reagieren.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-157">On each given element node in an event route, class listeners have the opportunity to respond to the routed event before any instance listener on the element can.</span></span> <span data-ttu-id="a2d4d-158">Aus diesem Grund werden Klassenhandler manchmal verwendet, um Routingereignisse zu unterdrücken, die von der Implementierung einer bestimmten Steuerelementklasse nicht weitergegeben werden sollen, oder um eine besondere Behandlung des Routingereignisses bereitzustellen, das eine Funktion der Klasse ist.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-158">For this reason, class handlers are sometimes used to suppress routed events that a particular control class implementation does not wish to propagate further, or to provide special handling of that routed event that is a feature of the class.</span></span> <span data-ttu-id="a2d4d-159">Eine Klasse kann z.B. ein eigenes klassenspezifisches Ereignis auslösen, das weitere Details über die Bedeutung einer Benutzereingabebedingung im Kontext der jeweiligen Klasse enthält.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-159">For instance, a class might raise its own class-specific event that contains more specifics about what some user input condition means in the context of that particular class.</span></span> <span data-ttu-id="a2d4d-160">Die Implementierung der Klasse kann das allgemeinere Routingereignis dann als behandelt markieren.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-160">The class implementation might then mark the more general routed event as handled.</span></span> <span data-ttu-id="a2d4d-161">Klassenhandler werden in der Regel so hinzugefügt, dass sie nicht für routingierte Ereignisse aufgerufen werden, bei <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> denen freigegebene Ereignisdaten bereits als behandelt markiert wurden, aber für atypische Fälle gibt es auch eine Signatur, die Klassenhandler registriert, die auch dann aufgerufen werden, wenn geroutete Ereignisse als behandelt markiert werden.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-161">Class handlers are typically added such that they are not invoked for routed events where shared event data was already marked handled, but for atypical cases there is also a <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that registers class handlers to invoke even when routed events are marked handled.</span></span>  
  
### <a name="class-handler-virtuals"></a><span data-ttu-id="a2d4d-162">Virtuelle Klassenhandler</span><span class="sxs-lookup"><span data-stu-id="a2d4d-162">Class Handler Virtuals</span></span>  
 <span data-ttu-id="a2d4d-163">Einige Elemente, insbesondere die <xref:System.Windows.UIElement>Basiselemente wie , machen leere virtuelle\*Methoden "On\*Event" und "OnPreview-Ereignis" verfügbar, die ihrer Liste der öffentlichen Routingereignisse entsprechen.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-163">Some elements, particularly the base elements such as <xref:System.Windows.UIElement>, expose empty "On\*Event" and "OnPreview\*Event" virtual methods that correspond to their list of public routed events.</span></span> <span data-ttu-id="a2d4d-164">Diese virtuellen Methoden können überschrieben werden, um einen Klassenhandler für dieses Routingereignis zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-164">These virtual methods can be overridden to implement a class handler for that routed event.</span></span> <span data-ttu-id="a2d4d-165">Die Basiselementklassen registrieren diese virtuellen Methoden als Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> für jedes solche geroutete Ereignis, das wie zuvor beschrieben verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-165">The base element classes register these virtual methods as their class handler for each such routed event using <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> as described earlier.</span></span> <span data-ttu-id="a2d4d-166">Die virtuellen On\*Event-Methoden vereinfachen die Implementierung der Klassenbehandlung für die relevanten Routingereignisse, ohne eine spezielle Initialisierung in statischen Konstruktoren für jeden Typ zu erfordern.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-166">The On\*Event virtual methods make it much simpler to implement class handling for the relevant routed events, without requiring special initialization in static constructors for each type.</span></span> <span data-ttu-id="a2d4d-167">Sie können z. B. <xref:System.Windows.UIElement.DragEnter> klassenbehandlung <xref:System.Windows.UIElement> für das Ereignis <xref:System.Windows.UIElement.OnDragEnter%2A> in jeder abgeleiteten Klasse hinzufügen, indem Sie die virtuelle Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-167">For instance, you can add class handling for the <xref:System.Windows.UIElement.DragEnter> event in any <xref:System.Windows.UIElement> derived class by overriding the <xref:System.Windows.UIElement.OnDragEnter%2A> virtual method.</span></span> <span data-ttu-id="a2d4d-168">In der Überschreibung können Sie das Routingereignis behandeln, andere Ereignisse auslösen, klassenspezifische Logik initialisieren, die Elementeigenschaften für Instanzen ändern kann, oder jede beliebige Kombination dieser Aktionen ausführen.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-168">Within the override, you could handle the routed event, raise other events, initiate class-specific logic that might change element properties on instances, or any combination of those actions.</span></span> <span data-ttu-id="a2d4d-169">Sie sollten die Basisimplementierung solcher Überschreibungen generell aufrufen, selbst wenn Sie das Ereignis als behandelt markieren.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-169">You should generally call the base implementation in such overrides even if you mark the event handled.</span></span> <span data-ttu-id="a2d4d-170">Das Aufrufen der Basisimplementierung wird dringend empfohlen, da sich die virtuelle Methode in der Basisklasse befindet.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-170">Calling the base implementation is strongly recommended because the virtual method is on the base class.</span></span> <span data-ttu-id="a2d4d-171">Das geschützte virtuelle Standardmuster, bei dem die Basisimplementierungen aus jeder virtuellen Methode aufgerufen werden, ersetzt und entspricht einem ähnlichen Mechanismus, der nativ in der Klassenbehandlung von Routingereignissen vorkommt. Dabei werden Klassenhandler für alle Klassen in einer Klassenhierarchie auf jeder Instanz aufgerufen, beginnend mit dem Handler der am stärksten abgeleiteten Klasse und anschließend mit den Handlern der Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-171">The standard protected virtual pattern of calling the base implementations from each virtual essentially replaces and parallels a similar mechanism that is native to routed event class handling, whereby class handlers for all classes in a class hierarchy are called on any given instance, starting with the most-derived class' handler and continuing to the base class handler.</span></span> <span data-ttu-id="a2d4d-172">Sie sollten den Aufruf der Basisimplementierung nur weglassen, wenn Ihre Klasse eine explizite Anforderung enthält, die Logik der Basisklassenbehandlung zu ändern.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-172">You should only omit the base implementation call if your class has a deliberate requirement to change the base class handling logic.</span></span> <span data-ttu-id="a2d4d-173">Es hängt von der Art Ihrer Implementierung ab, ob Sie die Basisimplementierung vor oder nach dem überschreibenden Code aufrufen.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-173">Whether you call the base implementation before or after your overriding code will depend on the nature of your implementation.</span></span>  
  
#### <a name="input-event-class-handling"></a><span data-ttu-id="a2d4d-174">Klassenbehandlung von Eingabeereignissen</span><span class="sxs-lookup"><span data-stu-id="a2d4d-174">Input Event Class Handling</span></span>  
 <span data-ttu-id="a2d4d-175">Virtuelle Methoden des Klassenhandlers werden alle so registriert, dass sie nur dann aufgerufen werden, wenn gemeinsam genutzte Ereignisdaten nicht bereits als behandelt markiert wurden.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-175">The class handler virtual methods are all registered such that they are only invoked in cases where any shared event data are not already marked handled.</span></span> <span data-ttu-id="a2d4d-176">Außerdem werden nur bei Eingabeereignissen die Tunneling- und Bubblingversionen in der Regel nacheinander ausgelöst und verwenden dieselben Ereignisdaten.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-176">Also, for the input events uniquely, the tunneling and bubbling versions typically are raised in sequence and share event data.</span></span> <span data-ttu-id="a2d4d-177">Dazu sollten Sie ein Ereignis für ein bestimmtes Paar von Eingabeereignis-Klassenhandlern, von denen einer die Tunneling-und der andere die Bubblingversion darstellt, nicht sofort als behandelt markieren.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-177">This entails that for a given pair of class handlers of input events where one is the tunneling version and the other is the bubbling version, you may not want to mark the event handled immediately.</span></span> <span data-ttu-id="a2d4d-178">Wenn Sie die virtuelle Methode der Tunneling-Klassenbehandlung implementieren, um das Ereignis als behandelt zu markieren, wird der Bubbling-Klassenhandler daran gehindert, aufgerufen zu werden (außerdem wird verhindert, dass alle normal registrierten Instanzhandler für das Tunneling- oder das Bubblingereignis aufgerufen werden).</span><span class="sxs-lookup"><span data-stu-id="a2d4d-178">If you implement the tunneling class handling virtual method to mark the event handled, that will prevent the bubbling class handler from being invoked (as well as preventing any normally registered instance handlers for either the tunneling or bubbling event from being invoked).</span></span>  
  
 <span data-ttu-id="a2d4d-179">Nach Abschluss der Klassenbehandlung für einen Knoten werden die Instanzlistener berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-179">Once class handling on a node is complete, the instance listeners are considered.</span></span>  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a><span data-ttu-id="a2d4d-180">Hinzufügen von Instanzhandlern, die ausgelöst werden, obwohl Ereignisse als behandelt markiert wurden</span><span class="sxs-lookup"><span data-stu-id="a2d4d-180">Adding Instance Handlers That Are Raised Even When Events Are Marked Handled</span></span>  
 <span data-ttu-id="a2d4d-181">Die <xref:System.Windows.UIElement.AddHandler%2A> Methode stellt eine bestimmte Überladung bereit, mit der Sie Handler hinzufügen können, die vom Ereignissystem aufgerufen werden, wenn ein Ereignis das Handlingelement in der Route erreicht, auch wenn ein anderer Handler die Ereignisdaten bereits angepasst hat, um dieses Ereignis als behandelt zu markieren.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-181">The <xref:System.Windows.UIElement.AddHandler%2A> method supplies a particular overload that allows you to add handlers that will be invoked by the event system whenever an event reaches the handling element in the route, even if some other handler has already adjusted the event data to mark that event as handled.</span></span> <span data-ttu-id="a2d4d-182">Dies wird in der Regel nicht ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-182">This is not typically done.</span></span> <span data-ttu-id="a2d4d-183">Ereignishandler können generell geschrieben werden, um alle Bereiche des Anwendungscodes anzupassen, die von einem Ereignis beeinflusst werden können, unabhängig davon, wo es in einer Elementstruktur behandelt wurde, auch wenn mehrere Ergebnisse gewünscht sind.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-183">Generally, handlers can be written to adjust all areas of application code that might be influenced by an event, regardless of where it was handled in an element tree, even if multiple end results are desired.</span></span> <span data-ttu-id="a2d4d-184">Darüber hinaus gibt es in der Regel nur ein Element, das auf dieses Ereignis reagieren muss, und die entsprechende Anwendungslogik ist bereits geschehen.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-184">Also, typically there is really only one element that needs to respond to that event, and the appropriate application logic had already happened.</span></span> <span data-ttu-id="a2d4d-185">Für Ausnahmefälle steht die `handledEventsToo`-Überladung zur Verfügung, in der ein anderes Element in einer Elementstruktur oder Zusammensetzung von Steuerelementen ein Ereignis bereits als behandelt markiert hat, während andere, in der Elementstruktur höhere oder niedrigere Elemente (je nach Route) ihre eigenen Handler aber aufrufen möchten.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-185">But the `handledEventsToo` overload is available for the exceptional cases where some other element in an element tree or control compositing has already marked an event as handled, but other elements either higher or lower in the element tree (depending on route) still wish to have their own handlers invoked.</span></span>  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a><span data-ttu-id="a2d4d-186">Markieren von behandelten Ereignisse als nicht behandelt</span><span class="sxs-lookup"><span data-stu-id="a2d4d-186">When to Mark Handled Events as Unhandled</span></span>  
 <span data-ttu-id="a2d4d-187">Im Allgemeinen sollten geroutete Ereignisse, die als behandelt<xref:System.Windows.RoutedEventArgs.Handled%2A> markiert `false`sind, nicht als nicht `handledEventsToo`behandelt markiert werden (zurückgesetzt auf ), auch nicht von Handlern, die auf .</span><span class="sxs-lookup"><span data-stu-id="a2d4d-187">Generally, routed events that are marked handled should not be marked unhandled (<xref:System.Windows.RoutedEventArgs.Handled%2A> set back to `false`) even by handlers that act on `handledEventsToo`.</span></span> <span data-ttu-id="a2d4d-188">Allerdings haben einige Ereignisse Ereignisdarstellungen auf hoher und niedriger Ebene, die sich überlappen können, wenn das Ereignis auf höherer Ebene an einer Position in der Struktur und das Ereignis auf niedrigerer Ebene an einer anderen Position angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-188">However, some input events have high-level and lower-level event representations that can overlap when the high-level event is seen at one position in the tree and the low-level event at another position.</span></span> <span data-ttu-id="a2d4d-189">Betrachten Sie z. B. den Fall, dass ein untergeordnetes <xref:System.Windows.UIElement.TextInput> Element ein Schlüsselereignis auf hoher Ebene <xref:System.Windows.UIElement.KeyDown>abhört, z. B. während ein übergeordnetes Element ein Ereignis auf niedriger Ebene abhört, z. B. .</span><span class="sxs-lookup"><span data-stu-id="a2d4d-189">For instance, consider the case where a child element listens to a high-level key event such as <xref:System.Windows.UIElement.TextInput> while a parent element listens to a low-level event such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="a2d4d-190">Wenn das übergeordnete Element das Ereignis auf niedrigerer Ebene behandelt, kann das Ereignis auf höherer Ebene sogar im untergeordneten Element unterdrückt werden, das intuitiv als Erstes die Möglichkeit haben sollte, das Ereignis zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-190">If the parent element handles the low-level event, the higher-level event can be suppressed even in the child element that intuitively should have first opportunity to handle the event.</span></span>  
  
 <span data-ttu-id="a2d4d-191">In diesen Situationen kann es erforderlich sein, für das Ereignis auf niedrigerer Ebene sowohl dem übergeordneten als auch dem untergeordneten Element Handler hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-191">In these situations it may be necessary to add handlers to both parent elements and child elements for the low-level event.</span></span> <span data-ttu-id="a2d4d-192">Die Handlerimplementierung für das untergeordnete Element kann das Ereignis auf niedrigerer Ebene als behandelt markieren, aber die Handlerimplementierung des übergeordneten Elements würde dies wieder rückgängig machen, damit andere Elemente weiter oben in der Struktur (und das Ereignis auf höherer Ebene) die Möglichkeit haben, zu reagieren.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-192">The child element handler implementation can mark the low-level event as handled, but the parent element handler implementation would set it unhandled again so that further elements up the tree (as well as the high-level event) can have the opportunity to respond.</span></span> <span data-ttu-id="a2d4d-193">Diese Situation ist aber relativ selten.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-193">This situation is should be fairly rare.</span></span>  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a><span data-ttu-id="a2d4d-194">Beabsichtigtes Unterdrücken von Eingabeereignissen für die Zusammensetzung von Steuerelementen</span><span class="sxs-lookup"><span data-stu-id="a2d4d-194">Deliberately Suppressing Input Events for Control Compositing</span></span>  
 <span data-ttu-id="a2d4d-195">Das Hauptszenario, in dem die Klassenbehandlung von Routingereignissen dazu verwendet wird, sind Eingabeereignisse und zusammengesetzte Steuerelemente.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-195">The main scenario where class handling of routed events is used is for input events and composited controls.</span></span> <span data-ttu-id="a2d4d-196">Ein zusammengesetztes Steuerelement besteht per definitionem aus mehreren praktischen Steuerelementen oder Steuerelement-Basisklassen.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-196">A composited control is by definition composed of multiple practical controls or control base classes.</span></span> <span data-ttu-id="a2d4d-197">Häufig möchte der Autor des Steuerelements alle möglichen Eingabeereignisse verbinden, die von den einzelnen Unterkomponenten ausgelöst werden können, um das gesamte Steuerelement als Ereignisquelle zu melden.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-197">Often the author of the control wishes to amalgamate all of the possible input events that each of the subcomponents might raise, in order to report the entire control as the singular event source.</span></span> <span data-ttu-id="a2d4d-198">In einigen Fällen möchte der Autor des Steuerelements die Ereignisse von Komponenten möglicherweise vollständig unterdrücken oder ein komponentendefiniertes Ereignis ersetzen, das weitere Informationen enthält oder ein spezifischeres Verhalten impliziert.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-198">In some cases the control author might wish to suppress the events from components entirely, or substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="a2d4d-199">Das kanonische Beispiel, das für jeden Komponentenautor sofort sichtbar ist, ist, wie ein [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> Mausereignis <xref:System.Windows.Controls.Primitives.ButtonBase.Click> behandelt wird, das schließlich zu dem intuitiven Ereignis auflöst, das alle Schaltflächen haben: ein Ereignis.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-199">The canonical example that is immediately visible to any component author is how a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> handles any mouse event that will eventually resolve to the intuitive event that all buttons have: a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 <span data-ttu-id="a2d4d-200">Die <xref:System.Windows.Controls.Button> Basisklasse<xref:System.Windows.Controls.Primitives.ButtonBase>( ) <xref:System.Windows.Controls.Control> leitet sich von <xref:System.Windows.FrameworkElement> und <xref:System.Windows.UIElement>ab, und ein Großteil der Ereignisinfrastruktur, die <xref:System.Windows.UIElement> für die Eingabeverarbeitung benötigt wird, ist auf der Ebene verfügbar.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-200">The <xref:System.Windows.Controls.Button> base class (<xref:System.Windows.Controls.Primitives.ButtonBase>) derives from <xref:System.Windows.Controls.Control> which in turn derives from <xref:System.Windows.FrameworkElement> and <xref:System.Windows.UIElement>, and much of the event infrastructure needed for control input processing is available at the <xref:System.Windows.UIElement> level.</span></span> <span data-ttu-id="a2d4d-201">Verarbeitet insbesondere <xref:System.Windows.UIElement> allgemeine <xref:System.Windows.Input.Mouse> Ereignisse, die Treffertests für den Mauszeiger innerhalb seiner Grenzen behandeln, und <xref:System.Windows.UIElement.MouseLeftButtonDown>stellt unterschiedliche Ereignisse für die gängigsten Schaltflächenaktionen bereit, z. B. .</span><span class="sxs-lookup"><span data-stu-id="a2d4d-201">In particular, <xref:System.Windows.UIElement> processes general <xref:System.Windows.Input.Mouse> events that handle hit testing for the mouse cursor within its bounds, and provides distinct events for the most common button actions, such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="a2d4d-202"><xref:System.Windows.UIElement>stellt auch eine <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> leere virtuelle als <xref:System.Windows.UIElement.MouseLeftButtonDown>vorregistrierte <xref:System.Windows.Controls.Primitives.ButtonBase> Klassenhandler für bereit und überschreibt sie.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-202"><xref:System.Windows.UIElement> also provides an empty virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> as the preregistered class handler for <xref:System.Windows.UIElement.MouseLeftButtonDown>, and <xref:System.Windows.Controls.Primitives.ButtonBase> overrides it.</span></span> <span data-ttu-id="a2d4d-203">In <xref:System.Windows.Controls.Primitives.ButtonBase> ähnlicher Weise werden <xref:System.Windows.UIElement.MouseLeftButtonUp>Klassenhandler für verwendet.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-203">Similarly, <xref:System.Windows.Controls.Primitives.ButtonBase> uses class handlers for <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="a2d4d-204">In den Überschreibungen, die die Ereignisdaten übergeben <xref:System.Windows.RoutedEventArgs> werden, markieren <xref:System.Windows.RoutedEventArgs.Handled%2A> die `true`Implementierungen diese Instanz als durch Festlegen auf behandelt, und dieselben Ereignisdaten werden entlang des restlichen Weges zu anderen Klassenhandlern und auch zu Instanzhandlern oder Ereignissettern fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-204">In the overrides, which are passed the event data, the implementations mark that <xref:System.Windows.RoutedEventArgs> instance as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`, and that same event data is what continues along the remainder of the route to other class handlers and also to instance handlers or event setters.</span></span> <span data-ttu-id="a2d4d-205">Außerdem wird <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> das <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis durch die Außerkraftsetzung als nächstes ausdemitagefahren.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-205">Also, the <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override will next raise the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="a2d4d-206">Das Endergebnis für die meisten <xref:System.Windows.UIElement.MouseLeftButtonDown> Listener wird sein, dass die und <xref:System.Windows.UIElement.MouseLeftButtonUp> Ereignisse "verschwinden" und stattdessen durch ersetzt werden, <xref:System.Windows.Controls.Primitives.ButtonBase.Click>ein Ereignis, das mehr Bedeutung hat, weil bekannt ist, dass dieses Ereignis von einer echten Schaltfläche und nicht von einem zusammengesetzten Teil der Schaltfläche oder von einem anderen Element vollständig stammt.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-206">The end result for most listeners will be that the <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseLeftButtonUp> events "disappear" and are replaced instead by <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, an event that holds more meaning because it is known that this event originated from a true button and not some composite piece of the button or from some other element entirely.</span></span>  
  
<a name="WorkingAroundEventSuppressionByControls"></a>
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="a2d4d-207">Umgehen der Ereignisunterdrückung von Steuerelementen</span><span class="sxs-lookup"><span data-stu-id="a2d4d-207">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="a2d4d-208">Manchmal kann dieses Ereignis unterdrückende Verhalten in einzelnen Steuerelementen einige allgemeinere Absichten der Ereignisbehandlungslogik der Anwendung behindern.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-208">Sometimes this event suppression behavior within individual controls can interfere with some more general intentions of event handling logic for your application.</span></span> <span data-ttu-id="a2d4d-209">Wenn Ihre Anwendung z. B. aus <xref:System.Windows.UIElement.MouseLeftButtonDown> irgendeinem Grund über einen Handler für das Stammelement der <xref:System.Windows.UIElement.MouseLeftButtonDown> Anwendung <xref:System.Windows.UIElement.MouseLeftButtonUp> verfügt, würden Sie feststellen, dass ein Mausklick auf eine Schaltfläche keine Handler auf der Stammebene aufrufen oder handler.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-209">For instance, if for some reason your application had a handler for <xref:System.Windows.UIElement.MouseLeftButtonDown> located at the application root element, you would notice that any mouse click on a button would not invoke <xref:System.Windows.UIElement.MouseLeftButtonDown> or <xref:System.Windows.UIElement.MouseLeftButtonUp> handlers at the root level.</span></span> <span data-ttu-id="a2d4d-210">Das Ereignis selbst würde aufbubblen (wie gesagt, Ereignisroutes werden nicht tatsächlich beendet, das Routingereignissystem ändert nur deren Aufrufverhalten für Ereignishandler, nachdem sie als behandelt markiert wurden).</span><span class="sxs-lookup"><span data-stu-id="a2d4d-210">The event itself actually did bubble up (again, event routes are not truly ended, but the routed event system changes their handler invocation behavior after being marked handled).</span></span> <span data-ttu-id="a2d4d-211">Wenn das geroutete Ereignis <xref:System.Windows.Controls.Primitives.ButtonBase> die Schaltfläche <xref:System.Windows.UIElement.MouseLeftButtonDown> erreicht hat, markierte die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Klassenbehandlung den behandelten Wert, da es das Ereignis durch mehr Bedeutung ersetzen wollte.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-211">When the routed event reached the button, the <xref:System.Windows.Controls.Primitives.ButtonBase> class handling marked the <xref:System.Windows.UIElement.MouseLeftButtonDown> handled because it wished to substitute the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with more meaning.</span></span> <span data-ttu-id="a2d4d-212">Daher wird <xref:System.Windows.UIElement.MouseLeftButtonDown> kein Standardhandler weiter oben auf der Route aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-212">Therefore, any standard <xref:System.Windows.UIElement.MouseLeftButtonDown> handler further up the route would not be invoked.</span></span> <span data-ttu-id="a2d4d-213">Es gibt zwei Verfahren, mit denen Sie sicherzustellen können, dass die Handler unter diesen Umständen aufgerufen werden würden.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-213">There are two techniques you can use to ensure that your handlers would be invoked in this circumstance.</span></span>  
  
 <span data-ttu-id="a2d4d-214">Die erste Technik besteht darin, `handledEventsToo` den <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>Handler absichtlich mithilfe der Signatur von hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-214">The first technique is to deliberately add the handler using the `handledEventsToo` signature of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="a2d4d-215">Dieses Verfahren zum Anhängen eines Ereignishandlers ist aber nur im Code und nicht in Markup möglich.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-215">A limitation of this approach is that this technique for attaching an event handler is only possible from code, not from markup.</span></span> <span data-ttu-id="a2d4d-216">Die einfache Syntax für die Angabe des Ereignishandlernamens als Ereignisattributwert über [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] ermöglicht dieses Verhalten nicht.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-216">The simple syntax of specifying the event handler name as an event attribute value via [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] does not enable that behavior.</span></span>  
  
 <span data-ttu-id="a2d4d-217">Das zweite Verfahren funktioniert nur für Eingabeereignisse, in denen die Tunneling- und Bubblingversionen des Routingereignisses kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-217">The second technique works only for input events, where the tunneling and bubbling versions of the routed event are paired.</span></span> <span data-ttu-id="a2d4d-218">Für diese Routingereignisse können Sie stattdessen der Vorschau-/Tunnelingversion des Routingereignisses Handler hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-218">For these routed events, you can add handlers to the preview/tunneling equivalent routed event instead.</span></span> <span data-ttu-id="a2d4d-219">Dieses Routingereignis tunnelt ausgehend vom Stamm durch die Route, damit der Code für die Behandlung der Schaltflächenklasse es nicht abfängt, vorausgesetzt, dass Sie den Vorschauhandler in einer Vorgängerebene in der Anwendungsstruktur angefügt haben.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-219">That routed event will tunnel through the route starting from the root, so the button class handling code would not intercept it, presuming that you attached the Preview handler at some ancestor element level in the application's element tree.</span></span> <span data-ttu-id="a2d4d-220">Wenn Sie diesen Ansatz verwenden, sollten Sie beim Markieren von Vorschauereignissen als behandelt vorsichtig vorgehen.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-220">If you use this approach, be cautious about marking any Preview event handled.</span></span> <span data-ttu-id="a2d4d-221">Wenn Sie das <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> Ereignis in der Handlerimplementierung als in <xref:System.Windows.RoutedEventArgs.Handled%2A> der Handlerimplementierung markiert haben, <xref:System.Windows.Controls.Primitives.ButtonBase.Click> würden Sie das Ereignis tatsächlich unterdrücken, wenn Sie das Ereignis als in der Handlerimplementierung markiert haben.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-221">For the example given with <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> being handled at the root element, if you marked the event as <xref:System.Windows.RoutedEventArgs.Handled%2A> in the handler implementation, you would actually suppress the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="a2d4d-222">Dies ist in der Regel kein erwünschtes Verhalten.</span><span class="sxs-lookup"><span data-stu-id="a2d4d-222">That is typically not desirable behavior.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a2d4d-223">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="a2d4d-223">See also</span></span>

- <xref:System.Windows.EventManager>
- [<span data-ttu-id="a2d4d-224">Vorschauereignisse</span><span class="sxs-lookup"><span data-stu-id="a2d4d-224">Preview Events</span></span>](preview-events.md)
- [<span data-ttu-id="a2d4d-225">Erstellen eines benutzerdefinierten Routingereignisses</span><span class="sxs-lookup"><span data-stu-id="a2d4d-225">Create a Custom Routed Event</span></span>](how-to-create-a-custom-routed-event.md)
- [<span data-ttu-id="a2d4d-226">Übersicht über Routingereignisse</span><span class="sxs-lookup"><span data-stu-id="a2d4d-226">Routed Events Overview</span></span>](routed-events-overview.md)
