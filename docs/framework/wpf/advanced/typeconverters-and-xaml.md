---
title: TypeConverter und XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: 6b8b58228e94ed12557e97406e55cc4165753076
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 02/09/2020
ms.locfileid: "77095085"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="19266-102">TypeConverter und XAML</span><span class="sxs-lookup"><span data-stu-id="19266-102">TypeConverters and XAML</span></span>
<span data-ttu-id="19266-103">In diesem Thema wird der Zweck der Typkonvertierung aus einer Zeichenfolge in eine allgemeinere Funktion der XAML-Sprache erläutert.</span><span class="sxs-lookup"><span data-stu-id="19266-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="19266-104">In der .NET Framework erfüllt die <xref:System.ComponentModel.TypeConverter>-Klasse einen bestimmten Zweck als Teil der Implementierung für eine verwaltete benutzerdefinierte Klasse, die als Eigenschafts Wert in der XAML-Attribut Verwendung verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="19266-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="19266-105">Wenn Sie eine benutzerdefinierte Klasse schreiben und Instanzen der Klasse als XAML-festleg Bare Attributwerte verwendet werden sollen, müssen Sie möglicherweise eine <xref:System.ComponentModel.TypeConverterAttribute> auf die Klasse anwenden, eine benutzerdefinierte <xref:System.ComponentModel.TypeConverter> Klasse schreiben oder beides.</span><span class="sxs-lookup"><span data-stu-id="19266-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  

## <a name="type-conversion-concepts"></a><span data-ttu-id="19266-106">Typkonvertierungskonzepte</span><span class="sxs-lookup"><span data-stu-id="19266-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="19266-107">XAML- und Zeichenfolgenwerte</span><span class="sxs-lookup"><span data-stu-id="19266-107">XAML and String Values</span></span>  
 <span data-ttu-id="19266-108">Wenn Sie einen Attributwert in einer XAML-Datei festlegen, ist der ursprüngliche Typ dieses Werts eine Zeichenfolge in reinem Text.</span><span class="sxs-lookup"><span data-stu-id="19266-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="19266-109">Auch andere primitive, z. b. <xref:System.Double>, sind Anfangstext Zeichenfolgen für einen XAML-Prozessor.</span><span class="sxs-lookup"><span data-stu-id="19266-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="19266-110">Ein XAML-Prozessor benötigt zwei Angaben, um einen Attributwert zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="19266-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="19266-111">Die erste Angabe ist der Werttyp der Eigenschaft, die festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="19266-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="19266-112">Jede Zeichenfolge, die einen Attributwert definiert, und in XAML verarbeitet wird, muss schließlich umgewandelt werden oder zu einem Wert dieses Typs aufgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="19266-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="19266-113">Wenn es sich beim Wert um einen Primitiv handelt, den der XAML-Parser versteht (beispielsweise ein numerischer Wert), wird versucht, eine direkte Konvertierung der Zeichenfolge vorzunehmen.</span><span class="sxs-lookup"><span data-stu-id="19266-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="19266-114">Wenn es sich bei dem Wert um eine Enumeration handelt, wird mithilfe der Zeichenfolge nach einer Namensübereinstimmung mit einer benannten Konstante in dieser Enumeration gesucht.</span><span class="sxs-lookup"><span data-stu-id="19266-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="19266-115">Wenn es sich beim Wert weder um einen primitiven Typ handelt, den der Parser versteht, noch um eine Enumeration, muss der zutreffende Typ einen Typ oder Wert bereitstellen können, der auf einer konvertierten Zeichenfolge beruht.</span><span class="sxs-lookup"><span data-stu-id="19266-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="19266-116">Dies erfolgt durch Angabe einer Typkonverterklasse.</span><span class="sxs-lookup"><span data-stu-id="19266-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="19266-117">Der Typkonverter ist eine Hilfsklasse zum Bereitstellen von Werten einer anderen Klasse im XAML-Szenario und möglicherweise auch für Codeaufrufe in .NET-Code.</span><span class="sxs-lookup"><span data-stu-id="19266-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="19266-118">Verwenden von vorhandenem Typkonvertierungsverhalten in XAML</span><span class="sxs-lookup"><span data-stu-id="19266-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="19266-119">Je nach Ihren Vorkenntnissen der zugrunde liegenden XAML-Konzepte verwenden Sie möglicherweise bereits das Typkonvertierungsverhalten in der grundlegenden XAML-Anwendung, ohne es zu wissen.</span><span class="sxs-lookup"><span data-stu-id="19266-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="19266-120">WPF definiert beispielsweise buchstäblich hunderte von Eigenschaften, die einen Wert vom Typ <xref:System.Windows.Point>annehmen.</span><span class="sxs-lookup"><span data-stu-id="19266-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="19266-121">Bei einem <xref:System.Windows.Point> handelt es sich um einen Wert, der eine Koordinate in einem zweidimensionalen Koordinatenraum beschreibt, und er verfügt über zwei wichtige Eigenschaften: <xref:System.Windows.Point.X%2A> und <xref:System.Windows.Point.Y%2A>.</span><span class="sxs-lookup"><span data-stu-id="19266-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="19266-122">Wenn Sie einen Punkt in XAML angeben, geben Sie ihn als Zeichenfolge mit einem Trennzeichen (in der Regel ein Komma) zwischen den <xref:System.Windows.Point.X%2A> und <xref:System.Windows.Point.Y%2A> Werten an, die Sie angeben.</span><span class="sxs-lookup"><span data-stu-id="19266-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="19266-123">Beispiel: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span><span class="sxs-lookup"><span data-stu-id="19266-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span></span>  
  
 <span data-ttu-id="19266-124">Selbst diese einfache Art von <xref:System.Windows.Point> und die einfache Verwendung in XAML umfassen einen Typkonverter.</span><span class="sxs-lookup"><span data-stu-id="19266-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="19266-125">In diesem Fall ist dies die-Klasse <xref:System.Windows.PointConverter>.</span><span class="sxs-lookup"><span data-stu-id="19266-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="19266-126">Der Typkonverter für <xref:System.Windows.Point>, der auf Klassenebene definiert ist, optimiert die Markup Verwendungen aller Eigenschaften, die <xref:System.Windows.Point>annehmen.</span><span class="sxs-lookup"><span data-stu-id="19266-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="19266-127">Ohne Typkonverter benötigen Sie das folgende, viel ausführlichere Markup für dasselbe zuvor gezeigte Beispiel:</span><span class="sxs-lookup"><span data-stu-id="19266-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 <span data-ttu-id="19266-128">Die Verwendung der Zeichenfolge für die Typkonvertierung oder die einer ausführlicheren entsprechenden Syntax ist eine Stilfrage beim Programmieren.</span><span class="sxs-lookup"><span data-stu-id="19266-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="19266-129">Der XAML-Tool-Workflow könnte auch beeinflussen, wie Werte festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="19266-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="19266-130">Einige XAML-Tools neigen dazu, die ausführlichste Form von Markup auszugeben, da ein Roundtrip zu Designeransichten oder zum eigenen Serialisierungsmechanismus einfacher ist.</span><span class="sxs-lookup"><span data-stu-id="19266-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="19266-131">Vorhandene Typkonverter können in der Regel auf WPF-und .NET Framework Typen ermittelt werden, indem eine Klasse (oder Eigenschaft) auf das vorhanden sein eines angewendeten <xref:System.ComponentModel.TypeConverterAttribute>überprüft wird.</span><span class="sxs-lookup"><span data-stu-id="19266-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="19266-132">Dieses Attribut benennt die Klasse, die den unterstützenden Typkonverter für Werte dieses Typs darstellt, für XAML-Zwecke sowie für mögliche andere Zwecke.</span><span class="sxs-lookup"><span data-stu-id="19266-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="19266-133">Typkonverter und Markuperweiterungen</span><span class="sxs-lookup"><span data-stu-id="19266-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="19266-134">Markuperweiterungen und Typkonverter füllen orthogonale Rollen in Bezug auf das Verhalten des XAML-Prozessors und die Szenarios, auf die sie auf angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="19266-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="19266-135">Obwohl der Kontext für die Verwendung von Markuperweiterungen verfügbar ist, wird das Typkonvertierungsverhalten von Eigenschaften, bei denen eine Markuperweiterung einen Wert bereitstellt, in der Regel nicht in den Implementierungen der Markuperweiterung überprüft.</span><span class="sxs-lookup"><span data-stu-id="19266-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="19266-136">Mit anderen Worten, auch wenn eine Markup Erweiterung eine Text Zeichenfolge als `ProvideValue` Ausgabe zurückgibt, wird das Typkonvertierungs Verhalten für diese Zeichenfolge, das auf einen bestimmten Eigenschafts-oder Eigenschafts Werttyp angewendet wird, im Allgemeinen nicht aufgerufen. der Zweck einer Markup Erweiterung besteht darin, eine Zeichenfolge zu verarbeiten und ein Objekt ohne einen Typkonverter zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="19266-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="19266-137">Eine allgemeine Situation, in der eine Markuperweiterung statt einem Typkonverter erforderlich ist, besteht im Erstellen eines Verweises auf ein vorhandenes Objekt.</span><span class="sxs-lookup"><span data-stu-id="19266-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="19266-138">Ein zustandsloser Typkonverter könnte bestenfalls nur eine neue Instanz genieren, die möglicherweise nicht gewünscht ist.</span><span class="sxs-lookup"><span data-stu-id="19266-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="19266-139">Weitere Informationen über Markuperweiterungen finden Sie unter [Markuperweiterungen und WPF XAML](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="19266-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="19266-140">Systemeigene Typkonverter</span><span class="sxs-lookup"><span data-stu-id="19266-140">Native Type Converters</span></span>  
 <span data-ttu-id="19266-141">In WPF- und .NET Framework-Implementierungen des XAML-Parsers gibt es bestimmte Typen, die über eine native Typkonvertierungsverarbeitung verfügen. Diese Typen werden jedoch herkömmlich nicht als primitive Typen angesehen.</span><span class="sxs-lookup"><span data-stu-id="19266-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="19266-142">Ein Beispiel eines solchen Typs ist <xref:System.DateTime>.</span><span class="sxs-lookup"><span data-stu-id="19266-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="19266-143">Der Grund hierfür ist die Funktionsweise der .NET Framework Architektur: der Typ <xref:System.DateTime> ist in mscorlib definiert, der grundlegendsten Bibliothek in .net.</span><span class="sxs-lookup"><span data-stu-id="19266-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="19266-144"><xref:System.DateTime> darf nicht mit einem Attribut attributiert werden, das aus einer anderen Assembly stammt, die eine Abhängigkeit einführt (<xref:System.ComponentModel.TypeConverterAttribute> ist vom System), sodass der übliche Typkonverter-Ermittlungs Mechanismus durch die Attributierung nicht unterstützt werden kann.</span><span class="sxs-lookup"><span data-stu-id="19266-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="19266-145">Stattdessen verfügt der XAML-Parser über eine Liste von Typen, für die diese native Verarbeitung erforderlich ist, und verarbeitet diese Typen ähnlich wie echte primitive Typen.</span><span class="sxs-lookup"><span data-stu-id="19266-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="19266-146">(Im Fall von <xref:System.DateTime> umfasst dies einen Aufruf<xref:System.DateTime.Parse%2A>.)</span><span class="sxs-lookup"><span data-stu-id="19266-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>   
## <a name="implementing-a-type-converter"></a><span data-ttu-id="19266-147">Implementieren eines Typkonverters</span><span class="sxs-lookup"><span data-stu-id="19266-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="19266-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="19266-148">TypeConverter</span></span>  
 <span data-ttu-id="19266-149">Im zuvor angegebenen <xref:System.Windows.Point> Beispiel wurde die-Klasse <xref:System.Windows.PointConverter> erwähnt.</span><span class="sxs-lookup"><span data-stu-id="19266-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="19266-150">Für .net-Implementierungen von XAML sind alle Typkonverter, die für XAML-Zwecke verwendet werden, Klassen, die von der Basisklasse <xref:System.ComponentModel.TypeConverter>abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="19266-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="19266-151">Die <xref:System.ComponentModel.TypeConverter>-Klasse war in Versionen von .NET Framework vorhanden, die vor dem vorhanden sein von XAML liegen. eine der ursprünglichen Verwendungsmöglichkeiten bestand darin, die Zeichen folgen Konvertierung für Eigenschafts Dialogfelder in visuellen Designern bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="19266-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="19266-152">Bei XAML wird die Rolle von <xref:System.ComponentModel.TypeConverter> erweitert, um die Basisklasse für Zeichen folgen-und Zeichen folgen Konvertierungen zu enthalten, die das Verarbeiten eines Zeichen folgen Attribut Werts und ggf. das Verarbeiten eines Lauf Zeitwerts einer bestimmten Objekt Eigenschaft zurück in eine Zeichenfolge für die Serialisierung als Attribut ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="19266-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="19266-153"><xref:System.ComponentModel.TypeConverter> definiert vier Member, die für die Umstellung von und aus Zeichen folgen für XAML-Verarbeitungszwecke relevant sind:</span><span class="sxs-lookup"><span data-stu-id="19266-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="19266-154">Dabei ist die wichtigste Methode <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="19266-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="19266-155">Diese Methode konvertiert die Eingabezeichenfolge in den erforderlichen Objekttyp.</span><span class="sxs-lookup"><span data-stu-id="19266-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="19266-156">Streng genommen könnte die <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>-Methode implementiert werden, um einen viel größeren Bereich von Typen in den gewünschten Zieltyp des Konverters zu konvertieren, und somit Zwecke verarbeiten, die über XAML hinausgehen, wie z. b. das unterstützen von Lauf Zeit Konvertierungen. für XAML-Zwecke ist es jedoch nur der Codepfad, der eine <xref:System.String> Eingabe verarbeiten kann.</span><span class="sxs-lookup"><span data-stu-id="19266-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="19266-157">Die nächstwichtigste Methode ist <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="19266-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="19266-158">Wenn eine Anwendung in eine Markup Darstellung konvertiert wird (wenn Sie beispielsweise in XAML als Datei gespeichert wird), ist <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> für die Erstellung einer Markup Darstellung verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="19266-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="19266-159">In diesem Fall ist der Codepfad, der für XAML wichtig ist, wenn Sie eine `destinationType` <xref:System.String> übergeben.</span><span class="sxs-lookup"><span data-stu-id="19266-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="19266-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> und <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> sind Unterstützungsmethoden, die verwendet werden, wenn ein Dienst die Funktionen der <xref:System.ComponentModel.TypeConverter> -Implementierung abfragt.</span><span class="sxs-lookup"><span data-stu-id="19266-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="19266-161">Sie müssen diese Methoden implementieren, um `true` für typspezifische Klassen zurückzugeben, welche die entsprechenden Konvertierungsmethoden Ihres Konverters unterstützen.</span><span class="sxs-lookup"><span data-stu-id="19266-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="19266-162">Für XAML-Zwecke bedeutet dies in der Regel den <xref:System.String> -Typ.</span><span class="sxs-lookup"><span data-stu-id="19266-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="19266-163">Kulturinformations- und Typkonverter für XAML</span><span class="sxs-lookup"><span data-stu-id="19266-163">Culture Information and Type Converters for XAML</span></span>  

 <span data-ttu-id="19266-164">Jede <xref:System.ComponentModel.TypeConverter>-Implementierung kann über eine eigene Interpretation der Bedeutung einer gültigen Zeichenfolge für eine Konvertierung verfügen. Außerdem kann Sie die Typbeschreibung, die als Parameter verwendet wird, verwenden oder ignorieren.</span><span class="sxs-lookup"><span data-stu-id="19266-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="19266-165">Im Hinblick auf die Kultur und das Konvertieren von XAML-Typen gibt es eine wichtige Überlegung.</span><span class="sxs-lookup"><span data-stu-id="19266-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="19266-166">Die Verwendung von lokalisierbaren Zeichenfolgen als Attributwerte wird von XAML vollständig unterstützt.</span><span class="sxs-lookup"><span data-stu-id="19266-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="19266-167">Die Verwendung lokalisierbarer Zeichenfolgen als Typkonvertereingabe mit bestimmten kulturellen Anforderungen wird nicht unterstützt, weil Typkonverter für XAML-Attributwerte ein zwangsläufig festes Sprachverarbeitungsverhalten umfassen, in dem die `en-US`-Kultur verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="19266-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="19266-168">Weitere Informationen zu den Entwurfs Gründen für diese Einschränkung finden Sie in der XAML-Sprachspezifikation ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span><span class="sxs-lookup"><span data-stu-id="19266-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span></span>  
  
 <span data-ttu-id="19266-169">Da die Kultur ein Problem darstellen kann, verwenden einige Kulturen ein Komma als Dezimaltrennzeichen für Zahlen.</span><span class="sxs-lookup"><span data-stu-id="19266-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="19266-170">Dies steht mit dem Verhalten in Konflikt, das viele der WPF XAML-Typkonverter aufweisen und darin besteht, ein Komma als Trennzeichen zu verwenden (auf Grundlage geschichtlicher Präzedenzfälle wie die allgemeine X,Y-Form oder durch Trennzeichen getrennte Listen).</span><span class="sxs-lookup"><span data-stu-id="19266-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="19266-171">Sogar die Übergabe einer Kultur im umgebenden XAML (das Festlegen von `Language` oder `xml:lang` auf die Kultur `sl-SI`, ein Beispiel für eine Kultur, die ein Komma für Dezimalstellen so verwendet) löst das Problem nicht.</span><span class="sxs-lookup"><span data-stu-id="19266-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="19266-172">Implementieren von ConvertFrom</span><span class="sxs-lookup"><span data-stu-id="19266-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="19266-173">Damit die <xref:System.ComponentModel.TypeConverter> -Methode für diesen Konverter als eine <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> -Implementierung verwendet werden kann, die XAML unterstützt, muss sie eine Zeichenfolge als den `value` -Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="19266-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="19266-174">Wenn die Zeichenfolge in einem gültigen Format vorliegt und von der <xref:System.ComponentModel.TypeConverter>-Implementierung konvertiert werden kann, muss das zurückgegebene Objekt eine Umwandlung in den von der-Eigenschaft erwarteten Typ unterstützen.</span><span class="sxs-lookup"><span data-stu-id="19266-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="19266-175">Andernfalls muss die <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> -Implementierung `null`zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="19266-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="19266-176">Jede <xref:System.ComponentModel.TypeConverter>-Implementierung kann eine eigene Interpretation davon aufweisen, was eine gültige Zeichenfolge für eine Konvertierung ausmacht, und kann auch die Typbeschreibung oder Kultur Kontexte verwenden oder ignorieren, die als Parameter verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="19266-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="19266-177">Bei der WPF-XAML-Verarbeitung werden jedoch möglicherweise nicht in allen Fällen Werte an den Kontext der Typbeschreibung weitergegeben. Die auf `xml:lang` basierende Kultur wird möglicherweise auch nicht weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="19266-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="19266-178">Verwenden Sie auf gar keinen Fall die geschweiften Klammern,vor allem { , als ein mögliches Element Ihres Zeichenfolgenformats.</span><span class="sxs-lookup"><span data-stu-id="19266-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="19266-179">Diese Zeichen sind als ein Eintrag reserviert und dienen dem Beenden einer Markuperweiterungssequenz.</span><span class="sxs-lookup"><span data-stu-id="19266-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="19266-180">Implementieren von ConvertTo</span><span class="sxs-lookup"><span data-stu-id="19266-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="19266-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> wird möglicherweise für die Serialisierungsunterstützung verwendet.</span><span class="sxs-lookup"><span data-stu-id="19266-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="19266-182">Die Serialisierungsunterstützung durch <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> für Ihren benutzerdefinierten Typ und dessen Typkonverter ist nicht unbedingt erforderlich.</span><span class="sxs-lookup"><span data-stu-id="19266-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="19266-183">Wenn Sie jedoch ein Steuerelement implementieren oder die Serialisierung als Bestandteil der Features oder zum Entwerfen Ihrer Klasse verwenden, sollten Sie <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>implementieren.</span><span class="sxs-lookup"><span data-stu-id="19266-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="19266-184">Um als <xref:System.ComponentModel.TypeConverter>-Implementierung verwendet werden zu können, die XAML unterstützt, muss die <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>-Methode für diesen Konverter eine Instanz des Typs (oder eines Werts) akzeptieren, der als `value`-Parameter unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="19266-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="19266-185">Wenn der `destinationType`-Parameter der Typ <xref:System.String>ist, muss das zurückgegebene Objekt in der Lage sein, als <xref:System.String>umgewandelt zu werden.</span><span class="sxs-lookup"><span data-stu-id="19266-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="19266-186">Die zurückgegebene Zeichenfolge muss einen serialisierten Wert von `value`darstellen.</span><span class="sxs-lookup"><span data-stu-id="19266-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="19266-187">Im Idealfall sollte das von Ihnen ausgewählte Serialisierungsformat in der Lage sein, den gleichen Wert zu erzeugen, wenn diese Zeichenfolge ohne erheblichen Verlust von Informationen an die <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> Implementierung desselben Konverters übermittelt wurde.</span><span class="sxs-lookup"><span data-stu-id="19266-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="19266-188">Wenn der Wert nicht serialisiert werden kann oder der Konverter die Serialisierung nicht unterstützt, muss die <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> Implementierung `null`zurückgeben. in diesem Fall ist es zulässig, eine Ausnahme auszulösen.</span><span class="sxs-lookup"><span data-stu-id="19266-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="19266-189">Wenn Sie jedoch Ausnahmen auslösen, sollten Sie die Möglichkeit melden, diese Konvertierung nicht als Teil ihrer <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> Implementierung zu verwenden, sodass die bewährte Vorgehensweise bei der Überprüfung mit <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> zuerst unterstützt wird, um Ausnahmen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="19266-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="19266-190">Wenn `destinationType` Parameter nicht vom Typ <xref:System.String>ist, können Sie Ihre eigene konverterverarbeitung auswählen.</span><span class="sxs-lookup"><span data-stu-id="19266-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="19266-191">Normalerweise würden Sie die grundlegende Implementierungs Verarbeitung wiederherstellen, die im grundlegendsten-<xref:System.ComponentModel.TypeConverter.ConvertTo%2A> eine bestimmte Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="19266-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="19266-192">Implementieren von CanConvertTo</span><span class="sxs-lookup"><span data-stu-id="19266-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="19266-193">Ihre Implementierung <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> sollte `true` für `destinationType` vom Typ <xref:System.String>zurückgeben und andernfalls die grundlegende Implementierung ableiten.</span><span class="sxs-lookup"><span data-stu-id="19266-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="19266-194">Implementieren von CanConvertFrom</span><span class="sxs-lookup"><span data-stu-id="19266-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="19266-195">Ihre Implementierung <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> sollte `true` für `sourceType` vom Typ <xref:System.String>zurückgeben und andernfalls die grundlegende Implementierung ableiten.</span><span class="sxs-lookup"><span data-stu-id="19266-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>   
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="19266-196">Anwenden von TypeConverterAttribute</span><span class="sxs-lookup"><span data-stu-id="19266-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="19266-197">Damit Ihr benutzerdefinierter Typkonverter als der aktive Typkonverter für eine benutzerdefinierte Klasse von einem XAML-Prozessor verwendet werden kann, müssen Sie den <xref:System.ComponentModel.TypeConverterAttribute> auf Ihre Klassendefinition anwenden.</span><span class="sxs-lookup"><span data-stu-id="19266-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="19266-198">Beim <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> , den Sie über das Attribut angeben, muss es sich um den Typnamen Ihres benutzerdefinierten Typkonverters handeln.</span><span class="sxs-lookup"><span data-stu-id="19266-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="19266-199">Wenn ein XAML-Prozessor nach Anwendung dieses Attributs Werte verarbeitet, bei denen der Eigenschaftstyp Ihren benutzerdefinierten Klassentyp verwendet, kann es Zeichenfolgen eingeben und Objektinstanzen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="19266-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="19266-200">Sie können auch einen Typkonverter auf Grundlage einzelner Eigenschaften bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="19266-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="19266-201">Anstatt ein <xref:System.ComponentModel.TypeConverterAttribute> auf die Klassendefinition anzuwenden, wenden Sie es auf eine Eigenschafts Definition an (die Haupt Definition, nicht die `get`/`set` darin enthaltenen Implementierungen).</span><span class="sxs-lookup"><span data-stu-id="19266-201">Instead of applying a <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="19266-202">Der Eigenschaftstyp muss mit dem Typ übereinstimmen, der durch Ihren benutzerdefinierten Typkonverter verarbeitet wird.</span><span class="sxs-lookup"><span data-stu-id="19266-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="19266-203">Wenn dieses Attribut angewendet ist, wenn ein XAML-Prozessor Werte dieser Eigenschaft verarbeitet, kann es Eingabezeichenfolgen verarbeiten und Objektinstanzen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="19266-203">With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="19266-204">Die Typkonvertertechnik pro Eigenschaft ist besonders nützlich, wenn Sie einen Eigenschaftentyp aus Microsoft .NET Framework oder einer anderen Bibliothek verwenden möchten, in der Sie die Klassendefinition nicht steuern können und keine <xref:System.ComponentModel.TypeConverterAttribute> dort anwenden können.</span><span class="sxs-lookup"><span data-stu-id="19266-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="19266-205">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="19266-205">See also</span></span>

- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="19266-206">Übersicht über XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="19266-206">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="19266-207">Markuperweiterungen und WPF-XAML</span><span class="sxs-lookup"><span data-stu-id="19266-207">Markup Extensions and WPF XAML</span></span>](markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="19266-208">Ausführliche Erläuterung der XAML-Syntax</span><span class="sxs-lookup"><span data-stu-id="19266-208">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
