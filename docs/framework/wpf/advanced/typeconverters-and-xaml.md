---
title: TypeConverter und XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: 53e2d14cf331cf41b20300afbe8966538bf621ca
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/01/2018
ms.locfileid: "43407108"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="93487-102">TypeConverter und XAML</span><span class="sxs-lookup"><span data-stu-id="93487-102">TypeConverters and XAML</span></span>
<span data-ttu-id="93487-103">In diesem Thema wird der Zweck der Typkonvertierung aus einer Zeichenfolge in eine allgemeinere Funktion der XAML-Sprache erläutert.</span><span class="sxs-lookup"><span data-stu-id="93487-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="93487-104">In .NET Framework die <xref:System.ComponentModel.TypeConverter> Klasse einen bestimmten Zweck dient, als Teil der Implementierung für eine verwaltete benutzerdefinierte Klasse, die als Eigenschaftswert in der XAML-Attributverwendung verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="93487-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="93487-105">Wenn Sie eine benutzerdefinierte Klasse schreiben und Instanzen dieser Klasse als festlegbare XAML-Attributwerte verwendet werden sollen, müssen Sie möglicherweise Anwenden einer <xref:System.ComponentModel.TypeConverterAttribute> in Ihrer Klasse schreiben Sie eine benutzerdefinierte <xref:System.ComponentModel.TypeConverter> Klasse oder beides.</span><span class="sxs-lookup"><span data-stu-id="93487-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  
  

  
## <a name="type-conversion-concepts"></a><span data-ttu-id="93487-106">Typkonvertierungskonzepte</span><span class="sxs-lookup"><span data-stu-id="93487-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="93487-107">XAML- und Zeichenfolgenwerte</span><span class="sxs-lookup"><span data-stu-id="93487-107">XAML and String Values</span></span>  
 <span data-ttu-id="93487-108">Wenn Sie einen Attributwert in einer XAML-Datei festlegen, ist der ursprüngliche Typ dieses Werts eine Zeichenfolge in reinem Text.</span><span class="sxs-lookup"><span data-stu-id="93487-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="93487-109">Auch andere Primitive wie z. B. <xref:System.Double> sind anfänglich Textzeichenfolgen für einen XAML-Prozessor.</span><span class="sxs-lookup"><span data-stu-id="93487-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="93487-110">Ein XAML-Prozessor benötigt zwei Angaben, um einen Attributwert zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="93487-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="93487-111">Die erste Angabe ist der Werttyp der Eigenschaft, die festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="93487-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="93487-112">Jede Zeichenfolge, die einen Attributwert definiert, und in XAML verarbeitet wird, muss schließlich umgewandelt werden oder zu einem Wert dieses Typs aufgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="93487-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="93487-113">Wenn es sich beim Wert um einen Primitiv handelt, den der XAML-Parser versteht (beispielsweise ein numerischer Wert), wird versucht, eine direkte Konvertierung der Zeichenfolge vorzunehmen.</span><span class="sxs-lookup"><span data-stu-id="93487-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="93487-114">Wenn es sich bei dem Wert um eine Enumeration handelt, wird mithilfe der Zeichenfolge nach einer Namensübereinstimmung mit einer benannten Konstante in dieser Enumeration gesucht.</span><span class="sxs-lookup"><span data-stu-id="93487-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="93487-115">Wenn es sich beim Wert weder um einen primitiven Typ handelt, den der Parser versteht, noch um eine Enumeration, muss der zutreffende Typ einen Typ oder Wert bereitstellen können, der auf einer konvertierten Zeichenfolge beruht.</span><span class="sxs-lookup"><span data-stu-id="93487-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="93487-116">Dies erfolgt durch Angabe einer Typkonverterklasse.</span><span class="sxs-lookup"><span data-stu-id="93487-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="93487-117">Der Typkonverter ist eine Hilfsklasse zum Bereitstellen von Werten einer anderen Klasse im XAML-Szenario und möglicherweise auch für Codeaufrufe in .NET-Code.</span><span class="sxs-lookup"><span data-stu-id="93487-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="93487-118">Verwenden von vorhandenem Typkonvertierungsverhalten in XAML</span><span class="sxs-lookup"><span data-stu-id="93487-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="93487-119">Je nach Ihren Vorkenntnissen der zugrunde liegenden XAML-Konzepte verwenden Sie möglicherweise bereits das Typkonvertierungsverhalten in der grundlegenden XAML-Anwendung, ohne es zu wissen.</span><span class="sxs-lookup"><span data-stu-id="93487-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="93487-120">WPF definiert z.B. buchstäblich Hunderte von Eigenschaften, die einen Wert vom Typ akzeptieren <xref:System.Windows.Point>.</span><span class="sxs-lookup"><span data-stu-id="93487-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="93487-121">Ein <xref:System.Windows.Point> ist ein Wert, der eine Koordinate in einem zweidimensionalen Koordinatenraum beschreibt, und es eigentlich nur zwei wichtige Eigenschaften hat: <xref:System.Windows.Point.X%2A> und <xref:System.Windows.Point.Y%2A>.</span><span class="sxs-lookup"><span data-stu-id="93487-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="93487-122">Wenn Sie einen Punkt in XAML angeben, geben Sie ihn als eine Zeichenfolge mit einem Trennzeichen (in der Regel ein Komma) zwischen den <xref:System.Windows.Point.X%2A> und <xref:System.Windows.Point.Y%2A> Werte, die Sie bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="93487-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="93487-123">Beispiel: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1">`.</span><span class="sxs-lookup"><span data-stu-id="93487-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1">`.</span></span>  
  
 <span data-ttu-id="93487-124">Auch dieser einfache Typ von <xref:System.Windows.Point> und dessen einfache Verwendung in XAML erfordern einen Typkonverter.</span><span class="sxs-lookup"><span data-stu-id="93487-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="93487-125">In diesem Fall ist, die die Klasse <xref:System.Windows.PointConverter>.</span><span class="sxs-lookup"><span data-stu-id="93487-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="93487-126">Der Typkonverter für <xref:System.Windows.Point> definiert die Klasse auf optimiert die Verwendungsmöglichkeiten von Markup von allen Eigenschaften, die annehmen <xref:System.Windows.Point>.</span><span class="sxs-lookup"><span data-stu-id="93487-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="93487-127">Ohne Typkonverter benötigen Sie das folgende, viel ausführlichere Markup für dasselbe zuvor gezeigte Beispiel:</span><span class="sxs-lookup"><span data-stu-id="93487-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  
  
 `<LinearGradientBrush>`  
  
 `<LinearGradientBrush.StartPoint>`  
  
 `<Point X="0" Y="0"/>`  
  
 `</LinearGradientBrush.StartPoint>`  
  
 `<LinearGradientBrush.EndPoint>`  
  
 `<Point X="1" Y="1"/>`  
  
 `</LinearGradientBrush.EndPoint>`  
  
 `<LinearGradientBrush>`  
  
 <span data-ttu-id="93487-128">Die Verwendung der Zeichenfolge für die Typkonvertierung oder die einer ausführlicheren entsprechenden Syntax ist eine Stilfrage beim Programmieren.</span><span class="sxs-lookup"><span data-stu-id="93487-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="93487-129">Der XAML-Tool-Workflow könnte auch beeinflussen, wie Werte festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="93487-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="93487-130">Einige XAML-Tools neigen dazu, die ausführlichste Form von Markup auszugeben, da ein Roundtrip zu Designeransichten oder zum eigenen Serialisierungsmechanismus einfacher ist.</span><span class="sxs-lookup"><span data-stu-id="93487-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="93487-131">Vorhandenen Typkonverter können in der Regel auf WPF- und .NET Framework-Typen ermittelt werden, durch Prüfen auf eine Klasse (oder Eigenschaft) das Vorhandensein einer angewendeten <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="93487-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="93487-132">Dieses Attribut benennt die Klasse, die den unterstützenden Typkonverter für Werte dieses Typs darstellt, für XAML-Zwecke sowie für mögliche andere Zwecke.</span><span class="sxs-lookup"><span data-stu-id="93487-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="93487-133">Typkonverter und Markuperweiterungen</span><span class="sxs-lookup"><span data-stu-id="93487-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="93487-134">Markuperweiterungen und Typkonverter füllen orthogonale Rollen in Bezug auf das Verhalten des XAML-Prozessors und die Szenarios, auf die sie auf angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="93487-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="93487-135">Obwohl der Kontext für die Verwendung von Markuperweiterungen verfügbar ist, wird das Typkonvertierungsverhalten von Eigenschaften, bei denen eine Markuperweiterung einen Wert bereitstellt, in der Regel nicht in den Implementierungen der Markuperweiterung überprüft.</span><span class="sxs-lookup"><span data-stu-id="93487-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="93487-136">Das heißt, auch wenn eine Markuperweiterung eine Textzeichenfolge als zurückgibt seine `ProvideValue` auszugeben, Typkonvertierungsverhalten für diese Zeichenfolge entsprechend der auf eine bestimmte Eigenschaft oder der Werttyp der Eigenschaft angewendet wird nicht aufgerufen, in der Regel wird des Zwecks einer Markuperweiterung an Prozess ein Zeichenfolge und ein Objekt ohne beteiligten Typkonverter zurück.</span><span class="sxs-lookup"><span data-stu-id="93487-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="93487-137">Eine allgemeine Situation, in der eine Markuperweiterung statt einem Typkonverter erforderlich ist, besteht im Erstellen eines Verweises auf ein vorhandenes Objekt.</span><span class="sxs-lookup"><span data-stu-id="93487-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="93487-138">Ein zustandsloser Typkonverter könnte bestenfalls nur eine neue Instanz genieren, die möglicherweise nicht gewünscht ist.</span><span class="sxs-lookup"><span data-stu-id="93487-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="93487-139">Weitere Informationen über Markuperweiterungen finden Sie unter [Markuperweiterungen und WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="93487-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="93487-140">Systemeigene Typkonverter</span><span class="sxs-lookup"><span data-stu-id="93487-140">Native Type Converters</span></span>  
 <span data-ttu-id="93487-141">In WPF- und .NET Framework-Implementierungen des XAML-Parsers gibt es bestimmte Typen, die über eine native Typkonvertierungsverarbeitung verfügen. Diese Typen werden jedoch herkömmlich nicht als primitive Typen angesehen.</span><span class="sxs-lookup"><span data-stu-id="93487-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="93487-142">Ein Beispiel eines solchen Typs ist <xref:System.DateTime>.</span><span class="sxs-lookup"><span data-stu-id="93487-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="93487-143">Der Grund dafür basiert auf der Funktionsweise der .NET Framework-Architektur: der Typ <xref:System.DateTime> in "mscorlib", die grundlegendste Bibliothek in .NET definiert ist.</span><span class="sxs-lookup"><span data-stu-id="93487-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="93487-144"><xref:System.DateTime> darf nicht mit einem Attribut zu attribuieren, die aus einer anderen Assembly stammt, eine Abhängigkeit einführt (<xref:System.ComponentModel.TypeConverterAttribute> stammt aus dem System), damit der gewöhnliche Typkonverter-Ermittlungsmechanismus durch die Attributierung nicht unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="93487-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="93487-145">Stattdessen verfügt der XAML-Parser über eine Liste von Typen, für die diese native Verarbeitung erforderlich ist, und verarbeitet diese Typen ähnlich wie echte primitive Typen.</span><span class="sxs-lookup"><span data-stu-id="93487-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="93487-146">(Im Fall von <xref:System.DateTime> Dies umfasst einen Aufruf von <xref:System.DateTime.Parse%2A>.)</span><span class="sxs-lookup"><span data-stu-id="93487-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>   
## <a name="implementing-a-type-converter"></a><span data-ttu-id="93487-147">Implementieren eines Typkonverters</span><span class="sxs-lookup"><span data-stu-id="93487-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="93487-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="93487-148">TypeConverter</span></span>  
 <span data-ttu-id="93487-149">In der <xref:System.Windows.Point> im bereits erwähnten Beispiel, die Klasse <xref:System.Windows.PointConverter> erwähnt wurde.</span><span class="sxs-lookup"><span data-stu-id="93487-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="93487-150">Für .NET-Implementierungen von XAML, sind alle Typkonverter für XAML-Zwecke verwendet werden, die von der Basisklasse abgeleitete Klassen <xref:System.ComponentModel.TypeConverter>.</span><span class="sxs-lookup"><span data-stu-id="93487-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="93487-151">Die <xref:System.ComponentModel.TypeConverter> -Klasse gab es in .NET Framework-Versionen, die das Vorhandensein des XAML vorausgehen, eines der ursprünglichen Verwendungsweisen bestand darin die zeichenfolgenkonvertierung für Eigenschaftendialogfelder in visuellen Designern bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="93487-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="93487-152">Für XAML, die Rolle des <xref:System.ComponentModel.TypeConverter> wird erweitert, damit die Basisklasse für Konvertierungen aus to- und from-Zeichenfolge, mit denen möglicherweise einen Run-Time-Wert, der einer bestimmten Objekteigenschaft zurück in eine Zeichenfolge für das Verarbeiten und Analysieren eines Zeichenfolgenattributwerts die Serialisierung als Attribut.</span><span class="sxs-lookup"><span data-stu-id="93487-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="93487-153"><xref:System.ComponentModel.TypeConverter> definiert vier Member, die für die Konvertierung in und aus Zeichenfolgen für XAML-Verarbeitungszwecke relevant sind:</span><span class="sxs-lookup"><span data-stu-id="93487-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
-   <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="93487-154">Die wichtigste Methode ist <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="93487-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="93487-155">Diese Methode konvertiert die Eingabezeichenfolge in den erforderlichen Objekttyp.</span><span class="sxs-lookup"><span data-stu-id="93487-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="93487-156">Streng genommen ist der <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> -Methode kann implementiert werden, um eine viel breitere Palette von Typen in den vom Konverter beabsichtigten Zieltyp zu konvertieren, und somit für Zwecke, die über XAML hinausgehen werden sollen, z.B. die Unterstützung von Konvertierungen zur Laufzeit, sondern für XAML-Zwecke Es ist nur der Codepfad, der verarbeiten kann eine <xref:System.String> Eingabe, die wichtig ist.</span><span class="sxs-lookup"><span data-stu-id="93487-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="93487-157">Die nächste wichtigste Methode ist <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="93487-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="93487-158">Wenn eine Anwendung in eine Markupdarstellung umgewandelt wird (z. B. Wenn sie in XAML als Datei gespeichert ist), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> ist verantwortlich für die Erstellung einer Markupdarstellung.</span><span class="sxs-lookup"><span data-stu-id="93487-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="93487-159">In diesem Fall der Codepfad, der für XAML wichtig ist, wenn Sie übergeben eine `destinationType` von <xref:System.String> .</span><span class="sxs-lookup"><span data-stu-id="93487-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="93487-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> und <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> sind Unterstützungsmethoden, die verwendet werden, wenn ein Dienst die Funktionen der <xref:System.ComponentModel.TypeConverter> -Implementierung abfragt.</span><span class="sxs-lookup"><span data-stu-id="93487-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="93487-161">Sie müssen diese Methoden implementieren, um `true` für typspezifische Klassen zurückzugeben, welche die entsprechenden Konvertierungsmethoden Ihres Konverters unterstützen.</span><span class="sxs-lookup"><span data-stu-id="93487-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="93487-162">Für XAML-Zwecke bedeutet dies in der Regel den <xref:System.String> -Typ.</span><span class="sxs-lookup"><span data-stu-id="93487-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="93487-163">Kulturinformations- und Typkonverter für XAML</span><span class="sxs-lookup"><span data-stu-id="93487-163">Culture Information and Type Converters for XAML</span></span>  
 <span data-ttu-id="93487-164">Jede <xref:System.ComponentModel.TypeConverter> Implementierung kann über eine eigene Interpretation von was eine gültige Zeichenfolge für eine Konvertierung ausmacht und können auch verwenden oder die als Parameter übergebene typbeschreibung ignorieren.</span><span class="sxs-lookup"><span data-stu-id="93487-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="93487-165">Im Hinblick auf die Kultur und das Konvertieren von XAML-Typen gibt es eine wichtige Überlegung.</span><span class="sxs-lookup"><span data-stu-id="93487-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="93487-166">Die Verwendung von lokalisierbaren Zeichenfolgen als Attributwerte wird von XAML vollständig unterstützt.</span><span class="sxs-lookup"><span data-stu-id="93487-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="93487-167">Die Verwendung lokalisierbarer Zeichenfolgen als Typkonvertereingabe mit bestimmten kulturellen Anforderungen wird nicht unterstützt, weil Typkonverter für XAML-Attributwerte ein zwangsläufig festes Sprachverarbeitungsverhalten umfassen, in dem die `en-US`-Kultur verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="93487-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="93487-168">Weitere Informationen zu den Gründe für diese Einschränkung finden Sie in der XAML-Sprachspezifikation ([\[MS-XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525)).</span><span class="sxs-lookup"><span data-stu-id="93487-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525)).</span></span>  
  
 <span data-ttu-id="93487-169">Da die Kultur ein Problem darstellen kann, verwenden einige Kulturen ein Komma als Dezimaltrennzeichen für Zahlen.</span><span class="sxs-lookup"><span data-stu-id="93487-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="93487-170">Dies steht mit dem Verhalten in Konflikt, das viele der WPF XAML-Typkonverter aufweisen und darin besteht, ein Komma als Trennzeichen zu verwenden (auf Grundlage geschichtlicher Präzedenzfälle wie die allgemeine X,Y-Form oder durch Trennzeichen getrennte Listen).</span><span class="sxs-lookup"><span data-stu-id="93487-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="93487-171">Sogar die Übergabe einer Kultur im umgebenden XAML (das Festlegen von `Language` oder `xml:lang` auf die Kultur `sl-SI`, ein Beispiel für eine Kultur, die ein Komma für Dezimalstellen so verwendet) löst das Problem nicht.</span><span class="sxs-lookup"><span data-stu-id="93487-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="93487-172">Implementieren von ConvertFrom</span><span class="sxs-lookup"><span data-stu-id="93487-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="93487-173">Damit die <xref:System.ComponentModel.TypeConverter> -Methode für diesen Konverter als eine <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> -Implementierung verwendet werden kann, die XAML unterstützt, muss sie eine Zeichenfolge als den `value` -Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="93487-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="93487-174">Wenn die Zeichenfolge in einem gültigen formatieren, und konvertiert werden kann, indem die <xref:System.ComponentModel.TypeConverter> -Implementierung, und klicken Sie dann auf das zurückgegebene Objekt muss eine Umwandlung in den von der Eigenschaft erwarteten Typ unterstützen.</span><span class="sxs-lookup"><span data-stu-id="93487-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="93487-175">Andernfalls muss die <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> -Implementierung `null`zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="93487-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="93487-176">Jede <xref:System.ComponentModel.TypeConverter> Implementierung kann über eine eigene Interpretation von was eine gültige Zeichenfolge für eine Konvertierung ausmacht und können auch verwenden oder ignorieren Sie den Typ typbeschreibung oder kulturkontexte als Parameter übergeben.</span><span class="sxs-lookup"><span data-stu-id="93487-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="93487-177">Bei der WPF-XAML-Verarbeitung werden jedoch möglicherweise nicht in allen Fällen Werte an den Kontext der Typbeschreibung weitergegeben. Die auf `xml:lang` basierende Kultur wird möglicherweise auch nicht weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="93487-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93487-178">Verwenden Sie auf gar keinen Fall die geschweiften Klammern,vor allem { , als ein mögliches Element Ihres Zeichenfolgenformats.</span><span class="sxs-lookup"><span data-stu-id="93487-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="93487-179">Diese Zeichen sind als ein Eintrag reserviert und dienen dem Beenden einer Markuperweiterungssequenz.</span><span class="sxs-lookup"><span data-stu-id="93487-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="93487-180">Implementieren von ConvertTo</span><span class="sxs-lookup"><span data-stu-id="93487-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="93487-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> wird möglicherweise für die Serialisierungsunterstützung verwendet.</span><span class="sxs-lookup"><span data-stu-id="93487-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="93487-182">Die Serialisierungsunterstützung durch <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> für Ihren benutzerdefinierten Typ und dessen Typkonverter ist nicht unbedingt erforderlich.</span><span class="sxs-lookup"><span data-stu-id="93487-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="93487-183">Wenn Sie jedoch ein Steuerelement implementieren oder die Serialisierung als Bestandteil der Features oder zum Entwerfen Ihrer Klasse verwenden, sollten Sie <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>implementieren.</span><span class="sxs-lookup"><span data-stu-id="93487-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="93487-184">Verwendet werden kann als eine <xref:System.ComponentModel.TypeConverter> -Implementierung, XAML, unterstützt, die <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> -Methode für diesen Konverter muss eine Instanz vom Typ (oder einen Wert) unterstützt akzeptieren, als die `value` Parameter.</span><span class="sxs-lookup"><span data-stu-id="93487-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="93487-185">Wenn die `destinationType` Parameter ist der Typ <xref:System.String>, und klicken Sie dann das zurückgegebene Objekt umgewandelt werden kann muss <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="93487-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="93487-186">Die zurückgegebene Zeichenfolge muss einen serialisierten Wert von `value`darstellen.</span><span class="sxs-lookup"><span data-stu-id="93487-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="93487-187">Im Idealfall muss das Serialisierungsformat, das Sie auswählen, den gleichen Wert zu generieren, wenn diese Zeichenfolge übergeben wurden, kann die <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> -Implementierung desselben Konverters, ohne erhebliche Informationsverluste.</span><span class="sxs-lookup"><span data-stu-id="93487-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="93487-188">Wenn der Wert kann nicht serialisiert werden, oder der Konverter keine Serialisierung unterstützt die <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> Implementierung muss zurückgeben `null`, und darf in diesem Fall einer Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="93487-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="93487-189">Aber wenn Sie Ausnahmen auslösen, sollten Sie melden, dass die Unfähigkeit, diese Konvertierung als Teil Ihrer <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> Implementierung, damit die bewährte Methode eine Überprüfung mit <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> zuerst zum Vermeiden von Ausnahmen werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="93487-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="93487-190">Wenn `destinationType` Parameter ist nicht vom Typ <xref:System.String>, Sie können Ihre eigene konverterverarbeitung auswählen.</span><span class="sxs-lookup"><span data-stu-id="93487-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="93487-191">Sie würden in der Regel wiederherstellen, die grundlegende implementierungsverarbeitung vor, die in den grundlegendsten <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> eine bestimmte Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="93487-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="93487-192">Implementieren von CanConvertTo</span><span class="sxs-lookup"><span data-stu-id="93487-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="93487-193">Ihre Implementierung <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> sollte `true` für `destinationType` vom Typ <xref:System.String>zurückgeben und andernfalls die grundlegende Implementierung ableiten.</span><span class="sxs-lookup"><span data-stu-id="93487-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="93487-194">Implementieren von CanConvertFrom</span><span class="sxs-lookup"><span data-stu-id="93487-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="93487-195">Ihre Implementierung <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> sollte `true` für `sourceType` vom Typ <xref:System.String> zurückgeben und andernfalls die grundlegende Implementierung ableiten.</span><span class="sxs-lookup"><span data-stu-id="93487-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>   
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="93487-196">Anwenden von TypeConverterAttribute</span><span class="sxs-lookup"><span data-stu-id="93487-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="93487-197">In der Reihenfolge für Ihr benutzerdefinierter Typkonverter als der agierende Typkonverter für eine benutzerdefinierte Klasse von einem XAML-Prozessor, müssen Sie anwenden, die [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> auf Ihre Klassendefinition.</span><span class="sxs-lookup"><span data-stu-id="93487-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="93487-198">Beim <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> , den Sie über das Attribut angeben, muss es sich um den Typnamen Ihres benutzerdefinierten Typkonverters handeln.</span><span class="sxs-lookup"><span data-stu-id="93487-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="93487-199">Wenn ein XAML-Prozessor nach Anwendung dieses Attributs Werte verarbeitet, bei denen der Eigenschaftstyp Ihren benutzerdefinierten Klassentyp verwendet, kann es Zeichenfolgen eingeben und Objektinstanzen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="93487-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="93487-200">Sie können auch einen Typkonverter auf Grundlage einzelner Eigenschaften bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="93487-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="93487-201">Anstelle einer [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> auf die Klassendefinition, wenden Sie es auf eine Eigenschaftsdefinition (die hauptdefinition, nicht die `get` / `set` Implementierungen).</span><span class="sxs-lookup"><span data-stu-id="93487-201">Instead of applying a [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="93487-202">Der Eigenschaftstyp muss mit dem Typ übereinstimmen, der durch Ihren benutzerdefinierten Typkonverter verarbeitet wird.</span><span class="sxs-lookup"><span data-stu-id="93487-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="93487-203">Wenn dieses Attribut angewendet ist, wenn ein XAML-Prozessor Werte dieser Eigenschaft verarbeitet, kann es Eingabezeichenfolgen verarbeiten und Objektinstanzen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="93487-203">With this attribute applied, when a XAMLprocessor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="93487-204">Die Typkonvertertechnik auf Grundlage einzelner Eigenschaften ist besonders nützlich, wenn Sie einen Eigenschaftentyp aus Microsoft .NET Framework oder eine andere Bibliothek auch, in dem Sie die Klassendefinition weder steuern und können nicht angewendet werden, verwenden eine <xref:System.ComponentModel.TypeConverterAttribute> vorhanden.</span><span class="sxs-lookup"><span data-stu-id="93487-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="93487-205">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="93487-205">See Also</span></span>  
 <xref:System.ComponentModel.TypeConverter>  
 [<span data-ttu-id="93487-206">Übersicht über XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="93487-206">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)  
 [<span data-ttu-id="93487-207">Markuperweiterungen und WPF-XAML</span><span class="sxs-lookup"><span data-stu-id="93487-207">Markup Extensions and WPF XAML</span></span>](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)  
 [<span data-ttu-id="93487-208">Ausführliche Erläuterung der XAML-Syntax</span><span class="sxs-lookup"><span data-stu-id="93487-208">XAML Syntax In Detail</span></span>](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)
