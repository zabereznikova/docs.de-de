---
title: XAML- und benutzerdefinierte Klassen für WPF
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: acf3ba12a9a7e6ba9a8e378892098f5f265a23d9
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/02/2018
ms.locfileid: "43461799"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="e6c81-102">XAML- und benutzerdefinierte Klassen für WPF</span><span class="sxs-lookup"><span data-stu-id="e6c81-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="e6c81-103">Die Implementierung von XAML in [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]-Frameworks unterstützt die Möglichkeit zum Definieren einer benutzerdefinierten Klasse oder Struktur in einer beliebigen [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]-Sprache und den anschließenden Zugriff auf diese Klasse unter Verwendung von XAML-Markup.</span><span class="sxs-lookup"><span data-stu-id="e6c81-103">XAML as implemented in [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] frameworks supports the ability to define a custom class or structure in any [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] language, and then access that class using XAML markup.</span></span> <span data-ttu-id="e6c81-104">Sie können eine Mischung aus [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-Typen und ihren benutzerdefinierten Typen innerhalb derselben Markupdatei verwenden. Die übliche Vorgehensweise hierbei ist, Ihren benutzerdefinierten Typen ein XAML-Namespace-Präfix zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="e6c81-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="e6c81-105">Dieses Thema beschreibt die Anforderungen, die eine benutzerdefinierte Klasse erfüllen muss, um als XAML-Element verwendet werden zu können.</span><span class="sxs-lookup"><span data-stu-id="e6c81-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  
  
 
  
<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="e6c81-106">Benutzerdefinierte Klassen in Anwendungen oder Assemblys</span><span class="sxs-lookup"><span data-stu-id="e6c81-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="e6c81-107">Benutzerdefinierte Klassen, die in XAML verwendet werden, können auf zwei verschiedene Arten definiert werden: im CodeBehind oder in anderem Code, der die primäre [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-Anwendung erzeugt, oder als Klasse in einer separaten Assembly, z.B. einer ausführbare Datei oder einer als Klassenbibliothek verwendeten DLL.</span><span class="sxs-lookup"><span data-stu-id="e6c81-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="e6c81-108">Jeder dieser Ansätze hat bestimmte Vor- und Nachteile.</span><span class="sxs-lookup"><span data-stu-id="e6c81-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
-   <span data-ttu-id="e6c81-109">Der Vorteil der Erstellung einer Klassenbibliothek ist, dass alle diese benutzerdefinierten Klassen über viele verschiedene mögliche Anwendungen gemeinsam genutzt werden können.</span><span class="sxs-lookup"><span data-stu-id="e6c81-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="e6c81-110">Eine separate Bibliothek gibt Ihnen auch mehr Kontrolle über die Versionierung von Anwendungen und vereinfacht das Erstellen einer Klasse, in denen die gewünschten Klasse als Stammelement auf einer XAML-Seite verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="e6c81-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
-   <span data-ttu-id="e6c81-111">Der Vorteil bei der Definition der benutzerdefinierten Klassen in der Anwendung ist, dass diese Technik relativ schlank ist und Probleme bei Bereitstellung und Tests minimiert, die auftreten, wenn Sie separate Assemblys zusätzlich zur ausführbaren Hauptdatei der Anwendung einführen.</span><span class="sxs-lookup"><span data-stu-id="e6c81-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
-   <span data-ttu-id="e6c81-112">Egal, ob sie in derselben oder einer anderen Assembly definiert sind: benutzerdefinierte Klassen benötigen eine Zuordnung zwischen dem CLR-Namespace und dem XML-Namespace, um in XAML als Elemente verwendet werden zu können.</span><span class="sxs-lookup"><span data-stu-id="e6c81-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="e6c81-113">Siehe [XAML-Namespaces und Namespacezuordnung für WPF-XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="e6c81-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="e6c81-114">Anforderungen an benutzerdefinierten Klassen als XAML-Elemente</span><span class="sxs-lookup"><span data-stu-id="e6c81-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="e6c81-115">Um als Objektelement instanziiert werden zu können, muss die Klasse die folgenden Anforderungen erfüllen:</span><span class="sxs-lookup"><span data-stu-id="e6c81-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="e6c81-116">Ihre benutzerdefinierte Klasse muss öffentlich sein und über einen parameterlosen öffentlichen Standardkonstruktor verfügen.</span><span class="sxs-lookup"><span data-stu-id="e6c81-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="e6c81-117">(Hinweise zu Strukturen finden Sie im folgenden Abschnitt.)</span><span class="sxs-lookup"><span data-stu-id="e6c81-117">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="e6c81-118">Die benutzerdefinierte Klasse darf keine geschachtelte Klasse sein.</span><span class="sxs-lookup"><span data-stu-id="e6c81-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="e6c81-119">Geschachtelte Klassen und der "Punkt" in ihrer allgemeinen CLR-Notation verursachen Konflikte mit anderen [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]- und/oder XAML-Funktionen wie z.B. angefügten Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="e6c81-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="e6c81-120">Ihre Objektdefinition ermöglicht nicht nur die Verwendung von Objektelement-Syntax, sondern auch von Eigenschaftenelement-Syntax für alle öffentlichen Eigenschaften, die dieses Objekt als Werttyp haben.</span><span class="sxs-lookup"><span data-stu-id="e6c81-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="e6c81-121">Dies liegt darin begründet, dass das Objekt jetzt als Objektelement instanziiert werden kann und somit den Eigenschaftenelementwert einer solchen Eigenschaft befüllen kann.</span><span class="sxs-lookup"><span data-stu-id="e6c81-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="e6c81-122">Strukturen</span><span class="sxs-lookup"><span data-stu-id="e6c81-122">Structures</span></span>  
 <span data-ttu-id="e6c81-123">Strukturen, die Sie als benutzerdefinierte Typen definieren, können immer in XAML in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] erstellt werden. Grund hierfür ist, dass die [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]-Compiler implizit einen Standardkonstruktor für Strukturen erstellen, die alle Eigenschaftswerte mit ihren Standardwerten initialisieren.</span><span class="sxs-lookup"><span data-stu-id="e6c81-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] compilers implicitly create a default constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="e6c81-124">In einigen Fällen sind für Strukturen das standardmäßige Konstruktionsverhalten und/oder die Verwendung als Objektelement nicht ratsam.</span><span class="sxs-lookup"><span data-stu-id="e6c81-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="e6c81-125">Möglicherweise sollen die Struktur und ihre befüllten Werte konzeptionell als Einheit fungieren, wobei die enthaltenen Werte möglicherweise sich gegenseitig ausschließende Interpretationen haben und daher keiner ihrer Eigenschaften ein Wert zugewiesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="e6c81-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="e6c81-126">Ein [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Beispiel einer solchen Struktur wird <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="e6c81-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="e6c81-127">Im Allgemeinen sollten solche Strukturen einen Typkonverter implementieren, sodass die Werte in Attributform ausgedrückt werden können, mit String-Konventionen, welche die verschiedenen Interpretationen oder Modi der Strukturwerte erstellen.</span><span class="sxs-lookup"><span data-stu-id="e6c81-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="e6c81-128">Die Struktur sollte über einen nicht standardmäßigen Konstruktor ein ähnliches Verhalten auch für die Codekonstruktion verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="e6c81-128">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="e6c81-129">Anforderungen an Eigenschaften einer benutzerdefinierten Klasse als XAML-Attribute</span><span class="sxs-lookup"><span data-stu-id="e6c81-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="e6c81-130">Eigenschaften müssen einen Werttypen referenzieren (z.B. einen primitiven Typen) oder eine Klasse verwenden, die entweder einen Standardkonstruktor oder einen Typkonverter besitzt, auf den ein XAML-Prozessor zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="e6c81-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a default constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="e6c81-131">In der CLR XAML-Implementierung finden XAML-Prozessoren entweder diese Konverter durch native Unterstützung für Sprachprimitive, oder durch Anwenden von <xref:System.ComponentModel.TypeConverterAttribute> auf einen Typ oder Member in unterstützenden Typdefinitionen.</span><span class="sxs-lookup"><span data-stu-id="e6c81-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="e6c81-132">Alternativ kann die Eigenschaft auf einen abstrakten Klassentyp oder eine Schnittstelle verweisen.</span><span class="sxs-lookup"><span data-stu-id="e6c81-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="e6c81-133">Bei abstrakten Klassen oder Schnittstellen wird bei der XAML-Analyse erwartet, dass der Eigenschaftswert mit praktischen Klasseninstanzen befüllt sein muss, die die Schnittstelle implementieren, oder Instanzen von Typen, die von der abstrakten Klasse abgeleitet sind.</span><span class="sxs-lookup"><span data-stu-id="e6c81-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="e6c81-134">Eigenschaften können für eine abstrakte Klasse deklariert werden, können jedoch nur in praktischen Klassen festgelegt werden, die von der abstrakten Klasse abgeleitet sind.</span><span class="sxs-lookup"><span data-stu-id="e6c81-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="e6c81-135">Dies liegt daran, dass für das Erstellen eines Objektelements dieser Klasse ein öffentlicher Standardkonstruktor für diese Klasse Grundvoraussetzung ist.</span><span class="sxs-lookup"><span data-stu-id="e6c81-135">This is because creating the object element for the class at all requires a public default constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="e6c81-136">TypeConverter-fähige Attributsyntax</span><span class="sxs-lookup"><span data-stu-id="e6c81-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="e6c81-137">Wenn Sie einen dedizierten, mit Attributen versehenen Typkonverter auf Klassenebene bereitstellen, wird durch die angewendete Typumwandlung Attributsyntax für jede Eigenschaft ermöglicht, die diesen Typ instanziieren muss.</span><span class="sxs-lookup"><span data-stu-id="e6c81-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="e6c81-138">Ein Typkonverter ermöglicht keine Objektelementverwendung des Typs; nur das Vorhandensein eines Standardkonstruktors für diesen Typ ermöglicht Objektelementverwendung.</span><span class="sxs-lookup"><span data-stu-id="e6c81-138">A type converter does not enable object element usage of the type; only the presence of a default constructor for that type enables object element usage.</span></span> <span data-ttu-id="e6c81-139">Aus diesem Grund sind Eigenschaften, für die ein Typkonverter aktiviert ist, im Allgemeinen nicht in Eigenschaftensyntax verwendbar, es sei denn, der Typ selbst unterstützt ebenfalls Objektelementsyntax.</span><span class="sxs-lookup"><span data-stu-id="e6c81-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="e6c81-140">Die Ausnahme ist, wenn Sie eine Eigenschaftenelement-Syntax angeben, das Eigenschaftenelement jedoch eine Zeichenfolge enthält.</span><span class="sxs-lookup"><span data-stu-id="e6c81-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="e6c81-141">Diese Verwendung ist Wesentlichen äquivalent zur Nutzung der Attributsyntax, und eine solche Verwendung ist nicht üblich, es sei denn, besteht die Notwendigkeit für eine robustere Behandlung von Leerzeichen von den Wert des Attributs.</span><span class="sxs-lookup"><span data-stu-id="e6c81-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="e6c81-142">Nachfolgend sehen sie z.B. ein Eigenschaftenelement, das eine Zeichenfolge akzeptiert, und das dazugehörige Äquivalent in Attributsyntax:</span><span class="sxs-lookup"><span data-stu-id="e6c81-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="e6c81-143">Beispiele für Eigenschaften, die Attributsyntax zulässig ist jedoch Eigenschaftenelement-Syntax, die ein Objektelement enthält ist nicht zulässig, über die XAML, sind verschiedene Eigenschaften, verwenden die <xref:System.Windows.Input.Cursor> Typ.</span><span class="sxs-lookup"><span data-stu-id="e6c81-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="e6c81-144">Die <xref:System.Windows.Input.Cursor> -Klasse verfügt über einen Typkonverter <xref:System.Windows.Input.CursorConverter>, aber nicht über einen Standardkonstruktor verfügbar macht also die <xref:System.Windows.FrameworkElement.Cursor%2A> Eigenschaft kann nur festgelegt werden über die Attributsyntax, obwohl die tatsächliche <xref:System.Windows.Input.Cursor> Typ ein Verweistyp ist.</span><span class="sxs-lookup"><span data-stu-id="e6c81-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a default constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="e6c81-145">Typkonverter auf Eigenschaftenebene</span><span class="sxs-lookup"><span data-stu-id="e6c81-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="e6c81-146">Alternativ kann die Eigenschaft selbst auf der Eigenschaftenebene einen Typkonverter deklarieren.</span><span class="sxs-lookup"><span data-stu-id="e6c81-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="e6c81-147">Dies ermöglicht eine "Minisprache", die Objekte vom Typ der Eigenschaft Inline instanziiert, indem eingehende Zeichenfolgenwerte des Attributs als Eingabe für eine <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> Vorgang basierend auf den entsprechenden Typ.</span><span class="sxs-lookup"><span data-stu-id="e6c81-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="e6c81-148">Dies erfolgt in der Regel, um einen zweckmäßigen Accessor bereitzustellen und nicht als alleiniges Mittel zum Festlegen einer Eigenschaft in XAML.</span><span class="sxs-lookup"><span data-stu-id="e6c81-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="e6c81-149">Es ist jedoch auch möglich, Typkonverter für Attribute dort einzusetzen, wo Sie vorhandene [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]-Typen verwenden möchten, die entweder keinen Standardkonstruktor oder keinen attribuierten Typkonverter bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="e6c81-149">However, it is also possible to use type converters for attributes where you want to use existing [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] types that do not supply either a default constructor or an attributed type converter.</span></span> <span data-ttu-id="e6c81-150">Beispiele aus der [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] -API sind bestimmte Eigenschaften mit den <xref:System.Globalization.CultureInfo> Typ.</span><span class="sxs-lookup"><span data-stu-id="e6c81-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="e6c81-151">In diesem Fall [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] verwendet das bestehende Microsoft .NET Framework <xref:System.Globalization.CultureInfo> Typ für eine bessere Kompatibilität und Migration von Szenarien, die in früheren Versionen des Frameworks verwendet wurden, aber die <xref:System.Globalization.CultureInfo> Typ nicht die erforderlichen Konstruktoren oder auf Typebene typkonvertierung als Eigenschaftswert XAML direkt verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="e6c81-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="e6c81-152">Wenn Sie eine Eigenschaft verfügbar machen, die in XAML Verwendung findet, insbesondere dann, wenn Sie Autor eines Steuerelements sind, sollten Sie unbedingt die Eigenschaft durch eine Abhängigkeitseigenschaft unterstützen.</span><span class="sxs-lookup"><span data-stu-id="e6c81-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="e6c81-153">Dies ist vor allem dann, wenn die vorhandene [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] Implementierung der XAML-Prozessor, da Sie mithilfe von verbessern können <xref:System.Windows.DependencyProperty> sichern.</span><span class="sxs-lookup"><span data-stu-id="e6c81-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="e6c81-154">Eine Abhängigkeitseigenschaft wird für Ihre Eigenschaft Funktionen des Eigenschaftensystems verfügbar machen, die Benutzer von einer XAML-zugänglichen Eigenschaft erwarten.</span><span class="sxs-lookup"><span data-stu-id="e6c81-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="e6c81-155">Zu diesen Funktionen gehören z.B. Animationen, Datenbindungen und die Unterstützung von Stilen.</span><span class="sxs-lookup"><span data-stu-id="e6c81-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="e6c81-156">Weitere Informationen finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) und [Laden von XAML und Abhängigkeitseigenschaften](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="e6c81-156">For more information, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) and [XAML Loading and Dependency Properties](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="e6c81-157">Schreiben und Attribuieren eines Typkonverters</span><span class="sxs-lookup"><span data-stu-id="e6c81-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="e6c81-158">Sie gelegentlich benötigen zum Schreiben einer benutzerdefinierten <xref:System.ComponentModel.TypeConverter> abgeleitete Klasse, um die typkonvertierung für Ihren Eigenschaftstyp bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="e6c81-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="e6c81-159">Anweisungen zum Ableiten und erstellen einen Typkonverter, die XAML-Verwendungen unterstützen kann, und Anwenden der <xref:System.ComponentModel.TypeConverterAttribute>, finden Sie unter [TypeConverter und XAML](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="e6c81-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="e6c81-160">Anforderungen an die Attributsyntax für XAML-Ereignishandler bei Ereignissen einer Benutzerdefinierten Klasse</span><span class="sxs-lookup"><span data-stu-id="e6c81-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="e6c81-161">Damit ein Ereignis als [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]-Ereignis verwendet werden kann, muss es als öffentliches Ereignis einer Klasse verfügbar gemacht werden, die einen Standardkonstruktor unterstützt, oder einer abstrakten Klasse, in der auf das Ereignis über abgeleitete Klassen zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="e6c81-161">To be usable as a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event, the event must be exposed as a public event on a class that supports a default constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="e6c81-162">Um einfache Art als Routingereignis, verwendet werden Ihre [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] Ereignis sollten explizit implementieren `add` und `remove` -Methoden, die hinzufügen und Entfernen von Ereignishandlern für die [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] Ereignissignatur und dann diese Handler an das <xref:System.Windows.UIElement.AddHandler%2A>und <xref:System.Windows.UIElement.RemoveHandler%2A> Methoden.</span><span class="sxs-lookup"><span data-stu-id="e6c81-162">In order to be used conveniently as a routed event, your [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event should implement explicit `add` and `remove` methods, which add and remove handlers for the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="e6c81-163">Diese Methoden fügen die Handler zum Routingereignis-Handlerspeicher auf der Instanz, der das Ereignis zugeordnet ist, hinzu oder entfernen sie.</span><span class="sxs-lookup"><span data-stu-id="e6c81-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e6c81-164">Es ist möglich, registrieren Sie Handler für Routingereignisse mithilfe direkt <xref:System.Windows.UIElement.AddHandler%2A>, und absichtlich kein definieren eine [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] -Ereignis, das das Routingereignis verfügbar macht.</span><span class="sxs-lookup"><span data-stu-id="e6c81-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event that exposes the routed event.</span></span> <span data-ttu-id="e6c81-165">Davon wird im Allgemeinen abgeraten, da das Ereignis in diesem Fall keine XAML-Attributsyntax zum Anhängen von Handlern ermöglicht, und die resultierende Klasse eine weniger transparente XAML-Ansicht der Möglichkeiten dieses Typs bieten wird.</span><span class="sxs-lookup"><span data-stu-id="e6c81-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a><span data-ttu-id="e6c81-166">Schreiben von Auflistungseigenschaften</span><span class="sxs-lookup"><span data-stu-id="e6c81-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="e6c81-167">Eigenschaften, die einen Auflistungstyp annehmen, haben eine XAML-Syntax, die Ihnen ermöglicht, Objekte anzugeben, die der Auflistung hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="e6c81-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="e6c81-168">Diese Syntax hat zwei interessante Features.</span><span class="sxs-lookup"><span data-stu-id="e6c81-168">This syntax has two notable features.</span></span>  
  
-   <span data-ttu-id="e6c81-169">Das Objekt, das das Auflistungsobjekt darstellt, muss nicht in Objektelementsyntax angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="e6c81-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="e6c81-170">Dieses Auflistungstyps ist implizit dann vorhanden, wenn Sie eine Eigenschaft in XAML angeben, die einen Auflistungstyp annimmt.</span><span class="sxs-lookup"><span data-stu-id="e6c81-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
-   <span data-ttu-id="e6c81-171">Untergeordnete Elemente der Auflistungseigenschaft im Markup werden so verarbeitet, dass sie Mitglieder der Auflistung werden.</span><span class="sxs-lookup"><span data-stu-id="e6c81-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="e6c81-172">Normalerweise erfolgt der Codezugriff auf die Mitglieder einer Auflistung über Listen- bzw. Wörterbuch-Methoden wie z.B. `Add`, oder über einen Indexer.</span><span class="sxs-lookup"><span data-stu-id="e6c81-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="e6c81-173">XAML-Syntax unterstützt jedoch weder Methoden noch Indexer (Ausnahme: XAML 2009 kann Methoden unterstützen, aber die Verwendungen von XAML 2009 schränkt die Verwendungsmöglichkeiten mit WPF ein; siehe [XAML 2009-Sprachfunktionen](../../../../docs/framework/xaml-services/xaml-2009-language-features.md)).</span><span class="sxs-lookup"><span data-stu-id="e6c81-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../../../docs/framework/xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="e6c81-174">Auflistungen sind offensichtlich eine durchaus übliche Anforderung beim Erstellen einer Struktur von Elementen, und Sie benötigen eine Methode zum Befüllen dieser Auflistungen im deklarativen XAML-Code.</span><span class="sxs-lookup"><span data-stu-id="e6c81-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="e6c81-175">Aus diesem Grund werden untergeordnete Elemente einer Auflistungseigenschaft verarbeitet, indem sie der Auflistung hinzugefügt werden, die dem Typwert der Auflistungseigenschaft entspricht.</span><span class="sxs-lookup"><span data-stu-id="e6c81-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="e6c81-176">Die Implementierung von .NET Framework-XAML-Diensten und somit der WPF XAML-Prozessor verwenden die folgende Definition für eine Auflistungseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="e6c81-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="e6c81-177">Die Eigenschaftentyp der Eigenschaft muss einen der folgenden implementieren:</span><span class="sxs-lookup"><span data-stu-id="e6c81-177">The property type of the property must implement one of the following:</span></span>  
  
-   <span data-ttu-id="e6c81-178">Implementiert <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="e6c81-178">Implements <xref:System.Collections.IList>.</span></span>  
  
-   <span data-ttu-id="e6c81-179">Implementiert <xref:System.Collections.IDictionary> oder das generische Äquivalent (<xref:System.Collections.Generic.IDictionary%602>).</span><span class="sxs-lookup"><span data-stu-id="e6c81-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
-   <span data-ttu-id="e6c81-180">Leitet sich von <xref:System.Array> (Weitere Informationen zu Arrays in XAML finden Sie unter [X: Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="e6c81-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md).)</span></span>  
  
-   <span data-ttu-id="e6c81-181">Implementiert <xref:System.Windows.Markup.IAddChild> (eine Schnittstelle definiert, indem [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span><span class="sxs-lookup"><span data-stu-id="e6c81-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="e6c81-182">Jeder dieser Typen in CLR verfügt über eine `Add`-Methode, die vom XAML-Prozessor verwendet wird, um der zugrunde liegenden Auflistung bei der Erstellung des Objektdiagramms Elemente hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="e6c81-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e6c81-183">Die generische `List` und `Dictionary` Schnittstellen (<xref:System.Collections.Generic.IList%601> und <xref:System.Collections.Generic.IDictionary%602>) werden nicht unterstützt, für die auflistungserkennung durch den [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML-Prozessor.</span><span class="sxs-lookup"><span data-stu-id="e6c81-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="e6c81-184">Allerdings können Sie die <xref:System.Collections.Generic.List%601> Klasse als Basisklasse verwendet, da er implementiert <xref:System.Collections.IList> direkt oder <xref:System.Collections.Generic.Dictionary%602> als Basisklasse, da er implementiert <xref:System.Collections.IDictionary> direkt.</span><span class="sxs-lookup"><span data-stu-id="e6c81-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="e6c81-185">Wenn Sie eine Eigenschaft, die eine Auflistung annimmt, deklarieren, sollten Sie sorgfältig darauf achten, wie dieser Eigenschaftswert in neuen Instanzen des Typs initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="e6c81-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="e6c81-186">Wenn Sie die Eigenschaft nicht als Abhängigkeitseigenschaft implementieren, ist es angebracht, der Eigenschaft ein unterstützendes Feld zuzuweisen, das den Typkonstruktor der Auflistung aufruft.</span><span class="sxs-lookup"><span data-stu-id="e6c81-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="e6c81-187">Wenn die Eigenschaft eine Abhängigkeitseigenschaft ist, müssen Sie die Auflistungseigenschaft als Teil des standardmäßigen Typkonstruktors initialisieren.</span><span class="sxs-lookup"><span data-stu-id="e6c81-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="e6c81-188">Der Grund dafür ist, dass eine Abhängigkeitseigenschaft ihren Standardwert aus Metadaten übernimmt, und Sie in der Regel nicht möchten, dass der Anfangswert einer Auflistungseigenschaft eine statische, gemeinsam genutzte Auflistung ist.</span><span class="sxs-lookup"><span data-stu-id="e6c81-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="e6c81-189">Es sollte eine Auflistungsinstanz pro enthaltender Typinstanz geben.</span><span class="sxs-lookup"><span data-stu-id="e6c81-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="e6c81-190">Weitere Informationen finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="e6c81-190">For more information, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="e6c81-191">Sie können für Ihre Auflistungseigenschaft einen benutzerdefinierten Auflistungstyp implementieren.</span><span class="sxs-lookup"><span data-stu-id="e6c81-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="e6c81-192">Aufgrund der impliziten Behandlung der Auflistungseigenschaft muss der benutzerdefinierte Auflistungstyp keinen Standardkonstruktor bereitstellen, um implizit in XAML verwendet werden zu können.</span><span class="sxs-lookup"><span data-stu-id="e6c81-192">Because of implicit collection property treatment, the custom collection type does not need to provide a default constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="e6c81-193">Allerdings können Sie für den Auflistungstyp optional einen Standardkonstruktor bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="e6c81-193">However, you can optionally provide a default constructor for the collection type.</span></span> <span data-ttu-id="e6c81-194">Dies ist eine durchaus ratsame Praxis.</span><span class="sxs-lookup"><span data-stu-id="e6c81-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="e6c81-195">Solange Sie keinen Standardkonstruktor bereitstellen, können Sie die Auflistung nicht explizit als Element deklarieren.</span><span class="sxs-lookup"><span data-stu-id="e6c81-195">Unless you do provide a default constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="e6c81-196">Einige Markupautoren sehen die explizite Auflistung möglicherweise als guten und zu bevorzugenden Markupstil.</span><span class="sxs-lookup"><span data-stu-id="e6c81-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="e6c81-197">Darüber hinaus kann ein Standardkonstruktor die Initialisierungsanforderungen vereinfachen, wenn Sie neue Objekte erstellen, die Ihren Auflistungstyp als Eigenschaftswert verwenden.</span><span class="sxs-lookup"><span data-stu-id="e6c81-197">Also, a default constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="e6c81-198">Deklarieren von XAML-Inhaltseigenschaften</span><span class="sxs-lookup"><span data-stu-id="e6c81-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="e6c81-199">Die XAML-Sprache definiert das Konzept einer [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]-Inhaltseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="e6c81-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="e6c81-200">Jede Klasse, die in Objektsyntax verwendet werden kann, hat genau eine XAML-Inhaltseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="e6c81-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="e6c81-201">Um eine Eigenschaft, die XAML-Inhaltseigenschaft für die Klasse zu deklarieren, wenden die <xref:System.Windows.Markup.ContentPropertyAttribute> als Teil der Definition der Klasse.</span><span class="sxs-lookup"><span data-stu-id="e6c81-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="e6c81-202">Geben Sie den Namen der gewünschten XAML Inhaltseigenschaft als die <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> im Attribut.</span><span class="sxs-lookup"><span data-stu-id="e6c81-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="e6c81-203">Die Eigenschaft angegeben wird als Zeichenfolge den Namen nicht als Konstrukt Reflektion z. B. <xref:System.Reflection.PropertyInfo>.</span><span class="sxs-lookup"><span data-stu-id="e6c81-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="e6c81-204">Sie können eine Auflistungseigenschaft als XAML-Inhaltseigenschaft angeben.</span><span class="sxs-lookup"><span data-stu-id="e6c81-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="e6c81-205">Dies führt zu einer Verwendung dieser Eigenschaft, bei der das Objektelement ein oder mehrere untergeordnete Elemente ohne dazwischenliegende Auflistungs-Objektelemente oder Eigenschaftenelement-Tags haben kann.</span><span class="sxs-lookup"><span data-stu-id="e6c81-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="e6c81-206">Diese Elemente werden dann als Wert für die XAML-Inhaltseigenschaft behandelt und der unterstützenden Auflistungsinstanz hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="e6c81-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="e6c81-207">Einige vorhandene XAML-Inhaltseigenschaften verwenden den Eigenschaftentyp `Object`.</span><span class="sxs-lookup"><span data-stu-id="e6c81-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="e6c81-208">Dies ermöglicht eine XAML-Inhalt, die primitive können Eigenschaftswerte wie z. B. eine <xref:System.String> sowie einen einzelnen Verweisobjektwert.</span><span class="sxs-lookup"><span data-stu-id="e6c81-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="e6c81-209">Befolgen Sie dieses Modell, ist Ihr Typ sowohl für die Typbestimmung als auch für die Behandlung der möglichen Typen zuständig.</span><span class="sxs-lookup"><span data-stu-id="e6c81-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="e6c81-210">Der Hauptgrund für eine <xref:System.Object> Content Typ ist zur Unterstützung von sowohl eine einfache Möglichkeit des Hinzufügens von Objektinhalten als Zeichenfolge (die eine standardmäßige WPF-Behandlung erhält) oder eine fortgeschrittene Möglichkeit zum Hinzufügen von Objekt-Inhalt, der angibt, eine nicht standardmäßige Präsentation oder zusätzliche Daten.</span><span class="sxs-lookup"><span data-stu-id="e6c81-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a><span data-ttu-id="e6c81-211">Serialisieren von XAML</span><span class="sxs-lookup"><span data-stu-id="e6c81-211">Serializing XAML</span></span>  
 <span data-ttu-id="e6c81-212">Für bestimmte Szenarios, z.B. Wenn Sie Autor eines Steuerelements sind, möchten Sie möglicherweise auch sicherstellen, dass jede Objektdarstellung, die in XAML instanziiert werden kann, auch wieder zurück in das entsprechende XAML-Markup serialisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="e6c81-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="e6c81-213">Serialisierungsanforderungen werden in diesem Thema nicht beschrieben.</span><span class="sxs-lookup"><span data-stu-id="e6c81-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="e6c81-214">Informationen hierzu finden Sie unter [Übersicht über das Erstellen von Steuerelementen](../../../../docs/framework/wpf/controls/control-authoring-overview.md) und [Elementstruktur und Serialisierung](../../../../docs/framework/wpf/advanced/element-tree-and-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="e6c81-214">See [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md) and [Element Tree and Serialization](../../../../docs/framework/wpf/advanced/element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e6c81-215">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="e6c81-215">See Also</span></span>  
 [<span data-ttu-id="e6c81-216">Übersicht über XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="e6c81-216">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)  
 [<span data-ttu-id="e6c81-217">Benutzerdefinierte Abhängigkeitseigenschaften</span><span class="sxs-lookup"><span data-stu-id="e6c81-217">Custom Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)  
 [<span data-ttu-id="e6c81-218">Übersicht über das Erstellen von Steuerelementen</span><span class="sxs-lookup"><span data-stu-id="e6c81-218">Control Authoring Overview</span></span>](../../../../docs/framework/wpf/controls/control-authoring-overview.md)  
 [<span data-ttu-id="e6c81-219">Übersicht über Basiselemente</span><span class="sxs-lookup"><span data-stu-id="e6c81-219">Base Elements Overview</span></span>](../../../../docs/framework/wpf/advanced/base-elements-overview.md)  
 [<span data-ttu-id="e6c81-220">Laden von XAML und Abhängigkeitseigenschaften</span><span class="sxs-lookup"><span data-stu-id="e6c81-220">XAML Loading and Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md)
