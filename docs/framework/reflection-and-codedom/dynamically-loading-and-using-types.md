---
title: Dynamisches Laden und Verwenden von Typen
description: Hier erfahren Sie mehr über das dynamische Laden und Verwenden von Typen in .NET. Verwenden Sie die Reflexion, mit der die Infrastruktur bereitgestellt wird, die von Sprachcompilern für die Implementierung impliziter später Bindungen verwendet wird.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- late binding, about late binding
- early binding
- dynamically loading and using types
- implicit late binding
- reflection, dynamically using types
ms.assetid: db985bec-5942-40ec-b13a-771ae98623dc
ms.openlocfilehash: be9991a4df866f65aabe063be3cc2b374f4d124d
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/26/2020
ms.locfileid: "96266791"
---
# <a name="dynamically-loading-and-using-types"></a><span data-ttu-id="83e3a-104">Dynamisches Laden und Verwenden von Typen</span><span class="sxs-lookup"><span data-stu-id="83e3a-104">Dynamically Loading and Using Types</span></span>

<span data-ttu-id="83e3a-105">Reflektion stellt Infrastruktur bereit, die von Sprachcompilern für die Implementierung impliziter später Bindungen verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="83e3a-105">Reflection provides infrastructure used by language compilers to implement implicit late binding.</span></span> <span data-ttu-id="83e3a-106">Unter Binden versteht man das Auffinden der Deklaration (d.h. der Implementierung), die einem eindeutig festgelegten Typ entspricht.</span><span class="sxs-lookup"><span data-stu-id="83e3a-106">Binding is the process of locating the declaration (that is, the implementation) that corresponds to a uniquely specified type.</span></span> <span data-ttu-id="83e3a-107">Wenn dieser Prozess zur Runtime und nicht zum Zeitpunkt der Kompilierung stattfindet, wird von einer späten Bindung gesprochen.</span><span class="sxs-lookup"><span data-stu-id="83e3a-107">When this process occurs at run time rather than at compile time, it is called late binding.</span></span> <span data-ttu-id="83e3a-108">Visual Basic ermöglicht Ihnen, die implizite späte Bindung in Ihrem Code zu verwenden. Der Visual Basic-Compiler ruft eine Hilfsmethode auf, die mithilfe von Reflektion den Objekttyp abruft.</span><span class="sxs-lookup"><span data-stu-id="83e3a-108">Visual Basic allows you to use implicit late binding in your code; the Visual Basic compiler calls a helper method that uses reflection to obtain the object type.</span></span> <span data-ttu-id="83e3a-109">Aufgrund der an die Hilfsmethode übergebenen Argumente wird die entsprechende Methode zur Runtime aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="83e3a-109">The arguments passed to the helper method cause the appropriate method to be invoked at run time.</span></span> <span data-ttu-id="83e3a-110">Diese Argumente sind die Instanz (ein Objekt), auf der die Methode aufgerufen werden muss, der Namen der aufgerufenen Methode (eine Zeichenfolge) und die Argumente, die an die aufgerufene Methode übergeben werden (ein Array von Objekten).</span><span class="sxs-lookup"><span data-stu-id="83e3a-110">These arguments are the instance (an object) on which to invoke the method, the name of the invoked method (a string), and the arguments passed to the invoked method (an array of objects).</span></span>  
  
 <span data-ttu-id="83e3a-111">Im folgenden Beispiel verwendet der Visual Basic-Compiler Reflektion implizit, um eine Methode für ein Objekt aufzurufen, dessen Typ zur Kompilierzeit nicht bekannt ist.</span><span class="sxs-lookup"><span data-stu-id="83e3a-111">In the following example, the Visual Basic compiler uses reflection implicitly to call a method on an object whose type is not known at compile time.</span></span> <span data-ttu-id="83e3a-112">Ein **HelloWorld**-Klasse verfügt über eine **PrintHello**-Methode, die „Hello World“ zusammen mit anderem Text ausgibt, der an die **PrintHello**-Methode übergeben wurde.</span><span class="sxs-lookup"><span data-stu-id="83e3a-112">A **HelloWorld** class has a **PrintHello** method that prints out "Hello World" concatenated with some text that is passed to the **PrintHello** method.</span></span> <span data-ttu-id="83e3a-113">Die in diesem Beispiel aufgerufene **PrintHello**-Methode ist eigentlich eine <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>-Methode. Im Visual Basic-Code kann die **PrintHello**-Methode aufgerufen werden, als ob der Typ des Objekts (helloObj) schon zur Kompilierzeit bekannt wäre (frühe Bindung) statt erst zur Runtime (späte Bindung).</span><span class="sxs-lookup"><span data-stu-id="83e3a-113">The **PrintHello** method called in this example is actually a <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>; the Visual Basic code allows the **PrintHello** method to be invoked as if the type of the object (helloObj) were known at compile time (early binding) rather than at run time (late binding).</span></span>  
  
```vb
Module Hello  
    Sub Main()  
        ' Sets up the variable.  
        Dim helloObj As Object  
        ' Creates the object.  
        helloObj = new HelloWorld()  
        ' Invokes the print method as if it was early bound  
        ' even though it is really late bound.  
        helloObj.PrintHello("Visual Basic Late Bound")  
    End Sub  
End Module  
```  
  
## <a name="custom-binding"></a><span data-ttu-id="83e3a-114">Benutzerdefinierte Bindung</span><span class="sxs-lookup"><span data-stu-id="83e3a-114">Custom Binding</span></span>  

 <span data-ttu-id="83e3a-115">Abgesehen davon, dass Reflektion implizit von Compilern für das späte Binden verwendet wird, kann sie auch explizit im Code für das späte Binden angewandt werden.</span><span class="sxs-lookup"><span data-stu-id="83e3a-115">In addition to being used implicitly by compilers for late binding, reflection can be used explicitly in code to accomplish late binding.</span></span>  
  
 <span data-ttu-id="83e3a-116">Die [Common Language Runtime](../../standard/clr.md) unterstützt verschiedene Programmiersprachen, wobei sich die Bindungsregeln dieser Sprachen unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="83e3a-116">The [common language runtime](../../standard/clr.md) supports multiple programming languages, and the binding rules of these languages differ.</span></span> <span data-ttu-id="83e3a-117">Beim frühen Binden können Codegeneratoren den Bindungsvorgang vollständig steuern.</span><span class="sxs-lookup"><span data-stu-id="83e3a-117">In the early-bound case, code generators can completely control this binding.</span></span> <span data-ttu-id="83e3a-118">Beim späten Binden durch Reflektion muss der Vorgang durch eine benutzerdefinierte Bindung gesteuert werden.</span><span class="sxs-lookup"><span data-stu-id="83e3a-118">However, in late binding through reflection, binding must be controlled by customized binding.</span></span> <span data-ttu-id="83e3a-119">Die <xref:System.Reflection.Binder>-Klasse stellt die benutzerdefinierte Steuerung der Auswahl und des Aufrufs von Membern bereit.</span><span class="sxs-lookup"><span data-stu-id="83e3a-119">The <xref:System.Reflection.Binder> class provides custom control of member selection and invocation.</span></span>  
  
 <span data-ttu-id="83e3a-120">Mithilfe der benutzerdefinierten Bindung können Sie eine Assembly zur Runtime laden, Informationen über Typen in dieser Assembly abrufen, den gewünschten Typ angeben und dann für diesen Typ die Methoden aufrufen oder auf die Felder bzw. Eigenschaften zugreifen.</span><span class="sxs-lookup"><span data-stu-id="83e3a-120">Using custom binding, you can load an assembly at run time, obtain information about types in that assembly, specify the type that you want, and then invoke methods or access fields or properties on that type.</span></span> <span data-ttu-id="83e3a-121">Diese Technik ist hilfreich, wenn Sie den Typ eines Objekts zur Kompilierzeit nicht kennen, z.B., wenn der Objekttyp von der Benutzereingabe abhängt.</span><span class="sxs-lookup"><span data-stu-id="83e3a-121">This technique is useful if you do not know an object's type at compile time, such as when the object type is dependent on user input.</span></span>  
  
 <span data-ttu-id="83e3a-122">Das folgende Beispiel zeigt einen einfachen benutzerdefinierten Binder, der keine Argumenttypumwandlung bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="83e3a-122">The following example demonstrates a simple custom binder that provides no argument type conversion.</span></span> <span data-ttu-id="83e3a-123">Der Code für `Simple_Type.dll` steht vor dem Hauptbeispiel.</span><span class="sxs-lookup"><span data-stu-id="83e3a-123">Code for `Simple_Type.dll` precedes the main example.</span></span> <span data-ttu-id="83e3a-124">Achten Sie darauf, dass Sie `Simple_Type.dll` erstellen und dann zur Buildzeit einen Verweis darauf in das Projekt einbinden.</span><span class="sxs-lookup"><span data-stu-id="83e3a-124">Be sure to build `Simple_Type.dll` and then include a reference to it in the project at build time.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#1](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source1.cpp#1)]
 [!code-csharp[Conceptual.Types.Dynamic#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source1.cs#1)]
 [!code-vb[Conceptual.Types.Dynamic#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source1.vb#1)]  
  
### <a name="invokemember-and-createinstance"></a><span data-ttu-id="83e3a-125">InvokeMember und CreateInstance</span><span class="sxs-lookup"><span data-stu-id="83e3a-125">InvokeMember and CreateInstance</span></span>  

 <span data-ttu-id="83e3a-126">Verwenden Sie <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>, um einen Member eines Typs aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="83e3a-126">Use <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> to invoke a member of a type.</span></span> <span data-ttu-id="83e3a-127">Die **CreateInstance**-Methoden verschiedener Klassen wie <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> und <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType> sind spezielle Formen von **InvokeMember**, die neue Instanzen des angegebenen Typs erstellen.</span><span class="sxs-lookup"><span data-stu-id="83e3a-127">The **CreateInstance** methods of various classes, such as <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, are specialized forms of **InvokeMember** that create new instances of the specified type.</span></span> <span data-ttu-id="83e3a-128">Die **Binder**-Klasse wird in diesen Methoden für die Auflösung von Überladungen und die Koersion von Argumenten verwendet.</span><span class="sxs-lookup"><span data-stu-id="83e3a-128">The **Binder** class is used for overload resolution and argument coercion in these methods.</span></span>  
  
 <span data-ttu-id="83e3a-129">Im folgenden Beispiel werden drei mögliche Kombinationen der Argumentkoersion (Typkonvertierung) und Memberauswahl dargestellt.</span><span class="sxs-lookup"><span data-stu-id="83e3a-129">The following example shows the three possible combinations of argument coercion (type conversion) and member selection.</span></span> <span data-ttu-id="83e3a-130">Im 1. Fall ist keine Argumentkoersion oder Memberauswahl erforderlich.</span><span class="sxs-lookup"><span data-stu-id="83e3a-130">In Case 1, no argument coercion or member selection is needed.</span></span> <span data-ttu-id="83e3a-131">Im 2. Fall ist nur die Memberauswahl notwendig.</span><span class="sxs-lookup"><span data-stu-id="83e3a-131">In Case 2, only member selection is needed.</span></span> <span data-ttu-id="83e3a-132">Im 3. Fall muss nur die Argumentkoersion vorgenommen werden.</span><span class="sxs-lookup"><span data-stu-id="83e3a-132">In Case 3, only argument coercion is needed.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source2.cpp#2)]
 [!code-csharp[Conceptual.Types.Dynamic#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source2.cs#2)]
 [!code-vb[Conceptual.Types.Dynamic#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source2.vb#2)]  
  
 <span data-ttu-id="83e3a-133">Die Überladungsauflösung ist nötig, wenn mehr als ein Member mit demselben Namen verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="83e3a-133">Overload resolution is needed when more than one member with the same name is available.</span></span> <span data-ttu-id="83e3a-134">Die Methoden <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> und <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> werden zum Auflösen der Bindung zu einem einzelnes Member verwendet.</span><span class="sxs-lookup"><span data-stu-id="83e3a-134">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> methods are used to resolve binding to a single member.</span></span> <span data-ttu-id="83e3a-135">**Binder.BindToMethod** stellt außerdem die Auflösung von Eigenschaften über die Eigenschaftenaccessoren **get** und **set** bereit.</span><span class="sxs-lookup"><span data-stu-id="83e3a-135">**Binder.BindToMethod** also provides property resolution through the **get** and **set** property accessors.</span></span>  
  
 <span data-ttu-id="83e3a-136">**BindToMethod** gibt die aufzurufende <xref:System.Reflection.MethodBase>-Klasse oder einen NULL-Verweis zurück (**Nothing** in Visual Basic), wenn kein solcher Aufruf möglich ist.</span><span class="sxs-lookup"><span data-stu-id="83e3a-136">**BindToMethod** returns the <xref:System.Reflection.MethodBase> to invoke, or a null reference (**Nothing** in Visual Basic) if no such invocation is possible.</span></span> <span data-ttu-id="83e3a-137">Die Rückgabewert von **MethodBase** muss keiner der im *match*-Parameter enthaltenen sein, obwohl dies normalerweise der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="83e3a-137">The **MethodBase** return value need not be one of those contained in the *match* parameter, although that is the usual case.</span></span>  
  
 <span data-ttu-id="83e3a-138">Wenn ByRef-Argumente vorhanden sind, kann der Aufrufer sie bei Bedarf wiederherstellen.</span><span class="sxs-lookup"><span data-stu-id="83e3a-138">When ByRef arguments are present, the caller might want to get them back.</span></span> <span data-ttu-id="83e3a-139">Aus diesem Grund ermöglicht es **Binder** einem Client, das Argumentarray wieder in seine ursprüngliche Form zu versetzen, wenn es von **BindToMethod** bearbeitet wurde.</span><span class="sxs-lookup"><span data-stu-id="83e3a-139">Therefore, **Binder** allows a client to map the array of arguments back to its original form if **BindToMethod** has manipulated the argument array.</span></span> <span data-ttu-id="83e3a-140">Dazu muss dem Aufrufer gewährleistet werden, dass die Reihenfolge der Argumente nicht verändert wurde.</span><span class="sxs-lookup"><span data-stu-id="83e3a-140">In order to do this, the caller must be guaranteed that the order of the arguments is unchanged.</span></span> <span data-ttu-id="83e3a-141">Wenn Argumente nach Namen übergeben werden, sortiert **Binder** das Argumentarray neu, und dies wird dem Aufrufer angezeigt.</span><span class="sxs-lookup"><span data-stu-id="83e3a-141">When arguments are passed by name, **Binder** reorders the argument array, and that is what the caller sees.</span></span> <span data-ttu-id="83e3a-142">Weitere Informationen finden Sie unter <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="83e3a-142">For more information, see <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="83e3a-143">Die Menge der verfügbaren Member sind diejenigen, die im Typ oder einem Basistyp definiert.</span><span class="sxs-lookup"><span data-stu-id="83e3a-143">The set of available members are those members defined in the type or any base type.</span></span> <span data-ttu-id="83e3a-144">Wenn <xref:System.Reflection.BindingFlags> angegeben wird, werden Member aller Zugriffsebenen in den Satz zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="83e3a-144">If <xref:System.Reflection.BindingFlags> is specified, members of any accessibility will be returned in the set.</span></span> <span data-ttu-id="83e3a-145">Wenn **BindingFlags.NonPublic** nicht angegeben wird, muss der Binder die Zugriffsregeln erzwingen.</span><span class="sxs-lookup"><span data-stu-id="83e3a-145">If **BindingFlags.NonPublic** is not specified, the binder must enforce accessibility rules.</span></span> <span data-ttu-id="83e3a-146">Wenn die Bindungsflags **Public** oder **NonPublic** angegeben werden, müssen Sie auch die Bindungsflags **Instance** oder **Static** angeben. Andernfalls werden keine Member zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="83e3a-146">When specifying the **Public** or **NonPublic** binding flag, you must also specify the **Instance** or **Static** binding flag, or no members will be returned.</span></span>  
  
 <span data-ttu-id="83e3a-147">Wenn nur ein Member mit dem angegebenen Namen verfügbar ist, ist kein Rückruf notwendig, und die Bindung wird auf der Methode ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="83e3a-147">If there is only one member of the given name, no callback is necessary, and binding is done on that method.</span></span> <span data-ttu-id="83e3a-148">Fall 1 des Codebeispiels veranschaulicht dies: Hier ist nur eine **PrintBob**-Methode verfügbar, und daher ist kein Rückruf erforderlich.</span><span class="sxs-lookup"><span data-stu-id="83e3a-148">Case 1 of the code example illustrates this point: Only one **PrintBob** method is available, and therefore no callback is needed.</span></span>  
  
 <span data-ttu-id="83e3a-149">Wenn sich mehr als ein Member im verfügbaren Satz befindet, werden alle diese Methoden an **BindToMethod** übergeben, das die richtige Methode ausgewählt und sie zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="83e3a-149">If there is more than one member in the available set, all these methods are passed to **BindToMethod**, which selects the appropriate method and returns it.</span></span> <span data-ttu-id="83e3a-150">Bei Fall 2 des Codebeispiels gibt es zwei Methoden namens **PrintValue**.</span><span class="sxs-lookup"><span data-stu-id="83e3a-150">In Case 2 of the code example, there are two methods named **PrintValue**.</span></span> <span data-ttu-id="83e3a-151">Die geeignete Methode wird über einen Aufruf von **BindToMethod** ausgewählt.</span><span class="sxs-lookup"><span data-stu-id="83e3a-151">The appropriate method is selected by the call to **BindToMethod**.</span></span>  
  
 <span data-ttu-id="83e3a-152"><xref:System.Reflection.Binder.ChangeType%2A> führt die Argumentkoersion (Typkonvertierung) aus, die die eigentlichen Argumente in den Typ der formalen Argumente der ausgewählten Methode konvertiert.</span><span class="sxs-lookup"><span data-stu-id="83e3a-152"><xref:System.Reflection.Binder.ChangeType%2A> performs argument coercion (type conversion), which converts the actual arguments to the type of the formal arguments of the selected method.</span></span> <span data-ttu-id="83e3a-153">**ChangeType** wird für jedes Argument aufgerufen, selbst wenn die Typen exakt übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="83e3a-153">**ChangeType** is called for every argument even if the types match exactly.</span></span>  
  
 <span data-ttu-id="83e3a-154">In Fall 3 des Codebeispiels wird ein Argument des Typs **String** mit dem Wert „5,5“ an eine Methode mit einem formalen Argument vom Typ **Double** übergeben.</span><span class="sxs-lookup"><span data-stu-id="83e3a-154">In Case 3 of the code example, an actual argument of type **String** with a value of "5.5" is passed to a method with a formal argument of type **Double**.</span></span> <span data-ttu-id="83e3a-155">Damit der Aufruf erfolgreich ausgeführt werden kann, muss der Zeichenfolgenwert „5,5“ in einen Double-Wert konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="83e3a-155">For the invocation to succeed, the string value "5.5" must be converted to a double value.</span></span> <span data-ttu-id="83e3a-156">Für diese Konvertierung ist **ChangeType** zuständig.</span><span class="sxs-lookup"><span data-stu-id="83e3a-156">**ChangeType** performs this conversion.</span></span>  
  
 <span data-ttu-id="83e3a-157">**ChangeType** führt nur verlustfreie oder [Erweiterungsumwandlungen](../../standard/base-types/type-conversion.md) aus, wie in der folgenden Tabelle dargestellt.</span><span class="sxs-lookup"><span data-stu-id="83e3a-157">**ChangeType** performs only lossless or [widening coercions](../../standard/base-types/type-conversion.md), as shown in the following table.</span></span>  
  
|<span data-ttu-id="83e3a-158">Quelltyp</span><span class="sxs-lookup"><span data-stu-id="83e3a-158">Source type</span></span>|<span data-ttu-id="83e3a-159">Zieltyp</span><span class="sxs-lookup"><span data-stu-id="83e3a-159">Target type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="83e3a-160">Beliebiger Typ</span><span class="sxs-lookup"><span data-stu-id="83e3a-160">Any type</span></span>|<span data-ttu-id="83e3a-161">Dessen Basistyp</span><span class="sxs-lookup"><span data-stu-id="83e3a-161">Its base type</span></span>|  
|<span data-ttu-id="83e3a-162">Beliebiger Typ</span><span class="sxs-lookup"><span data-stu-id="83e3a-162">Any type</span></span>|<span data-ttu-id="83e3a-163">Die implementierte Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="83e3a-163">Interface it implements</span></span>|  
|<span data-ttu-id="83e3a-164">Char</span><span class="sxs-lookup"><span data-stu-id="83e3a-164">Char</span></span>|<span data-ttu-id="83e3a-165">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="83e3a-165">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="83e3a-166">Byte</span><span class="sxs-lookup"><span data-stu-id="83e3a-166">Byte</span></span>|<span data-ttu-id="83e3a-167">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="83e3a-167">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="83e3a-168">SByte</span><span class="sxs-lookup"><span data-stu-id="83e3a-168">SByte</span></span>|<span data-ttu-id="83e3a-169">Int16, Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="83e3a-169">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="83e3a-170">UInt16</span><span class="sxs-lookup"><span data-stu-id="83e3a-170">UInt16</span></span>|<span data-ttu-id="83e3a-171">UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="83e3a-171">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="83e3a-172">Int16</span><span class="sxs-lookup"><span data-stu-id="83e3a-172">Int16</span></span>|<span data-ttu-id="83e3a-173">Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="83e3a-173">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="83e3a-174">UInt32</span><span class="sxs-lookup"><span data-stu-id="83e3a-174">UInt32</span></span>|<span data-ttu-id="83e3a-175">UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="83e3a-175">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="83e3a-176">Int32</span><span class="sxs-lookup"><span data-stu-id="83e3a-176">Int32</span></span>|<span data-ttu-id="83e3a-177">Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="83e3a-177">Int64, Single, Double</span></span>|  
|<span data-ttu-id="83e3a-178">UInt64</span><span class="sxs-lookup"><span data-stu-id="83e3a-178">UInt64</span></span>|<span data-ttu-id="83e3a-179">Single, Double</span><span class="sxs-lookup"><span data-stu-id="83e3a-179">Single, Double</span></span>|  
|<span data-ttu-id="83e3a-180">Int64</span><span class="sxs-lookup"><span data-stu-id="83e3a-180">Int64</span></span>|<span data-ttu-id="83e3a-181">Single, Double</span><span class="sxs-lookup"><span data-stu-id="83e3a-181">Single, Double</span></span>|  
|<span data-ttu-id="83e3a-182">Single</span><span class="sxs-lookup"><span data-stu-id="83e3a-182">Single</span></span>|<span data-ttu-id="83e3a-183">Double</span><span class="sxs-lookup"><span data-stu-id="83e3a-183">Double</span></span>|  
|<span data-ttu-id="83e3a-184">Nichtverweistyp</span><span class="sxs-lookup"><span data-stu-id="83e3a-184">Nonreference type</span></span>|<span data-ttu-id="83e3a-185">Verweistyp</span><span class="sxs-lookup"><span data-stu-id="83e3a-185">Reference type</span></span>|  
  
 <span data-ttu-id="83e3a-186">Die <xref:System.Type>-Klasse verfügt über **Get**-Methoden, die Parameter des Typs **Binder** nutzen, um Verweise auf einen bestimmten Member aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="83e3a-186">The <xref:System.Type> class has **Get** methods that use parameters of type **Binder** to resolve references to a particular member.</span></span> <span data-ttu-id="83e3a-187"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, und <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> suchen nach einem bestimmten Member des aktuellen Typs, indem sie die Signaturinformationen für diesen Member zur Verfügung stellen.</span><span class="sxs-lookup"><span data-stu-id="83e3a-187"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, and <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> search for a particular member of the current type by providing signature information for that member.</span></span> <span data-ttu-id="83e3a-188"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> und <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> werden wieder aufgerufen, um die jeweiligen Signaturinformationen der geeigneten Methoden auszuwählen.</span><span class="sxs-lookup"><span data-stu-id="83e3a-188"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> are called back on to select the given signature information of the appropriate methods.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="83e3a-189">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="83e3a-189">See also</span></span>

- <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- [<span data-ttu-id="83e3a-190">Anzeigen von Typinformationen</span><span class="sxs-lookup"><span data-stu-id="83e3a-190">Viewing Type Information</span></span>](viewing-type-information.md)
- [<span data-ttu-id="83e3a-191">Typkonvertierung in .NET Framework</span><span class="sxs-lookup"><span data-stu-id="83e3a-191">Type Conversion in the .NET Framework</span></span>](../../standard/base-types/type-conversion.md)
