---
title: Bausteine der C#-Programme
description: Hier lernen Sie Member, Ausdrücke und Anweisungen von C# kennen. Typen enthalten Member, die Sie schreiben. Diese Member werden aus Anweisungen und Ausdrücken erstellt.
ms.date: 08/06/2020
ms.openlocfilehash: e4350f2c2b6005fb59dd868f0f7f628bd07b0053
ms.sourcegitcommit: 0802ac583585110022beb6af8ea0b39188b77c43
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/26/2020
ms.locfileid: "93342695"
---
# <a name="program-building-blocks"></a><span data-ttu-id="dc977-105">Programmbausteine</span><span class="sxs-lookup"><span data-stu-id="dc977-105">Program building blocks</span></span>

<span data-ttu-id="dc977-106">Die im vorherigen Artikel beschriebenen Typen werden mithilfe der folgenden Bausteine erstellt: [\***Member** _](../programming-guide/classes-and-structs/members.md), [_*_Ausdrücke_*_ und _*_Anweisungen_*_](../programming-guide/statements-expressions-operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="dc977-106">The types described in the previous article are built using these building blocks: [\***members** _](../programming-guide/classes-and-structs/members.md), [_*_expressions_*_, and _*_statements_*_](../programming-guide/statements-expressions-operators/index.md).</span></span>

## <a name="members"></a><span data-ttu-id="dc977-107">Member</span><span class="sxs-lookup"><span data-stu-id="dc977-107">Members</span></span>

<span data-ttu-id="dc977-108">Die Member von `class` sind entweder _*_statische Member_*_ oder _*_Instanzmember_*_.</span><span class="sxs-lookup"><span data-stu-id="dc977-108">The members of a `class` are either _*_static members_*_ or _*_instance members_*_.</span></span> <span data-ttu-id="dc977-109">Statische Member gehören zu Klassen, Instanzmember gehören zu Objekten (Instanzen von Klassen).</span><span class="sxs-lookup"><span data-stu-id="dc977-109">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="dc977-110">In der folgenden Liste finden Sie einen Überblick über die Memberarten, die eine Klasse enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="dc977-110">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="dc977-111">_\*Konstanten\*\*: Konstante Werte, die der Klasse zugeordnet sind</span><span class="sxs-lookup"><span data-stu-id="dc977-111">_\*Constants\*\*: Constant values associated with the class</span></span>
- <span data-ttu-id="dc977-112">**Felder:**  Variablen, die der Klasse zugeordnet werden</span><span class="sxs-lookup"><span data-stu-id="dc977-112">**Fields**:  Variables that are associated of the class</span></span>
- <span data-ttu-id="dc977-113">**Methods** (Methoden):  Aktionen, die von der Klasse ausgeführt werden</span><span class="sxs-lookup"><span data-stu-id="dc977-113">**Methods**:  Actions that can be performed by the class</span></span>
- <span data-ttu-id="dc977-114">**Properties:** Aktionen im Zusammenhang mit dem Lesen und Schreiben von benannten Eigenschaften der Klasse</span><span class="sxs-lookup"><span data-stu-id="dc977-114">**Properties**: Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="dc977-115">**Indexer:** Aktionen im Zusammenhang mit dem Indizieren von Instanzen der Klasse, z.B. einem Array</span><span class="sxs-lookup"><span data-stu-id="dc977-115">**Indexers**: Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="dc977-116">**Ereignisse:** Benachrichtigungen, die von der Klasse generiert werden können</span><span class="sxs-lookup"><span data-stu-id="dc977-116">**Events**: Notifications that can be generated by the class</span></span>
- <span data-ttu-id="dc977-117">**Operatoren:** Operatoren für Konvertierungen und Ausdrücke, die von der Klasse unterstützt werden</span><span class="sxs-lookup"><span data-stu-id="dc977-117">**Operators**: Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="dc977-118">**Konstruktoren:** Aktionen, die zum Initialisieren von Instanzen der Klasse oder der Klasse selbst benötigt werden</span><span class="sxs-lookup"><span data-stu-id="dc977-118">**Constructors**: Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="dc977-119">**Finalizer:** Aktionen, die ausgeführt werden, bevor Instanzen der Klasse dauerhaft verworfen werden</span><span class="sxs-lookup"><span data-stu-id="dc977-119">**Finalizers**: Actions performed before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="dc977-120">**Typen:** Geschachtelte Typen, die von der Klasse deklariert werden</span><span class="sxs-lookup"><span data-stu-id="dc977-120">**Types**: Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="dc977-121">Barrierefreiheit</span><span class="sxs-lookup"><span data-stu-id="dc977-121">Accessibility</span></span>

<span data-ttu-id="dc977-122">Jeder Member einer Klasse ist mit einem Zugriff verknüpft, der die Regionen des Programmtexts steuert, die auf den Member zugreifen können.</span><span class="sxs-lookup"><span data-stu-id="dc977-122">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="dc977-123">Es gibt sechs mögliche Formen des Zugriffs.</span><span class="sxs-lookup"><span data-stu-id="dc977-123">There are six possible forms of accessibility.</span></span> <span data-ttu-id="dc977-124">Die Zugriffsmodifizierer werden im Folgenden zusammengefasst.</span><span class="sxs-lookup"><span data-stu-id="dc977-124">The access modifiers are summarized below.</span></span>

- <span data-ttu-id="dc977-125">`public`: Der Zugriff ist nicht eingeschränkt.</span><span class="sxs-lookup"><span data-stu-id="dc977-125">`public`: Access isn't limited.</span></span>
- <span data-ttu-id="dc977-126">`private`: Der Zugriff ist auf diese Klasse beschränkt.</span><span class="sxs-lookup"><span data-stu-id="dc977-126">`private`: Access is limited to this class.</span></span>
- <span data-ttu-id="dc977-127">`protected`: Der Zugriff ist auf diese Klasse oder von dieser abgeleiteten Klassen beschränkt.</span><span class="sxs-lookup"><span data-stu-id="dc977-127">`protected`: Access is limited to this class or classes derived from this class.</span></span>
- <span data-ttu-id="dc977-128">`internal`: Der Zugriff ist auf die aktuelle Assembly (`.exe` oder `.dll`) beschränkt.</span><span class="sxs-lookup"><span data-stu-id="dc977-128">`internal`: Access is limited to the current assembly (`.exe` or `.dll`).</span></span>
- <span data-ttu-id="dc977-129">`protected internal`: Der Zugriff ist auf diese Klasse, auf Klassen, die von dieser Klasse abgeleitet wurden, oder auf Klassen innerhalb der gleichen Assembly beschränkt.</span><span class="sxs-lookup"><span data-stu-id="dc977-129">`protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.</span></span>
- <span data-ttu-id="dc977-130">`private protected`: Der Zugriff ist auf diese Klasse und auf Klassen in derselben Assembly beschränkt, die von diesem Typ abgeleitet wurden.</span><span class="sxs-lookup"><span data-stu-id="dc977-130">`private protected`: Access is limited to this class or classes derived from this type within the same assembly.</span></span>

## <a name="fields"></a><span data-ttu-id="dc977-131">Felder</span><span class="sxs-lookup"><span data-stu-id="dc977-131">Fields</span></span>

<span data-ttu-id="dc977-132">Ein *Feld* ist eine Variable, die einer Klasse oder einer Instanz einer Klasse zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="dc977-132">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="dc977-133">Ein Feld, das mit dem static-Modifizierer deklariert wurde, definiert ein statisches Feld.</span><span class="sxs-lookup"><span data-stu-id="dc977-133">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="dc977-134">Ein statisches Feld identifiziert genau einen Speicherort.</span><span class="sxs-lookup"><span data-stu-id="dc977-134">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="dc977-135">Unabhängig davon, wie viele Instanzen einer Klasse erstellt werden, gibt es immer nur eine Kopie eines statischen Felds.</span><span class="sxs-lookup"><span data-stu-id="dc977-135">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="dc977-136">Ein Feld, das ohne den static-Modifizierer deklariert wurde, definiert ein Instanzfeld.</span><span class="sxs-lookup"><span data-stu-id="dc977-136">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="dc977-137">Jede Instanz einer Klasse enthält eine separate Kopie aller Instanzfelder dieser Klasse.</span><span class="sxs-lookup"><span data-stu-id="dc977-137">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="dc977-138">Im folgenden Beispiel weist jede Instanz der `Color`-Klasse eine separate Kopie der Instanzfelder `R`, `G` und `B` auf, aber es gibt nur eine Kopie der statischen Felder `Black`, `White`, `Red`, `Green` und `Blue`:</span><span class="sxs-lookup"><span data-stu-id="dc977-138">In the following example, each instance of the `Color` class has a separate copy of the `R`, `G`, and `B` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

<span data-ttu-id="dc977-139">Wie im vorherigen Beispiel gezeigt, können *schreibgeschützte Felder* mit einem `readonly`-Modifizierer deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-139">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="dc977-140">Zuweisungen zu einem schreibgeschützten Feld können nur im Rahmen der Deklaration des Felds oder in einem Konstruktor derselben Klasse auftreten.</span><span class="sxs-lookup"><span data-stu-id="dc977-140">Assignment to a read-only field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="dc977-141">Methoden</span><span class="sxs-lookup"><span data-stu-id="dc977-141">Methods</span></span>

<span data-ttu-id="dc977-142">Eine *Methode* ist ein Member, das eine Berechnung oder eine Aktion implementiert, die durch ein Objekt oder eine Klasse durchgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="dc977-142">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="dc977-143">Auf *statische Methoden* wird über die Klasse zugegriffen.</span><span class="sxs-lookup"><span data-stu-id="dc977-143">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="dc977-144">Auf *Instanzmethoden* wird über Instanzen der Klasse zugegriffen.</span><span class="sxs-lookup"><span data-stu-id="dc977-144">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="dc977-145">Methoden verfügen über eine Liste von *Parametern*, die Werte oder Variablenverweise darstellen, die an die Methode übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-145">Methods may have a list of *parameters*, which represent values or variable references passed to the method.</span></span> <span data-ttu-id="dc977-146">Methoden besitzen einen *Rückgabetyp*, der den Typ des Werts festlegt, der von der Methode berechnet und zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dc977-146">Methods have a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="dc977-147">Der Rückgabetyp einer Methode lautet `void`, wenn kein Wert zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dc977-147">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="dc977-148">Ebenso wie Typen können Methoden einen Satz an Typparametern aufweisen, für den beim Aufruf der Methode Typargumente angegeben werden müssen.</span><span class="sxs-lookup"><span data-stu-id="dc977-148">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="dc977-149">Im Gegensatz zu Typen können die Typargumente häufig aus den Argumenten eines Methodenaufrufs abgeleitet werden und müssen nicht explizit angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-149">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="dc977-150">Die *Signatur* einer Methode muss innerhalb der Klasse eindeutig sein, in der die Methode deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="dc977-150">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="dc977-151">Die Signatur einer Methode besteht aus dem Namen der Methode, der Anzahl von Typparametern und der Anzahl, den Modifizierern und den Typen der zugehörigen Parameter.</span><span class="sxs-lookup"><span data-stu-id="dc977-151">The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="dc977-152">Die Signatur einer Methode umfasst nicht den Rückgabetyp.</span><span class="sxs-lookup"><span data-stu-id="dc977-152">The signature of a method doesn't include the return type.</span></span>

<span data-ttu-id="dc977-153">Wenn es sich bei einem Methodenkörper um einen einzelnen Ausdruck handelt, kann die Methode mithilfe eines kompakten Ausdrucksformat definiert werden. Dies wird im folgenden Beispiel veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="dc977-153">When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:</span></span>

```csharp
public override string ToString() => "This is an object";
```

### <a name="parameters"></a><span data-ttu-id="dc977-154">Parameter</span><span class="sxs-lookup"><span data-stu-id="dc977-154">Parameters</span></span>

<span data-ttu-id="dc977-155">Parameter werden dazu verwendet, Werte oder Variablenverweise an Methoden zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="dc977-155">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="dc977-156">Die Parameter einer Methode erhalten ihre tatsächlichen Werte über *Argumente*, die angegeben werden, wenn die Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="dc977-156">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="dc977-157">Es gibt vier Arten von Parametern: Wertparameter, Verweisparameter, Ausgabeparameter und Parameterarrays.</span><span class="sxs-lookup"><span data-stu-id="dc977-157">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="dc977-158">Ein *Wertparameter* wird zum Übergeben von Eingabeargumenten verwendet.</span><span class="sxs-lookup"><span data-stu-id="dc977-158">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="dc977-159">Ein Wertparameter entspricht einer lokalen Variablen, die ihren Anfangswert von dem Argument erhält, das für den Parameter übergeben wurde.</span><span class="sxs-lookup"><span data-stu-id="dc977-159">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="dc977-160">Änderungen an einem Wertparameter wirken sich nicht auf das Argument aus, das für den Parameter übergeben wurde.</span><span class="sxs-lookup"><span data-stu-id="dc977-160">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="dc977-161">Wertparameter können optional sein, indem ein Standardwert festgelegt wird, damit die zugehörigen Argumente weggelassen werden können.</span><span class="sxs-lookup"><span data-stu-id="dc977-161">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="dc977-162">Ein *Verweisparameter* wird zum Übergeben von Argumenten als Verweis verwendet.</span><span class="sxs-lookup"><span data-stu-id="dc977-162">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="dc977-163">Das für einen Verweisparameter übergebene Argument muss eine Variable mit einem definitiven Wert sein.</span><span class="sxs-lookup"><span data-stu-id="dc977-163">The argument passed for a reference parameter must be a variable with a definite value.</span></span> <span data-ttu-id="dc977-164">Währen der Ausführung der Methode stellt der Verweisparameter denselben Speicherort wie die Argumentvariable dar.</span><span class="sxs-lookup"><span data-stu-id="dc977-164">During execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="dc977-165">Ein Verweisparameter wird mit dem `ref`-Modifizierer deklariert.</span><span class="sxs-lookup"><span data-stu-id="dc977-165">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="dc977-166">Das folgende Beispiel veranschaulicht die Verwendung des `ref`-Parameters.</span><span class="sxs-lookup"><span data-stu-id="dc977-166">The following example shows the use of `ref` parameters.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

<span data-ttu-id="dc977-167">Ein *Ausgabeparameter* wird zum Übergeben von Argumenten als Verweis verwendet.</span><span class="sxs-lookup"><span data-stu-id="dc977-167">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="dc977-168">Er ist einem Verweisparameter ähnlich, außer dass er nicht erfordert, dass Sie explizit dem vom Aufrufer bereitgestellten Argument einen Wert zuweisen.</span><span class="sxs-lookup"><span data-stu-id="dc977-168">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="dc977-169">Ein Ausgabeparameter wird mit dem `out`-Modifizierer deklariert.</span><span class="sxs-lookup"><span data-stu-id="dc977-169">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="dc977-170">Das folgende Beispiel zeigt die Verwendung von `out`-Parametern mithilfe der in C# 7 eingeführten Syntax.</span><span class="sxs-lookup"><span data-stu-id="dc977-170">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

<span data-ttu-id="dc977-171">Ein *Parameterarray* ermöglicht es, eine variable Anzahl von Argumenten an eine Methode zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="dc977-171">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="dc977-172">Ein Parameterarray wird mit dem `params`-Modifizierer deklariert.</span><span class="sxs-lookup"><span data-stu-id="dc977-172">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="dc977-173">Nur der letzte Parameter einer Methode kann ein Parameterarray sein, und es muss sich um ein eindimensionales Parameterarray handeln.</span><span class="sxs-lookup"><span data-stu-id="dc977-173">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="dc977-174">Die Methoden `Write` und `WriteLine` der Klasse <xref:System.Console?displayProperty=nameWithType> sind gute Beispiele für die Nutzung eines Parameterarrays.</span><span class="sxs-lookup"><span data-stu-id="dc977-174">The `Write` and `WriteLine` methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="dc977-175">Sie werden folgendermaßen deklariert.</span><span class="sxs-lookup"><span data-stu-id="dc977-175">They're declared as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

<span data-ttu-id="dc977-176">Innerhalb einer Methode mit einem Parameterarray verhält sich das Parameterarray wie ein regulärer Parameter des Arraytyps.</span><span class="sxs-lookup"><span data-stu-id="dc977-176">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="dc977-177">Beim Aufruf einer Methode mit einem Parameterarray ist es jedoch möglich, entweder ein einzelnes Argument des Parameterarraytyps oder eine beliebige Anzahl von Argumenten des Elementtyps des Parameterarrays zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="dc977-177">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="dc977-178">Im letzteren Fall wird automatisch eine Arrayinstanz erstellt und mit den vorgegebenen Argumenten initialisiert.</span><span class="sxs-lookup"><span data-stu-id="dc977-178">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="dc977-179">Dieses Beispiel:</span><span class="sxs-lookup"><span data-stu-id="dc977-179">This example</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

<span data-ttu-id="dc977-180">...entspricht dem folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="dc977-180">is equivalent to writing the following.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a><span data-ttu-id="dc977-181">Methodenkörper und lokale Variablen</span><span class="sxs-lookup"><span data-stu-id="dc977-181">Method body and local variables</span></span>

<span data-ttu-id="dc977-182">Der Methodenkörper gibt die Anweisungen an, die beim Aufruf der Methode ausgeführt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dc977-182">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="dc977-183">Ein Methodenkörper kann Variablen deklarieren, die für den Aufruf der Methode spezifisch sind.</span><span class="sxs-lookup"><span data-stu-id="dc977-183">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="dc977-184">Diese Variable werden *lokale Variablen* genannt.</span><span class="sxs-lookup"><span data-stu-id="dc977-184">Such variables are called *local variables*.</span></span> <span data-ttu-id="dc977-185">Die Deklaration einer lokalen Variable gibt einen Typnamen, einen Variablennamen und eventuell einen Anfangswert an.</span><span class="sxs-lookup"><span data-stu-id="dc977-185">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="dc977-186">Im folgenden Beispiel wird eine lokale Variable `i` mit einem Anfangswert von 0 und einer lokalen Variablen `j` ohne Anfangswert deklariert.</span><span class="sxs-lookup"><span data-stu-id="dc977-186">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

<span data-ttu-id="dc977-187">In C# muss eine lokale Variable *definitiv zugewiesen* sein, bevor ihr Wert abgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="dc977-187">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="dc977-188">Wenn die vorherige Deklaration von `i` beispielsweise keinen Anfangswert enthält, würde der Compiler bei der späteren Verwendung von `i` einen Fehler melden, weil `i` zu diesen Zeitpunkten im Programm nicht definitiv zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="dc977-188">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="dc977-189">Eine Methode kann `return`-Anweisungen verwenden, um die Steuerung an den zugehörigen Aufrufer zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="dc977-189">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="dc977-190">In einer Methode, die `void` zurückgibt, können `return`-Anweisungen keinen Ausdruck angeben.</span><span class="sxs-lookup"><span data-stu-id="dc977-190">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="dc977-191">In einer Methode, die nicht „void“ zurückgibt, müssen`return`-Anweisungen einen Ausdruck enthalten, der den Rückgabewert berechnet.</span><span class="sxs-lookup"><span data-stu-id="dc977-191">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="dc977-192">Statische Methoden und Instanzmethoden</span><span class="sxs-lookup"><span data-stu-id="dc977-192">Static and instance methods</span></span>

<span data-ttu-id="dc977-193">Eine Methode, die mit einem `static`-Modifizierer deklariert wird, ist eine *statische Methode*.</span><span class="sxs-lookup"><span data-stu-id="dc977-193">A method declared with a `static` modifier is a *static method*.</span></span> <span data-ttu-id="dc977-194">Eine statische Methode führt keine Vorgänge für eine spezifische Instanz aus und kann nur direkt auf statische Member zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dc977-194">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="dc977-195">Eine Methode, die ohne einen `static`-Modifizierer deklariert wird, ist eine *Instanzmethode*.</span><span class="sxs-lookup"><span data-stu-id="dc977-195">A method declared without a `static` modifier is an *instance method*.</span></span> <span data-ttu-id="dc977-196">Eine Instanzmethode führt Vorgänge für eine spezifische Instanz aus und kann sowohl auf statische Member als auch auf Instanzmember zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dc977-196">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="dc977-197">Auf die Instanz, für die eine Instanzmethode aufgerufen wurde, kann explizit als `this` zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-197">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="dc977-198">Es ist ein Fehler, in einer statischen Methode auf `this` zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="dc977-198">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="dc977-199">Die folgende `Entity`-Klasse umfasst sowohl statische Member als auch Instanzmember.</span><span class="sxs-lookup"><span data-stu-id="dc977-199">The following `Entity` class has both static and instance members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

<span data-ttu-id="dc977-200">Jede `Entity`-Instanz enthält eine Seriennummer (und vermutlich weitere Informationen, die hier nicht angezeigt werden).</span><span class="sxs-lookup"><span data-stu-id="dc977-200">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="dc977-201">Der `Entity`-Konstruktor (der einer Instanzmethode ähnelt) initialisiert die neue Instanz mit der nächsten verfügbaren Seriennummer.</span><span class="sxs-lookup"><span data-stu-id="dc977-201">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="dc977-202">Da der Konstruktor ein Instanzmember ist, kann er sowohl auf das `_serialNo`-Instanzfeld als auch auf das statische `s_nextSerialNo`-Feld zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dc977-202">Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.</span></span>

<span data-ttu-id="dc977-203">Die statischen Methoden `GetNextSerialNo` und `SetNextSerialNo` können auf das statische Feld `s_nextSerialNo` zugreifen, aber es wäre ein Fehler, über diese Methoden direkt auf das Instanzfeld `_serialNo` zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="dc977-203">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.</span></span>

<span data-ttu-id="dc977-204">Im folgenden Beispiel wird die Verwendung der `Entity`-Klasse veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dc977-204">The following example shows the use of the `Entity` class.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

<span data-ttu-id="dc977-205">Die statischen Methoden `SetNextSerialNo` und `GetNextSerialNo` werden für die Klasse aufgerufen, während die `GetSerialNo`-Instanzmethode für Instanzen der Klasse aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="dc977-205">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="dc977-206">Virtuelle, überschriebene und abstrakte Methoden</span><span class="sxs-lookup"><span data-stu-id="dc977-206">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="dc977-207">Wenn die Deklaration einer Instanzmethode einen `virtual`-Modifizierer enthält, wird die Methode als *virtuelle Methode* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="dc977-207">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="dc977-208">Ist kein virtual-Modifizierer vorhanden, spricht man von einer *nicht virtuellen Methode*.</span><span class="sxs-lookup"><span data-stu-id="dc977-208">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="dc977-209">Beim Aufruf einer virtuellen Methode bestimmt der *Laufzeittyp* der Instanz, für die der Aufruf erfolgt, die tatsächlich aufzurufende Methodenimplementierung.</span><span class="sxs-lookup"><span data-stu-id="dc977-209">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="dc977-210">Beim Aufruf einer nicht virtuellen Methode ist der *Kompilierzeittyp* der bestimmende Faktor.</span><span class="sxs-lookup"><span data-stu-id="dc977-210">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="dc977-211">Eine virtuelle Methode kann in einer abgeleiteten Klasse *überschrieben* werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-211">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="dc977-212">Wenn eine Instanzmethodendeklaration einen override-Modifizierer enthält, überschreibt die Methode eine geerbte virtuelle Methode mit derselben Signatur.</span><span class="sxs-lookup"><span data-stu-id="dc977-212">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="dc977-213">Mit der virtuellen Methodendeklaration wird eine neue Methode eingeführt.</span><span class="sxs-lookup"><span data-stu-id="dc977-213">A virtual method declaration introduces a new method.</span></span> <span data-ttu-id="dc977-214">Eine Deklaration einer Überschreibungsmethode spezialisiert eine vorhandene geerbte virtuelle Methode, indem eine neue Implementierung dieser Methode bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="dc977-214">An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="dc977-215">Eine *abstrakte Methode* ist eine virtuelle Methode ohne Implementierung.</span><span class="sxs-lookup"><span data-stu-id="dc977-215">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="dc977-216">Eine abstrakte Methode wird mit dem Modifizierer `abstract` deklariert und ist nur in einer abstrakten Klasse zulässig.</span><span class="sxs-lookup"><span data-stu-id="dc977-216">An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class.</span></span> <span data-ttu-id="dc977-217">Eine abstrakte Methode muss in jeder nicht abstrakten abgeleiteten Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-217">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="dc977-218">Im folgenden Beispiel wird die abstrakte Klasse `Expression` deklariert, die einen Ausdrucksbaumstrukturknoten sowie drei abgeleitete Klassen repräsentiert: `Constant`, `VariableReference` und `Operation`. Diese implementieren Ausdrucksbaumstrukturknoten für Konstanten, variable Verweise und arithmetische Operationen.</span><span class="sxs-lookup"><span data-stu-id="dc977-218">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="dc977-219">(Dieses Beispiel ähnelt den Ausdrucksbaumstrukturtypen, ist aber nicht mit diesen verwandt.)</span><span class="sxs-lookup"><span data-stu-id="dc977-219">(This example is similar to, but not related to the expression tree types).</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

<span data-ttu-id="dc977-220">Die vorherigen vier Klassen können zum Modellieren arithmetischer Ausdrücke verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-220">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="dc977-221">Beispielsweise kann mithilfe von Instanzen dieser Klassen der Ausdruck `x + 3` folgendermaßen dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-221">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

<span data-ttu-id="dc977-222">Die `Evaluate`-Methode einer `Expression`-Instanz wird aufgerufen, um den vorgegebenen Ausdruck auszuwerten und einen `double`-Wert zu generieren.</span><span class="sxs-lookup"><span data-stu-id="dc977-222">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="dc977-223">Die Methode verwendet ein `Dictionary`-Argument, das Variablennamen (als Schlüssel der Einträge) und Werte (als Werte der Einträge) enthält.</span><span class="sxs-lookup"><span data-stu-id="dc977-223">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="dc977-224">Da `Evaluate` eine abstrakte Methode ist, müssen nicht-abstrakte Klassen, die von `Expression` abgeleitet sind, `Evaluate` außer Kraft setzen.</span><span class="sxs-lookup"><span data-stu-id="dc977-224">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="dc977-225">Eine Implementierung von `Constant` für `Evaluate` gibt lediglich die gespeicherte Konstante zurück.</span><span class="sxs-lookup"><span data-stu-id="dc977-225">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="dc977-226">Eine Implementierung von `VariableReference` sucht im Wörterbuch nach dem Variablennamen und gibt den Ergebniswert zurück.</span><span class="sxs-lookup"><span data-stu-id="dc977-226">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="dc977-227">Eine Implementierung von `Operation` wertet zunächst (durch einen rekursiven Aufruf der zugehörigen `Evaluate`-Methoden) den linken und rechten Operanden aus und führt dann die vorgegebene arithmetische Operation aus.</span><span class="sxs-lookup"><span data-stu-id="dc977-227">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="dc977-228">Das folgende Programm verwendet die `Expression`-Klassen zum Auswerten des Ausdrucks `x * (y + 2)` für verschiedene Werte von `x` und `y`.</span><span class="sxs-lookup"><span data-stu-id="dc977-228">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a><span data-ttu-id="dc977-229">Methodenüberladung</span><span class="sxs-lookup"><span data-stu-id="dc977-229">Method overloading</span></span>

<span data-ttu-id="dc977-230">Das *Überladen* von Methoden macht es möglich, dass mehrere Methoden in derselben Klasse denselben Namen verwenden, solange sie eindeutige Signaturen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dc977-230">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="dc977-231">Beim Kompilieren des Aufrufs einer überladenen Methode verwendet der Compiler die *Überladungsauflösung*, um die spezifische Methode zu ermitteln, die aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dc977-231">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="dc977-232">Die Überladungsauflösung ermittelt die Methode, die den Argumenten am besten entspricht.</span><span class="sxs-lookup"><span data-stu-id="dc977-232">Overload resolution finds the one method that best matches the arguments.</span></span> <span data-ttu-id="dc977-233">Wenn keine optimale Übereinstimmung gefunden wird, wird ein Fehler gemeldet.</span><span class="sxs-lookup"><span data-stu-id="dc977-233">If no single best match can be found, an error is reported.</span></span> <span data-ttu-id="dc977-234">Das folgende Beispiel zeigt die Verwendung der Überladungsauflösung.</span><span class="sxs-lookup"><span data-stu-id="dc977-234">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="dc977-235">Der Kommentar für jeden Aufruf in der `UsageExample`-Methode zeigt, welche Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="dc977-235">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

<span data-ttu-id="dc977-236">Wie im Beispiel gezeigt, kann eine bestimmte Methode immer ausgewählt werden, indem die Argumente explizit in die exakten Parametertypen und Typargumente umgewandelt werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-236">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="dc977-237">Andere Funktionsmember</span><span class="sxs-lookup"><span data-stu-id="dc977-237">Other function members</span></span>

<span data-ttu-id="dc977-238">Member, die ausführbaren Code enthalten, werden als *Funktionsmember* einer Klasse bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="dc977-238">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="dc977-239">Im vorherigen Abschnitt wurden Methoden beschrieben, die die Haupttypen von Funktionsmembern sind.</span><span class="sxs-lookup"><span data-stu-id="dc977-239">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="dc977-240">In diesem Abschnitt werden die weiteren Funktionsmember behandelt, die C# unterstützt: Konstruktoren, Eigenschaften, Indexer, Ereignisse, Operatoren und Finalizer.</span><span class="sxs-lookup"><span data-stu-id="dc977-240">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="dc977-241">Im folgenden Beispiel wird eine generische Klasse namens `MyList<T>` gezeigt, die eine wachsende Liste von Objekten implementiert.</span><span class="sxs-lookup"><span data-stu-id="dc977-241">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="dc977-242">Die Klasse enthält verschiedene Beispiele der gängigsten Arten von Funktionsmembern.</span><span class="sxs-lookup"><span data-stu-id="dc977-242">The class contains several examples of the most common kinds of function members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a><span data-ttu-id="dc977-243">Konstruktoren</span><span class="sxs-lookup"><span data-stu-id="dc977-243">Constructors</span></span>

<span data-ttu-id="dc977-244">C# unterstützt sowohl Instanzkonstruktoren als auch statische Konstruktoren.</span><span class="sxs-lookup"><span data-stu-id="dc977-244">C# supports both instance and static constructors.</span></span> <span data-ttu-id="dc977-245">Ein *Instanzkonstruktor* ist ein Member, der die erforderlichen Aktionen zum Initialisieren einer Instanz einer Klasse implementiert.</span><span class="sxs-lookup"><span data-stu-id="dc977-245">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="dc977-246">Ein *statischer Konstruktor* ist ein Member, der die zum Initialisieren einer Klasse erforderlichen Aktionen implementiert, um die Klasse beim ersten Laden selbst zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="dc977-246">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="dc977-247">Ein Konstruktor wird wie eine Methode ohne Rückgabetyp und mit demselben Namen wie die enthaltende Klasse deklariert.</span><span class="sxs-lookup"><span data-stu-id="dc977-247">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="dc977-248">Wenn eine Konstruktordeklaration einen `static`-Modifizierer enthält, deklariert diese einen statischen Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="dc977-248">If a constructor declaration includes a `static` modifier, it declares a static constructor.</span></span> <span data-ttu-id="dc977-249">Andernfalls wird ein Instanzkonstruktor deklariert.</span><span class="sxs-lookup"><span data-stu-id="dc977-249">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="dc977-250">Instanzkonstruktoren können überladen werden und optionale Parameter verwenden.</span><span class="sxs-lookup"><span data-stu-id="dc977-250">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="dc977-251">Die `MyList<T>`-Klasse deklariert z.B. einen Instanzkonstruktor mit einem einzelnen optionalen `int`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="dc977-251">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="dc977-252">Instanzkonstruktoren werden über den `new`-Operator aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dc977-252">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="dc977-253">Die folgenden Anweisungen weisen zwei Instanzen von `MyList<string>` unter Verwendung des Konstruktors der `MyList`-Klasse zu, mit dem optionalen Argument und ohne das optionale Argument.</span><span class="sxs-lookup"><span data-stu-id="dc977-253">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

<span data-ttu-id="dc977-254">Im Gegensatz zu anderen Membern werden Instanzkonstruktoren nicht geerbt.</span><span class="sxs-lookup"><span data-stu-id="dc977-254">Unlike other members, instance constructors aren't inherited.</span></span> <span data-ttu-id="dc977-255">Eine Klasse weist keine anderen Instanzkonstruktoren auf als diejenigen, die tatsächlich in der Klasse deklariert wurden.</span><span class="sxs-lookup"><span data-stu-id="dc977-255">A class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="dc977-256">Wenn kein Instanzkonstruktor für eine Klasse angegeben ist, wird automatisch ein leerer Instanzkonstruktor ohne Parameter bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="dc977-256">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="dc977-257">Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="dc977-257">Properties</span></span>

<span data-ttu-id="dc977-258">*Eigenschaften* sind eine natürliche Erweiterung der Felder.</span><span class="sxs-lookup"><span data-stu-id="dc977-258">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="dc977-259">Beide sind benannte Member mit zugeordneten Typen, und für den Zugriff auf Felder und Eigenschaften wird dieselbe Syntax verwendet.</span><span class="sxs-lookup"><span data-stu-id="dc977-259">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="dc977-260">Im Gegensatz zu Feldern geben Eigenschaften jedoch keine Speicherorte an.</span><span class="sxs-lookup"><span data-stu-id="dc977-260">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="dc977-261">Stattdessen verfügen Eigenschaften über *Zugriffsmethoden*, die die ausgeführten Anweisungen angeben, wenn ihre Werte gelesen oder geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-261">Instead, properties have *accessors* that specify the statements executed when their values are read or written.</span></span>

<span data-ttu-id="dc977-262">Eine Eigenschaft wird wie ein Feld deklariert, abgesehen davon, dass die Deklaration nicht auf ein Semikolon, sondern auf einen get- oder set-Accessor endet, der von den Trennzeichen `{` und `}` umschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="dc977-262">A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="dc977-263">Eine Eigenschaft, die sowohl einen get- als auch einen set-Accessor aufweist, ist eine *Eigenschaft mit Lese- und Schreibzugriff*. Eine Eigenschaft, die nur einen get-Accessor aufweist, ist *schreibgeschützt*, eine Eigenschaft, die nur einen set-Accessor aufweist, ist *lesegeschützt*.</span><span class="sxs-lookup"><span data-stu-id="dc977-263">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="dc977-264">Ein get-Accessor entspricht einer Methode ohne Parameter mit einem Rückgabewert des Eigenschaftstyps.</span><span class="sxs-lookup"><span data-stu-id="dc977-264">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="dc977-265">Ein set-Accessor entspricht einer Methode mit einem einzigen Parameter namens „value“ ohne Rückgabetyp.</span><span class="sxs-lookup"><span data-stu-id="dc977-265">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="dc977-266">Die get-Zugriffsmethode berechnet den Wert der Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dc977-266">The get accessor computes the value of the property.</span></span> <span data-ttu-id="dc977-267">Die set-Zugriffsmethode stellt einen neuen Wert für die Eigenschaft bereit.</span><span class="sxs-lookup"><span data-stu-id="dc977-267">The set accessor provides a new value for the property.</span></span> <span data-ttu-id="dc977-268">Wenn die Eigenschaft das Ziel einer Zuweisung oder der Operand von `++` oder `--` ist, wird die set-Zugriffsmethode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dc977-268">When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked.</span></span> <span data-ttu-id="dc977-269">In anderen Fällen, in denen die Eigenschaft referenziert wird, wird die get-Zugriffsmethode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dc977-269">In other cases where the property is referenced, the get accessor is invoked.</span></span>

<span data-ttu-id="dc977-270">Die `MyList<T>`-Klasse deklariert die beiden Eigenschaften „`Count`“ und „`Capacity`“, von denen die eine schreibgeschützt ist und die andere Lese- und Schreibzugriff besitzt.</span><span class="sxs-lookup"><span data-stu-id="dc977-270">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="dc977-271">Im folgenden Beispielcode wird die Verwendung dieser Eigenschaften veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="dc977-271">The following code is an example of use of these properties:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

<span data-ttu-id="dc977-272">Ähnlich wie bei Feldern und Methoden unterstützt C# sowohl Instanzeigenschaften als auch statische Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="dc977-272">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="dc977-273">Statische Eigenschaften werden mit dem static-Modifizierer, Instanzeigenschaften werden ohne static-Modifizierer deklariert.</span><span class="sxs-lookup"><span data-stu-id="dc977-273">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="dc977-274">Die Accessors einer Eigenschaft können virtuell sein.</span><span class="sxs-lookup"><span data-stu-id="dc977-274">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="dc977-275">Wenn eine Eigenschaftendeklaration einen `virtual`-, `abstract`- oder `override`-Modifizierer enthält, wird dieser auf den Accessor der Eigenschaft angewendet.</span><span class="sxs-lookup"><span data-stu-id="dc977-275">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="dc977-276">Indexer</span><span class="sxs-lookup"><span data-stu-id="dc977-276">Indexers</span></span>

<span data-ttu-id="dc977-277">Ein *Indexer* ist ein Member, mit dem Objekte wie ein Array indiziert werden können.</span><span class="sxs-lookup"><span data-stu-id="dc977-277">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="dc977-278">Ein Indexer wird wie eine Eigenschaft deklariert, abgesehen davon, dass der Name des Members `this` ist, gefolgt von einer Parameterliste, die zwischen die Trennzeichen `[` und `]` geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="dc977-278">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="dc977-279">Die Parameter stehen im Accessor des Indexers zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="dc977-279">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="dc977-280">Ähnlich wie Eigenschaften können Indexer Lese-/Schreibzugriff besitzen, schreibgeschützt und lesegeschützt sein und virtuelle Accessors verwenden.</span><span class="sxs-lookup"><span data-stu-id="dc977-280">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="dc977-281">Die `MyList<T>`-Klasse deklariert einen einzigen Indexer mit Lese-/Schreibzugriff, der einen `int`-Parameter akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="dc977-281">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="dc977-282">Der Indexer ermöglicht es, Instanzen von `MyList<T>` mit `int`-Werten zu indizieren.</span><span class="sxs-lookup"><span data-stu-id="dc977-282">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="dc977-283">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="dc977-283">For example:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAccess":::

<span data-ttu-id="dc977-284">Indexer können überladen werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-284">Indexers can be overloaded.</span></span> <span data-ttu-id="dc977-285">Eine Klasse kann mehrere Indexer deklarieren, solange sich die Anzahl oder die Typen ihrer Parameter unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="dc977-285">A class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="dc977-286">Events</span><span class="sxs-lookup"><span data-stu-id="dc977-286">Events</span></span>

<span data-ttu-id="dc977-287">Ein *Ereignis* ist ein Member, der es einer Klasse oder einem Objekt ermöglicht, Benachrichtigungen bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="dc977-287">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="dc977-288">Ein Ereignis wird wie ein Feld deklariert, abgesehen davon, dass es ein `event`-Schlüsselwort enthält und einen Delegattyp aufweisen muss.</span><span class="sxs-lookup"><span data-stu-id="dc977-288">An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="dc977-289">Innerhalb einer Klasse, die einen Ereignismember deklariert, verhält sich das Ereignis wie ein Feld des Delegattyps (vorausgesetzt, das Ereignis ist nicht abstrakt und deklariert keine Zugriffsmethoden).</span><span class="sxs-lookup"><span data-stu-id="dc977-289">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="dc977-290">Das Feld speichert einen Verweis auf einen Delegaten, der die Ereignishandler repräsentiert, die dem Ereignis hinzugefügt wurden.</span><span class="sxs-lookup"><span data-stu-id="dc977-290">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="dc977-291">Wenn keine Ereignishandler vorhanden sind, ist das Feld `null`.</span><span class="sxs-lookup"><span data-stu-id="dc977-291">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="dc977-292">Die `MyList<T>`-Klasse deklariert einen einzigen Ereignismember namens `Changed`, der angibt, dass der Liste ein neues Element hinzugefügt wurde.</span><span class="sxs-lookup"><span data-stu-id="dc977-292">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="dc977-293">Das Changed-Ereignis wird durch die virtuelle Methode `OnChanged` ausgelöst, die zunächst prüft, ob das Ereignis `null` ist (d.h. nicht über Handler verfügt).</span><span class="sxs-lookup"><span data-stu-id="dc977-293">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="dc977-294">Das Auslösen eines Ereignisses entspricht exakt dem Aufrufen des Delegats, der durch das Ereignis repräsentiert wird.</span><span class="sxs-lookup"><span data-stu-id="dc977-294">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event.</span></span> <span data-ttu-id="dc977-295">Es gibt keine speziellen Sprachkonstrukte zum Auslösen von Ereignissen.</span><span class="sxs-lookup"><span data-stu-id="dc977-295">There are no special language constructs for raising events.</span></span>

<span data-ttu-id="dc977-296">Clients reagieren über *Ereignishandler* auf Ereignisse.</span><span class="sxs-lookup"><span data-stu-id="dc977-296">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="dc977-297">Ereignishandler werden unter Verwendung des `+=`-Operators angefügt und mit dem `-=`-Operator entfernt.</span><span class="sxs-lookup"><span data-stu-id="dc977-297">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="dc977-298">Im folgenden Beispiel wird dem `Changed`-Ereignis von `MyList<string>` ein Ereignishandler hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="dc977-298">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

<span data-ttu-id="dc977-299">In fortgeschrittenen Szenarios, in denen die zugrunde liegende Speicherung eines Ereignisses gesteuert werden soll, kann eine Ereignisdeklaration explizit die Zugriffsmethoden `add` und `remove` bereitstellen, die der Zugriffsmethode `set` einer Eigenschaft ähneln.</span><span class="sxs-lookup"><span data-stu-id="dc977-299">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="dc977-300">Operatoren</span><span class="sxs-lookup"><span data-stu-id="dc977-300">Operators</span></span>

<span data-ttu-id="dc977-301">Ein *Operator* ist ein Member, der die Bedeutung der Anwendung eines bestimmten Ausdrucksoperators auf Instanzen einer Klasse definiert.</span><span class="sxs-lookup"><span data-stu-id="dc977-301">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="dc977-302">Es können drei Arten von Operatoren definiert werden: unäre Operatoren, binäre Operatoren und Konvertierungsoperatoren.</span><span class="sxs-lookup"><span data-stu-id="dc977-302">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="dc977-303">Alle Operatoren müssen als `public` und `static` deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-303">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="dc977-304">Die `MyList<T>`-Klasse deklariert zwei Operatoren: `operator ==` und `operator !=`.</span><span class="sxs-lookup"><span data-stu-id="dc977-304">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`.</span></span> <span data-ttu-id="dc977-305">Diese überschriebenen Operatoren verleihen Ausdrücken eine neue Bedeutung, die diese Operatoren auf `MyList`-Instanzen anwenden.</span><span class="sxs-lookup"><span data-stu-id="dc977-305">These overridden operators give new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="dc977-306">Insbesondere die Operatoren definieren die Gleichheit für zwei Instanzen von `MyList<T>`, indem alle enthaltenen Objekte mithilfe ihrer `Equals`-Methoden verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-306">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods.</span></span> <span data-ttu-id="dc977-307">Im folgenden Beispiel wird der `==`-Operator verwendet, um zwei Instanzen von `MyList<int>` zu vergleichen.</span><span class="sxs-lookup"><span data-stu-id="dc977-307">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

<span data-ttu-id="dc977-308">Die erste Methode `Console.WriteLine` gibt `True` aus, weil die zwei Listen dieselbe Anzahl von Objekten mit denselben Werten in derselben Reihenfolge enthalten.</span><span class="sxs-lookup"><span data-stu-id="dc977-308">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="dc977-309">Wenn `MyList<T>` nicht `operator ==` definieren würde, würde die Ausgabe der ersten `Console.WriteLine`-Methode `False` lauten, weil `a` und `b` auf unterschiedliche `MyList<int>`-Instanzen verweisen.</span><span class="sxs-lookup"><span data-stu-id="dc977-309">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="dc977-310">Finalizer</span><span class="sxs-lookup"><span data-stu-id="dc977-310">Finalizers</span></span>

<span data-ttu-id="dc977-311">Ein *Finalizer* ist ein Member, der die erforderlichen Aktionen zum Bereinigen einer Instanz einer Klasse implementiert.</span><span class="sxs-lookup"><span data-stu-id="dc977-311">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="dc977-312">In der Regel ist ein Finalizer erforderlich, um nicht verwaltete Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="dc977-312">Typically, a finalizer is needed to release unmanaged resources.</span></span> <span data-ttu-id="dc977-313">Finalizer können weder Parameter noch Zugriffsmodifizierer aufweisen und können nicht explizit aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-313">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="dc977-314">Der Finalizer für eine Instanz wird bei der Garbagecollection automatisch aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dc977-314">The finalizer for an instance is invoked automatically during garbage collection.</span></span> <span data-ttu-id="dc977-315">Weitere Details finden Sie im Artikel zum Thema [Finalizer](../programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="dc977-315">For more details, see the article on [finalizers](../programming-guide/classes-and-structs/destructors.md).</span></span>

<span data-ttu-id="dc977-316">Der Garbage Collector kann weitestgehend selbst über den Zeitpunkt der Objektbereinigung und die Ausführung der Finalizer entscheiden.</span><span class="sxs-lookup"><span data-stu-id="dc977-316">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="dc977-317">Insbesondere der Zeitpunkt für den Aufruf der Finalizer ist nicht festgelegt, und Finalizer können für beliebige Threads ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-317">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="dc977-318">Aus diesen und weiteren Gründen sollten Klassen Finalizer nur dann implementieren, wenn keine andere Lösung möglich ist.</span><span class="sxs-lookup"><span data-stu-id="dc977-318">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="dc977-319">Die `using`-Anweisung bietet einen besseren Ansatz für die Objektzerstörung.</span><span class="sxs-lookup"><span data-stu-id="dc977-319">The `using` statement provides a better approach to object destruction.</span></span>

## <a name="expressions"></a><span data-ttu-id="dc977-320">Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="dc977-320">Expressions</span></span>

<span data-ttu-id="dc977-321">*Ausdrücke* bestehen aus *Operanden* und *Operatoren*.</span><span class="sxs-lookup"><span data-stu-id="dc977-321">*Expressions* are constructed from *operands* and *operators*.</span></span> <span data-ttu-id="dc977-322">Die Operatoren eines Ausdrucks geben an, welche Operationen auf die Operanden angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-322">The operators of an expression indicate which operations to apply to the operands.</span></span> <span data-ttu-id="dc977-323">Beispiele für Operatoren sind `+`, `-`, `*`, `/` und `new`.</span><span class="sxs-lookup"><span data-stu-id="dc977-323">Examples of operators include `+`, `-`, `*`, `/`, and `new`.</span></span> <span data-ttu-id="dc977-324">Beispiele für Operanden sind Literale, Felder, lokale Variablen und Ausdrücke.</span><span class="sxs-lookup"><span data-stu-id="dc977-324">Examples of operands include literals, fields, local variables, and expressions.</span></span>

<span data-ttu-id="dc977-325">Wenn ein Ausdruck mehrere Operatoren enthält, steuert die *Rangfolge* der Operatoren die Reihenfolge, in der die einzelnen Operatoren ausgewertet werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-325">When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated.</span></span> <span data-ttu-id="dc977-326">Der Ausdruck `x + y * z` wird z.B. als `x + (y * z)` ausgewertet, da der `*`-Operator Vorrang vor dem `+`-Operator hat.</span><span class="sxs-lookup"><span data-stu-id="dc977-326">For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.</span></span>

<span data-ttu-id="dc977-327">Tritt ein Operand zwischen zwei Operatoren mit gleicher Rangfolge auf, steuert die *Assoziativität* der Operatoren die Reihenfolge, in der die Vorgänge ausgeführt werden:</span><span class="sxs-lookup"><span data-stu-id="dc977-327">When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:</span></span>

* <span data-ttu-id="dc977-328">Mit Ausnahme der Zuweisungs- und NULL-Sammeloperatoren sind alle binären Operatoren *linksassoziativ*, was bedeutet, dass Vorgänge von links nach rechts ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-328">Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right.</span></span> <span data-ttu-id="dc977-329">`x + y + z` wird beispielsweise als `(x + y) + z` ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="dc977-329">For example, `x + y + z` is evaluated as `(x + y) + z`.</span></span>
* <span data-ttu-id="dc977-330">Die Zuweisungsoperatoren, die NULL-Sammeloperatoren `??` und `??=` und der bedingte Operator `?:` sind *rechtsassoziativ*, d.h., die Operationen werden von rechts nach links ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="dc977-330">The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left.</span></span> <span data-ttu-id="dc977-331">`x = y = z` wird beispielsweise als `x = (y = z)` ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="dc977-331">For example, `x = y = z` is evaluated as `x = (y = z)`.</span></span>

<span data-ttu-id="dc977-332">Rangfolge und Assoziativität können mit Klammern gesteuert werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-332">Precedence and associativity can be controlled using parentheses.</span></span> <span data-ttu-id="dc977-333">In `x + y * z` wird beispielsweise zuerst `y` mit `z` multipliziert und dann das Ergebnis zu `x` addiert, aber in `(x + y) * z` werden zunächst `x` und `y` addiert, und dann wird das Ergebnis mit `z` multipliziert.</span><span class="sxs-lookup"><span data-stu-id="dc977-333">For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.</span></span>

<span data-ttu-id="dc977-334">Die meisten Operatoren können [*überladen*](../language-reference/operators/operator-overloading.md) werden.</span><span class="sxs-lookup"><span data-stu-id="dc977-334">Most operators can be [*overloaded*](../language-reference/operators/operator-overloading.md).</span></span> <span data-ttu-id="dc977-335">Das Überladen von Operatoren ermöglicht die Angabe benutzerdefinierter Operatorimplementierungen für Vorgänge, in denen einer der Operanden oder beide einer benutzerdefinierten Klasse oder einem benutzerdefinierten Strukturtyp angehören.</span><span class="sxs-lookup"><span data-stu-id="dc977-335">Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</span></span>

<span data-ttu-id="dc977-336">C# bietet eine Reihe von Operatoren für [arithmetische](../language-reference/operators/arithmetic-operators.md), [logische](../language-reference/operators/boolean-logical-operators.md), [bitweise und Verschiebungsvorgänge](../language-reference/operators/bitwise-and-shift-operators.md) sowie Vergleiche von [Gleichheit](../language-reference/operators/equality-operators.md) und [Reihenfolge](../language-reference/operators/comparison-operators.md).</span><span class="sxs-lookup"><span data-stu-id="dc977-336">C# provides a number of operators to perform [arithmetic](../language-reference/operators/arithmetic-operators.md), [logical](../language-reference/operators/boolean-logical-operators.md), [bitwise and shift](../language-reference/operators/bitwise-and-shift-operators.md) operations and [equality](../language-reference/operators/equality-operators.md) and [order](../language-reference/operators/comparison-operators.md) comparisons.</span></span>

<span data-ttu-id="dc977-337">Die vollständige Liste der nach Rangfolgenebene sortierten C#-Operatoren finden Sie unter [C#-Operatoren](../language-reference/operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="dc977-337">For the complete list of C# operators ordered by precedence level, see [C# operators](../language-reference/operators/index.md).</span></span>

## <a name="statements"></a><span data-ttu-id="dc977-338">Anweisungen</span><span class="sxs-lookup"><span data-stu-id="dc977-338">Statements</span></span>

<span data-ttu-id="dc977-339">Die Aktionen eines Programms werden mit *Anweisungen* ausgedrückt.</span><span class="sxs-lookup"><span data-stu-id="dc977-339">The actions of a program are expressed using *statements*.</span></span> <span data-ttu-id="dc977-340">C# unterstützt verschiedene Arten von Anweisungen, von denen ein Teil als eingebettete Anweisungen definiert ist.</span><span class="sxs-lookup"><span data-stu-id="dc977-340">C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.</span></span>

- <span data-ttu-id="dc977-341">Ein *Block* ermöglicht, mehrere Anweisungen in Kontexten zu schreiben, in denen eine einzelne Anweisung zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="dc977-341">A *block* permits multiple statements to be written in contexts where a single statement is allowed.</span></span> <span data-ttu-id="dc977-342">Ein Block besteht aus einer Liste von Anweisungen, die zwischen den Trennzeichen `{` und `}` geschrieben sind.</span><span class="sxs-lookup"><span data-stu-id="dc977-342">A block consists of a list of statements written between the delimiters `{` and `}`.</span></span>
- <span data-ttu-id="dc977-343">*Deklarationsanweisungen* werden verwendet, um lokale Variablen und Konstanten deklarieren.</span><span class="sxs-lookup"><span data-stu-id="dc977-343">*Declaration statements* are used to declare local variables and constants.</span></span>
- <span data-ttu-id="dc977-344">*Ausdrucksanweisungen* werden zum Auswerten von Ausdrücken verwendet.</span><span class="sxs-lookup"><span data-stu-id="dc977-344">*Expression statements* are used to evaluate expressions.</span></span> <span data-ttu-id="dc977-345">Ausdrücke, die als Anweisungen verwendet werden können, enthalten Methodenaufrufe, Objektzuordnungen mit dem `new`-Operator, Zuweisungen mit `=` und den Verbundzuweisungsoperatoren, Inkrementier- und Dekrementiervorgänge unter Verwendung des `++`- und `--`-Operators und `await`-Ausdrücke.</span><span class="sxs-lookup"><span data-stu-id="dc977-345">Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.</span></span>
- <span data-ttu-id="dc977-346">*Auswahlanweisungen* werden verwendet, um eine Anzahl von möglichen Anweisungen für die Ausführung anhand des Werts eines Ausdrucks auszuwählen.</span><span class="sxs-lookup"><span data-stu-id="dc977-346">*Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression.</span></span> <span data-ttu-id="dc977-347">Diese Gruppe enthält die Anweisungen `if` und `switch`.</span><span class="sxs-lookup"><span data-stu-id="dc977-347">This group contains the `if` and `switch` statements.</span></span>
- <span data-ttu-id="dc977-348">*Iterationsanweisungen* werden verwendet, um eine eingebettete Anweisung wiederholt auszuführen.</span><span class="sxs-lookup"><span data-stu-id="dc977-348">*Iteration statements* are used to execute repeatedly an embedded statement.</span></span> <span data-ttu-id="dc977-349">Diese Gruppe enthält die Anweisungen `while`, `do`, `for` und `foreach`.</span><span class="sxs-lookup"><span data-stu-id="dc977-349">This group contains the `while`, `do`, `for`, and `foreach` statements.</span></span>
- <span data-ttu-id="dc977-350">*Sprunganweisungen* werden verwendet, um die Steuerung zu übertragen.</span><span class="sxs-lookup"><span data-stu-id="dc977-350">*Jump statements* are used to transfer control.</span></span> <span data-ttu-id="dc977-351">Diese Gruppe enthält die Anweisungen `break`, `continue`, `goto`, `throw`, `return` und `yield`.</span><span class="sxs-lookup"><span data-stu-id="dc977-351">This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.</span></span>
- <span data-ttu-id="dc977-352">Mit der `try`... `catch`-Anweisung werden Ausnahmen abgefangen, die während der Ausführung eines Blocks auftreten, und mit der `try`... `finally`-Anweisung wird Finalisierungscode angegeben, der immer ausgeführt wird, unabhängig davon, ob eine Ausnahme aufgetreten ist oder nicht.</span><span class="sxs-lookup"><span data-stu-id="dc977-352">The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.</span></span>
- <span data-ttu-id="dc977-353">Mit den Anweisungen `checked` und `unchecked` wird der Überlaufüberprüfungs-Kontext für arithmetische Operationen für Ganzzahltypen und Konvertierungen gesteuert.</span><span class="sxs-lookup"><span data-stu-id="dc977-353">The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.</span></span>
- <span data-ttu-id="dc977-354">Die `lock`-Anweisung wird verwendet, um die Sperre für gegenseitigen Ausschluss für ein bestimmtes Objekt abzurufen, eine Anweisung auszuführen und die Sperre aufzuheben.</span><span class="sxs-lookup"><span data-stu-id="dc977-354">The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.</span></span>
- <span data-ttu-id="dc977-355">Die `using`-Anweisung wird verwendet, um eine Ressource abzurufen, eine Anweisung auszuführen und dann diese Ressource zu verwerfen.</span><span class="sxs-lookup"><span data-stu-id="dc977-355">The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.</span></span>

<span data-ttu-id="dc977-356">In der folgenden Liste werden die Arten von Anweisungen aufgeführt, die verwendet werden können:</span><span class="sxs-lookup"><span data-stu-id="dc977-356">The following lists the kinds of statements that can be used:</span></span>

* <span data-ttu-id="dc977-357">Deklaration lokaler Variablen</span><span class="sxs-lookup"><span data-stu-id="dc977-357">Local variable declaration.</span></span>
* <span data-ttu-id="dc977-358">Deklaration lokaler Konstanten</span><span class="sxs-lookup"><span data-stu-id="dc977-358">Local constant declaration.</span></span>
* <span data-ttu-id="dc977-359">Ausdrucksanweisung</span><span class="sxs-lookup"><span data-stu-id="dc977-359">Expression statement.</span></span>
* <span data-ttu-id="dc977-360">`if`-Anweisung</span><span class="sxs-lookup"><span data-stu-id="dc977-360">`if` statement.</span></span>
* <span data-ttu-id="dc977-361">`switch`-Anweisung</span><span class="sxs-lookup"><span data-stu-id="dc977-361">`switch` statement.</span></span>
* <span data-ttu-id="dc977-362">`while`-Anweisung</span><span class="sxs-lookup"><span data-stu-id="dc977-362">`while` statement.</span></span>
* <span data-ttu-id="dc977-363">`do`-Anweisung</span><span class="sxs-lookup"><span data-stu-id="dc977-363">`do` statement.</span></span>
* <span data-ttu-id="dc977-364">`for`-Anweisung</span><span class="sxs-lookup"><span data-stu-id="dc977-364">`for` statement.</span></span>
* <span data-ttu-id="dc977-365">`foreach`-Anweisung</span><span class="sxs-lookup"><span data-stu-id="dc977-365">`foreach` statement.</span></span>
* <span data-ttu-id="dc977-366">`break`-Anweisung</span><span class="sxs-lookup"><span data-stu-id="dc977-366">`break` statement.</span></span>
* <span data-ttu-id="dc977-367">`continue`-Anweisung</span><span class="sxs-lookup"><span data-stu-id="dc977-367">`continue` statement.</span></span>
* <span data-ttu-id="dc977-368">`goto`-Anweisung</span><span class="sxs-lookup"><span data-stu-id="dc977-368">`goto` statement.</span></span>
* <span data-ttu-id="dc977-369">`return`-Anweisung</span><span class="sxs-lookup"><span data-stu-id="dc977-369">`return` statement.</span></span>
* <span data-ttu-id="dc977-370">`yield`-Anweisung</span><span class="sxs-lookup"><span data-stu-id="dc977-370">`yield` statement.</span></span>
* <span data-ttu-id="dc977-371">`throw`-Anweisungen und `try`-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="dc977-371">`throw` statements and `try` statements.</span></span>
* <span data-ttu-id="dc977-372">`checked`- und `unchecked`-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="dc977-372">`checked` and `unchecked` statements.</span></span>
* <span data-ttu-id="dc977-373">`lock`-Anweisung</span><span class="sxs-lookup"><span data-stu-id="dc977-373">`lock` statement.</span></span>
* <span data-ttu-id="dc977-374">`using`-Anweisung</span><span class="sxs-lookup"><span data-stu-id="dc977-374">`using` statement.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="dc977-375">[Zurück](types.md)
>[Weiter](features.md)</span><span class="sxs-lookup"><span data-stu-id="dc977-375">[Previous](types.md)
[Next](features.md)</span></span>
