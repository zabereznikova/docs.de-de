---
title: Eigenschaften
description: Erfahren Sie mehr über C#-Eigenschaften, die Funktionen für die Validierung, berechnete Werte, die verzögerte Auswertung und Benachrichtigungen für Eigenschaftsänderungen umfassen.
ms.technology: csharp-fundamentals
ms.date: 04/25/2018
ms.openlocfilehash: 28050a77e1f7b0ac148bba6112aa79ef4d46b710
ms.sourcegitcommit: 0802ac583585110022beb6af8ea0b39188b77c43
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/26/2020
ms.locfileid: "89358907"
---
# <a name="properties"></a><span data-ttu-id="58407-103">Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="58407-103">Properties</span></span>

<span data-ttu-id="58407-104">Eigenschaften sind Bürger erster Klasse in C#.</span><span class="sxs-lookup"><span data-stu-id="58407-104">Properties are first class citizens in C#.</span></span> <span data-ttu-id="58407-105">Die Sprache definiert die Syntax, mit der Entwickler Code schreiben können, der genau ihre Entwurfsabsicht ausdrückt.</span><span class="sxs-lookup"><span data-stu-id="58407-105">The language defines syntax that enables developers to write code that accurately expresses their design intent.</span></span>

<span data-ttu-id="58407-106">Eigenschaften verhalten sich wie Felder, wenn darauf zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="58407-106">Properties behave like fields when they are accessed.</span></span>
<span data-ttu-id="58407-107">Jedoch sind Eigenschaften im Gegensatz zu Feldern mit Accessoren implementiert, die die ausgeführten Anweisungen definieren, wenn auf eine Eigenschaft zugegriffen oder sie zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="58407-107">However, unlike fields, properties are implemented with accessors that define the statements executed when a property is accessed or assigned.</span></span>

## <a name="property-syntax"></a><span data-ttu-id="58407-108">Eigenschaftssyntax</span><span class="sxs-lookup"><span data-stu-id="58407-108">Property syntax</span></span>

<span data-ttu-id="58407-109">Die Syntax für Eigenschaften ist eine natürliche Erweiterung von Feldern.</span><span class="sxs-lookup"><span data-stu-id="58407-109">The syntax for properties is a natural extension to fields.</span></span> <span data-ttu-id="58407-110">Ein Feld definiert einen Speicherort:</span><span class="sxs-lookup"><span data-stu-id="58407-110">A field defines a storage location:</span></span>

[!code-csharp[Person class with public fields](../../samples/snippets/csharp/properties/Person.cs#1)]

<span data-ttu-id="58407-111">Eine Eigenschaftendefinition enthält Deklarationen für einen `get`- und `set`-Accessor, der den Wert dieser Eigenschaft abruft oder zuweist:</span><span class="sxs-lookup"><span data-stu-id="58407-111">A property definition contains declarations for a `get` and `set` accessor that retrieves and assigns the value of that property:</span></span>

[!code-csharp[Person class with public properties](../../samples/snippets/csharp/properties/Person.cs#2)]

<span data-ttu-id="58407-112">Die oben dargestellte Syntax ist die *Auto-Eigenschaft*-Syntax.</span><span class="sxs-lookup"><span data-stu-id="58407-112">The syntax shown above is the *auto property* syntax.</span></span> <span data-ttu-id="58407-113">Der Compiler generiert den Speicherort für das Feld, das die Eigenschaft sichert.</span><span class="sxs-lookup"><span data-stu-id="58407-113">The compiler generates the storage location for the field that backs up the property.</span></span> <span data-ttu-id="58407-114">Der Compiler implementiert außerdem den Text der `get`- und `set`-Accessoren.</span><span class="sxs-lookup"><span data-stu-id="58407-114">The compiler also implements the body of the `get` and `set` accessors.</span></span>

<span data-ttu-id="58407-115">In einigen Fällen müssen Sie eine Eigenschaft auf einen anderen Wert als den Standardwert für seinen Datentyp initialisieren.</span><span class="sxs-lookup"><span data-stu-id="58407-115">Sometimes, you need to initialize a property to a value other than the default for its type.</span></span>  <span data-ttu-id="58407-116">C# ermöglicht dies, indem nach der schließenden Klammer für die Eigenschaft ein Wert festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="58407-116">C# enables that by setting a value after the closing brace for the property.</span></span> <span data-ttu-id="58407-117">Möglicherweise bevorzugen Sie den Anfangswert für die Eigenschaft `FirstName` als leere Zeichenfolge und nicht `null`.</span><span class="sxs-lookup"><span data-stu-id="58407-117">You may prefer the initial value for the `FirstName` property to be the empty string rather than `null`.</span></span> <span data-ttu-id="58407-118">Sie würden dies wie unten dargestellt angeben:</span><span class="sxs-lookup"><span data-stu-id="58407-118">You would specify that as shown below:</span></span>

[!code-csharp[Person class with properties and initializer](../../samples/snippets/csharp/properties/Person.cs#3)]

<span data-ttu-id="58407-119">Die bestimmte Initialisierung eignet sich am besten für schreibgeschützte Eigenschaften, wie Sie später in diesem Artikel sehen werden.</span><span class="sxs-lookup"><span data-stu-id="58407-119">Specific initialization is most useful for read-only properties, as you'll see later in this article.</span></span>

<span data-ttu-id="58407-120">Sie können den Speicher auch selbst definieren, wie unten dargestellt:</span><span class="sxs-lookup"><span data-stu-id="58407-120">You can also define the storage yourself, as shown below:</span></span>

[!code-csharp[Person class with properties and backing field](../../samples/snippets/csharp/properties/Person.cs#4)]

<span data-ttu-id="58407-121">Wenn die Implementierung einer Eigenschaft ein einzelner Ausdruck ist, können Sie *Ausdruckskörpermember* für die Getter oder Setter verwenden:</span><span class="sxs-lookup"><span data-stu-id="58407-121">When a property implementation is a single expression, you can use *expression-bodied members* for the getter or setter:</span></span>

[!code-csharp[Person class with properties and expression bodied getters and setters](../../samples/snippets/csharp/properties/Person.cs#5)]

<span data-ttu-id="58407-122">Diese vereinfachte Syntax wird in diesem Artikel immer dann verwendet, wenn es sich anbietet.</span><span class="sxs-lookup"><span data-stu-id="58407-122">This simplified syntax will be used where applicable throughout this article.</span></span>

<span data-ttu-id="58407-123">Die oben gezeigte Eigenschaftendefinition ist eine Schreib-Lese-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="58407-123">The property definition shown above is a read-write property.</span></span> <span data-ttu-id="58407-124">Beachten Sie das Schlüsselwort `value` im set-Accessor.</span><span class="sxs-lookup"><span data-stu-id="58407-124">Notice the keyword `value` in the set accessor.</span></span> <span data-ttu-id="58407-125">Der `set`-Accessor verfügt immer über einen einzelnen Parameter namens `value`.</span><span class="sxs-lookup"><span data-stu-id="58407-125">The `set` accessor always has a single parameter named `value`.</span></span> <span data-ttu-id="58407-126">Der `get`-Accessor muss einen Wert zurückgeben, der in den Typ der Eigenschaft konvertiert werden kann (`string` in diesem Beispiel).</span><span class="sxs-lookup"><span data-stu-id="58407-126">The `get` accessor must return a value that is convertible to the type of the property (`string` in this example).</span></span>

<span data-ttu-id="58407-127">Das sind die Grundlagen der Syntax.</span><span class="sxs-lookup"><span data-stu-id="58407-127">That's the basics of the syntax.</span></span> <span data-ttu-id="58407-128">Es gibt viele verschiedene Varianten, die eine Vielzahl von verschiedenen Entwürfen unterstützen.</span><span class="sxs-lookup"><span data-stu-id="58407-128">There are many different variations that support a variety of different design idioms.</span></span> <span data-ttu-id="58407-129">Lassen Sie uns diese erforschen, und lernen Sie die Syntaxoptionen für jede kennen.</span><span class="sxs-lookup"><span data-stu-id="58407-129">Let's explore, and learn the syntax options for each.</span></span>

## <a name="scenarios"></a><span data-ttu-id="58407-130">Szenarien</span><span class="sxs-lookup"><span data-stu-id="58407-130">Scenarios</span></span>

<span data-ttu-id="58407-131">In den Beispielen oben wurde eine der einfachsten Fälle von Eigenschaftendefinition gezeigt: eine Schreib-Lese-Eigenschaft ohne Überprüfung.</span><span class="sxs-lookup"><span data-stu-id="58407-131">The examples above showed one of the simplest cases of property definition: a read-write property with no validation.</span></span> <span data-ttu-id="58407-132">Durch das Schreiben des Codes, den Sie in den `get`- und `set`-Accessoren möchten, können Sie viele verschiedene Szenarios erstellen.</span><span class="sxs-lookup"><span data-stu-id="58407-132">By writing the code you want in the `get` and `set` accessors, you can create many different scenarios.</span></span>

### <a name="validation"></a><span data-ttu-id="58407-133">Validierung</span><span class="sxs-lookup"><span data-stu-id="58407-133">Validation</span></span>

<span data-ttu-id="58407-134">Sie können Code im `set`-Accessor schreiben, um sicherzustellen, dass die durch eine Eigenschaft dargestellten Werte immer gültig sind.</span><span class="sxs-lookup"><span data-stu-id="58407-134">You can write code in the `set` accessor to ensure that the values represented by a property are always valid.</span></span> <span data-ttu-id="58407-135">Angenommen, eine Regel für die `Person`-Klasse besagt, dass der Name nicht leer sein und keinen Leerraum enthalten darf.</span><span class="sxs-lookup"><span data-stu-id="58407-135">For example, suppose one rule for the `Person` class is that the name cannot be blank or white space.</span></span> <span data-ttu-id="58407-136">Sie würden das wie folgt schreiben:</span><span class="sxs-lookup"><span data-stu-id="58407-136">You would write that as follows:</span></span>

[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#6)]

<span data-ttu-id="58407-137">Das vorausgehende Beispiel kann unter Verwendung eines `throw`-Ausdrucks als Teil der Validierung des Eigenschaftensetters vereinfacht werden:</span><span class="sxs-lookup"><span data-stu-id="58407-137">The preceding example can be simplified by using a `throw` expression as part of the property setter validation:</span></span>

[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#7)]

<span data-ttu-id="58407-138">Das obige Beispiel erzwingt die Regel, dass der Vorname nicht leer sein und keinen Leerraum enthalten darf.</span><span class="sxs-lookup"><span data-stu-id="58407-138">The example above enforces the rule that the first name must not be blank or white space.</span></span> <span data-ttu-id="58407-139">Wenn ein Entwickler schreibt</span><span class="sxs-lookup"><span data-stu-id="58407-139">If a developer writes</span></span>

```csharp
hero.FirstName = "";
```

<span data-ttu-id="58407-140">Die Zuweisung löst eine `ArgumentException` aus.</span><span class="sxs-lookup"><span data-stu-id="58407-140">That assignment throws an `ArgumentException`.</span></span> <span data-ttu-id="58407-141">Da der set-Accessor einen void-Rückgabetyp aufweisen muss, melden Sie Fehler im set-Accessor durch Auslösen einer Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="58407-141">Because a property set accessor must have a void return type, you report errors in the set accessor by throwing an exception.</span></span>

<span data-ttu-id="58407-142">Sie können die gleiche Syntax auf alles andere in Ihrem Szenario erweitern, was benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="58407-142">You can extend this same syntax to anything needed in your scenario.</span></span> <span data-ttu-id="58407-143">Sie können die Beziehungen zwischen unterschiedlichen Eigenschaften oder gegen externe Bedingungen überprüfen.</span><span class="sxs-lookup"><span data-stu-id="58407-143">You can check the relationships between different properties, or validate against any external conditions.</span></span> <span data-ttu-id="58407-144">Gültige C#-Anweisungen sind in einem Eigenschaftenaccessor gültig.</span><span class="sxs-lookup"><span data-stu-id="58407-144">Any valid C# statements are valid in a property accessor.</span></span>

### <a name="read-only"></a><span data-ttu-id="58407-145">Schreibgeschützt</span><span class="sxs-lookup"><span data-stu-id="58407-145">Read-only</span></span>

<span data-ttu-id="58407-146">Bis zu diesem Zeitpunkt sind alle Eigenschaftsdefinitionen, die Sie gesehen haben Lese-/Schreibeigenschaften mit öffentlichen Accessoren.</span><span class="sxs-lookup"><span data-stu-id="58407-146">Up to this point, all the property definitions you have seen are read/write properties with public accessors.</span></span> <span data-ttu-id="58407-147">Dies sind nicht die einzige gültigen Eingabehilfen für Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="58407-147">That's not the only valid accessibility for properties.</span></span>
<span data-ttu-id="58407-148">Sie können schreibgeschützte Eigenschaften erstellen, oder den set- und get-Accessoren verschiedene Eingabehilfen geben.</span><span class="sxs-lookup"><span data-stu-id="58407-148">You can create read-only properties, or give different accessibility to the set and get accessors.</span></span> <span data-ttu-id="58407-149">Angenommen, Ihre `Person`-Klasse sollte nur die Änderung des Werts der `FirstName`-Eigenschaft von anderen Methoden in dieser Klasse ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="58407-149">Suppose that your `Person` class should only enable changing the value of the `FirstName` property from other methods in that class.</span></span> <span data-ttu-id="58407-150">Sie konnten dem set-Accessor `private`-Eingabehilfen anstelle von `public` geben:</span><span class="sxs-lookup"><span data-stu-id="58407-150">You could give the set accessor `private` accessibility instead of `public`:</span></span>

[!code-csharp[Using a private setter for a publicly readonly property](../../samples/snippets/csharp/properties/Person.cs#8)]

<span data-ttu-id="58407-151">Nun, kann auf die `FirstName`-Eigenschaft von einem beliebigen Code zugegriffen werden, aber es kann nur von einem anderem Code in der `Person`-Klasse zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="58407-151">Now, the `FirstName` property can be accessed from any code, but it can only be assigned from other code in the `Person` class.</span></span>

<span data-ttu-id="58407-152">Sie können einen restriktiven Zugriffsmodifizierer zum set- oder get-Accessor hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="58407-152">You can add any restrictive access modifier to either the set or get accessors.</span></span> <span data-ttu-id="58407-153">Jeder Zugriffsmodifizierer, den Sie auf den einzelnen Accessor platzieren, muss eingeschränkter sein als der Zugriffsmodifizierer für die Eigenschaftsdefinition.</span><span class="sxs-lookup"><span data-stu-id="58407-153">Any access modifier you place on the individual accessor must be more limited than the access modifier on the property definition.</span></span> <span data-ttu-id="58407-154">Das Obige ist zulässig, da die `FirstName`-Eigenschaft `public` ist, aber der set-Accessor ist `private`.</span><span class="sxs-lookup"><span data-stu-id="58407-154">The above is legal because the `FirstName` property is `public`, but the set accessor is `private`.</span></span> <span data-ttu-id="58407-155">Sie können keine `private`-Eigenschaft mit einem `public`-Accessor deklarieren.</span><span class="sxs-lookup"><span data-stu-id="58407-155">You could not declare a `private` property with a `public` accessor.</span></span> <span data-ttu-id="58407-156">Eigenschaftendeklarationen können ebenfalls als `protected`, `internal`, `protected internal` oder sogar `private` deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="58407-156">Property declarations can also be declared `protected`, `internal`, `protected internal`, or, even `private`.</span></span>

<span data-ttu-id="58407-157">Es ist auch zulässig, den restriktiveren Modifizierer auf dem `get`-Accessor zu platzieren.</span><span class="sxs-lookup"><span data-stu-id="58407-157">It is also legal to place the more restrictive modifier on the `get` accessor.</span></span> <span data-ttu-id="58407-158">Sie verfügen z.B. über eine `public`-Eigenschaft, schränken jedoch den `get`-Accessor auf `private` ein.</span><span class="sxs-lookup"><span data-stu-id="58407-158">For example, you could have a `public` property, but restrict the `get` accessor to `private`.</span></span> <span data-ttu-id="58407-159">Dieses Szenario wird in der Praxis nur selten ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="58407-159">That scenario is rarely done in practice.</span></span>

<span data-ttu-id="58407-160">Sie können auch Änderungen an einer Eigenschaft beschränken, sodass sie nur in einem Konstruktor oder einem Eigenschafteninitialisierer festgelegt werden kann.</span><span class="sxs-lookup"><span data-stu-id="58407-160">You can also restrict modifications to a property so that it can only be set in a constructor or a property initializer.</span></span> <span data-ttu-id="58407-161">Sie können die `Person`-Klasse daher wie folgt ändern:</span><span class="sxs-lookup"><span data-stu-id="58407-161">You can modify the `Person` class so as follows:</span></span>

[!code-csharp[A readonly auto implemented property](../../samples/snippets/csharp/properties/Person.cs#9)]

<span data-ttu-id="58407-162">Diese Funktion wird am häufigsten für die Initialisierung von Auflistungen verwendet, die als schreibgeschützte Eigenschaften verfügbar gemacht werden:</span><span class="sxs-lookup"><span data-stu-id="58407-162">This feature is most commonly used for initializing collections that are exposed as read-only properties:</span></span>

```csharp
public class Measurements
{
    public ICollection<DataPoint> points { get; } = new List<DataPoint>();
}
```

### <a name="computed-properties"></a><span data-ttu-id="58407-163">Berechnete Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="58407-163">Computed properties</span></span>

<span data-ttu-id="58407-164">Eine Eigenschaft muss nicht einfach den Wert eines Memberfelds zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="58407-164">A property does not need to simply return the value of a member field.</span></span> <span data-ttu-id="58407-165">Sie können Eigenschaften erstellen, die einen berechneten Wert zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="58407-165">You can create properties that return a computed value.</span></span> <span data-ttu-id="58407-166">Lassen Sie uns das `Person`-Objekt so erweitern, dass es den vollständigen Namen zurückgibt, berechnet durch die Verkettung des ersten und letzten Namens:</span><span class="sxs-lookup"><span data-stu-id="58407-166">Let's expand the `Person` object to return the full name, computed by concatenating the first and last names:</span></span>

[!code-csharp[A computed property](../../samples/snippets/csharp/properties/Person.cs#10)]

<span data-ttu-id="58407-167">Im Beispiel oben wird das Feature [Zeichenfolgeninterpolation](./language-reference/tokens/interpolated.md) verwendet, um die formatierte Zeichenfolge für den vollständigen Namen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="58407-167">The example above uses the [string interpolation](./language-reference/tokens/interpolated.md) feature to create the formatted string for the full name.</span></span>

<span data-ttu-id="58407-168">Sie können auch einen *Ausdruckskörpermember* verwenden, was eine kompaktere Möglichkeit zum Erstellen der berechneten `FullName`-Eigenschaft darstellt:</span><span class="sxs-lookup"><span data-stu-id="58407-168">You can also use an *expression-bodied member*, which provides a more succinct way to create the computed `FullName` property:</span></span>

[!code-csharp[A computed property using an expression bodied member](../../samples/snippets/csharp/properties/Person.cs#11)]

<span data-ttu-id="58407-169">*Ausdruckskörpermember* verwenden die Syntax von *Lambdaausdrücken* zum Definieren einer Methode, die einen einzelnen Ausdruck enthält.</span><span class="sxs-lookup"><span data-stu-id="58407-169">*Expression-bodied members* use the *lambda expression* syntax to define methods that contain a single expression.</span></span> <span data-ttu-id="58407-170">Hier gibt dieser Ausdruck den vollständigen Namen für das Person-Objekt zurück.</span><span class="sxs-lookup"><span data-stu-id="58407-170">Here, that expression returns the full name for the person object.</span></span>

### <a name="cached-evaluated-properties"></a><span data-ttu-id="58407-171">Zwischengespeicherte ausgewertete Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="58407-171">Cached evaluated properties</span></span>

<span data-ttu-id="58407-172">Sie können das Konzept einer berechneten Eigenschaft mit dem Speicher mischen und eine *zwischengespeicherte ausgewertete Eigenschaft* erstellen.</span><span class="sxs-lookup"><span data-stu-id="58407-172">You can mix the concept of a computed property with storage and create a *cached evaluated property*.</span></span>  <span data-ttu-id="58407-173">Sie können z.B. die `FullName`-Eigenschaft so aktualisieren, dass die Zeichenfolgenformatierung nur beim ersten Zugriff umgesetzt wird:</span><span class="sxs-lookup"><span data-stu-id="58407-173">For example, you could update the `FullName` property so that the string formatting only happened the first time it was accessed:</span></span>

[!code-csharp[Caching the value of a computed property](../../samples/snippets/csharp/properties/Person.cs#12)]

<span data-ttu-id="58407-174">Der obige Code enthält jedoch einen Fehler.</span><span class="sxs-lookup"><span data-stu-id="58407-174">The above code contains a bug though.</span></span> <span data-ttu-id="58407-175">Wenn der Code den Wert der `FirstName`- oder `LastName`-Eigenschaft aktualisiert, ist das zuvor ausgewertete `fullName`-Feld ungültig.</span><span class="sxs-lookup"><span data-stu-id="58407-175">If code updates the value of either the `FirstName` or `LastName` property, the previously evaluated `fullName` field is invalid.</span></span> <span data-ttu-id="58407-176">Sie müssen die `set`-Accessoren der `FirstName`- und `LastName`-Eigenschaft aktualisieren, damit das `fullName`-Feld erneut berechnet wird:</span><span class="sxs-lookup"><span data-stu-id="58407-176">You modify the `set` accessors of the `FirstName` and `LastName` property so that the `fullName` field is calculated again:</span></span>

[!code-csharp[Invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#13)]

<span data-ttu-id="58407-177">Diese endgültige Version wertet die `FullName`-Eigenschaft nur bei Bedarf aus.</span><span class="sxs-lookup"><span data-stu-id="58407-177">This final version evaluates the `FullName` property only when needed.</span></span>
<span data-ttu-id="58407-178">Wenn die zuvor berechnete Version gültig ist, wird sie verwendet.</span><span class="sxs-lookup"><span data-stu-id="58407-178">If the previously calculated version is valid, it's used.</span></span> <span data-ttu-id="58407-179">Wenn eine andere Änderung des Zustands die zuvor berechnete Version ungültig macht, wird sie neu berechnet.</span><span class="sxs-lookup"><span data-stu-id="58407-179">If another state change invalidates the previously calculated version, it will be recalculated.</span></span> <span data-ttu-id="58407-180">Entwickler, die diese Klasse verwenden, müssen die Details der Implementierung nicht kennen.</span><span class="sxs-lookup"><span data-stu-id="58407-180">Developers that use this class do not need to know the details of the implementation.</span></span> <span data-ttu-id="58407-181">Keine dieser interne Änderungen hat Einfluss auf die Verwendung des Person-Objekts.</span><span class="sxs-lookup"><span data-stu-id="58407-181">None of these internal changes affect the use of the Person object.</span></span> <span data-ttu-id="58407-182">Das ist der Hauptgrund für die Verwendung von Eigenschaften, um Datenmember eines Objekts verfügbar zu machen.</span><span class="sxs-lookup"><span data-stu-id="58407-182">That's the key reason for using Properties to expose data members of an object.</span></span>

### <a name="attaching-attributes-to-auto-implemented-properties"></a><span data-ttu-id="58407-183">Anfügen von Attributen an automatisch implementierte Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="58407-183">Attaching attributes to auto-implemented properties</span></span>

<span data-ttu-id="58407-184">Ab C# 7.3 können Feldattribute an das vom Compiler generierte Unterstützungsfeld in den automatisch implementierten Eigenschaften angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="58407-184">Beginning with C# 7.3, field attributes can be attached to the compiler generated backing field in auto-implemented properties.</span></span> <span data-ttu-id="58407-185">Sie sollten z.B. eine Überarbeitung der `Person`-Klasse hinzufügen, die eine eindeutige Eigenschaft des Integers `Id` hinzufügt.</span><span class="sxs-lookup"><span data-stu-id="58407-185">For example, consider a revision to the `Person` class that adds a unique integer `Id` property.</span></span>
<span data-ttu-id="58407-186">Schreiben Sie die `Id`-Eigenschaft unter Verwendung einer automatisch implementierten Eigenschaft. Für Ihren Entwurf ist es jedoch nicht erforderlich, die `Id`-Eigenschaft zu speichern.</span><span class="sxs-lookup"><span data-stu-id="58407-186">You write the`Id` property using an auto-implemented property, but your design does not call for persisting the `Id` property.</span></span> <span data-ttu-id="58407-187">Das <xref:System.NonSerializedAttribute>-Attribut kann nur an Felder, aber nicht an Eigenschaften angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="58407-187">The <xref:System.NonSerializedAttribute> can only be attached to fields, not properties.</span></span> <span data-ttu-id="58407-188">Sie können wie im folgenden Beispiel dargestellt das <xref:System.NonSerializedAttribute>-Attribut für die `Id`-Eigenschaft an das Unterstützungsfeld unter Verwendung des `field:`-Spezifizierers des Attributs anfügen:</span><span class="sxs-lookup"><span data-stu-id="58407-188">You can attach the <xref:System.NonSerializedAttribute> to the backing field for the `Id` property by using the `field:` specifier on the attribute, as shown in the following example:</span></span>

[!code-csharp[Attaching attributes to a backing field](../../samples/snippets/csharp/properties/Person.cs#14)]

<span data-ttu-id="58407-189">Diese Technik funktioniert für jedes beliebige Attribut, das Sie an das Unterstützungsfeld für die automatisch implementierte Eigenschaft anfügen.</span><span class="sxs-lookup"><span data-stu-id="58407-189">This technique works for any attribute you attach to the backing field on the auto-implemented property.</span></span>

### <a name="implementing-inotifypropertychanged"></a><span data-ttu-id="58407-190">Implementiert INotifyPropertyChanged</span><span class="sxs-lookup"><span data-stu-id="58407-190">Implementing INotifyPropertyChanged</span></span>

<span data-ttu-id="58407-191">Ein abschließendes Szenario, in dem Sie Code in einem Eigenschaftenaccessor schreiben müssen, ist zur Unterstützung der <xref:System.ComponentModel.INotifyPropertyChanged>-Schnittstelle, die verwendet wird, um Clients mit Datenbindung zu benachrichtigen, dass ein Wert geändert wurde.</span><span class="sxs-lookup"><span data-stu-id="58407-191">A final scenario where you need to write code in a property accessor is to support the <xref:System.ComponentModel.INotifyPropertyChanged> interface used to notify data binding clients that a value has changed.</span></span> <span data-ttu-id="58407-192">Wenn sich der Wert einer Eigenschaft ändert, löst das Objekt das <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType>-Ereignis aus, um die Änderung anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="58407-192">When the value of a property changes, the object raises the <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType> event to indicate the change.</span></span> <span data-ttu-id="58407-193">Die Bibliotheken mit Datenbindung wiederum aktualisieren die auf dieser Änderung basierenden Anzeigeelemente.</span><span class="sxs-lookup"><span data-stu-id="58407-193">The data binding libraries, in turn, update display elements based on that change.</span></span> <span data-ttu-id="58407-194">Der folgende Code zeigt, wie Sie `INotifyPropertyChanged` für die `FirstName`-Eigenschaft dieser Person-Klasse implementieren würden.</span><span class="sxs-lookup"><span data-stu-id="58407-194">The code below shows how you would implement `INotifyPropertyChanged` for the `FirstName` property of this person class.</span></span>

[!code-csharp[invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#15)]

<span data-ttu-id="58407-195">Der Operator `?.` wird *bedingter NULL-Operator* genannt.</span><span class="sxs-lookup"><span data-stu-id="58407-195">The `?.` operator is called the *null conditional operator*.</span></span> <span data-ttu-id="58407-196">Es sucht vor der Auswertung der rechten Seite des Operators nach einem NULL-Verweis.</span><span class="sxs-lookup"><span data-stu-id="58407-196">It checks for a null reference before evaluating the right side of the operator.</span></span> <span data-ttu-id="58407-197">Das Endergebnis bedeutet, dass, wenn sich keine Abonnenten im `PropertyChanged`-Ereignis befinden, der Code zum Auslösen des Ereignisses nicht ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="58407-197">The end result is that if there are no subscribers to the `PropertyChanged` event, the code to raise the event doesn't execute.</span></span> <span data-ttu-id="58407-198">Er würde eine `NullReferenceException` auslösen, ohne diese in diesem Fall zu überprüfen.</span><span class="sxs-lookup"><span data-stu-id="58407-198">It would throw a `NullReferenceException` without this check in that case.</span></span> <span data-ttu-id="58407-199">Weitere Informationen finden Sie unter [`events`](events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="58407-199">For more information, see [`events`](events-overview.md).</span></span> <span data-ttu-id="58407-200">In diesem Beispiel wird auch der neue `nameof`-Operator verwendet, um vom Symbol des Eigenschaftennamen in die Textdarstellung zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="58407-200">This example also uses the new `nameof` operator to convert from the property name symbol to its text representation.</span></span>
<span data-ttu-id="58407-201">Mithilfe von `nameof` können Fehler reduziert werden, bei denen Sie den Namen der Eigenschaft falsch eingegeben haben.</span><span class="sxs-lookup"><span data-stu-id="58407-201">Using `nameof` can reduce errors where you have mistyped the name of the property.</span></span>

<span data-ttu-id="58407-202">Erneut ist die Implementierung von <xref:System.ComponentModel.INotifyPropertyChanged> ein Beispiel für einen Fall, in dem Sie Code in Ihren Accessoren schreiben können, um die benötigten Szenarios zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="58407-202">Again, implementing <xref:System.ComponentModel.INotifyPropertyChanged> is an example of a case where you can write code in your accessors to support the scenarios you need.</span></span>

## <a name="summing-up"></a><span data-ttu-id="58407-203">Zusammenfassung</span><span class="sxs-lookup"><span data-stu-id="58407-203">Summing up</span></span>

<span data-ttu-id="58407-204">Eigenschaften sind eine Form intelligenter Felder in einer Klasse oder einem Objekt.</span><span class="sxs-lookup"><span data-stu-id="58407-204">Properties are a form of smart fields in a class or object.</span></span> <span data-ttu-id="58407-205">Außerhalb des Objekts wirken diese wie Felder in dem Objekt.</span><span class="sxs-lookup"><span data-stu-id="58407-205">From outside the object, they appear like fields in the object.</span></span> <span data-ttu-id="58407-206">Eigenschaften können jedoch mithilfe der vollständigen Palette der C#-Funktionalität implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="58407-206">However, properties can be implemented using the full palette of C# functionality.</span></span>
<span data-ttu-id="58407-207">Sie können Überprüfung, verschiedene Eingabehilfen, verzögerte Auswertung oder alle Anforderungen, die Ihre Szenarios benötigen, bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="58407-207">You can provide validation, different accessibility, lazy evaluation, or any requirements your scenarios need.</span></span>
