---
title: Generieren und Nutzen asynchroner Datenströme
description: In diesem Tutorial für Fortgeschrittene wird veranschaulicht, wie asynchrone Streams generiert und verwendet werden. Asynchrone Streams erleichtern die Arbeit mit Datensequenzen, die asynchron generiert werden können.
ms.date: 02/10/2019
ms.technology: csharp-async
ms.custom: mvc
ms.openlocfilehash: 03254e5208a048469f4753d632de7b0d451cde40
ms.sourcegitcommit: 5988e9a29cedb8757320817deda3c08c6f44a6aa
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 04/28/2020
ms.locfileid: "82200105"
---
# <a name="tutorial-generate-and-consume-async-streams-using-c-80-and-net-core-30"></a><span data-ttu-id="70e05-104">Tutorial: Generieren und Nutzen asynchroner Datenströme mit C# 8.0 und .NET Core 3.0</span><span class="sxs-lookup"><span data-stu-id="70e05-104">Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0</span></span>

<span data-ttu-id="70e05-105">C# 8.0 führt **asynchrone Streams** ein, die eine Streamingdatenquelle modellieren.</span><span class="sxs-lookup"><span data-stu-id="70e05-105">C# 8.0 introduces **async streams**, which model a streaming source of data.</span></span> <span data-ttu-id="70e05-106">In Datenströmen werden Elemente häufig asynchron abgerufen oder generiert.</span><span class="sxs-lookup"><span data-stu-id="70e05-106">Data streams often retrieve or generate elements asynchronously.</span></span> <span data-ttu-id="70e05-107">Asynchrone Streams basieren auf neuen Schnittstellen, die in .NET Standard 2.1 eingeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="70e05-107">Async streams rely on new interfaces introduced in .NET Standard 2.1.</span></span> <span data-ttu-id="70e05-108">Diese Schnittstellen werden in .NET Core 3.0 und höher unterstützt.</span><span class="sxs-lookup"><span data-stu-id="70e05-108">These interfaces are supported in .NET Core 3.0 and later.</span></span> <span data-ttu-id="70e05-109">Sie stellen ein intuitives Programmiermodell für asynchrone Streamingdatenquellen bereit.</span><span class="sxs-lookup"><span data-stu-id="70e05-109">They provide a natural programming model for asynchronous streaming data sources.</span></span>

<span data-ttu-id="70e05-110">In diesem Tutorial lernen Sie, wie die folgenden Aufgaben ausgeführt werden:</span><span class="sxs-lookup"><span data-stu-id="70e05-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="70e05-111">Erstellen einer Datenquelle, die eine Sequenz von Datenelementen asynchron generiert</span><span class="sxs-lookup"><span data-stu-id="70e05-111">Create a data source that generates a sequence of data elements asynchronously.</span></span>
> - <span data-ttu-id="70e05-112">Asynchrones Nutzen dieser Datenquelle</span><span class="sxs-lookup"><span data-stu-id="70e05-112">Consume that data source asynchronously.</span></span>
> - <span data-ttu-id="70e05-113">Unterstützung für Abbruchvorgänge und erfasste Kontexte für asynchrone Streams</span><span class="sxs-lookup"><span data-stu-id="70e05-113">Support cancellation and captured contexts for asynchronous streams.</span></span>
> - <span data-ttu-id="70e05-114">Erkennen, wenn die neue Schnittstelle und Datenquelle früheren synchronen Datensequenzen vorgezogen werden</span><span class="sxs-lookup"><span data-stu-id="70e05-114">Recognize when the new interface and data source are preferred to earlier synchronous data sequences.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="70e05-115">Voraussetzungen</span><span class="sxs-lookup"><span data-stu-id="70e05-115">Prerequisites</span></span>

<span data-ttu-id="70e05-116">Sie müssen Ihren Computer zur Ausführung von .NET Core einrichten, einschließlich des C# 8.0-Compilers.</span><span class="sxs-lookup"><span data-stu-id="70e05-116">You'll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="70e05-117">Der C# 8-Compiler steht ab [Visual Studio 2019 Version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) oder mit dem [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download) zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="70e05-117">The C# 8 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

<span data-ttu-id="70e05-118">Sie müssen ein [GitHub-Zugriffstoken](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) erstellen, damit Sie auf den GitHub GraphQL-Endpunkt zugreifen können.</span><span class="sxs-lookup"><span data-stu-id="70e05-118">You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint.</span></span> <span data-ttu-id="70e05-119">Wählen Sie die folgenden Berechtigungen für Ihr GitHub-Zugriffstoken aus:</span><span class="sxs-lookup"><span data-stu-id="70e05-119">Select the following permissions for your GitHub Access Token:</span></span>

- <span data-ttu-id="70e05-120">repo:status</span><span class="sxs-lookup"><span data-stu-id="70e05-120">repo:status</span></span>
- <span data-ttu-id="70e05-121">public_repo</span><span class="sxs-lookup"><span data-stu-id="70e05-121">public_repo</span></span>

<span data-ttu-id="70e05-122">Speichern Sie das Zugriffstoken an einem sicheren Ort, damit Sie es für den Zugriff auf den GitHub-API-Endpunkt verwenden können.</span><span class="sxs-lookup"><span data-stu-id="70e05-122">Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.</span></span>

> [!WARNING]
> <span data-ttu-id="70e05-123">Schützen Sie Ihr persönliches Zugriffstoken.</span><span class="sxs-lookup"><span data-stu-id="70e05-123">Keep your personal access token secure.</span></span> <span data-ttu-id="70e05-124">Jede Software mit Ihrem persönlichen Zugriffstoken kann mit Ihren Zugriffsrechten GitHub-API-Aufrufe ausführen.</span><span class="sxs-lookup"><span data-stu-id="70e05-124">Any software with your personal access token could make GitHub API calls using your access rights.</span></span>

<span data-ttu-id="70e05-125">In diesem Tutorial wird vorausgesetzt, dass Sie C# und .NET, einschließlich Visual Studio oder die .NET Core-CLI kennen.</span><span class="sxs-lookup"><span data-stu-id="70e05-125">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="run-the-starter-application"></a><span data-ttu-id="70e05-126">Ausführen der Startanwendung</span><span class="sxs-lookup"><span data-stu-id="70e05-126">Run the starter application</span></span>

<span data-ttu-id="70e05-127">Sie können den Code für die in diesem Tutorial verwendete Startanwendung aus unserem Repository [dotnet/docs](https://github.com/dotnet/docs) im Ordner [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) abrufen.</span><span class="sxs-lookup"><span data-stu-id="70e05-127">You can get the code for the starter application used in this tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) folder.</span></span>

<span data-ttu-id="70e05-128">Die Startanwendung ist eine Konsolenanwendung, die die [GitHub GraphQL](https://developer.github.com/v4/)-Schnittstelle zum Abrufen aktueller Issues verwendet, die in das Repository [dotnet/docs](https://github.com/dotnet/docs) geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="70e05-128">The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository.</span></span> <span data-ttu-id="70e05-129">Sehen Sie sich zunächst folgenden Code für die `Main`-Methode der Starter-App an:</span><span class="sxs-lookup"><span data-stu-id="70e05-129">Start by looking at the following code for the starter app `Main` method:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetStarterAppMain" :::

<span data-ttu-id="70e05-130">Sie können entweder eine `GitHubKey`-Umgebungsvariable auf Ihr persönliches Zugriffstoken festlegen, oder Sie können das letzte Argument im Aufruf von `GenEnvVariable` durch Ihr persönliches Zugriffstoken ersetzen.</span><span class="sxs-lookup"><span data-stu-id="70e05-130">You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token.</span></span> <span data-ttu-id="70e05-131">Fügen Sie Ihren Zugriffscode nicht in den Quellcode ein, wenn Sie die Quelle für andere freigeben.</span><span class="sxs-lookup"><span data-stu-id="70e05-131">Don't put your access code in source code if you'll be sharing the source with others.</span></span> <span data-ttu-id="70e05-132">Laden Sie Zugriffscodes niemals in ein freigegebenes Quellrepository hoch.</span><span class="sxs-lookup"><span data-stu-id="70e05-132">Never upload access codes to a shared source repository.</span></span>

<span data-ttu-id="70e05-133">Nach dem Erstellen des GitHub-Clients werden durch den Code in `Main` ein Objekt für Fortschrittsberichte und ein Abbruchtoken erstellt.</span><span class="sxs-lookup"><span data-stu-id="70e05-133">After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token.</span></span> <span data-ttu-id="70e05-134">Nachdem die Objekte erstellt wurden, wird `runPagedQueryAsync` durch `Main` aufgerufen, um die neuesten 250 Issues abzurufen.</span><span class="sxs-lookup"><span data-stu-id="70e05-134">Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues.</span></span> <span data-ttu-id="70e05-135">Nach Abschluss dieser Aufgabe werden die Ergebnisse angezeigt.</span><span class="sxs-lookup"><span data-stu-id="70e05-135">After that task has finished, the results are displayed.</span></span>

<span data-ttu-id="70e05-136">Bei Ausführung der Startanwendung können Sie einige wichtige Details zur Ausführung dieser Anwendung beobachten.</span><span class="sxs-lookup"><span data-stu-id="70e05-136">When you run the starter application, you can make some important observations about how this application runs.</span></span>  <span data-ttu-id="70e05-137">Für jede von GitHub zurückgegebene Seite wird der Fortschritt gemeldet.</span><span class="sxs-lookup"><span data-stu-id="70e05-137">You'll see progress reported for each page returned from GitHub.</span></span> <span data-ttu-id="70e05-138">Sie können eine deutliche Pause beobachten, bevor GitHub eine weitere neue Seite mit Issues zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="70e05-138">You can observe a noticeable pause before GitHub returns each new page of issues.</span></span> <span data-ttu-id="70e05-139">Die Issues werden erst angezeigt, nachdem alle zehn Seiten aus GitHub abgerufen wurden.</span><span class="sxs-lookup"><span data-stu-id="70e05-139">Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.</span></span>

## <a name="examine-the-implementation"></a><span data-ttu-id="70e05-140">Untersuchen der Implementierung</span><span class="sxs-lookup"><span data-stu-id="70e05-140">Examine the implementation</span></span>

<span data-ttu-id="70e05-141">Die Implementierung zeigt, warum Sie das im vorherigen Abschnitt beschriebene Verhalten beobachten konnten.</span><span class="sxs-lookup"><span data-stu-id="70e05-141">The implementation reveals why you observed the behavior discussed in the previous section.</span></span> <span data-ttu-id="70e05-142">Untersuchen Sie den Code für `runPagedQueryAsync`:</span><span class="sxs-lookup"><span data-stu-id="70e05-142">Examine the code for `runPagedQueryAsync`:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetRunPagedQuery" :::

<span data-ttu-id="70e05-143">Konzentrieren wir uns auf den Paginierungsalgorithmus und die asynchrone Struktur des obigen Codes.</span><span class="sxs-lookup"><span data-stu-id="70e05-143">Let's concentrate on the paging algorithm and async structure of the preceding code.</span></span> <span data-ttu-id="70e05-144">(Details zur GitHub GraphQL-API finden Sie in der [GitHub GraphQL-Dokumentation](https://developer.github.com/v4/guides/).) Die `runPagedQueryAsync`-Methode listet die Issues vom neuesten zum ältesten auf.</span><span class="sxs-lookup"><span data-stu-id="70e05-144">(You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest.</span></span> <span data-ttu-id="70e05-145">Sie fordert 25 Issues pro Seite an und untersucht die `pageInfo`-Struktur der Antwort, um mit der vorherigen Seite fortzufahren.</span><span class="sxs-lookup"><span data-stu-id="70e05-145">It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page.</span></span> <span data-ttu-id="70e05-146">Dies entspricht der GraphQL-Standardpaginierungsunterstützung für mehrseitige Antworten.</span><span class="sxs-lookup"><span data-stu-id="70e05-146">That follows GraphQL's standard paging support for multi-page responses.</span></span> <span data-ttu-id="70e05-147">Die Antwort enthält ein `pageInfo`-Objekt mit einem `hasPreviousPages`-Wert und einem `startCursor`-Wert zum Anfordern der vorherigen Seite.</span><span class="sxs-lookup"><span data-stu-id="70e05-147">The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page.</span></span> <span data-ttu-id="70e05-148">Die Issues befinden sich im `nodes`-Array.</span><span class="sxs-lookup"><span data-stu-id="70e05-148">The issues are in the `nodes` array.</span></span> <span data-ttu-id="70e05-149">Die `runPagedQueryAsync`-Methode fügt diese Knoten einem Array an, das alle Ergebnisse aus allen Seiten enthält.</span><span class="sxs-lookup"><span data-stu-id="70e05-149">The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.</span></span>

<span data-ttu-id="70e05-150">Nach dem Abrufen und Wiederherstellen einer Seite mit Ergebnissen meldet `runPagedQueryAsync` den Fortschritt und prüft auf Abbruch.</span><span class="sxs-lookup"><span data-stu-id="70e05-150">After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation.</span></span> <span data-ttu-id="70e05-151">Wenn ein Abbruch angefordert wurde, löst `runPagedQueryAsync` eine <xref:System.OperationCanceledException> aus.</span><span class="sxs-lookup"><span data-stu-id="70e05-151">If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="70e05-152">Es gibt mehrere Elemente in diesem Code, die verbessert werden können.</span><span class="sxs-lookup"><span data-stu-id="70e05-152">There are several elements in this code that can be improved.</span></span> <span data-ttu-id="70e05-153">Vor allem muss `runPagedQueryAsync` Speicherplatz für alle zurückgegebenen Issues zuordnen.</span><span class="sxs-lookup"><span data-stu-id="70e05-153">Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned.</span></span> <span data-ttu-id="70e05-154">In diesem Beispiel wird der Vorgang bei 250 Issues beendet, weil das Abrufen aller offenen Issues wesentlich mehr Arbeitsspeicher zum Speichern aller abgerufenen Issues erfordern würde.</span><span class="sxs-lookup"><span data-stu-id="70e05-154">This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.</span></span> <span data-ttu-id="70e05-155">Der Algorithmus ist durch die Protokolle zur Unterstützung von Fortschrittsberichten und Abbruchvorgängen beim ersten Lesen schwieriger zu verstehen.</span><span class="sxs-lookup"><span data-stu-id="70e05-155">The protocols for supporting progress reports and cancellation make the algorithm harder to understand on its first reading.</span></span> <span data-ttu-id="70e05-156">Es sind mehr Typen und APIs beteiligt.</span><span class="sxs-lookup"><span data-stu-id="70e05-156">More types and APIs are involved.</span></span> <span data-ttu-id="70e05-157">Außerdem müssen Sie die Kommunikation über <xref:System.Threading.CancellationTokenSource> und die zugehörige <xref:System.Threading.CancellationToken>-Struktur verfolgen, um nachzuvollziehen, wo der Abbruch angefordert und wo er gewährt wird.</span><span class="sxs-lookup"><span data-stu-id="70e05-157">You must trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.</span></span>

## <a name="async-streams-provide-a-better-way"></a><span data-ttu-id="70e05-158">Bessere Möglichkeiten durch asynchrone Datenströme</span><span class="sxs-lookup"><span data-stu-id="70e05-158">Async streams provide a better way</span></span>

<span data-ttu-id="70e05-159">Mit asynchronen Datenströmen und der zugehörigen Sprachunterstützung lassen sich diese Probleme beheben.</span><span class="sxs-lookup"><span data-stu-id="70e05-159">Async streams and the associated language support address all those concerns.</span></span> <span data-ttu-id="70e05-160">Der Code, der die Sequenz generiert, kann mit `yield return` jetzt Elemente in einer Methode zurückgeben, die mit dem `async`-Modifizierer deklariert wurde.</span><span class="sxs-lookup"><span data-stu-id="70e05-160">The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier.</span></span> <span data-ttu-id="70e05-161">Sie können einen asynchronen Datenstrom mit einer `await foreach`-Schleife genau so nutzen, wie Sie eine beliebige Sequenz mit einer `foreach`-Schleife einsetzen.</span><span class="sxs-lookup"><span data-stu-id="70e05-161">You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.</span></span>

<span data-ttu-id="70e05-162">Diese neuen Sprachfeatures hängen von drei neuen Schnittstellen ab, die dem .NET Standard 2.1 hinzugefügt und in .NET Core 3.0 implementiert wurden:</span><span class="sxs-lookup"><span data-stu-id="70e05-162">These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:</span></span>

- <xref:System.Collections.Generic.IAsyncEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IAsyncEnumerator%601?displayProperty=nameWithType>
- <xref:System.IAsyncDisposable?displayProperty=nameWithType>

<span data-ttu-id="70e05-163">Diese drei Schnittstellen sollten den meisten C#-Entwicklern vertraut sein.</span><span class="sxs-lookup"><span data-stu-id="70e05-163">These three interfaces should be familiar to most C# developers.</span></span> <span data-ttu-id="70e05-164">Sie verhalten sich ähnlich wie ihre synchronen Gegenstücke:</span><span class="sxs-lookup"><span data-stu-id="70e05-164">They behave in a manner similar to their synchronous counterparts:</span></span>

- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>
- <xref:System.IDisposable?displayProperty=nameWithType>

<span data-ttu-id="70e05-165">Ein möglicherweise weniger bekannter Typ ist <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="70e05-165">One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span></span> <span data-ttu-id="70e05-166">Die `ValueTask`-Struktur bietet eine ähnliche API für die <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="70e05-166">The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="70e05-167">`ValueTask` wird in diesen Schnittstellen aus Leistungsgründen verwendet.</span><span class="sxs-lookup"><span data-stu-id="70e05-167">`ValueTask` is used in these interfaces for performance reasons.</span></span>

## <a name="convert-to-async-streams"></a><span data-ttu-id="70e05-168">Konvertieren in asynchrone Datenströme</span><span class="sxs-lookup"><span data-stu-id="70e05-168">Convert to async streams</span></span>

<span data-ttu-id="70e05-169">Als Nächstes konvertieren Sie die `runPagedQueryAsync`-Methode, um einen asynchronen Datenstrom zu generieren.</span><span class="sxs-lookup"><span data-stu-id="70e05-169">Next, convert the `runPagedQueryAsync` method to generate an async stream.</span></span> <span data-ttu-id="70e05-170">Ändern Sie zunächst die Signatur von `runPagedQueryAsync` so, dass ein `IAsyncEnumerable<JToken>` zurückgegeben wird, und entfernen Sie das Abbruchtoken und die Fortschrittsobjekte aus der Parameterliste, wie im folgenden Code gezeigt:</span><span class="sxs-lookup"><span data-stu-id="70e05-170">First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetUpdateSignature" :::

<span data-ttu-id="70e05-171">Der Startcode verarbeitet die einzelnen Seiten, während sie abgerufen werden, wie im folgenden Code gezeigt:</span><span class="sxs-lookup"><span data-stu-id="70e05-171">The starter code processes each page as the page is retrieved, as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetProcessPage" :::

<span data-ttu-id="70e05-172">Ersetzen Sie diese drei Zeilen durch den folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="70e05-172">Replace those three lines with the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetYieldReturnPage" :::

<span data-ttu-id="70e05-173">Sie können auch die Deklaration von `finalResults` weiter oben in dieser Methode sowie die `return`-Anweisung entfernen, die der von Ihnen geänderten Schleife folgt.</span><span class="sxs-lookup"><span data-stu-id="70e05-173">You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.</span></span>

<span data-ttu-id="70e05-174">Sie haben die Änderungen zum Generieren eines asynchronen Datenstroms abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="70e05-174">You've finished the changes to generate an async stream.</span></span> <span data-ttu-id="70e05-175">Die fertige Methode sollte in etwa dem folgenden Code entsprechen:</span><span class="sxs-lookup"><span data-stu-id="70e05-175">The finished method should resemble the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateAsyncStream" :::

<span data-ttu-id="70e05-176">Als Nächstes ändern Sie den Code, der die Sammlung nutzt, um den asynchronen Datenstrom zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="70e05-176">Next, you change the code that consumes the collection to consume the async stream.</span></span> <span data-ttu-id="70e05-177">Suchen Sie in `Main` den folgenden Code, der die Sammlung der Issues verarbeitet:</span><span class="sxs-lookup"><span data-stu-id="70e05-177">Find the following code in `Main` that processes the collection of issues:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetEnumerateOldStyle" :::

<span data-ttu-id="70e05-178">Ersetzen Sie den Code durch die folgende `await foreach`-Schleife:</span><span class="sxs-lookup"><span data-stu-id="70e05-178">Replace that code with the following `await foreach` loop:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateAsyncStream" :::

<span data-ttu-id="70e05-179">Die neue Schnittstelle <xref:System.Collections.Generic.IAsyncEnumerator%601> leitet von <xref:System.IAsyncDisposable> ab.</span><span class="sxs-lookup"><span data-stu-id="70e05-179">The new interface <xref:System.Collections.Generic.IAsyncEnumerator%601> derives from <xref:System.IAsyncDisposable>.</span></span> <span data-ttu-id="70e05-180">Das bedeutet, dass die vorhergehende Schleife den Stream asynchron löscht, wenn die Schleife beendet wird.</span><span class="sxs-lookup"><span data-stu-id="70e05-180">That means the preceding loop will asynchronously dispose the stream when the loop finishes.</span></span> <span data-ttu-id="70e05-181">Die Schleife ähnelt dem folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="70e05-181">You can imagine the loop looks like the following code:</span></span>

```csharp
int num = 0;
var enumerator = runPagedQueryAsync(client, PagedIssueQuery, "docs").GetEnumeratorAsync();
try
{
    while (await enumerator.MoveNextAsync())
    {
        var issue = enumerator.Current;
        Console.WriteLine(issue);
        Console.WriteLine($"Received {++num} issues in total");
    }
} finally
{
    if (enumerator != null)
        await enumerator.DisposeAsync();
}
```

<span data-ttu-id="70e05-182">Standardmäßig werden Streamelemente im erfassten Kontext verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="70e05-182">By default, stream elements are processed in the captured context.</span></span> <span data-ttu-id="70e05-183">Wenn Sie die Erfassung des Kontexts deaktivieren möchten, verwenden Sie die Erweiterungsmethode <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="70e05-183">If you want to disable capturing of the context, use the <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> extension method.</span></span> <span data-ttu-id="70e05-184">Weitere Informationen über Synchronisierungskontexte und die Erfassung des aktuellen Kontexts finden Sie im Artikel über das [Verwenden des aufgabenbasierten asynchronen Musters](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="70e05-184">For more information about synchronization contexts and capturing the current context, see the article on [consuming the Task-based asynchronous pattern](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

<span data-ttu-id="70e05-185">Asynchrone Streams unterstützen Abbruchvorgänge mithilfe desselben Protokolls wie andere `async`-Methoden.</span><span class="sxs-lookup"><span data-stu-id="70e05-185">Async streams support cancellation using the same protocol as other `async` methods.</span></span> <span data-ttu-id="70e05-186">Ändern Sie die Signatur für die asynchrone Iteratormethode folgendermaßen, damit Abbruchvorgänge unterstützt werden:</span><span class="sxs-lookup"><span data-stu-id="70e05-186">You would modify the signature for the async iterator method as follows to support cancellation:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateWithCancellation" :::

<span data-ttu-id="70e05-187">Das <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType>-Attribut bewirkt, dass der Compiler Code für <xref:System.Collections.Generic.IAsyncEnumerator%601> generiert, der dazu führt, dass das an `GetAsyncEnumerator` übergebene Token für den Text des asynchronen Iterators als dieses Argument sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="70e05-187">The <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> attribute causes the compiler to generate code for the <xref:System.Collections.Generic.IAsyncEnumerator%601> that makes the token passed to `GetAsyncEnumerator` visible to the body of the async iterator as that argument.</span></span> <span data-ttu-id="70e05-188">In `runQueryAsync` können Sie den Status des Tokens überprüfen und sich ggf. weitere Arbeit sparen.</span><span class="sxs-lookup"><span data-stu-id="70e05-188">Inside `runQueryAsync`, you could examine the state of the token and cancel further work if requested.</span></span>

<span data-ttu-id="70e05-189">Eine andere Erweiterungsmethode (<xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>) wird verwendet, um das Abbruchtoken an den asynchronen Stream zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="70e05-189">You use another extension method, <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>, to pass the cancellation token to the async stream.</span></span> <span data-ttu-id="70e05-190">Ändern Sie die Schleife, die die Issues enumeriert, folgendermaßen:</span><span class="sxs-lookup"><span data-stu-id="70e05-190">You would modify the loop enumerating the issues as follows:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateWithCancellation" :::

<span data-ttu-id="70e05-191">Sie können den Code für das abgeschlossene Tutorial aus dem Repository [dotnet/docs](https://github.com/dotnet/docs) im Ordner [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) abrufen.</span><span class="sxs-lookup"><span data-stu-id="70e05-191">You can get the code for the finished tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) folder.</span></span>

## <a name="run-the-finished-application"></a><span data-ttu-id="70e05-192">Ausführen der fertig gestellten Anwendung</span><span class="sxs-lookup"><span data-stu-id="70e05-192">Run the finished application</span></span>

<span data-ttu-id="70e05-193">Führen Sie die Anwendung erneut aus.</span><span class="sxs-lookup"><span data-stu-id="70e05-193">Run the application again.</span></span> <span data-ttu-id="70e05-194">Vergleichen Sie deren Verhalten mit dem Verhalten der Startanwendung.</span><span class="sxs-lookup"><span data-stu-id="70e05-194">Contrast its behavior with the behavior of the starter application.</span></span> <span data-ttu-id="70e05-195">Die erste Seite mit Ergebnissen wird aufgelistet, sobald sie verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="70e05-195">The first page of results is enumerated as soon as it's available.</span></span> <span data-ttu-id="70e05-196">Es gibt eine wahrnehmbare Pause, wenn eine neue Seite angefordert und abgerufen wird, und dann werden die Ergebnisse der nächsten Seite schnell aufgelistet.</span><span class="sxs-lookup"><span data-stu-id="70e05-196">There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.</span></span> <span data-ttu-id="70e05-197">Der `try` / `catch`-Block ist zur Verarbeitung eines Abbruchs nicht erforderlich: Der Aufrufer kann das Auflisten der Sammlung beenden.</span><span class="sxs-lookup"><span data-stu-id="70e05-197">The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection.</span></span> <span data-ttu-id="70e05-198">Der Fortschritt wird deutlich gemeldet, weil der asynchrone Datenstrom die Ergebnisse generiert, während die einzelnen Seiten heruntergeladen werden.</span><span class="sxs-lookup"><span data-stu-id="70e05-198">Progress is clearly reported because the async stream generates results as each page is downloaded.</span></span> <span data-ttu-id="70e05-199">Der Status jedes zurückgegebenen Problems ist nahtlos in der `await foreach`-Schleife enthalten.</span><span class="sxs-lookup"><span data-stu-id="70e05-199">The status for each issue returned is seamlessly included in the `await foreach` loop.</span></span> <span data-ttu-id="70e05-200">Sie benötigen kein Rückrufobjekt, um den Fortschritt nachzuverfolgen.</span><span class="sxs-lookup"><span data-stu-id="70e05-200">You don't need a callback object to track progress.</span></span>

<span data-ttu-id="70e05-201">Sie können Verbesserungen in der Arbeitsspeichernutzung erkennen, indem Sie den Code untersuchen.</span><span class="sxs-lookup"><span data-stu-id="70e05-201">You can see improvements in memory use by examining the code.</span></span> <span data-ttu-id="70e05-202">Sie müssen eine Sammlung nicht mehr zuordnen, um alle Ergebnisse zu speichern, bevor sie aufgelistet werden.</span><span class="sxs-lookup"><span data-stu-id="70e05-202">You no longer need to allocate a collection to store all the results before they're enumerated.</span></span> <span data-ttu-id="70e05-203">Der Aufrufer kann festlegen, wie die Ergebnisse genutzt werden und ob eine Speichersammlung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="70e05-203">The caller can determine how to consume the results and if a storage collection is needed.</span></span>

<span data-ttu-id="70e05-204">Führen Sie sowohl die Startanwendung als auch die fertig gestellte Anwendung aus, um die Unterschiede zwischen den Implementierungen selbst zu beobachten.</span><span class="sxs-lookup"><span data-stu-id="70e05-204">Run both the starter and finished applications and you can observe the differences between the implementations for yourself.</span></span> <span data-ttu-id="70e05-205">Wenn Sie fertig sind, können Sie das zu Beginn des Tutorials erstellte GitHub-Zugriffstoken löschen.</span><span class="sxs-lookup"><span data-stu-id="70e05-205">You can delete the GitHub access token you created when you started this tutorial after you've finished.</span></span> <span data-ttu-id="70e05-206">Wenn ein Angreifer Zugriff auf dieses Token erlangt hat, kann er mit Ihren Anmeldeinformationen auf GitHub-APIs zugreifen.</span><span class="sxs-lookup"><span data-stu-id="70e05-206">If an attacker gained access to that token, they could access GitHub APIs using your credentials.</span></span>
