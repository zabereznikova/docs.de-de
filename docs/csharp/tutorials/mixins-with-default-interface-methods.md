---
title: Erstellen von Mixin-Typen mithilfe von Standardschnittstellenmethoden
description: Mithilfe von Standardschnittstellenmembern können Sie Schnittstellen mit optionalen Standardimplementierungen für Implementierungpsprogramme erweitern.
ms.technology: csharp-advanced-concepts
ms.date: 10/04/2019
ms.openlocfilehash: ee0536ef51f9bea3e6851be23cc19fa28cc6916b
ms.sourcegitcommit: 07123a475af89b6da5bb6cc51ea40ab1e8a488f0
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/24/2020
ms.locfileid: "80134379"
---
# <a name="tutorial-mix-functionality-in-when-creating-classes-using-interfaces-with-default-interface-methods"></a><span data-ttu-id="4fa30-103">Tutorial: Untermischen von Funktionalität beim Erstellen von Klassen mithilfe von Schnittstellen mit Standardschnittstellenmethoden</span><span class="sxs-lookup"><span data-stu-id="4fa30-103">Tutorial: Mix functionality in when creating classes using interfaces with default interface methods</span></span>

<span data-ttu-id="4fa30-104">Ab C# 8.0 können Sie in .NET Core 3.0 eine Implementierung definieren, wenn Sie einen Member einer Schnittstelle deklarieren.</span><span class="sxs-lookup"><span data-stu-id="4fa30-104">Beginning with C# 8.0 on .NET Core 3.0, you can define an implementation when you declare a member of an interface.</span></span> <span data-ttu-id="4fa30-105">Dieses Feature bietet neue Funktionen, mit denen Sie Standardimplementierungen für Funktionen definieren können, die in Schnittstellen deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="4fa30-105">This feature provides new capabilities where you can define default implementations for features declared in interfaces.</span></span> <span data-ttu-id="4fa30-106">Klassen können auswählen, wann die Funktionalität überschrieben werden soll, wann die Standardfunktionalität verwendet werden soll und wann keine Unterstützung für diskrete Features deklariert werden soll.</span><span class="sxs-lookup"><span data-stu-id="4fa30-106">Classes can pick when to override functionality, when to use the default functionality, and when not to declare support for discrete features.</span></span>

<span data-ttu-id="4fa30-107">In diesem Tutorial lernen Sie, wie die folgenden Aufgaben ausgeführt werden:</span><span class="sxs-lookup"><span data-stu-id="4fa30-107">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> * <span data-ttu-id="4fa30-108">Erstellen von Schnittstellen mit Implementierungen, die diskrete Features beschreiben.</span><span class="sxs-lookup"><span data-stu-id="4fa30-108">Create interfaces with implementations that describe discrete features.</span></span>
> * <span data-ttu-id="4fa30-109">Erstellen von Klassen, die die Standardimplementierungen verwenden.</span><span class="sxs-lookup"><span data-stu-id="4fa30-109">Create classes that use the default implementations.</span></span>
> * <span data-ttu-id="4fa30-110">Erstellen von Klassen, die einige oder alle Standardimplementierungen überschreiben.</span><span class="sxs-lookup"><span data-stu-id="4fa30-110">Create classes that override some or all of the default implementations.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="4fa30-111">Voraussetzungen</span><span class="sxs-lookup"><span data-stu-id="4fa30-111">Prerequisites</span></span>

<span data-ttu-id="4fa30-112">Sie müssen Ihren Computer zur Ausführung von .NET Core einrichten, einschließlich des C# 8.0-Compilers.</span><span class="sxs-lookup"><span data-stu-id="4fa30-112">You’ll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="4fa30-113">Der C# 8.0-Compiler steht ab [Visual Studio 2019 Version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) oder ab dem [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download/dotnet-core) zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="4fa30-113">The C# 8.0 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), or the [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download/dotnet-core) or later.</span></span>

## <a name="limitations-of-extension-methods"></a><span data-ttu-id="4fa30-114">Einschränkungen von Erweiterungsmethoden</span><span class="sxs-lookup"><span data-stu-id="4fa30-114">Limitations of extension methods</span></span>

<span data-ttu-id="4fa30-115">Eine Möglichkeit, Verhalten zu implementieren, das als Teil einer Schnittstelle auftritt, besteht darin, [Erweiterungsmethoden](../programming-guide/classes-and-structs/extension-methods.md) zu definieren, die das Standardverhalten bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="4fa30-115">One way you can implement behavior that appears as part of an interface is to define [extension methods](../programming-guide/classes-and-structs/extension-methods.md) that provide the default behavior.</span></span> <span data-ttu-id="4fa30-116">Schnittstellen deklarieren einen minimalen Satz von Membern und bieten gleichzeitig eine größere Oberfläche für jede Klasse, die diese Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="4fa30-116">Interfaces declare a minimum set of members while providing a greater surface area for any class that implements that interface.</span></span> <span data-ttu-id="4fa30-117">Die Erweiterungsmethoden in <xref:System.Linq.Enumerable> stellen beispielsweise die Implementierung für jede beliebige Sequenz als Quelle einer LINQ-Abfrage bereit.</span><span class="sxs-lookup"><span data-stu-id="4fa30-117">For example, the extension methods in <xref:System.Linq.Enumerable> provide the implementation for any sequence to be the source of a LINQ query.</span></span>

<span data-ttu-id="4fa30-118">Erweiterungsmethoden werden zur Kompilierzeit mithilfe des deklarierten Typs der Variablen aufgelöst.</span><span class="sxs-lookup"><span data-stu-id="4fa30-118">Extension methods are resolved at compile time, using the declared type of the variable.</span></span> <span data-ttu-id="4fa30-119">Klassen, die die Schnittstelle implementieren, können eine bessere Implementierung für jede beliebige Erweiterungsmethode bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="4fa30-119">Classes that implement the interface can provide a better implementation for any extension method.</span></span> <span data-ttu-id="4fa30-120">Variablendeklarationen müssen dem implementierenden Typ entsprechen, damit der Compiler diese Implementierung auswählen kann.</span><span class="sxs-lookup"><span data-stu-id="4fa30-120">Variable declarations must match the implementing type to enable the compiler to choose that implementation.</span></span> <span data-ttu-id="4fa30-121">Wenn der Kompilierzeittyp mit der Schnittstelle übereinstimmt, werden Methodenaufrufe in die Erweiterungsmethode aufgelöst.</span><span class="sxs-lookup"><span data-stu-id="4fa30-121">When the compile-time type matches the interface, method calls resolve to the extension method.</span></span> <span data-ttu-id="4fa30-122">Ein weiteres Problem bei Erweiterungsmethoden ist, dass auf diese Methoden überall dort zugegriffen werden kann, wo auf die Klasse, die die Erweiterungsmethoden enthält, zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="4fa30-122">Another concern with extension methods is that those methods are accessible wherever the class containing the extension methods is accessible.</span></span> <span data-ttu-id="4fa30-123">Klassen können nichts deklarieren, wenn sie in Erweiterungsmethoden deklarierte Funktionen bereitstellen oder nicht bereitstellen sollten.</span><span class="sxs-lookup"><span data-stu-id="4fa30-123">Classes cannot declare if they should or should not provide features declared in extension methods.</span></span>

<span data-ttu-id="4fa30-124">Ab C# 8.0 können Sie die Standardimplementierungen als Schnittstellenmethoden deklarieren.</span><span class="sxs-lookup"><span data-stu-id="4fa30-124">Starting with C# 8.0, you can declare the default implementations as interface methods.</span></span> <span data-ttu-id="4fa30-125">Anschließend verwendet jede Klasse automatisch die Standardimplementierung.</span><span class="sxs-lookup"><span data-stu-id="4fa30-125">Then, every class automatically uses the default implementation.</span></span> <span data-ttu-id="4fa30-126">Jede Klasse, die eine bessere Implementierung bereitstellen kann, kann die Definition der Schnittstellenmethode mit einem besseren Algorithmus überschreiben.</span><span class="sxs-lookup"><span data-stu-id="4fa30-126">Any class that can provide a better implementation can override the interface method definition with a better algorithm.</span></span> <span data-ttu-id="4fa30-127">In gewisser Weise klingt diese Technik ähnlich wie die Verwendung von [Erweiterungsmethoden](../programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="4fa30-127">In one sense, this technique sounds similar to how you could use [extension methods](../programming-guide/classes-and-structs/extension-methods.md).</span></span>

<span data-ttu-id="4fa30-128">In diesem Artikel erfahren Sie, wie Standardschnittstellenimplementierungen neue Szenarien ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="4fa30-128">In this article, you'll learn how default interface implementations enable new scenarios.</span></span>

## <a name="design-the-application"></a><span data-ttu-id="4fa30-129">Entwerfen der Anwendung</span><span class="sxs-lookup"><span data-stu-id="4fa30-129">Design the application</span></span>

<span data-ttu-id="4fa30-130">Stellen Sie sich eine Anwendung für Smart Home-Automatisierung vor.</span><span class="sxs-lookup"><span data-stu-id="4fa30-130">Consider a home automation application.</span></span> <span data-ttu-id="4fa30-131">Sie haben wahrscheinlich viele verschiedene Arten von Leuchten und Indikatoren, die im gesamten Haus verwendet werden könnten.</span><span class="sxs-lookup"><span data-stu-id="4fa30-131">You probably have many different types of lights and indicators that could be used throughout the house.</span></span> <span data-ttu-id="4fa30-132">Jede Leuchte muss APIs unterstützen, um sie ein- und auszuschalten und den aktuellen Zustand zu melden.</span><span class="sxs-lookup"><span data-stu-id="4fa30-132">Every light must support APIs to turn them on and off, and to report the current state.</span></span> <span data-ttu-id="4fa30-133">Einige Leuchten und Indikatoren unterstützen möglicherweise andere Funktionen, beispielsweise:</span><span class="sxs-lookup"><span data-stu-id="4fa30-133">Some lights and indicators may support other features, such as:</span></span>

- <span data-ttu-id="4fa30-134">Einschalten der Leuchte und Ausschalten anhand eines Timers.</span><span class="sxs-lookup"><span data-stu-id="4fa30-134">Turn light on, then turn it off after a timer.</span></span>
- <span data-ttu-id="4fa30-135">Blinklichtfunktion der Leuchte für einen bestimmten Zeitraum.</span><span class="sxs-lookup"><span data-stu-id="4fa30-135">Blink the light for a period of time.</span></span>

<span data-ttu-id="4fa30-136">Einige dieser erweiterten Funktionen können auf Geräten emuliert werden, die den minimalen Satz unterstützen.</span><span class="sxs-lookup"><span data-stu-id="4fa30-136">Some of these extended capabilities could be emulated in devices that support the minimal set.</span></span> <span data-ttu-id="4fa30-137">Dies bedeutet, dass eine Standardimplementierung bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="4fa30-137">That indicates providing a default implementation.</span></span> <span data-ttu-id="4fa30-138">Für Geräte, die über mehr integrierte Funktionen verfügen, würde die Gerätesoftware die nativen Funktionen verwenden.</span><span class="sxs-lookup"><span data-stu-id="4fa30-138">For those devices that have more capabilities built in, the device software would use the native capabilities.</span></span> <span data-ttu-id="4fa30-139">Für andere Leuchten können sie sich entscheiden, die Schnittstelle zu implementieren und die Standardimplementierung zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="4fa30-139">For other lights, they could choose to implement the interface and use the default implementation.</span></span>

<span data-ttu-id="4fa30-140">Standardschnittstellenmember sind eine bessere Lösung für dieses Szenario als Erweiterungsmethoden.</span><span class="sxs-lookup"><span data-stu-id="4fa30-140">Default interface members is a better solution for this scenario than extension methods.</span></span> <span data-ttu-id="4fa30-141">Klassenautoren können steuern, welche Schnittstellen sie implementieren möchten.</span><span class="sxs-lookup"><span data-stu-id="4fa30-141">Class authors can control which interfaces they choose to implement.</span></span> <span data-ttu-id="4fa30-142">Diese Schnittstellen, die sie auswählen, sind als Methoden verfügbar.</span><span class="sxs-lookup"><span data-stu-id="4fa30-142">Those interfaces they choose are available as methods.</span></span> <span data-ttu-id="4fa30-143">Da Standardschnittstellenmethoden standardmäßig virtuell sind, wählt die Methodenbindung außerdem immer die Implementierung in der-Klasse aus.</span><span class="sxs-lookup"><span data-stu-id="4fa30-143">In addition, because default interface methods are virtual by default, the method dispatch always chooses the implementation in the class.</span></span>

<span data-ttu-id="4fa30-144">Erstellen wir den Code, um diese Unterschiede zu veranschaulichen.</span><span class="sxs-lookup"><span data-stu-id="4fa30-144">Let's create the code to demonstrate these differences.</span></span>

## <a name="create-interfaces"></a><span data-ttu-id="4fa30-145">Erstellen von Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="4fa30-145">Create interfaces</span></span>

<span data-ttu-id="4fa30-146">Beginnen Sie, indem Sie die Schnittstelle erstellen, die das Verhalten für alle Leuchten definiert:</span><span class="sxs-lookup"><span data-stu-id="4fa30-146">Start by creating the interface that defines the behavior for all lights:</span></span>

[!code-csharp[Declare base interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetILightInterfaceV1)]

<span data-ttu-id="4fa30-147">Eine einfache Deckenleuchte könnte diese Schnittstelle wie im folgenden Code dargestellt implementieren:</span><span class="sxs-lookup"><span data-stu-id="4fa30-147">A basic overhead light fixture might implement this interface as shown in the following code:</span></span>

[!code-csharp[First overhead light](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetOverheadLightV1)]

<span data-ttu-id="4fa30-148">In diesem Tutorial werden keine IoT-Geräte durch den Code gesteuert, sondern diese Aktivitäten werden emuliert, indem Nachrichten in die Konsole geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="4fa30-148">In this tutorial, the code doesn't drive IoT devices, but emulates those activities by writing messages to the console.</span></span> <span data-ttu-id="4fa30-149">Sie können den Code untersuchen, ohne Ihr Haus zu automatisieren.</span><span class="sxs-lookup"><span data-stu-id="4fa30-149">You can explore the code without automating your house.</span></span>

<span data-ttu-id="4fa30-150">Definieren wir nun die Schnittstelle für eine Leuchte, die nach einem Timeout automatisch ausgeschaltet werden kann:</span><span class="sxs-lookup"><span data-stu-id="4fa30-150">Next, let's define the interface for a light that can automatically turn off after a timeout:</span></span>

[!code-csharp[pure Timer interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetPureTimerInterface)]

<span data-ttu-id="4fa30-151">Sie könnten eine Basisimplementierung zur Deckenleuchte hinzufügen, aber eine bessere Lösung besteht darin, diese Schnittstellendefinition zu ändern, um eine `virtual`-Standardimplementierung bereitzustellen:</span><span class="sxs-lookup"><span data-stu-id="4fa30-151">You could add a basic implementation to the overhead light, but a better solution is to modify this interface definition to provide a `virtual` default implementation:</span></span>

[!code-csharp[Timer interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ITimerLight.cs?name=SnippetTimerLightFinal)]

<span data-ttu-id="4fa30-152">Durch Hinzufügen dieser Änderung kann die `OverheadLight`-Klasse die Timerfunktion implementieren, indem sie Unterstützung für die Schnittstelle deklariert:</span><span class="sxs-lookup"><span data-stu-id="4fa30-152">By adding that change, the `OverheadLight` class can implement the timer function by declaring support for the interface:</span></span>

```csharp
public class OverheadLight : ITimerLight { }
```

<span data-ttu-id="4fa30-153">Ein anderer Leuchtentyp unterstützt möglicherweise ein anspruchsvolleres Protokoll.</span><span class="sxs-lookup"><span data-stu-id="4fa30-153">A different light type may support a more sophisticated protocol.</span></span> <span data-ttu-id="4fa30-154">Er kann seine eigene Implementierung für `TurnOnFor` bereitstellen, wie im folgenden Code gezeigt:</span><span class="sxs-lookup"><span data-stu-id="4fa30-154">It can provide its own implementation for `TurnOnFor`, as shown in the following code:</span></span>

[!code-csharp[Override the timer function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/HalogenLight.cs?name=SnippetHalogenLight)]

<span data-ttu-id="4fa30-155">Im Gegensatz zum Überschreiben von Methoden der virtuellen Klasse verwendet die Deklaration von `TurnOnFor` in der `HalogenLight`-Klasse nicht das Schlüsselwort `override`.</span><span class="sxs-lookup"><span data-stu-id="4fa30-155">Unlike overriding virtual class methods, the declaration of `TurnOnFor` in the `HalogenLight` class does not use the `override` keyword.</span></span>

## <a name="mix-and-match-capabilities"></a><span data-ttu-id="4fa30-156">Mix-und-Match-Funktionen</span><span class="sxs-lookup"><span data-stu-id="4fa30-156">Mix and match capabilities</span></span>

<span data-ttu-id="4fa30-157">Die Vorteile von Standardschnittstellenmethoden werden deutlicher, wenn Sie erweiterte Funktionen einführen.</span><span class="sxs-lookup"><span data-stu-id="4fa30-157">The advantages of default interface methods become clearer as you introduce more advanced capabilities.</span></span> <span data-ttu-id="4fa30-158">Durch die Verwendung von Schnittstellen können Sie Mix-und-Match-Funktionen verwenden.</span><span class="sxs-lookup"><span data-stu-id="4fa30-158">Using interfaces enables you to mix and match capabilities.</span></span> <span data-ttu-id="4fa30-159">Außerdem kann jeder Klassenautor zwischen der Standardimplementierung und einer benutzerdefinierten Implementierung wählen.</span><span class="sxs-lookup"><span data-stu-id="4fa30-159">It also enables each class author to choose between the default implementation and a custom implementation.</span></span> <span data-ttu-id="4fa30-160">Fügen wir eine Schnittstelle mit einer Standardimplementierung für eine blinkende Leuchte hinzu:</span><span class="sxs-lookup"><span data-stu-id="4fa30-160">Let's add an interface with a default implementation for a blinking light:</span></span>

[!code-csharp[Define the blinking light interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/IBlinkingLight.cs?name=SnippetBlinkingLight)]

<span data-ttu-id="4fa30-161">Die Standardimplementierung ermöglicht jeder Leuchte das Blinken.</span><span class="sxs-lookup"><span data-stu-id="4fa30-161">The default implementation enables any light to blink.</span></span> <span data-ttu-id="4fa30-162">Die Deckenleuchte kann sowohl Timer- als auch Blinkfunktionen mit der Standardimplementierung hinzufügen:</span><span class="sxs-lookup"><span data-stu-id="4fa30-162">The overhead light can add both timer and blink capabilities using the default implementation:</span></span>

[!code-csharp[Use the default blink function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/OverheadLight.cs?name=SnippetOverheadLight)]

<span data-ttu-id="4fa30-163">Ein neuer Leuchtentyp (`LEDLight`) unterstützt die Timerfunktion und die Blinkfunktion direkt.</span><span class="sxs-lookup"><span data-stu-id="4fa30-163">A new light type, the `LEDLight` supports both the timer function and the blink function directly.</span></span> <span data-ttu-id="4fa30-164">Dieser Leuchtenstil implementiert sowohl die `ITimerLight`- als auch die `IBlinkingLight`-Schnittstelle und überschreibt die `Blink`-Methode:</span><span class="sxs-lookup"><span data-stu-id="4fa30-164">This light style implements both the `ITimerLight` and `IBlinkingLight` interfaces, and overrides the `Blink` method:</span></span>

[!code-csharp[Override the blink function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/LEDLight.cs?name=SnippetLEDLight)]

<span data-ttu-id="4fa30-165">Ein `ExtraFancyLight`-Element unterstützt ggf. Blink- und Timerfunktionen direkt:</span><span class="sxs-lookup"><span data-stu-id="4fa30-165">An `ExtraFancyLight` might support both blink and timer functions directly:</span></span>

[!code-csharp[Override the blink and timer function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ExtraFancyLight.cs?name=SnippetExtraFancyLight)]

<span data-ttu-id="4fa30-166">Das `HalogenLight`-Element, das Sie zuvor erstellt haben, unterstützt kein Blinken.</span><span class="sxs-lookup"><span data-stu-id="4fa30-166">The `HalogenLight` you created earlier doesn't support blinking.</span></span> <span data-ttu-id="4fa30-167">Fügen Sie `IBlinkingLight` daher nicht der Liste der unterstützten Schnittstellen dieses Elements hinzu.</span><span class="sxs-lookup"><span data-stu-id="4fa30-167">So, don't add the `IBlinkingLight` to the list of its supported interfaces.</span></span>

## <a name="detect-the-light-types-using-pattern-matching"></a><span data-ttu-id="4fa30-168">Erkennen der Leuchtentypen mithilfe von Musterabgleich</span><span class="sxs-lookup"><span data-stu-id="4fa30-168">Detect the light types using pattern matching</span></span>

<span data-ttu-id="4fa30-169">Schreiben wir nun etwas Testcode.</span><span class="sxs-lookup"><span data-stu-id="4fa30-169">Next, let's write some test code.</span></span> <span data-ttu-id="4fa30-170">Sie können das Feature [Musterabgleich](../pattern-matching.md) von C# verwenden, um die Funktionen einer Leuchte zu ermitteln, indem Sie untersuchen, welche Schnittstellen sie unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4fa30-170">You can make use of C#'s [pattern matching](../pattern-matching.md) feature to determine a light's capabilities by examining which interfaces it supports.</span></span>  <span data-ttu-id="4fa30-171">Die folgende Methode gibt die unterstützten Fähigkeiten der einzelnen Leuchten aus:</span><span class="sxs-lookup"><span data-stu-id="4fa30-171">The following method exercises the supported capabilities of each light:</span></span>

[!code-csharp[Test a light's capabilities](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetTestLightFunctions)]

<span data-ttu-id="4fa30-172">Der folgende Code in der `Main`-Methode erstellt alle Leuchtentypen nacheinander und testet die einzelnen Leuchten:</span><span class="sxs-lookup"><span data-stu-id="4fa30-172">The following code in your `Main` method creates each light type in sequence and tests that light:</span></span>

[!code-csharp[Test a light's capabilities](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetMainMethod)]

## <a name="how-the-compiler-determines-best-implementation"></a><span data-ttu-id="4fa30-173">So ermittelt der Compiler die beste Implementierung</span><span class="sxs-lookup"><span data-stu-id="4fa30-173">How the compiler determines best implementation</span></span>

<span data-ttu-id="4fa30-174">Dieses Szenario zeigt eine Basisschnittstelle ohne Implementierungen.</span><span class="sxs-lookup"><span data-stu-id="4fa30-174">This scenario shows a base interface without any implementations.</span></span> <span data-ttu-id="4fa30-175">Durch das Hinzufügen einer Methode zur `ILight`-Schnittstelle werden neue Komplexitäten eingeführt.</span><span class="sxs-lookup"><span data-stu-id="4fa30-175">Adding a method into the `ILight` interface introduces new complexities.</span></span> <span data-ttu-id="4fa30-176">Die Sprachregeln, die für Standardschnittstellenmethoden gelten, minimieren die Auswirkungen auf die konkreten Klassen, die mehrere abgeleitete Schnittstellen implementieren.</span><span class="sxs-lookup"><span data-stu-id="4fa30-176">The language rules governing default interface methods minimize the effect on the concrete classes that implement multiple derived interfaces.</span></span> <span data-ttu-id="4fa30-177">Erweitern wir die ursprüngliche Schnittstelle durch eine neue Methode, um zu zeigen, wie sich dadurch ihre Verwendung ändert.</span><span class="sxs-lookup"><span data-stu-id="4fa30-177">Let's enhance the original interface with a new method to show how that changes its use.</span></span> <span data-ttu-id="4fa30-178">Jede Indikatorleuchte kann ihren Energiestatus als Enumerationswert melden:</span><span class="sxs-lookup"><span data-stu-id="4fa30-178">Every indicator light can report its power status as an enumerated value:</span></span>

[!code-csharp[Enumeration for power status](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetPowerStatus)]

<span data-ttu-id="4fa30-179">Die Standardimplementierung geht von einer fehlenden Stromversorgung aus:</span><span class="sxs-lookup"><span data-stu-id="4fa30-179">The default implementation assumes no power:</span></span>

[!code-csharp[Report a default power status](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetILightInterface)]

<span data-ttu-id="4fa30-180">Diese Änderungen werden ordnungsgemäß kompiliert, auch wenn `ExtraFancyLight` Unterstützung für die `ILight`-Schnittstelle und die beiden abgeleiteten Schnittstellen `ITimerLight` und `IBlinkingLight` deklariert.</span><span class="sxs-lookup"><span data-stu-id="4fa30-180">These changes compile cleanly, even though the `ExtraFancyLight` declares support for the `ILight` interface and both derived interfaces, `ITimerLight` and `IBlinkingLight`.</span></span> <span data-ttu-id="4fa30-181">Es gibt nur eine „nächste“ Implementierung, die in der `ILight`-Schnittstelle deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="4fa30-181">There's only one "closest" implementation declared in the `ILight` interface.</span></span> <span data-ttu-id="4fa30-182">Jede Klasse, die eine Überschreibung deklariert hat, würde zur „nächsten“ Implementierung werden.</span><span class="sxs-lookup"><span data-stu-id="4fa30-182">Any class that declared an override would become the one "closest" implementation.</span></span> <span data-ttu-id="4fa30-183">Sie haben in den vorhergehenden Klassen Beispiele gesehen, die die Member anderer abgeleiteter Schnittstellen überschreiben.</span><span class="sxs-lookup"><span data-stu-id="4fa30-183">You saw examples in the preceding classes that overrode the members of other derived interfaces.</span></span>

<span data-ttu-id="4fa30-184">Vermeiden Sie das Überschreiben derselben Methode in mehreren abgeleiteten Schnittstellen.</span><span class="sxs-lookup"><span data-stu-id="4fa30-184">Avoid overriding the same method in multiple derived interfaces.</span></span> <span data-ttu-id="4fa30-185">Auf diese Weise wird ein mehrdeutiger Methodenaufruf erstellt, wenn eine Klasse beide abgeleiteten Schnittstellen implementiert.</span><span class="sxs-lookup"><span data-stu-id="4fa30-185">Doing so creates an ambiguous method call whenever a class implements both derived interfaces.</span></span> <span data-ttu-id="4fa30-186">Der Compiler kann keine einzelne bessere Methode auswählen, sodass er einen Fehler ausgibt.</span><span class="sxs-lookup"><span data-stu-id="4fa30-186">The compiler can't pick a single better method so it issues an error.</span></span> <span data-ttu-id="4fa30-187">Wenn z.B. sowohl `IBlinkingLight` als auch `ITimerLight` eine Überschreibung von `PowerStatus` implementiert hat, müsste `OverheadLight` eine spezifischere Überschreibung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="4fa30-187">For example, if both the `IBlinkingLight` and `ITimerLight` implemented an override of `PowerStatus`, the `OverheadLight` would need to provide a more specific override.</span></span> <span data-ttu-id="4fa30-188">Andernfalls kann der Compiler nicht zwischen den Implementierungen in den beiden abgeleiteten Schnittstellen wählen.</span><span class="sxs-lookup"><span data-stu-id="4fa30-188">Otherwise, the compiler can't pick between the implementations in the two derived interfaces.</span></span> <span data-ttu-id="4fa30-189">Sie können diese Situation in der Regel vermeiden, indem Sie Schnittstellendefinitionen klein halten und sich auf eine Funktion konzentrieren.</span><span class="sxs-lookup"><span data-stu-id="4fa30-189">You can usually avoid this situation by keeping interface definitions small and focused on one feature.</span></span> <span data-ttu-id="4fa30-190">In diesem Szenario ist jede Funktion einer Leuchte eine eigene Schnittstelle. Mehrere Schnittstellen werden nur von Klassen geerbt.</span><span class="sxs-lookup"><span data-stu-id="4fa30-190">In this scenario, each capability of a light is its own interface; multiple interfaces are only inherited by classes.</span></span>

<span data-ttu-id="4fa30-191">Dieses Beispiel zeigt ein Szenario, in dem Sie diskrete Features definieren können, die in Klassen gemischt werden können.</span><span class="sxs-lookup"><span data-stu-id="4fa30-191">This sample shows one scenario where you can define discrete features that can be mixed into classes.</span></span> <span data-ttu-id="4fa30-192">Sie deklarieren einen beliebigen Satz unterstützter Funktionen, indem Sie deklarieren, welche Schnittstellen eine Klasse unterstützt.</span><span class="sxs-lookup"><span data-stu-id="4fa30-192">You declare any set of supported functionality by declaring which interfaces a class supports.</span></span> <span data-ttu-id="4fa30-193">Durch die Verwendung von virtuellen Standardschnittstellenmethoden können Klassen eine andere Implementierung für beliebige oder alle Schnittstellenmethoden verwenden oder definieren.</span><span class="sxs-lookup"><span data-stu-id="4fa30-193">The use of virtual default interface methods enables classes to use or define a different implementation for any or all the interface methods.</span></span> <span data-ttu-id="4fa30-194">Diese Sprachfunktion bietet neue Möglichkeiten zum Modellieren der realen Systeme, die Sie entwickeln.</span><span class="sxs-lookup"><span data-stu-id="4fa30-194">This language capability provides new ways to model the real-world systems you're building.</span></span> <span data-ttu-id="4fa30-195">Standardschnittstellenmethoden bieten eine bessere Möglichkeit, verwandte Klassen auszudrücken, die Mix-and-Match-Funktionen verwenden, indem sie virtuelle Implementierungen dieser Funktionen verwenden.</span><span class="sxs-lookup"><span data-stu-id="4fa30-195">Default interface methods provide a clearer way to express related classes that may mix and match different features using virtual implementations of those capabilities.</span></span>
