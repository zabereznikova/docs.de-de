---
title: Ausdrucksbaumstrukturen mit Erläuterung
description: Weitere Informationen zu Ausdrucksbaumstrukturen und ihrer Verwendung für die Übersetzung von Algorithmen für die externe Ausführung und für das Überprüfen von Code vor der Ausführung.
ms.date: 06/20/2016
ms.technology: csharp-advanced-concepts
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: 12093e9c9246c87cc5ea3aedaca6ba34acacce4d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/14/2020
ms.locfileid: "73036994"
---
# <a name="expression-trees-explained"></a><span data-ttu-id="1cfec-103">Ausdrucksbaumstrukturen mit Erläuterung</span><span class="sxs-lookup"><span data-stu-id="1cfec-103">Expression Trees Explained</span></span>

[<span data-ttu-id="1cfec-104">Vorheriges – 2 Übersicht</span><span class="sxs-lookup"><span data-stu-id="1cfec-104">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="1cfec-105">Eine Ausdrucksbaumstruktur ist eine Datenstruktur, die Code darstellt.</span><span class="sxs-lookup"><span data-stu-id="1cfec-105">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="1cfec-106">Sie basiert auf den gleichen Strukturen, die ein Compiler verwendet, um Code zu analysieren und die kompilierte Ausgabe zu generieren.</span><span class="sxs-lookup"><span data-stu-id="1cfec-106">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="1cfec-107">Wenn Sie dieses Tutorial lesen, werden Sie feststellen, dass eine Ähnlichkeit zwischen Ausdrucksbaumstrukturen und den Typen in den Roslyn-APIs vorhanden ist, um [Analyzers and CodeFixes (Analyzer und CodeFixes)](https://github.com/dotnet/roslyn-analyzers) zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-107">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="1cfec-108">(Analyzer und CodeFixes sind NuGet-Pakete, die statische Analysen für Code ausführen und mögliche Korrekturen für einen Entwickler vorschlagen können.) Die Konzepte sind ähnlich, und das Endergebnis ist eine Datenstruktur, die eine Prüfung des Quellcodes auf sinnvolle Weise ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="1cfec-108">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="1cfec-109">Ausdrucksbaumstrukturen basieren jedoch auf einem völlig anderen Satz von Klassen und APIs als die Roslyn-APIs.</span><span class="sxs-lookup"><span data-stu-id="1cfec-109">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>

<span data-ttu-id="1cfec-110">Sehen wir uns ein einfaches Beispiel an.</span><span class="sxs-lookup"><span data-stu-id="1cfec-110">Let's look at a simple example.</span></span>
<span data-ttu-id="1cfec-111">Hier ist eine Codezeile:</span><span class="sxs-lookup"><span data-stu-id="1cfec-111">Here's a line of code:</span></span>

```csharp
var sum = 1 + 2;
```

<span data-ttu-id="1cfec-112">Würden Sie dies als eine Ausdrucksbaumstruktur analysieren, enthält die Struktur mehrere Knoten.</span><span class="sxs-lookup"><span data-stu-id="1cfec-112">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="1cfec-113">Der äußerste Knoten ist eine Variablendeklaration-Anweisung mit der Zuordnung (`var sum = 1 + 2;`). Dieser äußerste Knoten enthält mehrere untergeordnete Knoten: eine Variablendeklaration, ein Zuweisungsoperator und ein Ausdruck, der die rechte Seite des Gleichheitszeichens darstellt.</span><span class="sxs-lookup"><span data-stu-id="1cfec-113">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="1cfec-114">Dieser Ausdruck wird weiter unterteilt in Ausdrücke, die den Additionsvorgang und linken und rechten Operanden der Addition darstellen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-114">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="1cfec-115">Lassen Sie uns die Ausdrücke etwas genauer ansehen, die die rechte Seite neben dem Gleichheitszeichen bilden.</span><span class="sxs-lookup"><span data-stu-id="1cfec-115">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="1cfec-116">Der Ausdruck ist `1 + 2`.</span><span class="sxs-lookup"><span data-stu-id="1cfec-116">The expression is `1 + 2`.</span></span> <span data-ttu-id="1cfec-117">Das ist ein binärer Ausdruck.</span><span class="sxs-lookup"><span data-stu-id="1cfec-117">That's a binary expression.</span></span> <span data-ttu-id="1cfec-118">Genauer gesagt ist es ein binärer Additionsausdruck.</span><span class="sxs-lookup"><span data-stu-id="1cfec-118">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="1cfec-119">Ein binäre Additionsausdruck verfügt über zwei untergeordnete Elemente, die den linken und rechten Knoten des Additionsausdrucks darstellen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-119">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="1cfec-120">Hier sind die beiden Knoten konstante Ausdrücke: Der linke Operand ist der Wert `1`, und der rechte Operand ist der Wert `2`.</span><span class="sxs-lookup"><span data-stu-id="1cfec-120">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="1cfec-121">Visuell ist die gesamte Anweisung eine Struktur: Sie können beim Stammknoten beginnen und zu jedem Knoten in der Struktur navigieren, um den Code anzuzeigen, der die Anweisung bildet:</span><span class="sxs-lookup"><span data-stu-id="1cfec-121">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="1cfec-122">Variablendeklaration-Anweisung mit der Zuordnung (`var sum = 1 + 2;`)</span><span class="sxs-lookup"><span data-stu-id="1cfec-122">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
  - <span data-ttu-id="1cfec-123">Implizite Typdeklaration von Variablen (`var sum`)</span><span class="sxs-lookup"><span data-stu-id="1cfec-123">Implicit variable type declaration (`var sum`)</span></span>
    - <span data-ttu-id="1cfec-124">Implizites var-Schlüsselwort (`var`)</span><span class="sxs-lookup"><span data-stu-id="1cfec-124">Implicit var keyword (`var`)</span></span>
    - <span data-ttu-id="1cfec-125">Namensdeklaration von Variablen (`sum`)</span><span class="sxs-lookup"><span data-stu-id="1cfec-125">Variable name declaration (`sum`)</span></span>
  - <span data-ttu-id="1cfec-126">Zuweisungsoperator (`=`)</span><span class="sxs-lookup"><span data-stu-id="1cfec-126">Assignment operator (`=`)</span></span>
  - <span data-ttu-id="1cfec-127">Binärer Additionsausdruck (`1 + 2`)</span><span class="sxs-lookup"><span data-stu-id="1cfec-127">Binary addition expression (`1 + 2`)</span></span>
    - <span data-ttu-id="1cfec-128">Linker Operand (`1`)</span><span class="sxs-lookup"><span data-stu-id="1cfec-128">Left operand (`1`)</span></span>
    - <span data-ttu-id="1cfec-129">Additionsoperator (`+`)</span><span class="sxs-lookup"><span data-stu-id="1cfec-129">Addition operator (`+`)</span></span>
    - <span data-ttu-id="1cfec-130">Rechter Operand (`2`)</span><span class="sxs-lookup"><span data-stu-id="1cfec-130">Right operand (`2`)</span></span>

<span data-ttu-id="1cfec-131">Dies mag kompliziert aussehen, aber es ist sehr leistungsfähig.</span><span class="sxs-lookup"><span data-stu-id="1cfec-131">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="1cfec-132">Mit den gleichen Verfahren können Sie wesentlich kompliziertere Ausdrücke zerlegen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-132">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="1cfec-133">Betrachten Sie diesen Ausdruck:</span><span class="sxs-lookup"><span data-stu-id="1cfec-133">Consider this expression:</span></span>

```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="1cfec-134">Der obige Ausdruck ist auch die Variablendeklaration mit einer Zuordnung.</span><span class="sxs-lookup"><span data-stu-id="1cfec-134">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="1cfec-135">In dieser Instanz ist die rechte Seite der Zuordnung eine wesentlich kompliziertere Struktur.</span><span class="sxs-lookup"><span data-stu-id="1cfec-135">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="1cfec-136">Ich werde diesen Ausdruck nicht zerlegen, aber beachten Sie, was die verschiedenen Knoten sein könnten.</span><span class="sxs-lookup"><span data-stu-id="1cfec-136">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="1cfec-137">Es sind Methodenaufrufe vorhanden, die das aktuelle Objekt als Empfänger verwenden, einen, der einen expliziten `this`-Empfänger hat und einen, der das nicht hat.</span><span class="sxs-lookup"><span data-stu-id="1cfec-137">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="1cfec-138">Es sind Methodenaufrufe vorhanden, die andere Empfängerobjekte verwenden. Es sind konstante Argumente verschiedener Typen vorhanden.</span><span class="sxs-lookup"><span data-stu-id="1cfec-138">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="1cfec-139">Und schließlich gibt es einen binären Additionsoperator.</span><span class="sxs-lookup"><span data-stu-id="1cfec-139">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="1cfec-140">Je nach Rückgabetyp von `SecretSauceFunction()` oder `MoreSecretSauce()`, kann dieser binäre Additionsoperator ein Methodenaufruf an einen überschriebenen Additionsoperator sein, der einen statischen Methodenaufruf des binären Additionsoperators, der für eine Klasse definiert ist auflöst.</span><span class="sxs-lookup"><span data-stu-id="1cfec-140">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="1cfec-141">Trotz dieser spürbaren Komplexität erstellt der obige Ausdruck eine Baumstruktur, die so einfach wie das erste Beispiel navigiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1cfec-141">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="1cfec-142">Sie können untergeordnete Knoten durchlaufen lassen, um Endknoten im Ausdruck zu finden.</span><span class="sxs-lookup"><span data-stu-id="1cfec-142">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="1cfec-143">Übergeordnete Knoten verfügen über Verweise auf ihre untergeordneten Elemente, und jeder Knoten verfügt über eine Eigenschaft, die beschreibt, welche Art von Knoten es ist.</span><span class="sxs-lookup"><span data-stu-id="1cfec-143">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="1cfec-144">Die Struktur einer Ausdrucksbaumstruktur ist sehr konsistent.</span><span class="sxs-lookup"><span data-stu-id="1cfec-144">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="1cfec-145">Sobald Sie mit den Grundlagen vertraut sind, können Sie auch den komplexesten Code verstehen, wenn er als Ausdrucksbaumstruktur dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1cfec-145">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="1cfec-146">Die Eleganz in der Datenstruktur erläutert, wie der C#-Compiler die komplexesten C#-Programme analysieren und eine korrekte Ausgabe aus diesem komplizierten Quellcode erstellen kann.</span><span class="sxs-lookup"><span data-stu-id="1cfec-146">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="1cfec-147">Sobald Sie mit der Struktur von Ausdrucksbaumstrukturen vertraut sind, werden Sie feststellen, dass dieses Wissen es Ihnen ermöglicht, mit mehr und mehr erweiterten Szenarios zu arbeiten.</span><span class="sxs-lookup"><span data-stu-id="1cfec-147">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="1cfec-148">Dies bedeutet eine unglaubliche Leistung für Ausdrucksbaumstrukturen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-148">There is incredible power to expression trees.</span></span>

<span data-ttu-id="1cfec-149">Zusätzlich zum Übersetzen von Algorithmen, die in anderen Umgebungen ausgeführt werden sollen, können Ausdrucksbaumstrukturen verwendet werden, um das Schreiben von Algorithmen zu erleichtern, der Code überprüft, bevor Sie ihn ausführen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-149">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="1cfec-150">Sie können eine Methode schreiben, deren Argumente Ausdrücke sind, und anschließend diese Ausdrücke vor dem Ausführen des Codes überprüfen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-150">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="1cfec-151">Die Ausdrucksbaumstruktur ist eine vollständige Darstellung des Codes: Sie können Werte von beliebigen Unterausdrücken sehen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-151">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="1cfec-152">Sie können Methoden- und Eigenschaftsnamen sehen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-152">You can see method and property names.</span></span> <span data-ttu-id="1cfec-153">Sie können den Wert jedes konstanten Ausdrucks sehen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-153">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="1cfec-154">Sie können auch eine Ausdrucksbaumstruktur in einen ausführbaren Delegaten konvertieren und den Code ausführen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-154">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="1cfec-155">Mit den APIs für Ausdrucksbaumstrukturen können Sie Strukturen erstellen, die fast jeden gültigen Codekonstrukt darstellen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-155">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="1cfec-156">Um die Dinge so einfach wie möglich zu halten, können jedoch einige C#-Ausdrücke nicht in einer Ausdrucksbaumstruktur erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="1cfec-156">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="1cfec-157">Ein Beispiel sind asynchrone Ausdrücke (mithilfe der `async`- und `await`-Schlüsselwörter).</span><span class="sxs-lookup"><span data-stu-id="1cfec-157">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="1cfec-158">Wenn Ihre Bedürfnisse asynchrone Algorithmen erfordern, müssten Sie die `Task`-Objekte direkt bearbeiten, anstatt sich auf die Unterstützung des Compilers zu verlassen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-158">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="1cfec-159">Ein weiteres Beispiel ist die Erstellung von Schleifen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-159">Another is in creating loops.</span></span> <span data-ttu-id="1cfec-160">Normalerweise erstellen Sie diese mithilfe der Schleifen `for`, `foreach`, `while` oder `do`.</span><span class="sxs-lookup"><span data-stu-id="1cfec-160">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="1cfec-161">Wie Sie [später in dieser Serie](expression-trees-building.md) sehen werden, unterstützen die APIs für Ausdrucksbaumstrukturen einen einzelnen Schleifenausdruck mit `break`- und `continue`-Ausdrücken, die die Wiederholung der Schleife steuern.</span><span class="sxs-lookup"><span data-stu-id="1cfec-161">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="1cfec-162">Eine Sache, die für Sie nicht möglich ist, ist die Änderung einer Ausdrucksbaumstruktur.</span><span class="sxs-lookup"><span data-stu-id="1cfec-162">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="1cfec-163">Ausdrucksbaumstrukturen sind unveränderliche Datenstrukturen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-163">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="1cfec-164">Wenn Sie eine Ausdrucksbaumstruktur ändern möchten, müssen Sie eine neue Struktur erstellen, die eine Kopie des Originals ist, aber mit den gewünschten Änderungen.</span><span class="sxs-lookup"><span data-stu-id="1cfec-164">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span>

[<span data-ttu-id="1cfec-165">Weiter – Framework-Typen, die Ausdrucksbaumstrukturen unterstützen</span><span class="sxs-lookup"><span data-stu-id="1cfec-165">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)
