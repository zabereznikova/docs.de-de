---
title: Erste Schritte mit der semantischen Analyse
description: Dieses Tutorial bietet einen Überblick über die Arbeit mit semantischen Analysen mithilfe des .NET Compiler SDK.
ms.date: 02/06/2018
ms.custom: mvc
ms.openlocfilehash: a6dcaeeb86acb5c0e1602f01dc5952ffd9d5e3f5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/14/2020
ms.locfileid: "78240508"
---
# <a name="get-started-with-semantic-analysis"></a><span data-ttu-id="7724a-103">Erste Schritte mit der semantischen Analyse</span><span class="sxs-lookup"><span data-stu-id="7724a-103">Get started with semantic analysis</span></span>

<span data-ttu-id="7724a-104">Bei diesem Tutorial wird davon ausgegangen, dass Sie mit der Syntax-API vertraut sind.</span><span class="sxs-lookup"><span data-stu-id="7724a-104">This tutorial assumes you're familiar with the Syntax API.</span></span> <span data-ttu-id="7724a-105">Der Artikel [Erste Schritte mit der Syntaxanalyse](syntax-analysis.md) bietet eine Einführung zu diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="7724a-105">The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction.</span></span>

<span data-ttu-id="7724a-106">Im vorliegenden Tutorial erkunden Sie die APIs für **Symbol** und **Bindung**.</span><span class="sxs-lookup"><span data-stu-id="7724a-106">In this tutorial, you explore the **Symbol** and **Binding APIs**.</span></span> <span data-ttu-id="7724a-107">Diese APIs bieten Informationen zur _semantischen Bedeutung_ eines Programms.</span><span class="sxs-lookup"><span data-stu-id="7724a-107">These APIs provide information about the _semantic meaning_ of a program.</span></span> <span data-ttu-id="7724a-108">Sie ermöglichen es Ihnen, Fragen zu den Typen zu stellen und zu beantworten, die durch ein Symbol in Ihrem Programm dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="7724a-108">They enable you to ask and answer questions about the types represented by any symbol in your program.</span></span>

<span data-ttu-id="7724a-109">Die Installation des **SDK für die .NET Compiler Platform** ist erforderlich.</span><span class="sxs-lookup"><span data-stu-id="7724a-109">You'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-compilations-and-symbols"></a><span data-ttu-id="7724a-110">Grundlegendes zu Kompilierungen und Symbolen</span><span class="sxs-lookup"><span data-stu-id="7724a-110">Understanding Compilations and Symbols</span></span>

<span data-ttu-id="7724a-111">Wenn Sie eine Weile mit dem .NET Compiler SDK arbeiten, werden Ihnen die Unterschiede zwischen der Syntax-API und der Semantik-API immer vertrauter.</span><span class="sxs-lookup"><span data-stu-id="7724a-111">As you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API.</span></span> <span data-ttu-id="7724a-112">Die **Syntax-API** ermöglicht es Ihnen, die _Struktur_ eines Programms zu untersuchen.</span><span class="sxs-lookup"><span data-stu-id="7724a-112">The **Syntax API** allows you to look at the _structure_ of a program.</span></span> <span data-ttu-id="7724a-113">In vielen Fällen benötigen Sie jedoch weitere Informationen zur Semantik bzw. _Bedeutung_ eines Programms.</span><span class="sxs-lookup"><span data-stu-id="7724a-113">However, often you want richer information about the semantics or _meaning_ of a program.</span></span> <span data-ttu-id="7724a-114">Sie können zwar eine einzelne, losgelöste Codedatei oder einen isolierten Visual Basic- oder C#-Codeausschnitt syntaktisch analysieren, aber es ist wenig sinnvoll, Fragen wie „Welchen Typ weist diese Variable auf?“ sozusagen im luftleeren Raum zu stellen.</span><span class="sxs-lookup"><span data-stu-id="7724a-114">While a loose code file or snippet of Visual Basic or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as "what's the type of this variable" in a vacuum.</span></span> <span data-ttu-id="7724a-115">Die Bedeutung eines Typnamens kann von Assemblyverweisen, Namespaceimporten oder anderen Codedateien abhängig sein.</span><span class="sxs-lookup"><span data-stu-id="7724a-115">The meaning of a type name may be dependent on assembly references, namespace imports, or other code files.</span></span> <span data-ttu-id="7724a-116">Diese Fragen werden mithilfe der **Semantik-API**, insbesondere der <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType>-Klasse, beantwortet.</span><span class="sxs-lookup"><span data-stu-id="7724a-116">Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class.</span></span>

<span data-ttu-id="7724a-117">Eine Instanz von <xref:Microsoft.CodeAnalysis.Compilation> entspricht einem einzelnen Projekt aus Sicht des Compilers und repräsentiert alle Elemente, die zum Kompilieren eines Visual Basic- oder C#-Programms erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="7724a-117">An instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program.</span></span> <span data-ttu-id="7724a-118">Die **Kompilierung** umfasst die Quelldateien, die kompiliert werden sollen, sowie Assemblyverweise und Compileroptionen.</span><span class="sxs-lookup"><span data-stu-id="7724a-118">The **compilation** includes the set of source files to be compiled, assembly references, and compiler options.</span></span> <span data-ttu-id="7724a-119">Sie können alle weiteren Informationen in diesem Kontext heranziehen, um die Bedeutung des Codes genau zu verstehen.</span><span class="sxs-lookup"><span data-stu-id="7724a-119">You can reason about the meaning of the code using all the other information in this context.</span></span> <span data-ttu-id="7724a-120">Eine <xref:Microsoft.CodeAnalysis.Compilation> ermöglicht es Ihnen, **Symbole** zu suchen: Entitäten wie z.B. Typen, Namespaces, Member und Variablen, auf die Namen und andere Ausdrücke verweisen.</span><span class="sxs-lookup"><span data-stu-id="7724a-120">A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to.</span></span> <span data-ttu-id="7724a-121">Der Prozess der Verknüpfung von Namen und Ausdrücken mit **Symbolen** wird als **Bindung** bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="7724a-121">The process of associating names and expressions with **Symbols** is called **Binding**.</span></span>

<span data-ttu-id="7724a-122">Ebenso wie <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType> ist <xref:Microsoft.CodeAnalysis.Compilation> eine abstrakte Klasse mit sprachspezifischen Ableitungen.</span><span class="sxs-lookup"><span data-stu-id="7724a-122">Like <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives.</span></span> <span data-ttu-id="7724a-123">Wenn Sie eine Instanz von „Compilation“ erstellen, müssen Sie eine Factorymethode in der Klasse <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (oder <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) aufrufen.</span><span class="sxs-lookup"><span data-stu-id="7724a-123">When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class.</span></span>

## <a name="querying-symbols"></a><span data-ttu-id="7724a-124">Abfragen von Symbolen</span><span class="sxs-lookup"><span data-stu-id="7724a-124">Querying symbols</span></span>

<span data-ttu-id="7724a-125">In diesem Tutorial betrachten wir noch einmal das Hello World-Programm.</span><span class="sxs-lookup"><span data-stu-id="7724a-125">In this tutorial, you look at the "Hello World" program again.</span></span> <span data-ttu-id="7724a-126">Diesmal fragen Sie die Symbole im Programm ab, um zu verstehen, welche Typen durch diese Symbole repräsentiert werden.</span><span class="sxs-lookup"><span data-stu-id="7724a-126">This time, you query the symbols in the program to understand what types those symbols represent.</span></span> <span data-ttu-id="7724a-127">Sie fragen die Typen in einem Namespace ab und lernen, wie Sie die verfügbaren Methoden in einem Typ finden.</span><span class="sxs-lookup"><span data-stu-id="7724a-127">You query for the types in a namespace, and learn to find the methods available on a type.</span></span>

<span data-ttu-id="7724a-128">Den fertig gestellten Code für dieses Beispiel finden Sie in [unserem GitHub-Repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SemanticQuickStart).</span><span class="sxs-lookup"><span data-stu-id="7724a-128">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SemanticQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="7724a-129">Die Syntaxstrukturtypen verwenden Vererbung, um die verschiedenen Syntaxelemente zu beschreiben, die an verschiedenen Positionen im Programm gültig sind.</span><span class="sxs-lookup"><span data-stu-id="7724a-129">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="7724a-130">Bei der Verwendung dieser APIs müssen häufig Eigenschaften oder Sammlungsmember in bestimmte abgeleitete Typen umgewandelt werden.</span><span class="sxs-lookup"><span data-stu-id="7724a-130">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="7724a-131">In den folgenden Beispielen sind die Zuweisung und die Umwandlung separate Anweisungen, bei denen explizit typisierte Variablen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="7724a-131">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="7724a-132">Sie können den Code lesen, um die Rückgabetypen der API und den Laufzeittyp der zurückgegebenen Objekte zu sehen.</span><span class="sxs-lookup"><span data-stu-id="7724a-132">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="7724a-133">In der Praxis ist es eher üblich, implizit typisierte Variablen zu verwenden und die Typen der zu untersuchenden Objekte mithilfe von API-Namen zu beschreiben.</span><span class="sxs-lookup"><span data-stu-id="7724a-133">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="7724a-134">Erstellen Sie ein neues **Stand-Alone Code Analysis Tool**-Projekt für C#:</span><span class="sxs-lookup"><span data-stu-id="7724a-134">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="7724a-135">Wählen Sie in Visual Studio **Datei** > **Neu** > **Projekt** aus, um das Dialogfeld „Neues Projekt“ anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="7724a-135">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="7724a-136">Wählen Sie unter **Visual C#**  > **Erweiterbarkeit** die Option **Stand-Alone Code Analysis Tool** aus.</span><span class="sxs-lookup"><span data-stu-id="7724a-136">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="7724a-137">Nennen Sie Ihr Projekt **SemanticQuickStart**, und klicken Sie auf „OK“.</span><span class="sxs-lookup"><span data-stu-id="7724a-137">Name your project "**SemanticQuickStart**" and click OK.</span></span>

<span data-ttu-id="7724a-138">Sie werden das einfache Hello World!-</span><span class="sxs-lookup"><span data-stu-id="7724a-138">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="7724a-139">Programm analysieren, das weiter oben in diesem Artikel gezeigt wurde.</span><span class="sxs-lookup"><span data-stu-id="7724a-139">program shown earlier.</span></span>
<span data-ttu-id="7724a-140">Fügen Sie den Text für das Hello World-Programm als Konstante in Ihre `Program`-Klasse ein:</span><span class="sxs-lookup"><span data-stu-id="7724a-140">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program test](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="7724a-141">Anschließend fügen Sie den folgenden Code hinzu, um die Syntaxstruktur für den Codetext in der `programText`-Konstante zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="7724a-141">Next, add the following code to build the syntax tree for the code text in the `programText` constant.</span></span>  <span data-ttu-id="7724a-142">Fügen Sie Ihrer `Main`-Methode die folgende Zeile hinzu:</span><span class="sxs-lookup"><span data-stu-id="7724a-142">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="7724a-143">Anschließend erstellen Sie aus der bereits erstellten Struktur eine <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation>.</span><span class="sxs-lookup"><span data-stu-id="7724a-143">Next, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created.</span></span> <span data-ttu-id="7724a-144">Das Hello World-Beispiel basiert auf den Typen <xref:System.String> und <xref:System.Console>.</span><span class="sxs-lookup"><span data-stu-id="7724a-144">The "Hello World" sample relies on the <xref:System.String> and <xref:System.Console> types.</span></span> <span data-ttu-id="7724a-145">Sie müssen auf die Assembly verweisen, die diese beiden Typen in Ihrer Kompilierung deklariert.</span><span class="sxs-lookup"><span data-stu-id="7724a-145">You need to reference the assembly that declares those two types in your compilation.</span></span> <span data-ttu-id="7724a-146">Fügen Sie Ihrer `Main`-Methode folgende Zeile hinzu, um eine Kompilierung Ihrer Syntaxstruktur einschließlich des Verweises auf die entsprechende Assembly zu erstellen:</span><span class="sxs-lookup"><span data-stu-id="7724a-146">Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:</span></span>

[!code-csharp[Create the compilation](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#3 "Create the compilation for the semantic model")]

<span data-ttu-id="7724a-147">Die <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType>-Methode fügt Verweise zur Kompilierung hinzu.</span><span class="sxs-lookup"><span data-stu-id="7724a-147">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation.</span></span> <span data-ttu-id="7724a-148">Die <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType>-Methode lädt eine Assembly als Verweis.</span><span class="sxs-lookup"><span data-stu-id="7724a-148">The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> method loads an assembly as a reference.</span></span>

## <a name="querying-the-semantic-model"></a><span data-ttu-id="7724a-149">Abfragen des semantischen Modells</span><span class="sxs-lookup"><span data-stu-id="7724a-149">Querying the semantic model</span></span>

<span data-ttu-id="7724a-150">Sobald Sie über eine <xref:Microsoft.CodeAnalysis.Compilation> verfügen, können Sie diese nach einem <xref:Microsoft.CodeAnalysis.SemanticModel> für jede <xref:Microsoft.CodeAnalysis.SyntaxTree> in dieser <xref:Microsoft.CodeAnalysis.Compilation> abfragen.</span><span class="sxs-lookup"><span data-stu-id="7724a-150">Once you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="7724a-151">Sie können sich das Semantikmodell als die Quelle aller Informationen vorstellen, die Sie normalerweise aus IntelliSense erhalten.</span><span class="sxs-lookup"><span data-stu-id="7724a-151">You can think of the semantic model as the source for all the information you would normally get from intellisense.</span></span> <span data-ttu-id="7724a-152">Ein <xref:Microsoft.CodeAnalysis.SemanticModel> kann Fragen wie die folgenden beantworten: „Welche Namen befinden sich an diesem Ort im Gültigkeitsbereich?“, „Auf welche Member kann von dieser Methode aus zugegriffen werden?“, „Welche Variablen werden in diesem Textblock verwendet?“ und „Vorauf verweist dieser Name/dieser Ausdruck?“.</span><span class="sxs-lookup"><span data-stu-id="7724a-152">A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like "What names are in scope at this location?", "What members are accessible from this method?", "What variables are used in this block of text?", and "What does this name/expression refer to?"</span></span> <span data-ttu-id="7724a-153">Fügen Sie diese Anweisung hinzu, um das semantische Modell zu erstellen:</span><span class="sxs-lookup"><span data-stu-id="7724a-153">Add this statement to create the semantic model:</span></span>

[!code-csharp[Create the semantic model](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#4 "Create the semantic model")]

## <a name="binding-a-name"></a><span data-ttu-id="7724a-154">Binden eines Namens</span><span class="sxs-lookup"><span data-stu-id="7724a-154">Binding a name</span></span>

<span data-ttu-id="7724a-155">Die <xref:Microsoft.CodeAnalysis.Compilation> erstellt das <xref:Microsoft.CodeAnalysis.SemanticModel> aus der <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span><span class="sxs-lookup"><span data-stu-id="7724a-155">The <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="7724a-156">Nach dem Erstellen des Modells können Sie es abfragen, um die erste `using`-Direktive zu suchen und die Symbolinformationen für den `System`-Namespace abzurufen.</span><span class="sxs-lookup"><span data-stu-id="7724a-156">After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace.</span></span> <span data-ttu-id="7724a-157">Fügen Sie die folgenden beiden Zeilen zu Ihrer `Main`-Methode hinzu, um das Semantikmodell zu erstellen und das Symbol für die erste using-Anweisung abzurufen:</span><span class="sxs-lookup"><span data-stu-id="7724a-157">Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:</span></span>

[!code-csharp[Find the namespace symbol for the first using](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#5 "Find the namespace symbol for the first using")]

<span data-ttu-id="7724a-158">Nachdem das Modell abgerufen wurde, wird der Name in der ersten `using`-Anweisung gebunden, um eine <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> für den `System`-Namespace abzurufen.</span><span class="sxs-lookup"><span data-stu-id="7724a-158">The preceding code shows how to bind the name in the first `using` directive to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace.</span></span> <span data-ttu-id="7724a-159">Dieser Code verdeutlicht auch, dass Sie das **Syntaxmodell** verwenden, um die Struktur des Codes zu ermitteln. Das **Semantikmodell** verwenden Sie, um die Bedeutung des Codes zu verstehen.</span><span class="sxs-lookup"><span data-stu-id="7724a-159">The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning.</span></span> <span data-ttu-id="7724a-160">Das **Syntaxmodell** sucht die Zeichenfolge `System` in der using-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="7724a-160">The **syntax model** finds the string `System` in the using statement.</span></span> <span data-ttu-id="7724a-161">Das **Semantikmodell** verfügt über alle Informationen zu den im `System`-Namespace definierten Typen.</span><span class="sxs-lookup"><span data-stu-id="7724a-161">The **semantic model** has all the information about the types defined in the `System` namespace.</span></span>

<span data-ttu-id="7724a-162">Aus dem <xref:Microsoft.CodeAnalysis.SymbolInfo>-Objekt können Sie mithilfe der <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType>-Eigenschaft das <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> abrufen.</span><span class="sxs-lookup"><span data-stu-id="7724a-162">From the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="7724a-163">Diese Eigenschaft gibt das Symbol zurück, auf das dieser Ausdruck verweist.</span><span class="sxs-lookup"><span data-stu-id="7724a-163">This property returns the symbol this expression refers to.</span></span> <span data-ttu-id="7724a-164">Bei Ausdrücken, die auf nichts verweisen (wie z.B. numerische Literale), lautet diese Eigenschaft `null`.</span><span class="sxs-lookup"><span data-stu-id="7724a-164">For expressions that don't refer to anything (such as numeric literals) this property is `null`.</span></span> <span data-ttu-id="7724a-165">Wenn <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> nicht null ist, bezeichnet <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> den Typ des Symbols.</span><span class="sxs-lookup"><span data-stu-id="7724a-165">When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol.</span></span> <span data-ttu-id="7724a-166">In diesem Beispiel ist die <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType>-Eigenschaft ein <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7724a-166">In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7724a-167">Fügen Sie der `Main`-Methode den folgenden Code hinzu.</span><span class="sxs-lookup"><span data-stu-id="7724a-167">Add the following code to your `Main` method.</span></span> <span data-ttu-id="7724a-168">Der Code ruft das Symbol für den `System`-Namespace ab und zeigt alle untergeordneten Namespaces an, die im `System`-Namespace deklariert sind:</span><span class="sxs-lookup"><span data-stu-id="7724a-168">It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:</span></span>

[!code-csharp[Display all the child namespaces](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#6 "Display all the child namespaces from this compilation")]

<span data-ttu-id="7724a-169">Führen Sie das Programm aus. Folgende Ausgabe sollte angezeigt werden:</span><span class="sxs-lookup"><span data-stu-id="7724a-169">Run the program and you should see the following output:</span></span>

```output
System.Collections
System.Configuration
System.Deployment
System.Diagnostics
System.Globalization
System.IO
System.Numerics
System.Reflection
System.Resources
System.Runtime
System.Security
System.StubHelpers
System.Text
System.Threading
Press any key to continue . . .
```

> [!NOTE]
> <span data-ttu-id="7724a-170">Die Ausgabe umfasst nicht jeden Namespace, der ein untergeordneter Namespace des `System`-Namespace ist.</span><span class="sxs-lookup"><span data-stu-id="7724a-170">The output does not include every namespace that is a child namespace of the `System` namespace.</span></span> <span data-ttu-id="7724a-171">Sie zeigt jeden Namespace an, der in dieser Kompilierung vorhanden ist. Diese verweist nur auf die Assembly, in der `System.String` deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="7724a-171">It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared.</span></span> <span data-ttu-id="7724a-172">Namespaces, die in anderen Assemblys deklariert wurden, sind dieser Kompilierung unbekannt.</span><span class="sxs-lookup"><span data-stu-id="7724a-172">Any namespaces declared in other assemblies are not known to this compilation</span></span>

### <a name="binding-an-expression"></a><span data-ttu-id="7724a-173">Binden eines Ausdrucks</span><span class="sxs-lookup"><span data-stu-id="7724a-173">Binding an expression</span></span>

<span data-ttu-id="7724a-174">Der oben gezeigte Code veranschaulicht, wie Sie ein Symbol suchen, indem Sie es an einen Namen binden.</span><span class="sxs-lookup"><span data-stu-id="7724a-174">The preceding code shows how to find a symbol by binding to a name.</span></span> <span data-ttu-id="7724a-175">Es gibt weitere Ausdrücke in einem C#-Programm, die gebunden werden können, aber keine Namen sind.</span><span class="sxs-lookup"><span data-stu-id="7724a-175">There are other expressions in a C# program that can be bound that aren't names.</span></span> <span data-ttu-id="7724a-176">Um diese Funktion zu demonstrieren, sehen wir uns die Bindung an ein einfaches Zeichenfolgenliteral an.</span><span class="sxs-lookup"><span data-stu-id="7724a-176">To demonstrate this capability, let's access the binding to a simple string literal.</span></span>

<span data-ttu-id="7724a-177">Das Hello World-Programm enthält eine <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>: die Hello, World!-</span><span class="sxs-lookup"><span data-stu-id="7724a-177">The "Hello World" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the "Hello, World!"</span></span> <span data-ttu-id="7724a-178">Zeichenfolge, die in der Konsole angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="7724a-178">string displayed to the console.</span></span>

<span data-ttu-id="7724a-179">Sie finden die Hello, World!-</span><span class="sxs-lookup"><span data-stu-id="7724a-179">You find the "Hello, World!"</span></span> <span data-ttu-id="7724a-180">Zeichenfolge, indem Sie das einzelne Zeichenfolgenliteral im Programm suchen.</span><span class="sxs-lookup"><span data-stu-id="7724a-180">string by locating the single string literal in the program.</span></span> <span data-ttu-id="7724a-181">Wenn Sie den Syntaxknoten gefunden haben, rufen Sie die Typinformationen für diesen Knoten aus dem Semantikmodell ab.</span><span class="sxs-lookup"><span data-stu-id="7724a-181">Then, once you've located the syntax node, get the type info for that node from the semantic model.</span></span> <span data-ttu-id="7724a-182">Fügen Sie der `Main`-Methode den folgenden Code hinzu:</span><span class="sxs-lookup"><span data-stu-id="7724a-182">Add the following code to your `Main` method:</span></span>

[!code-csharp[Find the namespace symbol for the only using](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#7 "Find the namespace symbol for the only using")]

<span data-ttu-id="7724a-183">Die <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType>-Struktur enthält eine <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType>-Eigenschaft, die Zugriff auf die semantischen Informationen zum Typ des Literals erlaubt.</span><span class="sxs-lookup"><span data-stu-id="7724a-183">The <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal.</span></span> <span data-ttu-id="7724a-184">In diesem Beispiel handelt es sich um den Typ `string`.</span><span class="sxs-lookup"><span data-stu-id="7724a-184">In this example, that's the `string` type.</span></span> <span data-ttu-id="7724a-185">Fügen Sie eine Deklaration hinzu, die diese Eigenschaft einer lokalen Variable zuweist:</span><span class="sxs-lookup"><span data-stu-id="7724a-185">Add a declaration that assigns this property to a local variable:</span></span>

[!code-csharp[Find the semantic information about the string type](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#8 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="7724a-186">Zum Abschluss dieses Tutorials erstellen wir eine LINQ-Abfrage, die eine Sequenz aller öffentlichen Methoden erstellt, die im `string`-Typ deklariert sind und eine `string` zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="7724a-186">To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`.</span></span> <span data-ttu-id="7724a-187">Diese Abfrage wird ziemlich komplex – wir bauen sie daher Zeile für Zeile auf und rekonstruieren sie dann als Einzelabfrage.</span><span class="sxs-lookup"><span data-stu-id="7724a-187">This query gets complex, so let's build it line by line, then reconstruct it as a single query.</span></span> <span data-ttu-id="7724a-188">Die Quelle dieser Abfrage ist die Sequenz aller Member, die im `string`-Typ deklariert sind:</span><span class="sxs-lookup"><span data-stu-id="7724a-188">The source for this query is the sequence of all members declared on the `string` type:</span></span>

[!code-csharp[Access the sequence of members on the string type](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#9 "Access the sequence of members on the string type.")]

<span data-ttu-id="7724a-189">Diese Quellsequenz enthält alle Member, einschließlich Eigenschaften und Feldern. Filtern Sie die Sequenz daher mit der <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType>-Methode, um die Elemente zu finden, bei denen es sich um <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType>-Objekte handelt:</span><span class="sxs-lookup"><span data-stu-id="7724a-189">That source sequence contains all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType> objects:</span></span>

[!code-csharp[Filter the sequence to only methods](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#10 "Find the subset of the collection that is the methods.")]

<span data-ttu-id="7724a-190">Danach fügen Sie einen weiteren Filter hinzu, um nur die Methoden zurückzugeben, die öffentlich sind und eine `string` zurückgeben:</span><span class="sxs-lookup"><span data-stu-id="7724a-190">Next, add another filter to return only those methods that are public and return a `string`:</span></span>

[!code-csharp[Filter on return type and accessibility](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#11 "Find only the public methods that return a string.")]

<span data-ttu-id="7724a-191">Wählen Sie nur die name-Eigenschaft und nur eindeutige Namen aus, indem Sie alle Überladungen entfernen:</span><span class="sxs-lookup"><span data-stu-id="7724a-191">Select only the name property, and only distinct names by removing any overloads:</span></span>

[!code-csharp[find the distinct names.](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#12 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="7724a-192">Sie können auch mithilfe der LINQ-Abfragesyntax die vollständige Abfrage erstellen und dann alle Methodennamen in der Konsole anzeigen:</span><span class="sxs-lookup"><span data-stu-id="7724a-192">You can also build the full query using the LINQ query syntax, and then display all the method names in  the console:</span></span>

[!code-csharp[build and display the results of this query.](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#13 "Build and display the results of the query.")]

<span data-ttu-id="7724a-193">Kompilieren Sie das Programm, und führen Sie es aus.</span><span class="sxs-lookup"><span data-stu-id="7724a-193">Build and run the program.</span></span> <span data-ttu-id="7724a-194">Die folgende Ausgabe wird angezeigt:</span><span class="sxs-lookup"><span data-stu-id="7724a-194">You should see the following output:</span></span>

```output
Join
Substring
Trim
TrimStart
TrimEnd
Normalize
PadLeft
PadRight
ToLower
ToLowerInvariant
ToUpper
ToUpperInvariant
ToString
Insert
Replace
Remove
Format
Copy
Concat
Intern
IsInterned
Press any key to continue . . .
```

<span data-ttu-id="7724a-195">Sie haben die Semantik-API verwendet, um Informationen zu den Symbolen zu finden und anzuzeigen, die zu diesem Programm gehören.</span><span class="sxs-lookup"><span data-stu-id="7724a-195">You've used the Semantic API to find and display information about the symbols that are part of this program.</span></span>
