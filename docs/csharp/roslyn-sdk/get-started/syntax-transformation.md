---
title: Erste Schritte mit der Syntaxtransformation (Roslyn-APIs)
description: Eine Einführung in das Durchlaufen, Abfragen und schrittweise Durchlaufen von Syntaxstrukturen.
ms.date: 06/01/2018
ms.custom: mvc
ms.openlocfilehash: 232fe5fcba35f152dbc3f00b2f2c092b5df0dd35
ms.sourcegitcommit: de7f589de07a9979b6ac28f54c3e534a617d9425
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 05/05/2020
ms.locfileid: "82794792"
---
# <a name="get-started-with-syntax-transformation"></a><span data-ttu-id="c853a-103">Erste Schritte mit der Syntaxtransformation</span><span class="sxs-lookup"><span data-stu-id="c853a-103">Get started with syntax transformation</span></span>

<span data-ttu-id="c853a-104">Dieses Tutorial baut auf Konzepten und Methoden auf, die in den Schnellstarts [Erste Schritte mit der Syntaxanalyse](syntax-analysis.md) und [Erste Schritte mit der semantischen Analyse](semantic-analysis.md) erläutert werden.</span><span class="sxs-lookup"><span data-stu-id="c853a-104">This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts.</span></span> <span data-ttu-id="c853a-105">Wenn nicht bereits geschehen, sollten Sie diese Schnellstarts durchlaufen, bevor Sie mit diesem beginnen.</span><span class="sxs-lookup"><span data-stu-id="c853a-105">If you haven't already, you should complete those quickstarts before beginning this one.</span></span>

<span data-ttu-id="c853a-106">In diesem Schnellstart erforschen Sie Methoden zum Erstellen und Transformieren von Syntaxstrukturen.</span><span class="sxs-lookup"><span data-stu-id="c853a-106">In this quickstart, you explore techniques for creating and transforming syntax trees.</span></span> <span data-ttu-id="c853a-107">In Kombination mit den Methoden, die Sie in früheren Schnellstarts gelernt haben, erstellen Sie Ihr erstes Kommandozeilenrefactoring.</span><span class="sxs-lookup"><span data-stu-id="c853a-107">In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="immutability-and-the-net-compiler-platform"></a><span data-ttu-id="c853a-108">Unveränderlichkeit und die .NET Compiler Platform</span><span class="sxs-lookup"><span data-stu-id="c853a-108">Immutability and the .NET compiler platform</span></span>

<span data-ttu-id="c853a-109">**Unveränderlichkeit** ist ein Grundprinzip der .NET Compiler Platform.</span><span class="sxs-lookup"><span data-stu-id="c853a-109">**Immutability** is a fundamental tenet of the .NET compiler platform.</span></span> <span data-ttu-id="c853a-110">Unveränderliche Datenstrukturen können nach ihrer Erstellung nicht mehr geändert werden.</span><span class="sxs-lookup"><span data-stu-id="c853a-110">Immutable data structures can't be changed after they're created.</span></span> <span data-ttu-id="c853a-111">Sie können von mehreren Consumern gleichzeitig auf sichere Weise genutzt und analysiert werden.</span><span class="sxs-lookup"><span data-stu-id="c853a-111">Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.</span></span> <span data-ttu-id="c853a-112">Es besteht kein Risiko, dass ein Consumer einen anderen auf unvorhersehbare Weise beeinträchtigt.</span><span class="sxs-lookup"><span data-stu-id="c853a-112">There's no danger that one consumer affects another in unpredictable ways.</span></span> <span data-ttu-id="c853a-113">Für Ihr Analysetool sind keine Sperren oder andere Maßnahmen für die gleichzeitige Verwendung erforderlich.</span><span class="sxs-lookup"><span data-stu-id="c853a-113">Your analyzer doesn't need locks or other concurrency measures.</span></span> <span data-ttu-id="c853a-114">Diese Regel gilt für Syntaxstrukturen, Kompilierungen, Symbole, semantische Modelle und jede andere Datenstruktur.</span><span class="sxs-lookup"><span data-stu-id="c853a-114">This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.</span></span> <span data-ttu-id="c853a-115">Anstatt bestehende Strukturen zu modifizieren, werden durch APIs neue Objekte basierend auf den angegebenen Unterschieden zu den alten Objekten erstellt.</span><span class="sxs-lookup"><span data-stu-id="c853a-115">Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.</span></span> <span data-ttu-id="c853a-116">Sie wenden dieses Konzept auf Syntaxstrukturen an, um mithilfe von Transformationen neue Strukturen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="c853a-116">You apply this concept to syntax trees to create new trees using transformations.</span></span>

## <a name="create-and-transform-trees"></a><span data-ttu-id="c853a-117">Erstellen und Transformieren von Strukturen</span><span class="sxs-lookup"><span data-stu-id="c853a-117">Create and transform trees</span></span>

<span data-ttu-id="c853a-118">Sie wählen eine von zwei Strategien für Syntaxtransformationen.</span><span class="sxs-lookup"><span data-stu-id="c853a-118">You choose one of two strategies for syntax transformations.</span></span> <span data-ttu-id="c853a-119">**Factorymethoden** werden am besten verwendet, wenn Sie nach bestimmten Knoten suchen, die ersetzt werden sollen, oder nach bestimmten Stellen, an denen Sie neuen Code einfügen möchten.</span><span class="sxs-lookup"><span data-stu-id="c853a-119">**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.</span></span> <span data-ttu-id="c853a-120">**Rewriter** sind am besten geeignet, wenn Sie ein ganzes Projekt nach Codemustern durchsuchen möchten, die Sie ersetzen möchten.</span><span class="sxs-lookup"><span data-stu-id="c853a-120">**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.</span></span>

### <a name="create-nodes-with-factory-methods"></a><span data-ttu-id="c853a-121">Erstellen von Knoten mit Factorymethoden</span><span class="sxs-lookup"><span data-stu-id="c853a-121">Create nodes with factory methods</span></span>

<span data-ttu-id="c853a-122">Durch die erste Syntaxtransformation werden die Factorymethoden demonstriert.</span><span class="sxs-lookup"><span data-stu-id="c853a-122">The first syntax transformation demonstrates the factory methods.</span></span> <span data-ttu-id="c853a-123">Sie werden eine `using System.Collections;`-Anweisung durch eine `using System.Collections.Generic;`-Anweisung ersetzen.</span><span class="sxs-lookup"><span data-stu-id="c853a-123">You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="c853a-124">Dieses Beispiel zeigt, wie Sie <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType>-Objekte mit den <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType>-Factorymethoden erstellen.</span><span class="sxs-lookup"><span data-stu-id="c853a-124">This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods.</span></span> <span data-ttu-id="c853a-125">Für jede Art von **Knoten**, **Token** oder **Trivia** gibt es eine Factorymethode, die eine Instanz dieses Typs erstellt.</span><span class="sxs-lookup"><span data-stu-id="c853a-125">For each kind of **node**, **token**, or **trivia** there's a factory method that creates an instance of that type.</span></span> <span data-ttu-id="c853a-126">Sie erstellen Syntaxstrukturen, indem Sie Knoten hierarchisch von unten nach oben zusammensetzen.</span><span class="sxs-lookup"><span data-stu-id="c853a-126">You create syntax trees by composing nodes hierarchically in a bottom-up fashion.</span></span> <span data-ttu-id="c853a-127">Anschließend transformieren Sie das vorhandene Programm, indem Sie bestehende Knoten durch die neue, von Ihnen erstellte Struktur ersetzen.</span><span class="sxs-lookup"><span data-stu-id="c853a-127">Then, you'll transform the existing program be replacing existing nodes with the new tree you've created.</span></span>

<span data-ttu-id="c853a-128">Starten Sie Visual Studio, und erstellen Sie ein neues C#-Projekt namens **Stand-Alone Code Analysis Tool**.</span><span class="sxs-lookup"><span data-stu-id="c853a-128">Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="c853a-129">Wählen Sie in Visual Studio **Datei** > **Neu** > **Projekt** aus, um das Dialogfeld „Neues Projekt“ anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="c853a-129">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span> <span data-ttu-id="c853a-130">Wählen Sie unter **Visual C#**  > **Erweiterbarkeit** die Option **Stand-Alone Code Analysis Tool** aus.</span><span class="sxs-lookup"><span data-stu-id="c853a-130">Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="c853a-131">Dieser Schnellstart enthält zwei Beispielprojekte. Nennen Sie daher die Lösung **SyntaxTransformationQuickStart** und das Projekt **ConstructionCS**.</span><span class="sxs-lookup"><span data-stu-id="c853a-131">This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**.</span></span> <span data-ttu-id="c853a-132">Klicken Sie auf **OK**.</span><span class="sxs-lookup"><span data-stu-id="c853a-132">Click **OK**.</span></span>

<span data-ttu-id="c853a-133">Dieses Projekt verwendet die Methoden der Klasse <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType>, um ein <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>-Element zu erstellen, das den `System.Collections.Generic`-Namespace repräsentiert.</span><span class="sxs-lookup"><span data-stu-id="c853a-133">This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="c853a-134">Fügen Sie die folgende using-Anweisung am Anfang der Datei `Program.cs` hinzu, um die Factorymethoden der <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory>-Klasse und die Methoden von <xref:System.Console> zu importieren, sodass Sie sie später ohne Qualifizierung verwenden können:</span><span class="sxs-lookup"><span data-stu-id="c853a-134">Add the following using directive to the top of the `Program.cs` file to import the factory methods of the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> class and the methods of <xref:System.Console> so that you can use them later without qualifying them:</span></span>

[!code-csharp[import the SyntaxFactory class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings "import the Syntax Factory class and the System.Console class")]

<span data-ttu-id="c853a-135">Sie werden **Namenssyntaxknoten** erstellen, um die Struktur aufzubauen, die die `using System.Collections.Generic;`-Anweisung repräsentiert.</span><span class="sxs-lookup"><span data-stu-id="c853a-135">You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="c853a-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> ist die Basisklasse für vier Typen von Namen, die in C# verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c853a-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#.</span></span> <span data-ttu-id="c853a-137">Sie setzen diese vier Typen von Namen zusammen, um einen beliebigen Namen zu erstellen, der in der Programmiersprache C# enthalten sein kann:</span><span class="sxs-lookup"><span data-stu-id="c853a-137">You compose these four types of names together to create any name that can appear in the C# language:</span></span>

* <span data-ttu-id="c853a-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> steht für einfache einzelne Bezeichner wie `System` und `Microsoft`.</span><span class="sxs-lookup"><span data-stu-id="c853a-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.</span></span>
* <span data-ttu-id="c853a-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType> steht für einen generischen Typ oder Methodennamen wie `List<int>`.</span><span class="sxs-lookup"><span data-stu-id="c853a-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.</span></span>
* <span data-ttu-id="c853a-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType> steht für einen qualifizierten Namen der Form `<left-name>.<right-identifier-or-generic-name>` wie z.B. `System.IO`.</span><span class="sxs-lookup"><span data-stu-id="c853a-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.</span></span>
* <span data-ttu-id="c853a-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType> steht für einen Namen unter Verwendung eines externen Assemblyalias wie `LibraryV2::Foo`.</span><span class="sxs-lookup"><span data-stu-id="c853a-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.</span></span>

<span data-ttu-id="c853a-142">Sie verwenden die <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)>-Methode, um einen <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>-Knoten zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="c853a-142">You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node.</span></span> <span data-ttu-id="c853a-143">Fügen Sie den folgenden Code in Ihrer `Main`-Methode in `Program.cs` hinzu:</span><span class="sxs-lookup"><span data-stu-id="c853a-143">Add the following code in your `Main` method in `Program.cs`:</span></span>

[!code-csharp[create the system identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName "Create and display the system name identifier")]

<span data-ttu-id="c853a-144">Der vorangehende Code erstellt ein <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax>-Objekt und weist es der Variablen `name` zu.</span><span class="sxs-lookup"><span data-stu-id="c853a-144">The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`.</span></span> <span data-ttu-id="c853a-145">Viele der Roslyn-APIs geben Basisklassen zurück, um die Arbeit mit verwandten Typen zu erleichtern.</span><span class="sxs-lookup"><span data-stu-id="c853a-145">Many of the Roslyn APIs return base classes to make it easier to work with related types.</span></span> <span data-ttu-id="c853a-146">Die Variable `name`, eine <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, kann beim Erstellen von <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> wiederverwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c853a-146">The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="c853a-147">Verwenden Sie für das Beispiel keinen Typrückschluss.</span><span class="sxs-lookup"><span data-stu-id="c853a-147">Don't use type inference as you build the sample.</span></span> <span data-ttu-id="c853a-148">Sie werden diesen Schritt in diesem Projekt automatisieren.</span><span class="sxs-lookup"><span data-stu-id="c853a-148">You'll automate that step in this project.</span></span>

<span data-ttu-id="c853a-149">Sie haben nun den Namen erstellt.</span><span class="sxs-lookup"><span data-stu-id="c853a-149">You've created the name.</span></span> <span data-ttu-id="c853a-150">Jetzt ist es an der Zeit, die Struktur mit zusätzlichen Knoten zu erweitern, indem Sie ein <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>-Element erstellen.</span><span class="sxs-lookup"><span data-stu-id="c853a-150">Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="c853a-151">In der neuen Struktur wird `name` als linker Namensteil und ein neues <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax>-Element für den `Collections`-Namespace als rechter Teil von <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> verwendet.</span><span class="sxs-lookup"><span data-stu-id="c853a-151">The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="c853a-152">Fügen Sie den folgenden Code zu `program.cs` hinzu:</span><span class="sxs-lookup"><span data-stu-id="c853a-152">Add the following code to `program.cs`:</span></span>

[!code-csharp[create the collections identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName "Build the System.Collections identifier")]

<span data-ttu-id="c853a-153">Führen Sie den Code erneut aus, und sehen Sie sich die Ergebnisse an.</span><span class="sxs-lookup"><span data-stu-id="c853a-153">Run the code again, and see the results.</span></span> <span data-ttu-id="c853a-154">Sie bauen eine Knotenstruktur auf, die den Code darstellt.</span><span class="sxs-lookup"><span data-stu-id="c853a-154">You're building a tree of nodes that represents code.</span></span> <span data-ttu-id="c853a-155">Sie werden dieses Muster fortsetzen, um das <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>-Element für den `System.Collections.Generic`-Namespace zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="c853a-155">You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`.</span></span> <span data-ttu-id="c853a-156">Fügen Sie den folgenden Code zu `Program.cs` hinzu:</span><span class="sxs-lookup"><span data-stu-id="c853a-156">Add the following code to `Program.cs`:</span></span>

[!code-csharp[create the full identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace "Build the System.Collections.Generic identifier")]

<span data-ttu-id="c853a-157">Starten Sie das Programm erneut, um zu sehen, dass Sie die Struktur für den hinzuzufügenden Code erstellt haben.</span><span class="sxs-lookup"><span data-stu-id="c853a-157">Run the program again to see that you've built the tree for the code to add.</span></span>

### <a name="create-a-modified-tree"></a><span data-ttu-id="c853a-158">Erstellen einer geänderten Struktur</span><span class="sxs-lookup"><span data-stu-id="c853a-158">Create a modified tree</span></span>

<span data-ttu-id="c853a-159">Sie haben eine kleine Syntaxstruktur aufgebaut, die eine Anweisung enthält.</span><span class="sxs-lookup"><span data-stu-id="c853a-159">You've built a small syntax tree that contains one statement.</span></span> <span data-ttu-id="c853a-160">Die APIs zum Erstellen neuer Knoten sind die richtige Wahl, um einzelne Anweisungen oder andere kleine Codeblöcke zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="c853a-160">The APIs to create new nodes are the right choice to create single statements or other small code blocks.</span></span> <span data-ttu-id="c853a-161">Um jedoch größere Codeblöcke zu erstellen, sollten Sie Methoden verwenden, die Knoten ersetzen oder Knoten in eine bestehende Struktur einfügen.</span><span class="sxs-lookup"><span data-stu-id="c853a-161">However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.</span></span> <span data-ttu-id="c853a-162">Denken Sie daran, dass Syntaxstrukturen unveränderlich sind.</span><span class="sxs-lookup"><span data-stu-id="c853a-162">Remember that syntax trees are immutable.</span></span> <span data-ttu-id="c853a-163">Die **Syntax-API** bietet keinen Mechanismus, um eine bestehende Syntaxstruktur nach deren Aufbau zu ändern.</span><span class="sxs-lookup"><span data-stu-id="c853a-163">The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction.</span></span> <span data-ttu-id="c853a-164">Stattdessen stellt sie Methoden zur Verfügung, die neue Strukturen auf der Grundlage von Änderungen an bestehenden Strukturen erzeugen.</span><span class="sxs-lookup"><span data-stu-id="c853a-164">Instead, it provides methods that produce new trees based on changes to existing ones.</span></span> <span data-ttu-id="c853a-165">`With*`-Methoden werden in konkreten Klassen definiert, die von <xref:Microsoft.CodeAnalysis.SyntaxNode> abgeleitet sind, oder in Erweiterungsmethoden, die in der Klasse <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> deklariert sind.</span><span class="sxs-lookup"><span data-stu-id="c853a-165">`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class.</span></span> <span data-ttu-id="c853a-166">Diese Methoden erstellen einen neuen Knoten, indem sie Änderungen an den untergeordneten Eigenschaften eines vorhandenen Knotens vornehmen.</span><span class="sxs-lookup"><span data-stu-id="c853a-166">These methods create a new node by applying changes to an existing node's child properties.</span></span> <span data-ttu-id="c853a-167">Zusätzlich kann die <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A>-Erweiterungsmethode verwendet werden, um einen untergeordneten Knoten in einer Teilstruktur zu ersetzen.</span><span class="sxs-lookup"><span data-stu-id="c853a-167">Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree.</span></span> <span data-ttu-id="c853a-168">Diese Methode aktualisiert auch das übergeordnete Element, sodass dieses auf das neu erstellte untergeordnete Element zeigt. Die Methode wiederholt diesen Prozess für die gesamte Struktur – dies ist auch als _Umlaufen_ der Struktur bekannt.</span><span class="sxs-lookup"><span data-stu-id="c853a-168">This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spinning_ the tree.</span></span>

<span data-ttu-id="c853a-169">Der nächste Schritt besteht darin, eine Struktur zu erstellen, die ein ganzes (kleines) Programm darstellt, und diese dann zu ändern.</span><span class="sxs-lookup"><span data-stu-id="c853a-169">The next step is to create a tree that represents an entire (small) program and then modify it.</span></span> <span data-ttu-id="c853a-170">Fügen Sie den folgenden Code am Anfang der `Program`-Klasse hinzu:</span><span class="sxs-lookup"><span data-stu-id="c853a-170">Add the following code to the beginning of the `Program` class:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode "Create a tree that represents a small program")]

> [!NOTE]
> <span data-ttu-id="c853a-171">Der Beispielcode verwendet den `System.Collections`-Namespace und nicht den `System.Collections.Generic`-Namespace.</span><span class="sxs-lookup"><span data-stu-id="c853a-171">The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="c853a-172">Als Nächstes fügen Sie den folgenden Code am Ende der `Main`-Methode hinzu, um den Text zu analysieren und eine Struktur zu erstellen:</span><span class="sxs-lookup"><span data-stu-id="c853a-172">Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree "Create a tree that represents a small program")]

<span data-ttu-id="c853a-173">In diesem Beispiel wird die <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType>-Methode verwendet, um den Namen in einem <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax>-Knoten durch den im vorangehenden Code konstruierten zu ersetzen.</span><span class="sxs-lookup"><span data-stu-id="c853a-173">This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.</span></span>

<span data-ttu-id="c853a-174">Erstellen Sie einen neuen <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax>-Knoten mit der <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)>-Methode, um den `System.Collections`-Namen mit dem Namen zu aktualisieren, den Sie im vorangehenden Code erstellt haben.</span><span class="sxs-lookup"><span data-stu-id="c853a-174">Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code.</span></span> <span data-ttu-id="c853a-175">Fügen Sie den folgenden Code am Ende der `Main`-Methode hinzu:</span><span class="sxs-lookup"><span data-stu-id="c853a-175">Add the following code to the bottom of the `Main` method:</span></span>

[!code-csharp[create a new subtree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing "Create the subtree with the replaced namespace")]

<span data-ttu-id="c853a-176">Starten Sie das Programm, und schauen Sie sich die Ausgabe genau an.</span><span class="sxs-lookup"><span data-stu-id="c853a-176">Run the program and look carefully at the output.</span></span> <span data-ttu-id="c853a-177">Das `newusing`-Element wurde nicht in der Stammstruktur platziert.</span><span class="sxs-lookup"><span data-stu-id="c853a-177">The `newusing` hasn't been placed in the root tree.</span></span> <span data-ttu-id="c853a-178">Die ursprüngliche Struktur wurde nicht geändert.</span><span class="sxs-lookup"><span data-stu-id="c853a-178">The original tree hasn't been changed.</span></span>

<span data-ttu-id="c853a-179">Fügen Sie den folgenden Code mit der <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A>-Erweiterungsmethode hinzu, um eine neuen Struktur zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="c853a-179">Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree.</span></span> <span data-ttu-id="c853a-180">Die neue Struktur hat sich durch das Ersetzen des bestehenden Imports durch den aktualisierten `newUsing`-Knoten ergeben.</span><span class="sxs-lookup"><span data-stu-id="c853a-180">The new tree is the result of replacing the existing import with the updated `newUsing` node.</span></span> <span data-ttu-id="c853a-181">Sie weisen diese neue Struktur der vorhandenen `root`-Variablen zu:</span><span class="sxs-lookup"><span data-stu-id="c853a-181">You assign this new tree to the existing `root` variable:</span></span>

[!code-csharp[create a new root tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree "Create the transformed root tree with the replaced namespace")]

<span data-ttu-id="c853a-182">Führen Sie das Programm erneut aus.</span><span class="sxs-lookup"><span data-stu-id="c853a-182">Run the program again.</span></span> <span data-ttu-id="c853a-183">Diesmal wird der `System.Collections.Generic`-Namespace korrekt in die Struktur importiert.</span><span class="sxs-lookup"><span data-stu-id="c853a-183">This time the tree now correctly imports the `System.Collections.Generic` namespace.</span></span>

### <a name="transform-trees-using-syntaxrewriters"></a><span data-ttu-id="c853a-184">Transformieren von Strukturen mit `SyntaxRewriters`</span><span class="sxs-lookup"><span data-stu-id="c853a-184">Transform trees using `SyntaxRewriters`</span></span>

<span data-ttu-id="c853a-185">Die Methoden `With*` und <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> bieten komfortable Möglichkeiten, einzelne Branches einer Syntaxstruktur zu transformieren.</span><span class="sxs-lookup"><span data-stu-id="c853a-185">The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree.</span></span> <span data-ttu-id="c853a-186">Die <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType>-Klasse führt mehrere Transformationen in einer Syntaxstruktur durch.</span><span class="sxs-lookup"><span data-stu-id="c853a-186">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree.</span></span> <span data-ttu-id="c853a-187">Bei der <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType>-Klasse handelt es sich um eine Unterklasse von <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c853a-187">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c853a-188">Der <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> wendet eine Transformation auf einen bestimmten Typ von <xref:Microsoft.CodeAnalysis.SyntaxNode> an.</span><span class="sxs-lookup"><span data-stu-id="c853a-188">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span></span> <span data-ttu-id="c853a-189">Sie können Transformationen auf mehrere Typen von <xref:Microsoft.CodeAnalysis.SyntaxNode>-Objekten anwenden, unabhängig von deren Stelle in der Syntaxstruktur.</span><span class="sxs-lookup"><span data-stu-id="c853a-189">You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree.</span></span> <span data-ttu-id="c853a-190">Beim zweiten Projekt in diesem Schnellstart erstellen Sie ein Kommandozeilenrefactoring, das explizite Typen in lokalen Variablendeklarationen überall dort entfernt, wo Typrückschlüsse verwendet werden könnten.</span><span class="sxs-lookup"><span data-stu-id="c853a-190">The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.</span></span>

<span data-ttu-id="c853a-191">Erstellen Sie ein neues C#-Projekt namens **Stand-Alone Code Analysis Tool**.</span><span class="sxs-lookup"><span data-stu-id="c853a-191">Create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="c853a-192">Klicken Sie in Visual Studio mit der rechten Maustaste auf den Lösungsknoten `SyntaxTransformationQuickStart`.</span><span class="sxs-lookup"><span data-stu-id="c853a-192">In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node.</span></span> <span data-ttu-id="c853a-193">Wählen Sie **Hinzufügen** > **Neues Projekt**, um das Dialogfeld **Neues Projekt** anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="c853a-193">Choose **Add** > **New Project** to display the **New Project dialog**.</span></span> <span data-ttu-id="c853a-194">Wählen Sie unter **Visual C#**  > **Erweiterbarkeit** die Option **Stand-Alone Code Analysis Tool** aus.</span><span class="sxs-lookup"><span data-stu-id="c853a-194">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="c853a-195">Nennen Sie Ihr Projekt `TransformationCS`, und klicken Sie auf „OK“.</span><span class="sxs-lookup"><span data-stu-id="c853a-195">Name your project `TransformationCS` and click OK.</span></span>

<span data-ttu-id="c853a-196">Der erste Schritt besteht in der Erstellung einer Klasse, die von <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> abgeleitet ist, um Ihre Transformationen durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="c853a-196">The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations.</span></span> <span data-ttu-id="c853a-197">Fügen Sie zum Projekt eine neue Klassendatei hinzu.</span><span class="sxs-lookup"><span data-stu-id="c853a-197">Add a new class file to the project.</span></span> <span data-ttu-id="c853a-198">Wählen Sie in Visual Studio **Projekt** > **Klasse hinzufügen...** aus. Geben Sie im Dialogfeld **Neues Element hinzufügen**`TypeInferenceRewriter.cs` als Dateinamen ein.</span><span class="sxs-lookup"><span data-stu-id="c853a-198">In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.</span></span>

<span data-ttu-id="c853a-199">Fügen Sie der Datei `TypeInferenceRewriter.cs` die folgenden using-Anweisungen hinzu:</span><span class="sxs-lookup"><span data-stu-id="c853a-199">Add the following using directives to the `TypeInferenceRewriter.cs` file:</span></span>

[!code-csharp[add necessary usings](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings "Add required usings")]

<span data-ttu-id="c853a-200">Als Nächstes nutzen Sie die `TypeInferenceRewriter`-Klasse zur Erweiterung der <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter>-Klasse:</span><span class="sxs-lookup"><span data-stu-id="c853a-200">Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:</span></span>

[!code-csharp[add base class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass "Add base class")]

<span data-ttu-id="c853a-201">Fügen Sie den folgenden Code hinzu, um ein privates schreibgeschütztes Feld mit einem <xref:Microsoft.CodeAnalysis.SemanticModel>-Element zu deklarieren, und initialisieren Sie es im Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="c853a-201">Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor.</span></span> <span data-ttu-id="c853a-202">Sie werden dieses Feld später benötigen, um zu bestimmen, wo ein Typrückschluss verwendet werden kann:</span><span class="sxs-lookup"><span data-stu-id="c853a-202">You will need this field later on to determine where type inference can be used:</span></span>

[!code-csharp[initialize members](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction "Declare and initialize member variables")]

<span data-ttu-id="c853a-203">Überschreiben Sie die <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)>-Methode:</span><span class="sxs-lookup"><span data-stu-id="c853a-203">Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:</span></span>

```csharp
public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{

}
```

> [!NOTE]
> <span data-ttu-id="c853a-204">Viele der Roslyn-APIs deklarieren Rückgabetypen, die Basisklassen der tatsächlich zurückgegebenen Runtimetypen sind.</span><span class="sxs-lookup"><span data-stu-id="c853a-204">Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.</span></span> <span data-ttu-id="c853a-205">In vielen Szenarien kann eine Art von Knoten vollständig durch eine andere Art von Knoten ersetzt werden. Manchmal ist es sogar möglich, eine Art von Knoten zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="c853a-205">In many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.</span></span> <span data-ttu-id="c853a-206">In diesem Beispiel gibt die <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)>-Methode, anstelle des abgeleiteten Typs von <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>, ein <xref:Microsoft.CodeAnalysis.SyntaxNode>-Element zurück.</span><span class="sxs-lookup"><span data-stu-id="c853a-206">In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span></span> <span data-ttu-id="c853a-207">Dieser Rewriter gibt einen neuen <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>-Knoten zurück, der auf dem vorhandenen Knoten basiert.</span><span class="sxs-lookup"><span data-stu-id="c853a-207">This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.</span></span>

<span data-ttu-id="c853a-208">In diesem Schnellstart werden lokale Variablendeklarationen behandelt.</span><span class="sxs-lookup"><span data-stu-id="c853a-208">This quickstart handles local variable declarations.</span></span> <span data-ttu-id="c853a-209">Die diesbezüglichen Informationen können Sie auch für andere Deklarationen wie `foreach`-Schleifen, `for`-Schleifen, LINQ-Ausdrücke und Lambdaausdrücke nutzen.</span><span class="sxs-lookup"><span data-stu-id="c853a-209">You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions.</span></span> <span data-ttu-id="c853a-210">Außerdem transformiert der hier gezeigte Rewriter nur Deklarationen der einfachsten Form:</span><span class="sxs-lookup"><span data-stu-id="c853a-210">Furthermore this rewriter will only transform declarations of the simplest form:</span></span>

```csharp
Type variable = expression;
```

<span data-ttu-id="c853a-211">Wenn Sie selbst die verschiedenen Möglichkeiten erkunden möchten, ist es empfehlenswert, das fertig gestellte Beispiel für diese Typen von Variablendeklarationen einfach zu erweitern:</span><span class="sxs-lookup"><span data-stu-id="c853a-211">If you want to explore on your own, consider extending the finished sample for these types of variable declarations:</span></span>

```csharp
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
```

<span data-ttu-id="c853a-212">Fügen Sie den folgenden Code zum Text der `VisitLocalDeclarationStatement`-Methode hinzu, um das Umschreiben dieser Deklarationsformen zu überspringen:</span><span class="sxs-lookup"><span data-stu-id="c853a-212">Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:</span></span>

[!code-csharp[exclude other declarations](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions "Exclude variables declarations not processed by this sample")]

<span data-ttu-id="c853a-213">Die Methode gibt an, dass kein Umschreiben stattfindet, indem der Parameter `node` unverändert zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="c853a-213">The method indicates that no rewriting takes place by returning the `node` parameter unmodified.</span></span> <span data-ttu-id="c853a-214">Wenn keiner dieser `if`-Ausdrücke „TRUE“ ist, stellt der Knoten eine mögliche Deklaration mit Initialisierung dar.</span><span class="sxs-lookup"><span data-stu-id="c853a-214">If neither of those `if` expressions are true, the node represents a possible declaration with initialization.</span></span> <span data-ttu-id="c853a-215">Fügen Sie diese Anweisungen hinzu, um den in der Deklaration angegebenen Typnamen zu extrahieren, und binden Sie ihn mit dem <xref:Microsoft.CodeAnalysis.SemanticModel>-Feld, um ein Typsymbol zu erhalten:</span><span class="sxs-lookup"><span data-stu-id="c853a-215">Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:</span></span>

[!code-csharp[extract type name](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol "Extract the type name specified by the declaration")]

<span data-ttu-id="c853a-216">Fügen Sie nun diese Anweisung hinzu, um den Initialisierungsausdruck zu binden:</span><span class="sxs-lookup"><span data-stu-id="c853a-216">Now, add this statement to bind the initializer expression:</span></span>

[!code-csharp[bind initializer](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Bind the initializer expressions")]

<span data-ttu-id="c853a-217">Abschließend fügen Sie die folgende `if`-Anweisung hinzu, um den vorhandenen Typnamen durch das Schlüsselwort `var` zu ersetzen, wenn der Typ des Initialisierungsausdrucks dem angegebenen Typ entspricht:</span><span class="sxs-lookup"><span data-stu-id="c853a-217">Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:</span></span>

[!code-csharp[ReplaceNode](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ReplaceNode "Replace the initializer node")]

<span data-ttu-id="c853a-218">Die Bedingung ist erforderlich, da die Deklaration den Initialisierungsausdruck in eine Basisklasse oder eine Schnittstelle umwandeln kann.</span><span class="sxs-lookup"><span data-stu-id="c853a-218">The conditional is required because the declaration may cast the initializer expression to a base class or interface.</span></span> <span data-ttu-id="c853a-219">Wenn das gewünscht wird, stimmen die Typen auf der linken und rechten Seite der Zuweisung nicht überein.</span><span class="sxs-lookup"><span data-stu-id="c853a-219">If that's desired, the types on the left and right-hand side of the assignment don't match.</span></span> <span data-ttu-id="c853a-220">Das Entfernen des expliziten Typs würde in diesen Fällen die Semantik eines Programms verändern.</span><span class="sxs-lookup"><span data-stu-id="c853a-220">Removing the explicit type in these cases would change the semantics of a program.</span></span> <span data-ttu-id="c853a-221">`var` wird als Bezeichner und nicht als Schlüsselwort angegeben, da `var` ein kontextbezogenes Schlüsselwort ist.</span><span class="sxs-lookup"><span data-stu-id="c853a-221">`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword.</span></span> <span data-ttu-id="c853a-222">Die führenden und nachgestellten Trivia (Leerzeichen) werden vom alten Typnamen in das Schlüsselwort `var` übertragen, um vertikale Leerzeichen und Einrückungen beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="c853a-222">The leading and trailing trivia (white space) are transferred from the old type name to the `var` keyword to maintain vertical white space and indentation.</span></span> <span data-ttu-id="c853a-223">Es ist einfacher, `ReplaceNode` anstelle von `With*` für die Transformation der <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> zu verwenden, da der Typname eigentlich ein untergeordnetes Element der zweiten Ebene der Deklarationsanweisung ist.</span><span class="sxs-lookup"><span data-stu-id="c853a-223">It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.</span></span>

<span data-ttu-id="c853a-224">Sie haben den `TypeInferenceRewriter` abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="c853a-224">You've finished the `TypeInferenceRewriter`.</span></span> <span data-ttu-id="c853a-225">Kehren Sie nun zu Ihrer `Program.cs`-Datei zurück, um das Beispiel fertig zu stellen.</span><span class="sxs-lookup"><span data-stu-id="c853a-225">Now return to your `Program.cs` file to finish the example.</span></span> <span data-ttu-id="c853a-226">Erstellen Sie einen <xref:Microsoft.CodeAnalysis.Compilation>-Test, und rufen Sie daraus das <xref:Microsoft.CodeAnalysis.SemanticModel> ab.</span><span class="sxs-lookup"><span data-stu-id="c853a-226">Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it.</span></span> <span data-ttu-id="c853a-227">Verwenden Sie dieses <xref:Microsoft.CodeAnalysis.SemanticModel>, um Ihren `TypeInferenceRewriter` auszuprobieren.</span><span class="sxs-lookup"><span data-stu-id="c853a-227">Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`.</span></span> <span data-ttu-id="c853a-228">Diesen Schritt führen Sie zuletzt aus.</span><span class="sxs-lookup"><span data-stu-id="c853a-228">You'll do this step last.</span></span> <span data-ttu-id="c853a-229">In der Zwischenzeit deklarieren Sie eine Platzhaltervariable, die Ihre Testkompilierung repräsentiert:</span><span class="sxs-lookup"><span data-stu-id="c853a-229">In the meantime declare a placeholder variable representing your test compilation:</span></span>

[!code-csharp[DeclareCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation "Declare the test compilation")]

<span data-ttu-id="c853a-230">Nach einer kurzen Unterbrechung sollten Sie eine Wellenlinie für einen Fehler sehen, die darauf hinweist, dass die `CreateTestCompilation`-Methode nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="c853a-230">After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists.</span></span> <span data-ttu-id="c853a-231">Drücken Sie **Strg+Punkt**, um die Glühbirnenmeldung zu öffnen, und drücken Sie dann die EINGABETASTE, um den Befehl **Methodenstub generieren** aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="c853a-231">Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command.</span></span> <span data-ttu-id="c853a-232">Dieser Befehl erzeugt einen Methodenstub für die `CreateTestCompilation`-Methode in der `Program`-Klasse.</span><span class="sxs-lookup"><span data-stu-id="c853a-232">This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class.</span></span> <span data-ttu-id="c853a-233">Sie werden diese Methode zu einem späteren Zeitpunkt ausfüllen:</span><span class="sxs-lookup"><span data-stu-id="c853a-233">You'll come back to fill in this method later:</span></span>

![Generieren einer Methode aus der Verwendung in C#](./media/syntax-transformation/generate-from-usage.png)

<span data-ttu-id="c853a-235">Schreiben Sie den folgenden Code, um jede <xref:Microsoft.CodeAnalysis.SyntaxTree>-Klasse im <xref:Microsoft.CodeAnalysis.Compilation>-Test zu durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="c853a-235">Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="c853a-236">Initialisieren Sie für jeden einen neuen `TypeInferenceRewriter` mit dem <xref:Microsoft.CodeAnalysis.SemanticModel> für diese Struktur:</span><span class="sxs-lookup"><span data-stu-id="c853a-236">For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:</span></span>

[!code-csharp[IterateTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees "Iterate all the source trees in the test compilation")]

<span data-ttu-id="c853a-237">Fügen Sie innerhalb der von Ihnen erstellten `foreach`-Anweisung den folgenden Code hinzu, um die Transformation für jede Quellstruktur durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="c853a-237">Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree.</span></span> <span data-ttu-id="c853a-238">Dieser Code schreibt die neu transformierte Struktur bedingt aus, falls Änderungen vorgenommen wurden.</span><span class="sxs-lookup"><span data-stu-id="c853a-238">This code conditionally writes out the new transformed tree if any edits were made.</span></span> <span data-ttu-id="c853a-239">Ihr Rewriter sollte eine Struktur nur dann ändern, wenn er auf eine oder mehrere lokale Variablendeklarationen stößt, die durch einen Typrückschluss vereinfacht werden könnten:</span><span class="sxs-lookup"><span data-stu-id="c853a-239">Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:</span></span>

[!code-csharp[TransformTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees "Transform and save any trees that are modified by the rewriter")]

<span data-ttu-id="c853a-240">Der Code `File.WriteAllText` sollte mit einer Wellenlinie unterstrichen sein.</span><span class="sxs-lookup"><span data-stu-id="c853a-240">You should see squiggles under the `File.WriteAllText` code.</span></span> <span data-ttu-id="c853a-241">Wählen Sie die Glühbirne aus, und fügen Sie die erforderliche `using System.IO;`-Anweisung hinzu.</span><span class="sxs-lookup"><span data-stu-id="c853a-241">Select the light bulb, and add the necessary `using System.IO;` statement.</span></span>

<span data-ttu-id="c853a-242">Sie haben es fast geschafft!</span><span class="sxs-lookup"><span data-stu-id="c853a-242">You're almost done!</span></span> <span data-ttu-id="c853a-243">Es gibt noch einen Schritt: das Erstellen eines <xref:Microsoft.CodeAnalysis.Compilation>-Tests.</span><span class="sxs-lookup"><span data-stu-id="c853a-243">There's one step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="c853a-244">Da Sie bei diesem Schnellstart überhaupt keinen Typrückschluss verwendet haben, wäre das ein perfekter Testfall gewesen.</span><span class="sxs-lookup"><span data-stu-id="c853a-244">Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.</span></span> <span data-ttu-id="c853a-245">Leider würde das Erstellen einer Kompilierung aus einer C#-Projektdatei außerhalb des Rahmens dieser exemplarischen Vorgehensweise liegen.</span><span class="sxs-lookup"><span data-stu-id="c853a-245">Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.</span></span> <span data-ttu-id="c853a-246">Aber glücklicherweise gibt es, wenn Sie die Anweisungen genau befolgt haben, auch eine gute Nachricht.</span><span class="sxs-lookup"><span data-stu-id="c853a-246">But fortunately, if you've been following instructions carefully, there's hope.</span></span> <span data-ttu-id="c853a-247">Ersetzen Sie den Inhalt der `CreateTestCompilation`-Methode durch folgenden Code.</span><span class="sxs-lookup"><span data-stu-id="c853a-247">Replace the contents of the `CreateTestCompilation` method with the following code.</span></span> <span data-ttu-id="c853a-248">Es wird eine Testkompilierung erstellt, die zufällig mit dem in diesem Schnellstart beschriebenen Projekt übereinstimmt:</span><span class="sxs-lookup"><span data-stu-id="c853a-248">It creates a test compilation that coincidentally matches the project described in this quickstart:</span></span>

[!code-csharp[CreateTestCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation "Create a test compilation using the code written for this quickstart.")]

<span data-ttu-id="c853a-249">Drücken Sie die Daumen, und führen Sie das Projekt aus.</span><span class="sxs-lookup"><span data-stu-id="c853a-249">Cross your fingers and run the project.</span></span> <span data-ttu-id="c853a-250">Wählen Sie in Visual Studio **Debuggen** > **Debugging starten**.</span><span class="sxs-lookup"><span data-stu-id="c853a-250">In Visual Studio, choose **Debug** > **Start Debugging**.</span></span> <span data-ttu-id="c853a-251">Visual Studio informiert Sie darüber, dass sich die Dateien in Ihrem Projekt geändert haben.</span><span class="sxs-lookup"><span data-stu-id="c853a-251">You should be prompted by Visual Studio that the files in your project have changed.</span></span> <span data-ttu-id="c853a-252">Klicken Sie auf „**Ja, alle**“, um die geänderten Dateien neu zu laden.</span><span class="sxs-lookup"><span data-stu-id="c853a-252">Click "**Yes to All**" to reload the modified files.</span></span> <span data-ttu-id="c853a-253">Schauen Sie sich Ihr Werk etwas genauer an.</span><span class="sxs-lookup"><span data-stu-id="c853a-253">Examine them to observe your awesomeness.</span></span> <span data-ttu-id="c853a-254">Beachten Sie, wie viel sauberer der Code ohne all diese expliziten und redundanten Typspezifizierer aussieht.</span><span class="sxs-lookup"><span data-stu-id="c853a-254">Note how much cleaner the code looks without all those explicit and redundant type specifiers.</span></span>

<span data-ttu-id="c853a-255">Herzlichen Glückwunsch!</span><span class="sxs-lookup"><span data-stu-id="c853a-255">Congratulations!</span></span> <span data-ttu-id="c853a-256">Sie haben die **Compiler-APIs** verwendet, um Ihr eigenes Refactoring zu schreiben, das alle Dateien in einem C#-Projekt nach bestimmten syntaktischen Mustern durchsucht, die Semantik des Quellcodes in Übereinstimmung mit diesen Mustern analysiert und diese transformiert.</span><span class="sxs-lookup"><span data-stu-id="c853a-256">You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.</span></span> <span data-ttu-id="c853a-257">Sie sind jetzt offiziell Refactoringautor!</span><span class="sxs-lookup"><span data-stu-id="c853a-257">You're now officially a refactoring author!</span></span>
