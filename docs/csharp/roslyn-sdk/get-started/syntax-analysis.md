---
title: Erste Schritte mit der Syntaxanalyse (Roslyn-APIs)
description: Eine Einführung in das Durchlaufen, Abfragen und schrittweise Durchlaufen von Syntaxstrukturen.
ms.date: 02/05/2018
ms.custom: mvc
ms.openlocfilehash: 8b9dd909a83877755dc1ebafd58aae892e460b93
ms.sourcegitcommit: a8a205034eeffc7c3e1bdd6f506a75b0f7099ebf
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 10/06/2020
ms.locfileid: "91756155"
---
# <a name="get-started-with-syntax-analysis"></a><span data-ttu-id="0cda3-103">Erste Schritte mit der Syntaxanalyse</span><span class="sxs-lookup"><span data-stu-id="0cda3-103">Get started with syntax analysis</span></span>

<span data-ttu-id="0cda3-104">In diesem Tutorial lernen Sie die **Syntax-API** kennen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-104">In this tutorial, you'll explore the **Syntax API**.</span></span> <span data-ttu-id="0cda3-105">Die Syntax-API bietet Zugriff auf die Datenstrukturen, die ein C#- oder Visual Basic-Programm beschreiben.</span><span class="sxs-lookup"><span data-stu-id="0cda3-105">The Syntax API provides access to the data structures that describe a C# or Visual Basic program.</span></span> <span data-ttu-id="0cda3-106">Diese Datenstrukturen sind so detailliert, dass sie ein Programm jeder Größe vollständig darstellen können.</span><span class="sxs-lookup"><span data-stu-id="0cda3-106">These data structures have enough detail that they can fully represent any program of any size.</span></span> <span data-ttu-id="0cda3-107">Diese Strukturen können komplette Programme beschreiben, die sich fehlerfrei kompilieren und ausführen lassen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-107">These structures can describe complete programs that compile and run correctly.</span></span> <span data-ttu-id="0cda3-108">Sie können auch unvollständige Programme beschreiben, während Sie diese im Editor schreiben.</span><span class="sxs-lookup"><span data-stu-id="0cda3-108">They can also describe incomplete programs, as you write them, in the editor.</span></span>

<span data-ttu-id="0cda3-109">Um diese umfangreiche Ausdrucksmöglichkeit zu unterstützen, müssen die Datenstrukturen und APIs, aus denen die Syntax-API besteht, notwendigerweise komplex sein.</span><span class="sxs-lookup"><span data-stu-id="0cda3-109">To enable this rich expression, the data structures and APIs that make up the Syntax API are necessarily complex.</span></span> <span data-ttu-id="0cda3-110">Als Einstieg sehen wir uns die Datenstruktur für ein typisches Hello World-Programm an:</span><span class="sxs-lookup"><span data-stu-id="0cda3-110">Let's start with what the data structure looks like for the typical "Hello World" program:</span></span>

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="0cda3-111">Sehen Sie sich den Text des oben stehenden Programms an.</span><span class="sxs-lookup"><span data-stu-id="0cda3-111">Look at the text of the previous program.</span></span> <span data-ttu-id="0cda3-112">Sie werden bekannte Elemente erkennen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-112">You recognize familiar elements.</span></span> <span data-ttu-id="0cda3-113">Der gesamte Text repräsentiert eine einzelne Quelldatei, eine **Kompilierungseinheit**.</span><span class="sxs-lookup"><span data-stu-id="0cda3-113">The entire text represents a single source file, or a **compilation unit**.</span></span> <span data-ttu-id="0cda3-114">Die ersten drei Zeilen dieser Quelldatei sind **using-Direktiven**.</span><span class="sxs-lookup"><span data-stu-id="0cda3-114">The first three lines of that source file are **using directives**.</span></span> <span data-ttu-id="0cda3-115">Der Rest der Quelle ist in einer **Namespacedeklaration** enthalten.</span><span class="sxs-lookup"><span data-stu-id="0cda3-115">The remaining source is contained in a **namespace declaration**.</span></span> <span data-ttu-id="0cda3-116">Die Namespacedeklaration enthält eine untergeordnete **Klassendeklaration**.</span><span class="sxs-lookup"><span data-stu-id="0cda3-116">The namespace declaration contains a child **class declaration**.</span></span> <span data-ttu-id="0cda3-117">Die Klassendeklaration enthält eine **Methodendeklaration**.</span><span class="sxs-lookup"><span data-stu-id="0cda3-117">The class declaration contains one **method declaration**.</span></span>

<span data-ttu-id="0cda3-118">Die Syntax-API erstellt eine Baumstruktur, deren Stamm die Kompilierungseinheit repräsentiert.</span><span class="sxs-lookup"><span data-stu-id="0cda3-118">The Syntax API creates a tree structure with the root representing the compilation unit.</span></span> <span data-ttu-id="0cda3-119">Knoten in der Struktur repräsentieren die using-Direktiven, die Namespacedeklaration und alle anderen Elemente des Programms.</span><span class="sxs-lookup"><span data-stu-id="0cda3-119">Nodes in the tree represent the using directives, namespace declaration and all the other elements of the program.</span></span> <span data-ttu-id="0cda3-120">Die Baumstruktur setzt sich bis zur untersten Ebene fort: Die Zeichenfolge „Hello World!“</span><span class="sxs-lookup"><span data-stu-id="0cda3-120">The tree structure continues down to the lowest levels: the string "Hello World!"</span></span> <span data-ttu-id="0cda3-121">ist ein **Token für ein Zeichenfolgenliteral**, das eine Ableitung eines **Arguments** ist.</span><span class="sxs-lookup"><span data-stu-id="0cda3-121">is a **string literal token** that is a descendent of an **argument**.</span></span> <span data-ttu-id="0cda3-122">Die Syntax-API bietet Zugriff auf die Struktur des Programms.</span><span class="sxs-lookup"><span data-stu-id="0cda3-122">The Syntax API provides access to the structure of the program.</span></span> <span data-ttu-id="0cda3-123">Sie können Abfragen nach bestimmten Codemethoden erstellen, die gesamte Struktur schrittweise durchlaufen, um den Code zu verstehen und durch Modifizieren der vorhandenen Struktur neue Strukturen erstellen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-123">You can query for specific code practices, walk the entire tree to understand the code, and create new trees by modifying the existing tree.</span></span>

<span data-ttu-id="0cda3-124">Diese kurze Beschreibung bietet einen Überblick über die Art der Informationen, auf die Sie mithilfe der Syntax-API zugreifen können.</span><span class="sxs-lookup"><span data-stu-id="0cda3-124">That brief description provides an overview of the kind of information accessible using the Syntax API.</span></span> <span data-ttu-id="0cda3-125">Die Syntax-API ist nichts anderes als eine formale API, die die vertrauten Codekonstrukte beschreibt, die Sie aus C# kennen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-125">The Syntax API is nothing more than a formal API that describes the familiar code constructs you know from C#.</span></span> <span data-ttu-id="0cda3-126">Sie bietet Informationen zur Formatierung des Codes, z.B. zu Zeilenumbrüchen, Leerräumen und Einzügen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-126">The full capabilities include information about how the code is formatted including line breaks, white space, and indenting.</span></span> <span data-ttu-id="0cda3-127">Mit diesen Informationen können Sie den Code genau so darstellen, wie er von Programmierern oder dem Compiler geschrieben und gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="0cda3-127">Using this information, you can fully represent the code as written and read by human programmers or the compiler.</span></span> <span data-ttu-id="0cda3-128">Dank dieser Struktur gewinnt der Quellcode eine ganz neue Bedeutungsebene, auf der Sie interagieren können.</span><span class="sxs-lookup"><span data-stu-id="0cda3-128">Using this structure enables you to interact with the source code on a deeply meaningful level.</span></span> <span data-ttu-id="0cda3-129">Sie sehen nicht nur Zeichenfolgen, sondern Daten, die die Struktur eines C#-Programms repräsentieren.</span><span class="sxs-lookup"><span data-stu-id="0cda3-129">It's no longer text strings, but data that represents the structure of a C# program.</span></span>

<span data-ttu-id="0cda3-130">Installieren Sie zunächst das **SDK für die .NET Compiler Platform**:</span><span class="sxs-lookup"><span data-stu-id="0cda3-130">To get started, you'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-syntax-trees"></a><span data-ttu-id="0cda3-131">Grundlegendes zu Syntaxstrukturen</span><span class="sxs-lookup"><span data-stu-id="0cda3-131">Understanding syntax trees</span></span>

<span data-ttu-id="0cda3-132">Verwenden Sie die Syntax-API zur Analyse der Struktur von C#-Code.</span><span class="sxs-lookup"><span data-stu-id="0cda3-132">You use the Syntax API for any analysis of the structure of C# code.</span></span> <span data-ttu-id="0cda3-133">Die **Syntax-API** stellt die Parser, die Syntaxstrukturen und die Hilfsprogramme zur Verfügung, die Sie zum Analysieren und Konstruieren von Syntaxstrukturen benötigen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-133">The **Syntax API** exposes the parsers, the syntax trees, and utilities for analyzing and constructing syntax trees.</span></span> <span data-ttu-id="0cda3-134">So können Sie im Code nach bestimmten Syntaxelementen suchen oder den Code für ein Programm lesen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-134">It's how you search code for specific syntax elements or read the code for a program.</span></span>

<span data-ttu-id="0cda3-135">Eine Syntaxstruktur ist eine Datenstruktur, die von den C#- und Visual Basic-Compilern verwendet wird, um C#- und Visual Basic-Programme zu verstehen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-135">A syntax tree is a data structure used by the C# and Visual Basic compilers to understand C# and Visual Basic programs.</span></span> <span data-ttu-id="0cda3-136">Syntaxstrukturen werden durch denselben Parser erzeugt, der ausgeführt wird, wenn ein Projekt erstellt wird oder ein Entwickler die Taste F5 drückt.</span><span class="sxs-lookup"><span data-stu-id="0cda3-136">Syntax trees are produced by the same parser that runs when a project is built or a developer hits F5.</span></span> <span data-ttu-id="0cda3-137">Die Syntaxstrukturen weisen vollständige Datentreue mit der Sprache auf; jedes Informationselement in einer Codedatei wird in der Struktur dargestellt.</span><span class="sxs-lookup"><span data-stu-id="0cda3-137">The syntax trees have full-fidelity with the language; every bit of information in a code file is represented in the tree.</span></span> <span data-ttu-id="0cda3-138">Das Schreiben einer Syntaxstruktur als Text reproduziert exakt den ursprünglichen Text, der analysiert wurde.</span><span class="sxs-lookup"><span data-stu-id="0cda3-138">Writing a syntax tree to text reproduces the exact original text that was parsed.</span></span> <span data-ttu-id="0cda3-139">Syntaxstrukturen sind zudem **unveränderlich** – nach dem Erstellen kann eine Syntaxstruktur nicht mehr geändert werden.</span><span class="sxs-lookup"><span data-stu-id="0cda3-139">The syntax trees are also **immutable**; once created a syntax tree can never be changed.</span></span> <span data-ttu-id="0cda3-140">Consumer der Strukturen können die Strukturen ohne Sperren oder andere Parallelitätsmaßnahmen in mehreren Threads analysieren, weil sie wissen, dass sich die Daten niemals ändern.</span><span class="sxs-lookup"><span data-stu-id="0cda3-140">Consumers of the trees can analyze the trees on multiple threads, without locks or other concurrency measures, knowing the data never changes.</span></span> <span data-ttu-id="0cda3-141">Sie können APIs verwenden, um neue Strukturen zu erstellen, die durch Modifizieren einer vorhandenen Struktur entstehen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-141">You can use APIs to create new trees that are the result of modifying an existing tree.</span></span>

<span data-ttu-id="0cda3-142">Syntaxstrukturen bestehen aus den folgenden vier primären Bausteinen:</span><span class="sxs-lookup"><span data-stu-id="0cda3-142">The four primary building blocks of syntax trees are:</span></span>

* <span data-ttu-id="0cda3-143">Die <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>-Klasse: Eine Instanz dieser Klasse repräsentiert eine vollständige Analysestruktur.</span><span class="sxs-lookup"><span data-stu-id="0cda3-143">The <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType> class, an instance of which represents an entire parse tree.</span></span> <span data-ttu-id="0cda3-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> ist eine abstrakte Klasse mit sprachspezifischen Ableitungen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> is an abstract class that has language-specific derivatives.</span></span> <span data-ttu-id="0cda3-145">Sie verwenden die Analysemethoden der Klasse <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (oder <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>), um Text in C# (oder Visual Basic) zu analysieren.</span><span class="sxs-lookup"><span data-stu-id="0cda3-145">You use the parse methods of the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) class to parse text in C# (or Visual Basic).</span></span>
* <span data-ttu-id="0cda3-146">Die <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>-Klasse: Instanzen dieser Klasse repräsentieren syntaktische Konstrukte wie Deklarationen, Anweisungen, Klauseln und Ausdrücke.</span><span class="sxs-lookup"><span data-stu-id="0cda3-146">The <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> class, instances of which represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span>
* <span data-ttu-id="0cda3-147">Die <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType>-Struktur: Diese Struktur repräsentiert ein einzelnes Schlüsselwort oder Interpunktionszeichen oder einen einzelnen Bezeichner oder Operator.</span><span class="sxs-lookup"><span data-stu-id="0cda3-147">The <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType> structure, which represents an individual keyword, identifier, operator, or punctuation.</span></span>
* <span data-ttu-id="0cda3-148">Die <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType>-Struktur: Diese Struktur repräsentiert syntaktisch unwichtige Informationen wie Leerräume zwischen Token, Vorverarbeitungsdirektiven und Kommentare.</span><span class="sxs-lookup"><span data-stu-id="0cda3-148">And lastly the <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> structure, which represents syntactically insignificant bits of information such as the white space between tokens, preprocessing directives, and comments.</span></span>

<span data-ttu-id="0cda3-149">Trivia, Token und Knoten werden hierarchisch zusammengestellt und bilden eine Struktur, die alle Elemente in einem Visual Basic- oder C#-Codefragment vollständig repräsentiert.</span><span class="sxs-lookup"><span data-stu-id="0cda3-149">Trivia, tokens, and nodes are composed hierarchically to form a tree that completely represents everything in a fragment of Visual Basic or C# code.</span></span> <span data-ttu-id="0cda3-150">Sie können diese Struktur im Fenster **Syntaxschnellansicht** anzeigen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-150">You can see this structure using the **Syntax Visualizer** window.</span></span> <span data-ttu-id="0cda3-151">Wählen Sie in Visual Studio **Ansicht** > **Weitere Fenster** > **Syntaxschnellansicht** aus.</span><span class="sxs-lookup"><span data-stu-id="0cda3-151">In Visual Studio, choose **View** > **Other Windows** > **Syntax Visualizer**.</span></span> <span data-ttu-id="0cda3-152">Die oben gezeigte C#-Quelldatei sieht in der **Syntaxschnellansicht** ungefähr wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="0cda3-152">For example, the preceding C# source file examined using the **Syntax Visualizer** looks like the following figure:</span></span>

<span data-ttu-id="0cda3-153">**SyntaxNode**: Blau | **SyntaxToken**: Grün | **SyntaxTrivia**: Rot ![C#-Codedatei](media/walkthrough-csharp-syntax-figure1.png)</span><span class="sxs-lookup"><span data-stu-id="0cda3-153">**SyntaxNode**: Blue | **SyntaxToken**: Green | **SyntaxTrivia**: Red ![C# Code File](media/walkthrough-csharp-syntax-figure1.png)</span></span>

<span data-ttu-id="0cda3-154">Durch Navigieren in dieser Struktur lässt sich jede Anweisung, jeder Ausdruck, jedes Token und jeder Leerraum in einer Codedatei auffinden.</span><span class="sxs-lookup"><span data-stu-id="0cda3-154">By navigating this tree structure, you can find any statement, expression, token, or bit of white space in a code file.</span></span>

<span data-ttu-id="0cda3-155">Sie können zwar in einer Codedatei mithilfe der Syntax-APIs alles finden, in den meisten Szenarien müssen Sie jedoch kleine Codeausschnitte untersuchen oder nach bestimmten Anweisungen oder Fragmenten suchen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-155">While you can find anything in a code file using the Syntax APIs, most scenarios involve examining small snippets of code, or searching for particular statements or fragments.</span></span> <span data-ttu-id="0cda3-156">Die beiden folgenden Beispiele zeigen typische Vorgehensweisen beim Durchsuchen der Codestruktur oder beim Suchen nach einzelnen Anweisungen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-156">The two examples that follow show typical uses to browse the structure of code, or search for single statements.</span></span>

## <a name="traversing-trees"></a><span data-ttu-id="0cda3-157">Durchlaufen von Strukturen</span><span class="sxs-lookup"><span data-stu-id="0cda3-157">Traversing trees</span></span>

<span data-ttu-id="0cda3-158">Sie können die Knoten in einer Syntaxstruktur auf zwei Arten untersuchen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-158">You can examine the nodes in a syntax tree in two ways.</span></span> <span data-ttu-id="0cda3-159">Sie können die Struktur durchlaufen und jeden einzelnen Knoten untersuchen oder Abfragen für bestimmte Elemente oder Knoten ausführen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-159">You can traverse the tree to examine each node, or you can query for specific elements or nodes.</span></span>

### <a name="manual-traversal"></a><span data-ttu-id="0cda3-160">Manuelles Durchlaufen</span><span class="sxs-lookup"><span data-stu-id="0cda3-160">Manual traversal</span></span>

<span data-ttu-id="0cda3-161">Den fertig gestellten Code für dieses Beispiel finden Sie in [unserem GitHub-Repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="0cda3-161">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="0cda3-162">Die Syntaxstrukturtypen verwenden Vererbung, um die verschiedenen Syntaxelemente zu beschreiben, die an verschiedenen Positionen im Programm gültig sind.</span><span class="sxs-lookup"><span data-stu-id="0cda3-162">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="0cda3-163">Bei der Verwendung dieser APIs müssen häufig Eigenschaften oder Sammlungsmember in bestimmte abgeleitete Typen umgewandelt werden.</span><span class="sxs-lookup"><span data-stu-id="0cda3-163">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="0cda3-164">In den folgenden Beispielen sind die Zuweisung und die Umwandlung separate Anweisungen, bei denen explizit typisierte Variablen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="0cda3-164">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="0cda3-165">Sie können den Code lesen, um die Rückgabetypen der API und den Laufzeittyp der zurückgegebenen Objekte zu sehen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-165">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="0cda3-166">In der Praxis ist es eher üblich, implizit typisierte Variablen zu verwenden und die Typen der zu untersuchenden Objekte mithilfe von API-Namen zu beschreiben.</span><span class="sxs-lookup"><span data-stu-id="0cda3-166">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="0cda3-167">Erstellen Sie ein neues **Stand-Alone Code Analysis Tool**-Projekt für C#:</span><span class="sxs-lookup"><span data-stu-id="0cda3-167">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="0cda3-168">Wählen Sie in Visual Studio **Datei** > **Neu** > **Projekt** aus, um das Dialogfeld „Neues Projekt“ anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-168">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="0cda3-169">Wählen Sie unter **Visual C#**  > **Erweiterbarkeit** die Option **Stand-Alone Code Analysis Tool** aus.</span><span class="sxs-lookup"><span data-stu-id="0cda3-169">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="0cda3-170">Nennen Sie Ihr Projekt **SyntaxTreeManualTraversal**, und klicken Sie auf „OK“.</span><span class="sxs-lookup"><span data-stu-id="0cda3-170">Name your project "**SyntaxTreeManualTraversal**" and click OK.</span></span>

<span data-ttu-id="0cda3-171">Sie werden das einfache Hello World!-</span><span class="sxs-lookup"><span data-stu-id="0cda3-171">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="0cda3-172">Programm analysieren, das weiter oben in diesem Artikel gezeigt wurde.</span><span class="sxs-lookup"><span data-stu-id="0cda3-172">program shown earlier.</span></span>
<span data-ttu-id="0cda3-173">Fügen Sie den Text für das Hello World-Programm als Konstante in Ihre `Program`-Klasse ein:</span><span class="sxs-lookup"><span data-stu-id="0cda3-173">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program text](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="0cda3-174">Anschließend fügen Sie den folgenden Code hinzu, um die **Syntaxstruktur** für den Codetext in der `programText`-Konstante zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-174">Next, add the following code to build the **syntax tree** for the code text in the `programText` constant.</span></span>  <span data-ttu-id="0cda3-175">Fügen Sie Ihrer `Main`-Methode die folgende Zeile hinzu:</span><span class="sxs-lookup"><span data-stu-id="0cda3-175">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="0cda3-176">Diese beiden Zeilen erstellen die Struktur und rufen den Stammknoten dieser Struktur ab.</span><span class="sxs-lookup"><span data-stu-id="0cda3-176">Those two lines create the tree and retrieve the root node of that tree.</span></span> <span data-ttu-id="0cda3-177">Jetzt können Sie die Knoten in der Struktur untersuchen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-177">You can now examine the nodes in the tree.</span></span> <span data-ttu-id="0cda3-178">Fügen Sie diese Zeilen zu Ihrer `Main`-Methode hinzu, um einige der Eigenschaften des Stammknotens in der Struktur anzuzeigen:</span><span class="sxs-lookup"><span data-stu-id="0cda3-178">Add these lines to your `Main` method to display some of the properties of the root node in the tree:</span></span>

[!code-csharp[Examine the root node](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#3 "Examine the root node")]

<span data-ttu-id="0cda3-179">Führen Sie die Anwendung aus, um festzustellen, was Ihr Code in Zusammenhang mit dem Stammknoten in dieser Struktur erkannt hat.</span><span class="sxs-lookup"><span data-stu-id="0cda3-179">Run the application to see what your code has discovered about the root node in this tree.</span></span>

<span data-ttu-id="0cda3-180">In der Regel würden Sie die Struktur durchlaufen, um mehr über den Code zu erfahren.</span><span class="sxs-lookup"><span data-stu-id="0cda3-180">Typically, you'd traverse the tree to learn about the code.</span></span> <span data-ttu-id="0cda3-181">In diesem Beispiel analysieren Sie bekannten Code, um die APIs zu erkunden.</span><span class="sxs-lookup"><span data-stu-id="0cda3-181">In this example, you're analyzing code you know to explore the APIs.</span></span> <span data-ttu-id="0cda3-182">Fügen Sie folgenden Code hinzu, um den ersten Member des `root`-Knotens zu untersuchen:</span><span class="sxs-lookup"><span data-stu-id="0cda3-182">Add the following code to examine the first member of the `root` node:</span></span>

[!code-csharp[Find the first member](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#4 "Find the first member")]

<span data-ttu-id="0cda3-183">Dieser Member ist eine <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0cda3-183">That member is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0cda3-184">Er repräsentiert alle Elemente im Bereich der `namespace HelloWorld`-Deklaration.</span><span class="sxs-lookup"><span data-stu-id="0cda3-184">It represents everything in the scope of the `namespace HelloWorld` declaration.</span></span> <span data-ttu-id="0cda3-185">Fügen Sie folgenden Code hinzu, um zu ermitteln, welche Knoten im `HelloWorld`-Namespace deklariert sind:</span><span class="sxs-lookup"><span data-stu-id="0cda3-185">Add the following code to examine what nodes are declared inside the `HelloWorld` namespace:</span></span>

[!code-csharp[Find the class declaration](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#5 "Find the class declaration")]

<span data-ttu-id="0cda3-186">Führen Sie das Programm aus, um das Ergebnis anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-186">Run the program to see what you've learned.</span></span>

<span data-ttu-id="0cda3-187">Da Sie jetzt wissen, dass die Deklaration eine <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType> ist, deklarieren Sie eine neue Variable dieses Typs, um die Klassendeklaration zu untersuchen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-187">Now that you know the declaration is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, declare a new variable of that type to examine the class declaration.</span></span> <span data-ttu-id="0cda3-188">Diese Klasse enthält nur einen Member: die `Main`-Methode.</span><span class="sxs-lookup"><span data-stu-id="0cda3-188">This class only contains one member: the `Main` method.</span></span> <span data-ttu-id="0cda3-189">Fügen Sie folgenden Code hinzu, um die `Main`-Methode zu suchen und in eine <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType> umzuwandeln.</span><span class="sxs-lookup"><span data-stu-id="0cda3-189">Add the following code to find the `Main` method, and cast it to a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span></span>

[!code-csharp[Find the main declaration](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#6 "Find the main declaration")]

<span data-ttu-id="0cda3-190">Der Knoten mit der Methodendeklaration enthält alle syntaktischen Informationen zu der Methode.</span><span class="sxs-lookup"><span data-stu-id="0cda3-190">The method declaration node contains all the syntactic information about the method.</span></span> <span data-ttu-id="0cda3-191">Jetzt zeigen wir den Rückgabetyp der `Main`-Methode, die Anzahl und Typen der Argumente und den Textkörper der Methode an.</span><span class="sxs-lookup"><span data-stu-id="0cda3-191">Let's display the return type of the `Main` method, the number and types of the arguments, and the body text of the method.</span></span> <span data-ttu-id="0cda3-192">Fügen Sie den folgenden Code hinzu:</span><span class="sxs-lookup"><span data-stu-id="0cda3-192">Add the following code:</span></span>

[!code-csharp[Examine the syntax of the main method](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#7 "Display information about the main method")]

<span data-ttu-id="0cda3-193">Führen Sie das Programm aus, um alle Informationen anzuzeigen, die Sie zu diesem Programm ermittelt haben:</span><span class="sxs-lookup"><span data-stu-id="0cda3-193">Run the program to see all the information you've discovered about this program:</span></span>

```text
The tree is a CompilationUnit node.
The tree has 1 elements in it.
The tree has 4 using statements. They are:
        System
        System.Collections
        System.Linq
        System.Text
The first member is a NamespaceDeclaration.
There are 1 members declared in this namespace.
The first member is a ClassDeclaration.
There are 1 members declared in the Program class.
The first member is a MethodDeclaration.
The return type of the Main method is void.
The method has 1 parameters.
The type of the args parameter is string[].
The body text of the Main method follows:
        {
            Console.WriteLine("Hello, World!");
        }
```

### <a name="query-methods"></a><span data-ttu-id="0cda3-194">Abfragemethoden</span><span class="sxs-lookup"><span data-stu-id="0cda3-194">Query methods</span></span>

<span data-ttu-id="0cda3-195">Zusätzlich zum Durchlaufen von Strukturen können Sie die Syntaxstruktur auch mithilfe der in <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> definierten Abfragemethoden untersuchen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-195">In addition to traversing trees, you can also explore the syntax tree using the query methods defined on <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0cda3-196">Diese Methoden werden Ihnen vertraut vorkommen, wenn Sie XPath kennen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-196">These methods should be immediately familiar to anyone familiar with XPath.</span></span> <span data-ttu-id="0cda3-197">Sie können diese Methoden mit LINQ verwenden, um Elemente in einer Struktur schnell zu finden.</span><span class="sxs-lookup"><span data-stu-id="0cda3-197">You can use these methods with LINQ to quickly find things in a tree.</span></span> <span data-ttu-id="0cda3-198"><xref:Microsoft.CodeAnalysis.SyntaxNode> weist Abfragemethoden wie z.B. <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> und <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A> auf.</span><span class="sxs-lookup"><span data-stu-id="0cda3-198">The <xref:Microsoft.CodeAnalysis.SyntaxNode> has query methods such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span></span>

<span data-ttu-id="0cda3-199">Sie können diese Abfragemethoden verwenden, um anstelle des Navigierens in der Struktur das Argument für die `Main`-Methode zu suchen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-199">You can use these query methods to find the argument to the `Main` method as an alternative to navigating the tree.</span></span> <span data-ttu-id="0cda3-200">Fügen Sie am Ende Ihrer `Main`-Methode folgenden Code hinzu:</span><span class="sxs-lookup"><span data-stu-id="0cda3-200">Add the following code to the bottom of your `Main` method:</span></span>

[!code-csharp[Query the tree for the arguments to Main](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#8 "Query the tree for the arguments to Main")]

<span data-ttu-id="0cda3-201">Die erste Anweisung verwendet einen LINQ-Ausdruck und die <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>-Methode, um denselben Parameter zu suchen wie im vorherigen Beispiel.</span><span class="sxs-lookup"><span data-stu-id="0cda3-201">The first statement uses a LINQ expression and the <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> method to locate the same parameter as in the previous example.</span></span>

<span data-ttu-id="0cda3-202">Führen Sie das Programm aus, und Sie werden feststellen, dass der LINQ-Ausdruck denselben Parameter gefunden hat wie beim manuellen Navigieren durch die Struktur.</span><span class="sxs-lookup"><span data-stu-id="0cda3-202">Run the program, and you can see that the LINQ expression found the same parameter as manually navigating the tree.</span></span>

<span data-ttu-id="0cda3-203">Das Beispiel verwendet `WriteLine`-Anweisungen, um während des Durchlaufens Informationen zu den Syntaxstrukturen anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-203">The sample uses `WriteLine` statements to display information about the syntax trees as they are traversed.</span></span> <span data-ttu-id="0cda3-204">Sie erhalten auch mehr Informationen, wenn Sie das fertig gestellte Programm im Debugger ausführen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-204">You can also learn much more by running the finished program under the debugger.</span></span> <span data-ttu-id="0cda3-205">Sie können die Eigenschaften und Methoden, die zu der für das Hello World-Programm erstellten Syntaxstruktur gehören, genauer untersuchen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-205">You can examine more of the properties and methods that are part of the syntax tree created for the hello world program.</span></span>

## <a name="syntax-walkers"></a><span data-ttu-id="0cda3-206">Syntaxwalker</span><span class="sxs-lookup"><span data-stu-id="0cda3-206">Syntax walkers</span></span>

<span data-ttu-id="0cda3-207">Es gibt häufig Situationen, in denen Sie in einer Syntaxstruktur alle Knoten eines bestimmten Typs finden möchten, z.B. jede Eigenschaftendeklaration in einer Datei.</span><span class="sxs-lookup"><span data-stu-id="0cda3-207">Often you want to find all nodes of a specific type in a syntax tree, for example, every property declaration in a file.</span></span> <span data-ttu-id="0cda3-208">Indem Sie die <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType>-Klasse erweitern und die <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)>-Methode überschreiben, können Sie jede Eigenschaftendeklaration in einer Syntaxstruktur verarbeiten, ohne die Struktur vorher kennen zu müssen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-208">By extending the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> class and overriding the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)> method, you process every property declaration in a syntax tree without knowing its structure beforehand.</span></span> <span data-ttu-id="0cda3-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> ist eine bestimmte Art von <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor>, der rekursiv einen Knoten und jedes seiner untergeordneten Elemente besucht.</span><span class="sxs-lookup"><span data-stu-id="0cda3-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> is a specific kind of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor> that recursively visits a node and each of its children.</span></span>

<span data-ttu-id="0cda3-210">Dieses Beispiel implementiert einen <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>, der eine Syntaxstruktur untersucht.</span><span class="sxs-lookup"><span data-stu-id="0cda3-210">This example implements a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines a syntax tree.</span></span> <span data-ttu-id="0cda3-211">Gefundene `using`-Direktiven, die keinen `System`-Namespace importieren, werden gesammelt.</span><span class="sxs-lookup"><span data-stu-id="0cda3-211">It collects `using` directives it finds that aren't importing a `System` namespace.</span></span>

<span data-ttu-id="0cda3-212">Erstellen Sie ein neues **Stand-Alone Code Analysis Tool**-Projekt für C#, und nennen Sie es **SyntaxWalker**.</span><span class="sxs-lookup"><span data-stu-id="0cda3-212">Create a new C# **Stand-Alone Code Analysis Tool** project; name it "**SyntaxWalker**."</span></span>

<span data-ttu-id="0cda3-213">Den fertig gestellten Code für dieses Beispiel finden Sie in [unserem GitHub-Repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="0cda3-213">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span></span> <span data-ttu-id="0cda3-214">Das Beispiel in GitHub enthält beide in diesem Tutorial beschriebenen Projekte.</span><span class="sxs-lookup"><span data-stu-id="0cda3-214">The sample on GitHub contains both projects described in this tutorial.</span></span>

<span data-ttu-id="0cda3-215">Wie im vorherigen Beispiel können Sie eine Zeichenfolgenkonstante definieren, die den Text des Programms enthält, das Sie analysieren möchten:</span><span class="sxs-lookup"><span data-stu-id="0cda3-215">As in the previous sample, you can define a string constant to hold the text of the program you're going to analyze:</span></span>

[!code-csharp[Define the code text to analyzer](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#1 "Define the program text to analyze")]

<span data-ttu-id="0cda3-216">Dieser Quelltext enthält `using`-Direktiven, die an vier Stellen verteilt sind: auf Dateiebene, im Namespace der obersten Ebene und in den beiden geschachtelten Namespaces.</span><span class="sxs-lookup"><span data-stu-id="0cda3-216">This source text contains `using` directives scattered across four different locations: the file-level, in the top-level namespace, and in the two nested namespaces.</span></span> <span data-ttu-id="0cda3-217">Dieses Beispiel zeigt ein grundlegendes Szenario für die Verwendung der <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>-Klasse zum Abfragen von Code.</span><span class="sxs-lookup"><span data-stu-id="0cda3-217">This example highlights a core scenario for using the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> class to query code.</span></span> <span data-ttu-id="0cda3-218">Es wäre sehr umständlich, jeden Knoten in der Stammsyntaxstruktur besuchen zu müssen, um using-Deklarationen zu finden.</span><span class="sxs-lookup"><span data-stu-id="0cda3-218">It would be cumbersome to visit every node in the root syntax tree to find using declarations.</span></span> <span data-ttu-id="0cda3-219">Stattdessen erstellen Sie eine abgeleitete Klasse und überschreiben die Methoden, die nur aufgerufen werden, denn der aktuelle Knoten in der Struktur eine using-Direktive ist.</span><span class="sxs-lookup"><span data-stu-id="0cda3-219">Instead, you create a derived class and override the method that gets called only when the current node in the tree is a using directive.</span></span> <span data-ttu-id="0cda3-220">Ihr Besucher führt keine Aktionen für einen andern Knotentyp aus.</span><span class="sxs-lookup"><span data-stu-id="0cda3-220">Your visitor does not do any work on any other node types.</span></span> <span data-ttu-id="0cda3-221">Diese Einzelmethode untersucht jede der `using`-Anweisungen und erstellt eine Sammlung der Namespaces, die sich nicht im `System`-Namespace befinden.</span><span class="sxs-lookup"><span data-stu-id="0cda3-221">This single method examines each of the `using` statements and builds a collection of the namespaces that aren't in the `System` namespace.</span></span> <span data-ttu-id="0cda3-222">Sie erstellen einen <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>, der alle `using`-Anweisungen untersucht, und zwar nur die `using`-Anweisungen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-222">You build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines all the `using` statements, but only the `using` statements.</span></span>

<span data-ttu-id="0cda3-223">Nachdem Sie den Programmtext definieren haben, müssen Sie eine `SyntaxTree` erstellen und das Stammelement dieser Struktur abrufen:</span><span class="sxs-lookup"><span data-stu-id="0cda3-223">Now that you've defined the program text, you need to create a `SyntaxTree` and get the root of that tree:</span></span>

[!code-csharp[Create the Syntax tree and access the root](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#2 "Create the Syntax tree and access the root node.")]

<span data-ttu-id="0cda3-224">Erstellen Sie als Nächstes eine neue Klasse.</span><span class="sxs-lookup"><span data-stu-id="0cda3-224">Next, create a new class.</span></span> <span data-ttu-id="0cda3-225">Wählen Sie in Visual Studio **Projekt** > **Neues Element hinzufügen** aus.</span><span class="sxs-lookup"><span data-stu-id="0cda3-225">In Visual Studio, choose **Project** > **Add New Item**.</span></span> <span data-ttu-id="0cda3-226">Geben Sie im Dialogfeld **Neues Element hinzufügen** den Namen *UsingCollector.cs* als Dateinamen ein.</span><span class="sxs-lookup"><span data-stu-id="0cda3-226">In the **Add New Item** dialog type *UsingCollector.cs* as the filename.</span></span>

<span data-ttu-id="0cda3-227">Sie implementieren die `using`-Besucherfunktionalität in der `UsingCollector`-Klasse.</span><span class="sxs-lookup"><span data-stu-id="0cda3-227">You implement the `using` visitor functionality in the `UsingCollector` class.</span></span> <span data-ttu-id="0cda3-228">Beginnen Sie, indem Sie die `UsingCollector`-Klasse aus <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> ableiten.</span><span class="sxs-lookup"><span data-stu-id="0cda3-228">Start by making the `UsingCollector` class derive from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span></span>

[!code-csharp[Declare the base class for the using collector](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#3 "Declare the base class for the UsingCollector")]

<span data-ttu-id="0cda3-229">Sie benötigen Speicherplatz, um die gesammelten Namespaceknoten zu speichern.</span><span class="sxs-lookup"><span data-stu-id="0cda3-229">You need storage to hold the namespace nodes that you're collecting.</span></span>  <span data-ttu-id="0cda3-230">Deklarieren Sie eine öffentliche schreibgeschützte Eigenschaft in der `UsingCollector`-Klasse, und verwenden Sie diese Variable, um die gefundenen <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax>-Knoten zu speichern:</span><span class="sxs-lookup"><span data-stu-id="0cda3-230">Declare a public read-only property in the `UsingCollector` class; you use this variable to store the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> nodes you find:</span></span>

[!code-csharp[Declare storage for the using syntax nodes](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#4 "Declare storage for the using syntax nodes")]

<span data-ttu-id="0cda3-231">Die Basisklasse <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implementiert die Logik, gemäß der jeder Knoten in der Syntaxstruktur besucht wird.</span><span class="sxs-lookup"><span data-stu-id="0cda3-231">The base class, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implements the logic to visit each node in the syntax tree.</span></span> <span data-ttu-id="0cda3-232">Die abgeleitete Klasse überschreibt die Methoden, die für die Knoten aufgerufen werden, für die Sie sich interessieren.</span><span class="sxs-lookup"><span data-stu-id="0cda3-232">The derived class overrides the methods called for the specific nodes you're interested in.</span></span> <span data-ttu-id="0cda3-233">In diesem Fall gilt Ihr Interesse allen `using`-Direktiven.</span><span class="sxs-lookup"><span data-stu-id="0cda3-233">In this case, you're interested in any `using` directive.</span></span> <span data-ttu-id="0cda3-234">Das bedeutet, dass Sie die <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)>-Methode überschreiben müssen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-234">That means you must override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> method.</span></span> <span data-ttu-id="0cda3-235">Das einzige Argument in dieser Methode ist ein <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType>-Objekt.</span><span class="sxs-lookup"><span data-stu-id="0cda3-235">The one argument to this method is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="0cda3-236">Das ist ein wichtiger Vorteil gegenüber der Verwendung der Besucher: Diese rufen die überschriebenen Methoden mit Argumenten auf, die bereits in den bestimmten Knotentyp umgewandelt wurden.</span><span class="sxs-lookup"><span data-stu-id="0cda3-236">That's an important advantage to using the visitors: they call the overridden methods with arguments already cast to the specific node type.</span></span> <span data-ttu-id="0cda3-237">Die <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType>-Klasse weist eine <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name>-Eigenschaft auf, die den Namen des zu importierenden Namespace speichert.</span><span class="sxs-lookup"><span data-stu-id="0cda3-237">The <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> class has a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> property that stores the name of the namespace being imported.</span></span> <span data-ttu-id="0cda3-238">Es handelt sich um eine <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0cda3-238">It is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0cda3-239">Fügen Sie folgenden Code in die <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)>-Überschreibung ein:</span><span class="sxs-lookup"><span data-stu-id="0cda3-239">Add the following code in the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> override:</span></span>

[!code-csharp[Examine using nodes for the System namespace](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#5 "Examine all using nodes for the System namespace.")]

<span data-ttu-id="0cda3-240">Wie beim oben aufgeführten Beispiel haben Sie eine Vielzahl von `WriteLine`-Anweisungen hinzugefügt, die dabei helfen, diese Methode zu verstehen.</span><span class="sxs-lookup"><span data-stu-id="0cda3-240">As with the earlier example, you've added a variety of `WriteLine` statements to aid in understanding of this method.</span></span> <span data-ttu-id="0cda3-241">Sie sehen, wann die Methode aufgerufen wird und welche Argumente bei jedem Aufruf an die Methode übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="0cda3-241">You can see when it's called, and what arguments are passed to it each time.</span></span>

<span data-ttu-id="0cda3-242">Zum Schluss müssen Sie zwei Codezeilen hinzufügen, um den `UsingCollector` zu erstellen und dafür zu sorgen, dass dieser den Stammknoten besucht und alle `using`-Anweisungen sammelt.</span><span class="sxs-lookup"><span data-stu-id="0cda3-242">Finally, you need to add two lines of code to create the `UsingCollector` and have it visit the root node, collecting all the `using` statements.</span></span> <span data-ttu-id="0cda3-243">Fügen Sie dann eine `foreach`-Schleife ein, um alle `using`-Anweisungen anzuzeigen, die der Collector gefunden hat:</span><span class="sxs-lookup"><span data-stu-id="0cda3-243">Then, add a `foreach` loop to display all the `using` statements your collector found:</span></span>

[!code-csharp[Create the UsingCollector and visit the root node.](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#6 "Create the UsingCollector and visit the root node.")]

<span data-ttu-id="0cda3-244">Kompilieren Sie das Projekt, und führen Sie es aus.</span><span class="sxs-lookup"><span data-stu-id="0cda3-244">Compile and run the program.</span></span> <span data-ttu-id="0cda3-245">Die folgende Ausgabe wird angezeigt:</span><span class="sxs-lookup"><span data-stu-id="0cda3-245">You should see the following output:</span></span>

```console
        VisitUsingDirective called with System.
        VisitUsingDirective called with System.Collections.Generic.
        VisitUsingDirective called with System.Linq.
        VisitUsingDirective called with System.Text.
        VisitUsingDirective called with Microsoft.CodeAnalysis.
                Success. Adding Microsoft.CodeAnalysis.
        VisitUsingDirective called with Microsoft.CodeAnalysis.CSharp.
                Success. Adding Microsoft.CodeAnalysis.CSharp.
        VisitUsingDirective called with Microsoft.
                Success. Adding Microsoft.
        VisitUsingDirective called with System.ComponentModel.
        VisitUsingDirective called with Microsoft.Win32.
                Success. Adding Microsoft.Win32.
        VisitUsingDirective called with System.Runtime.InteropServices.
        VisitUsingDirective called with System.CodeDom.
        VisitUsingDirective called with Microsoft.CSharp.
                Success. Adding Microsoft.CSharp.
Microsoft.CodeAnalysis
Microsoft.CodeAnalysis.CSharp
Microsoft
Microsoft.Win32
Microsoft.CSharp
Press any key to continue . . .
```

<span data-ttu-id="0cda3-246">Herzlichen Glückwunsch!</span><span class="sxs-lookup"><span data-stu-id="0cda3-246">Congratulations!</span></span> <span data-ttu-id="0cda3-247">Sie haben die **Syntax-API** verwendet, um bestimmte Arten von C#-Anweisungen und -Deklarationen in C#-Quellcode zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="0cda3-247">You've used the **Syntax API** to locate specific kinds of C# statements and declarations in C# source code.</span></span>
