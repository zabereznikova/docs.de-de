---
title: Neues in C# 6 – C#-Leitfaden
description: Neues zu den neuen Features in Version 6 von C#
ms.date: 12/12/2018
ms.openlocfilehash: da40b4c9d4af0094fdd907c542e971ba55086e0f
ms.sourcegitcommit: 67ebdb695fd017d79d9f1f7f35d145042d5a37f7
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 10/20/2020
ms.locfileid: "92224236"
---
# <a name="whats-new-in-c-6"></a><span data-ttu-id="5a2ae-103">Neues in C# 6</span><span class="sxs-lookup"><span data-stu-id="5a2ae-103">What's New in C# 6</span></span>

<span data-ttu-id="5a2ae-104">Die Version 6.0 von C# enthält zahlreiche Features, die die Produktivität für Entwickler verbessern.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-104">The 6.0 release of C# contained many features that improve productivity for developers.</span></span> <span data-ttu-id="5a2ae-105">Der Gesamteffekt dieser Features ist es, dass Sie präziseren Code schreiben, der zudem lesbarer ist.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-105">The overall effect of these features is that you write more concise code that is also more readable.</span></span> <span data-ttu-id="5a2ae-106">Die Syntax benötigt weniger Aufwand für viele allgemeine Methoden.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-106">The syntax contains less ceremony for many common practices.</span></span> <span data-ttu-id="5a2ae-107">Es ist einfacher, die Entwurfsabsicht mit weniger Aufwand anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-107">It's easier to see the design intent with less ceremony.</span></span> <span data-ttu-id="5a2ae-108">Mit diesen Features sind Sie produktiver und können besser lesbaren Code schreiben.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-108">Learn these features well, and you'll be more productive and write more readable code.</span></span> <span data-ttu-id="5a2ae-109">Zudem können Sie sich besser auf Ihre Features statt auf die Sprachkonstrukte konzentrieren.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-109">You can concentrate more on your features than on the constructs of the language.</span></span>

<span data-ttu-id="5a2ae-110">Im weiteren Verlauf dieses Artikels finden Sie eine Übersicht über die einzelnen Features, in der jeweils ein Link enthalten ist, über den Sie weitere Informationen zum Feature erhalten.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-110">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span> <span data-ttu-id="5a2ae-111">Die Funktionen werden zusätzlich in einem [interaktiven Tutorial zur Einführung von C# 6](../tutorials/exploration/csharp-6.yml) im Abschnitt „Tutorials“ näher erklärt.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-111">You can also explore the features in an [interactive exploration on C# 6](../tutorials/exploration/csharp-6.yml) in the tutorials section.</span></span>

## <a name="read-only-auto-properties"></a><span data-ttu-id="5a2ae-112">Schreibgeschützte Auto-Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="5a2ae-112">Read-only auto-properties</span></span>

<span data-ttu-id="5a2ae-113">*Schreibgeschützte Auto-Eigenschaften* ermöglichen eine präzisere Syntax um unveränderliche Typen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-113">*Read-only auto-properties* provide a more concise syntax to create immutable types.</span></span> <span data-ttu-id="5a2ae-114">Sie deklarieren die Auto-Eigenschaft nur mit einem Get-Accessor:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-114">You declare the auto-property with only a get accessor:</span></span>

[!code-csharp[ReadOnlyAutoProperty](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoProperty)]

<span data-ttu-id="5a2ae-115">Die `FirstName`- und `LastName`-Eigenschaften können nur im Text des Konstruktors der gleichen Klasse festgelegt werden:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-115">The `FirstName` and `LastName` properties can be set only in the body of the constructor of the same class:</span></span>

[!code-csharp[ReadOnlyAutoPropertyConstructor](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoPropertyConstructor)]

<span data-ttu-id="5a2ae-116">Wenn Sie versuchen, `LastName` in einer anderen Methode festzulegen, wird ein `CS0200`-Kompilierungsfehler erzeugt:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-116">Trying to set `LastName` in another method generates a `CS0200` compilation error:</span></span>

```csharp
public class Student
{
    public string LastName { get;  }

    public void ChangeName(string newLastName)
    {
        // Generates CS0200: Property or indexer cannot be assigned to -- it is read only
        LastName = newLastName;
    }
}
```

<span data-ttu-id="5a2ae-117">Dieses Feature ermöglicht eine korrekte Sprachenunterstützung zum Erstellen unveränderlicher Typen und nutzt die präzisere und praktischere Syntax für automatische Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-117">This feature enables true language support for creating immutable types and uses the more concise and convenient auto-property syntax.</span></span>

<span data-ttu-id="5a2ae-118">Wenn durch das Hinzufügen dieser Syntax eine zugängliche Methode nicht entfernt wird, handelt es sich um eine [binärkompatible Änderung](version-update-considerations.md#binary-compatible-changes).</span><span class="sxs-lookup"><span data-stu-id="5a2ae-118">If adding this syntax doesn't remove an accessible method, it's a [binary compatible change](version-update-considerations.md#binary-compatible-changes).</span></span>

## <a name="auto-property-initializers"></a><span data-ttu-id="5a2ae-119">Auto-Eigenschaft-Initialisierer</span><span class="sxs-lookup"><span data-stu-id="5a2ae-119">Auto-property initializers</span></span>

<span data-ttu-id="5a2ae-120">Mit *Initialisierern für automatische Eigenschaften* können Sie den ursprünglichen Wert für eine automatische Eigenschaft als Teil der Eigenschaftendeklaration deklarieren.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-120">*Auto-property initializers* let you declare the initial value for an auto-property as part of the property declaration.</span></span>

[!code-csharp[Initialization](../../../samples/snippets/csharp/new-in-6/newcode.cs#Initialization)]

<span data-ttu-id="5a2ae-121">Der `Grades`-Member wird dort initialisiert, wo er deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-121">The `Grades` member is initialized where it's declared.</span></span> <span data-ttu-id="5a2ae-122">Dies erleichtert die einmalige Ausführung der Initialisierung.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-122">That makes it easier to perform the initialization exactly once.</span></span> <span data-ttu-id="5a2ae-123">Die Initialisierung ist Teil der Eigenschaftendeklaration. Dadurch ist es einfacher, die Speicherbelegung mit der öffentlichen Schnittstelle für `Student`-Objekte gleichzustellen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-123">The initialization is part of the property declaration, making it easier to equate the storage allocation with the public interface for `Student` objects.</span></span>

## <a name="expression-bodied-function-members"></a><span data-ttu-id="5a2ae-124">Ausdruckskörper-Funktionsmember</span><span class="sxs-lookup"><span data-stu-id="5a2ae-124">Expression-bodied function members</span></span>

<span data-ttu-id="5a2ae-125">Viele Member, die Sie schreiben, sind einzelne Anweisungen, die einzelne Ausdrücke darstellen können.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-125">Many members that you write are single statements that could be single expressions.</span></span> <span data-ttu-id="5a2ae-126">Schreiben Sie stattdessen einen Ausdruckskörpermember.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-126">Write an expression-bodied member instead.</span></span> <span data-ttu-id="5a2ae-127">Dies funktioniert für Methoden und schreibgeschützte Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-127">It works for methods and read-only properties.</span></span> <span data-ttu-id="5a2ae-128">Das Außerkraftsetzen von `ToString()` ist z.B. oft eine gute Wahl:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-128">For example, an override of `ToString()` is often a great candidate:</span></span>

[!code-csharp[ToStringExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#ToStringExpressionMember)]

<span data-ttu-id="5a2ae-129">Sie können diese Syntax auch für schreibgeschützte Eigenschaften verwenden:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-129">You can also use this syntax for read-only properties:</span></span>

[!code-csharp[FullNameExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]

<span data-ttu-id="5a2ae-130">Das Ändern eines vorhandenen Members in ein Ausdruckskörpermember ist eine [binärkompatible Änderung](version-update-considerations.md#binary-compatible-changes).</span><span class="sxs-lookup"><span data-stu-id="5a2ae-130">Changing an existing member to an expression bodied member is a [binary compatible change](version-update-considerations.md#binary-compatible-changes).</span></span>

## <a name="using-static"></a><span data-ttu-id="5a2ae-131">verwendet statische</span><span class="sxs-lookup"><span data-stu-id="5a2ae-131">using static</span></span>

<span data-ttu-id="5a2ae-132">Die Erweiterung *verwendet statische* erlaubt Ihnen das Importieren der statischen Methoden einer einzelnen Klasse.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-132">The *using static* enhancement enables you to import the static methods of a single class.</span></span> <span data-ttu-id="5a2ae-133">Sie geben die von Ihnen verwendete Klasse ein:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-133">You specify the class you're using:</span></span>

[!code-csharp[UsingStaticMath](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticMath)]

<span data-ttu-id="5a2ae-134">Die <xref:System.Math>-Klasse enthält keine Instanzmethoden.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-134">The <xref:System.Math> does not contain any instance methods.</span></span> <span data-ttu-id="5a2ae-135">Sie können auch `using static` zum Importieren von statischen Methoden einer Klasse für eine Klasse verwenden, die jeweils über statische Methoden und Instanzenmethoden verfügt.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-135">You can also use `using static` to import a class' static methods for a class that has both static and instance methods.</span></span> <span data-ttu-id="5a2ae-136">Eines der nützlichsten Beispiele ist <xref:System.String>:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-136">One of the most useful examples is <xref:System.String>:</span></span>

[!code-csharp[UsingStatic](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStatic)]

> [!NOTE]
> <span data-ttu-id="5a2ae-137">Sie müssen den vollqualifizierten Klassennamen `System.String` in einer statischen using-Anweisung verwenden.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-137">You must use the fully qualified class name, `System.String`  in a static using statement.</span></span>  <span data-ttu-id="5a2ae-138">Sie können das `string`-Schlüsselwort nicht stattdessen verwenden.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-138">You cannot use the `string` keyword instead.</span></span>

<span data-ttu-id="5a2ae-139">Beim Importieren einer `static using`-Anweisung befinden sich Erweiterungsmethoden nur im Gültigkeitsbereich, wenn Sie mithilfe der Aufrufsyntax für Erweiterungsmethoden aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-139">When imported from a `static using` statement, extension methods are only in scope when called using the extension method invocation syntax.</span></span> <span data-ttu-id="5a2ae-140">Wenn sie als statische Methode aufgerufen werden, befinden sie sich nicht im Gültigkeitsbereich.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-140">They aren't in scope when called as a static method.</span></span> <span data-ttu-id="5a2ae-141">Sie sehen dies oft in LINQ-Abfragen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-141">You'll often see this in LINQ queries.</span></span> <span data-ttu-id="5a2ae-142">Sie können das LINQ-Muster importieren, indem Sie <xref:System.Linq.Enumerable> oder <xref:System.Linq.Queryable> importieren.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-142">You can import the LINQ pattern by importing <xref:System.Linq.Enumerable>, or <xref:System.Linq.Queryable>.</span></span>

[!code-csharp[UsingStaticLinq](../../../samples/snippets/csharp/new-in-6/newcode.cs#usingStaticLinq)]

<span data-ttu-id="5a2ae-143">Erweiterungsmethoden werden normalerweise mithilfe von Aufrufausdrücken für Erweiterungsmethoden aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-143">You typically call extension methods using extension method invocation expressions.</span></span> <span data-ttu-id="5a2ae-144">Für den seltenen Fall, dass sie durch die Aufrufsyntax für statische Methoden aufgerufen werden, wird der Klassenname hinzugefügt, um Mehrdeutigkeiten zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-144">Adding the class name in the rare case where you call them using static method call syntax resolves ambiguity.</span></span>

<span data-ttu-id="5a2ae-145">Die `static using`-Direktive importiert auch keine geschachtelten Typen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-145">The `static using` directive also imports any nested types.</span></span> <span data-ttu-id="5a2ae-146">Sie können auf alle geschachtelten Typen ohne Qualifikation verweisen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-146">You can reference any nested types without qualification.</span></span>

## <a name="null-conditional-operators"></a><span data-ttu-id="5a2ae-147">Bedingter NULL-Operator</span><span class="sxs-lookup"><span data-stu-id="5a2ae-147">Null-conditional operators</span></span>

<span data-ttu-id="5a2ae-148">Der *NULL-bedingte Operator* erleichtert und optimiert NULL-Überprüfungen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-148">The *null conditional operator* makes null checks much easier and fluid.</span></span> <span data-ttu-id="5a2ae-149">Ersetzen Sie einfach den Memberzugriff `.` durch `?.`:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-149">Replace the member access `.` with `?.`:</span></span>

[!code-csharp[NullConditional](../../../samples/snippets/csharp/new-in-6/program.cs#NullConditional)]

<span data-ttu-id="5a2ae-150">Im vorangegangenen Beispiel, ist die Variable `first``null` zugewiesen, wenn das Person-Objekt `null` ist.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-150">In the preceding example, the variable `first` is assigned `null` if the person object is `null`.</span></span> <span data-ttu-id="5a2ae-151">Andernfalls wird ihr der Wert der `FirstName`-Eigenschaft zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-151">Otherwise, it is assigned the value of the `FirstName` property.</span></span> <span data-ttu-id="5a2ae-152">Beachten Sie vor allem, dass `?.` bedeutet, dass diese Codezeile keine `NullReferenceException` generiert, wenn die `person`-Variable `null` ist.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-152">Most importantly, the `?.` means that this line of code doesn't generate a `NullReferenceException` if the `person` variable is `null`.</span></span> <span data-ttu-id="5a2ae-153">Stattdessen wird sie vorzeitig abgebrochen (Kurzschlussauswertung) und gibt `null` zurück.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-153">Instead, it short-circuits and returns `null`.</span></span> <span data-ttu-id="5a2ae-154">Sie können auch einen bedingten NULL-Operator für den Zugriff von Array oder Indexern verwenden.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-154">You can also use a null conditional operator for array or indexer access.</span></span> <span data-ttu-id="5a2ae-155">Ersetzen Sie `[]` durch `?[]` im Indexausdruck.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-155">Replace `[]` with `?[]` in the index expression.</span></span>

<span data-ttu-id="5a2ae-156">Dieser Ausdruck gibt einen `string`-Wert zurück, unabhängig vom Wert von `person`.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-156">The following expression returns a `string`, regardless of the value of `person`.</span></span> <span data-ttu-id="5a2ae-157">Häufig können Sie dieses Konstrukt mit dem *NULL-Sammeloperator* verwenden, um die Standardwerte zuzuweisen, wenn eine der Eigenschaften `null` ist.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-157">You often use this construct with the *null coalescing* operator to assign default values when one of the properties is `null`.</span></span> <span data-ttu-id="5a2ae-158">Im Falle einer Verkürzung im Ausdruck wird der zurückgegebene `null`-Wert aufgelistet, damit er mit dem vollständigen Ausdruck übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-158">When the expression short-circuits, the `null` value returned is typed to match the full expression.</span></span>

[!code-csharp[NullCoalescing](../../../samples/snippets/csharp/new-in-6/program.cs#NullCoalescing)]

<span data-ttu-id="5a2ae-159">Sie können auch `?.` verwenden, um Methoden bedingt aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-159">You can also use `?.` to conditionally invoke methods.</span></span> <span data-ttu-id="5a2ae-160">Die häufigste Verwendung von Memberfunktionen mit dem bedingten NULL-Operator besteht darin, Delegaten (oder Ereignishandler), die möglicherweise `null` sind, sicher aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-160">The most common use of member functions  with the null conditional operator is to safely invoke delegates (or event handlers) that may be `null`.</span></span>  <span data-ttu-id="5a2ae-161">Dazu müssen Sie die `Invoke`-Methode des Delegaten mithilfe des `?.`-Operators aufrufen, um auf den Member zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-161">You'll call the delegate's `Invoke` method using the `?.` operator to access the member.</span></span> <span data-ttu-id="5a2ae-162">Im Artikel zum [Delegieren von Mustern](../delegates-patterns.md#handling-null-delegates) finden Sie ein Beispiel dazu.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-162">You can see an example in the [delegate patterns](../delegates-patterns.md#handling-null-delegates) article.</span></span>

<span data-ttu-id="5a2ae-163">Die Regeln des `?.`-Operators stellen sicher, dass die linke Seite des Operators nur einmal ausgewertet wird.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-163">The rules of the `?.` operator ensure that the left-hand side of the operator is evaluated only once.</span></span> <span data-ttu-id="5a2ae-164">Dadurch werden viele Idiome aktiviert, einschließlich folgendes Beispiel, in dem Ereignishandler verwendet werden:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-164">It enables many idioms, including the following example using event handlers:</span></span>

```csharp
// preferred in C# 6:
this.SomethingHappened?.Invoke(this, eventArgs);
```

<span data-ttu-id="5a2ae-165">Stellen Sie sicher, dass die linke Seite nur einmal ausgewertet wird, um einen beliebigen Ausdruck sowie Methodenaufrufe auf der linken Seite von `?.` zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-165">Ensuring that the left side is evaluated only once also enables you to use any expression, including method calls, on the left side of the `?.`</span></span>

## <a name="string-interpolation"></a><span data-ttu-id="5a2ae-166">Zeichenfolgeninterpolation</span><span class="sxs-lookup"><span data-stu-id="5a2ae-166">String interpolation</span></span>

<span data-ttu-id="5a2ae-167">Ab C# 6 können Sie mit dem neuen Feature für [Zeichenfolgeninterpolationen](../language-reference/tokens/interpolated.md) Ausdrücke in eine Zeichenfolge einbetten.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-167">With C# 6, the new [string interpolation](../language-reference/tokens/interpolated.md) feature enables you to embed expressions in a string.</span></span> <span data-ttu-id="5a2ae-168">Stellen Sie einfach `$` vor die Zeichenfolge, und verwenden Sie Ausdrücke zwischen `{` und `}` anstelle von Ordnungszahlen:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-168">Simply preface the string with `$`and use expressions between `{` and `}` instead of ordinals:</span></span>

[!code-csharp[stringInterpolation](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]

<span data-ttu-id="5a2ae-169">In diesem Beispiel werden Eigenschaften für die ersetzten Ausdrücke verwendet.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-169">This example uses properties for the substituted expressions.</span></span> <span data-ttu-id="5a2ae-170">Sie können einen beliebigen Ausdruck verwenden.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-170">You can use any expression.</span></span> <span data-ttu-id="5a2ae-171">Sie können z.B. den Notendurchschnitt eines Studenten als Teil der Interpolation berechnen:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-171">For example, you could compute a student's grade point average as part of the interpolation:</span></span>

[!code-csharp[stringInterpolationFormat](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationFormat)]

<span data-ttu-id="5a2ae-172">Die vorherige Codezeile formatiert den Wert für `Grades.Average()` als Gleitkommazahl mit zwei Dezimalstellen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-172">The preceding line of code formats the value for `Grades.Average()` as a floating-point number with two decimal places.</span></span>

<span data-ttu-id="5a2ae-173">Häufig müssen Sie die Zeichenfolge formatieren, die unter Verwendung einer bestimmten Kultur erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-173">Often, you may need to format the string produced using a specific culture.</span></span> <span data-ttu-id="5a2ae-174">Hierbei nutzen Sie die Tatsache, dass das Objekt, das durch die Zeichenfolgeninterpolation erstellt wurde, implizit in <xref:System.FormattableString?displayProperty=nameWithType> konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-174">You use the fact that the object produced by a string interpolation can be implicitly converted to <xref:System.FormattableString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5a2ae-175">Die <xref:System.FormattableString>-Instanz enthält die zusammengesetzte Formatzeichenfolge sowie die Ergebnisse der Auswertung der Ausdrücke, bevor sie in Zeichenfolgen konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-175">The <xref:System.FormattableString> instance contains the composite format string and the results of evaluating the expressions before converting them to strings.</span></span> <span data-ttu-id="5a2ae-176">Verwenden Sie die <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType>-Methode, um die Kultur anzugeben, wenn Sie eine Zeichenfolge formatieren.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-176">Use the <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> method to specify the culture when formatting a string.</span></span> <span data-ttu-id="5a2ae-177">Im folgenden Beispiel wird eine Zeichenfolge mit deutscher Kultur (de-DE) erstellt.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-177">The following example produces a string using the German (de-DE) culture.</span></span> <span data-ttu-id="5a2ae-178">(In der deutschen Kultur wird standardmäßig das Zeichen „,“ als Dezimaltrennzeichen sowie das Zeichen „.“ als Tausendertrennzeichen verwendet.)</span><span class="sxs-lookup"><span data-stu-id="5a2ae-178">(By default, the German culture uses the ',' character for the decimal separator, and the '.' character as the thousands separator.)</span></span>

```csharp
FormattableString str = $"Average grade is {s.Grades.Average()}";
var gradeStr = str.ToString(new System.Globalization.CultureInfo("de-DE"));
```

<span data-ttu-id="5a2ae-179">Wenn Sie mehr über die Zeichenfolgeninterpolation erfahren möchten, sehen Sie sich das interaktive Tutorial [Zeichenfolgeninterpolation in C#](../tutorials/exploration/interpolated-strings.yml), den Artikel [Zeichenfolgeninterpolation](../language-reference/tokens/interpolated.md) und das Tutorial [Zeichenfolgeninterpolation in C#](../tutorials/string-interpolation.md) an.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-179">To get started with string interpolation, see the [String interpolation in C#](../tutorials/exploration/interpolated-strings.yml) interactive tutorial, the [String interpolation](../language-reference/tokens/interpolated.md) article, and the [String interpolation in C#](../tutorials/string-interpolation.md) tutorial.</span></span>

## <a name="exception-filters"></a><span data-ttu-id="5a2ae-180">Ausnahmefilter</span><span class="sxs-lookup"><span data-stu-id="5a2ae-180">Exception filters</span></span>

<span data-ttu-id="5a2ae-181">*Ausnahmefilter* sind Klauseln, die festlegen, wann eine bestimmte Catch-Klausel angewendet werden muss.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-181">*Exception Filters* are clauses that determine when a given catch clause should be applied.</span></span> <span data-ttu-id="5a2ae-182">Wenn der für einen Ausnahmefilter verwendete Ausdruck `true` ergibt, führt die Catch-Klausel die normale Verarbeitung auf einer Ausnahme durch.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-182">If the expression used for an exception filter evaluates to `true`, the catch clause performs its normal processing on an exception.</span></span> <span data-ttu-id="5a2ae-183">Wenn der Ausdruck `false` ergibt, wird die `catch`-Klausel übersprungen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-183">If the expression evaluates to `false`, then the `catch` clause is skipped.</span></span> <span data-ttu-id="5a2ae-184">Eine Verwendung ist, Informationen über eine Ausnehme zu untersuchen, um zu bestimmen, ob eine `catch`-Klausel die Ausnahme verarbeiten kann:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-184">One use is to examine information about an exception to determine if a `catch` clause can process the exception:</span></span>

[!code-csharp[ExceptionFilter](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilter)]

## <a name="the-nameof-expression"></a><span data-ttu-id="5a2ae-185">Der `nameof`-Ausdruck</span><span class="sxs-lookup"><span data-stu-id="5a2ae-185">The `nameof` expression</span></span>

<span data-ttu-id="5a2ae-186">Der Ausdruck [nameof](../language-reference/operators/nameof.md) wird zum Namen eines Symbols ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-186">The [nameof](../language-reference/operators/nameof.md) expression evaluates to the name of a symbol.</span></span> <span data-ttu-id="5a2ae-187">Es ist eine hervorragende Möglichkeit, Tools zum Arbeiten zu bringen, wenn Sie den Namen einer Variable, Eigenschaften oder eines Memberfelds benötigen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-187">It's a great way to get tools working whenever you need the name of a variable, a property, or a member field.</span></span> <span data-ttu-id="5a2ae-188">Eine der häufigsten Verwendungszwecke für `nameof` besteht darin, den Namen eines Symbols bereitzustellen, die eine Ausnahme ausgelöst hat:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-188">One of the most common uses for `nameof` is to provide the name of a symbol that caused an exception:</span></span>

[!code-csharp[nameof](../../../samples/snippets/csharp/new-in-6/NewCode.cs#UsingStaticString)]

<span data-ttu-id="5a2ae-189">Sie können den Ausdruck auch mit auf XAML basierenden Anwendungen verwenden, die die `INotifyPropertyChanged`-Schnittstelle implementieren:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-189">Another use is with XAML-based applications that implement the `INotifyPropertyChanged` interface:</span></span>

[!code-csharp[nameofNotify](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#nameofNotify)]

## <a name="await-in-catch-and-finally-blocks"></a><span data-ttu-id="5a2ae-190">„Await“ in Catch- und Finally-Blöcken</span><span class="sxs-lookup"><span data-stu-id="5a2ae-190">Await in Catch and Finally blocks</span></span>

<span data-ttu-id="5a2ae-191">C# 5 hat mehrere Einschränkungen im Hinblick auf die Position von `await`-Ausdrücken.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-191">C# 5 had several limitations around where you could place `await` expressions.</span></span> <span data-ttu-id="5a2ae-192">Sie können mit C# 6 nun `await` in `catch`- oder `finally`-Ausdrücken verwenden.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-192">With C# 6, you can now use `await` in `catch` or `finally` expressions.</span></span> <span data-ttu-id="5a2ae-193">Dies wird am häufigsten in Protokollierungsszenarios verwendet:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-193">This is most often used with logging scenarios:</span></span>

[!code-csharp[AwaitFinally](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#AwaitFinally)]

<span data-ttu-id="5a2ae-194">Die Implementierungsdetails für das Hinzufügen von `await`-Unterstützung in `catch`- und `finally`-Klauseln stellt sicher, dass das Verhalten konsistent mit dem Verhalten für synchronen Code ist.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-194">The implementation details for adding `await` support inside `catch` and `finally` clauses ensure that the behavior is consistent with the behavior for synchronous code.</span></span> <span data-ttu-id="5a2ae-195">Wenn Code, der in einer `catch`- oder `finally`-Klausel ausgeführt wird, ausgelöst wird, so sucht die Ausführung nach einer passenden `catch`-Klausel im nächsten Block in der Umgebung.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-195">When code executed in a `catch` or `finally` clause throws, execution looks for a suitable `catch` clause in the next surrounding block.</span></span> <span data-ttu-id="5a2ae-196">Wenn eine aktuelle Ausnahme aufgetreten ist, geht diese Ausnahme verloren.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-196">If there was a current exception, that exception is lost.</span></span> <span data-ttu-id="5a2ae-197">Das Gleiche passiert bei erwarteten Ausdrücken in `catch`- und `finally`-Klauseln: eine passende `catch` wird gesucht und die aktuelle Ausnahme, falls vorhanden, geht verloren.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-197">The same happens with awaited expressions in `catch` and `finally` clauses: a suitable `catch` is searched for, and the current exception, if any, is lost.</span></span>  

> [!NOTE]
> <span data-ttu-id="5a2ae-198">Dieses Verhalten ist der Grund, warum es empfohlen wird, `catch`- und `finally`-Klauseln sorgfältig zu schreiben, um die Einführung neuer Ausnahmen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-198">This behavior is the reason it's recommended to write `catch` and `finally` clauses carefully, to avoid introducing new exceptions.</span></span>

## <a name="initialize-associative-collections-using-indexers"></a><span data-ttu-id="5a2ae-199">Initialisieren von assoziativen Sammlungen unter Verwendung von Indexern</span><span class="sxs-lookup"><span data-stu-id="5a2ae-199">Initialize associative collections using indexers</span></span>

<span data-ttu-id="5a2ae-200">Der *Indexinitialisierer* ist eines von zwei Features, die Auflistungsinitialisierer konsistenter mit der Indexnutzung machen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-200">*Index Initializers* is one of two features that make collection initializers more consistent with index usage.</span></span> <span data-ttu-id="5a2ae-201">In früheren Releases von C# konnten Sie *Sammlungsinitialisierer* nur mit Sammlungen im Sequenzformat (einschließlich <xref:System.Collections.Generic.Dictionary%602>) verwenden, indem Sie Klammern um Schlüssel- und Wertpaare gesetzt haben:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-201">In earlier releases of C#, you could use *collection initializers* with sequence style collections, including <xref:System.Collections.Generic.Dictionary%602>, by adding braces around key and value pairs:</span></span>

[!code-csharp[ListInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#CollectionInitializer)]

<span data-ttu-id="5a2ae-202">Sie können sie mit <xref:System.Collections.Generic.Dictionary%602>-Sammlungen und anderen Typen verwenden, wenn die zugängliche `Add`-Methode mehr als ein Argument akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-202">You can use them with <xref:System.Collections.Generic.Dictionary%602> collections and other types where the accessible `Add` method accepts more than one argument.</span></span> <span data-ttu-id="5a2ae-203">Die neue Syntax unterstützt Zuweisungen mit einem Index in die Auflistung:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-203">The new syntax supports assignment using an index into the collection:</span></span>

[!code-csharp[DictionaryInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#DictionaryInitializer)]

<span data-ttu-id="5a2ae-204">Dieses Feature bedeutet, dass assoziative Container mithilfe von Syntax initialisiert werden können, die ähnlich dem ist, was für Sequenzcontainern für einige Versionen vorhanden war.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-204">This feature means that associative containers can be initialized using syntax similar to what's been in place for sequence containers for several versions.</span></span>

## <a name="extension-add-methods-in-collection-initializers"></a><span data-ttu-id="5a2ae-205">Erweiterungs-`Add`-Methoden in Auflistungsinitialisierern</span><span class="sxs-lookup"><span data-stu-id="5a2ae-205">Extension `Add` methods in collection initializers</span></span>

<span data-ttu-id="5a2ae-206">Ein weiteres Feature zur Vereinfachung der Auflistungsinitialisierer ist die Möglichkeit, eine *Erweiterungsmethode* für die `Add`-Methode zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-206">Another feature that makes collection initialization easier is the ability to use an *extension method* for the `Add` method.</span></span> <span data-ttu-id="5a2ae-207">Dieses Feature wurde für die Parität mit Visual Basic hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-207">This feature was added for parity with Visual Basic.</span></span> <span data-ttu-id="5a2ae-208">Das Feature ist am nützlichsten, wenn Sie über eine benutzerdefinierte Auflistungsklasse verfügen, die eine Methode mit einem anderen Namen besitzt, um semantisch neue Elemente hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-208">The feature is most useful when you have a custom collection class that has a method with a different name to semantically add new items.</span></span>

## <a name="improved-overload-resolution"></a><span data-ttu-id="5a2ae-209">Verbesserte Überladungsauflösung</span><span class="sxs-lookup"><span data-stu-id="5a2ae-209">Improved overload resolution</span></span>

<span data-ttu-id="5a2ae-210">Dieses letzte Feature ist eines, das Sie bestimmt nicht bemerken.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-210">This last feature is one you probably won't notice.</span></span> <span data-ttu-id="5a2ae-211">Es gab Konstrukte, bei denen die vorherige Version des C#-Compilers womögliche einige Methodenaufrufe erkannt hat, einschließlich mehrdeutige Lambdaausdrücke.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-211">There were constructs where the previous version of the C# compiler may have found some method calls involving lambda expressions ambiguous.</span></span> <span data-ttu-id="5a2ae-212">Betrachten Sie diese Methode:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-212">Consider this method:</span></span>

[!code-csharp[AsyncMethod](../../../samples/snippets/csharp/new-in-6/overloads.cs#AsyncMethod)]

<span data-ttu-id="5a2ae-213">In früheren Methoden von C# schlug der Aufruf dieser Methode mithilfe der Syntax für die Methodengruppe fehl:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-213">In earlier versions of C#, calling that method using the method group syntax would fail:</span></span>

[!code-csharp[MethodGroup](../../../samples/snippets/csharp/new-in-6/overloads.cs#MethodGroup)]

<span data-ttu-id="5a2ae-214">Der frühere Compiler konnte nicht richtig zwischen `Task.Run(Action)` und `Task.Run(Func<Task>())` unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-214">The earlier compiler couldn't distinguish correctly between `Task.Run(Action)` and `Task.Run(Func<Task>())`.</span></span> <span data-ttu-id="5a2ae-215">In früheren Versionen müssten Sie einen Lambdaausdruck als Argument verwenden:</span><span class="sxs-lookup"><span data-stu-id="5a2ae-215">In previous versions, you'd need to use a lambda expression as an argument:</span></span>

[!code-csharp[Lambda](../../../samples/snippets/csharp/new-in-6/overloads.cs#Lambda)]

<span data-ttu-id="5a2ae-216">Der C# 6-Compiler bestimmt ordnungsgemäß, dass `Task.Run(Func<Task>())` eine bessere Wahl ist.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-216">The C# 6 compiler correctly determines that `Task.Run(Func<Task>())` is a better choice.</span></span>

### <a name="deterministic-compiler-output"></a><span data-ttu-id="5a2ae-217">Deterministische Compilerausgabe</span><span class="sxs-lookup"><span data-stu-id="5a2ae-217">Deterministic compiler output</span></span>

<span data-ttu-id="5a2ae-218">Die Option `-deterministic` weist den Compiler an, eine Byte für Byte identische Ausgabeassembly für aufeinanderfolgende Kompilierungen der gleichen Quelldateien zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-218">The `-deterministic` option instructs the compiler to produce a byte-for-byte identical output assembly for successive compilations of the same source files.</span></span>

<span data-ttu-id="5a2ae-219">Jede Kompilierung erzeugt standardmäßig eine eindeutige Ausgabe.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-219">By default, every compilation produces unique output on each compilation.</span></span> <span data-ttu-id="5a2ae-220">Der Compiler fügt einen Zeitstempel und eine aus zufälligen Zahlen generierte GUID hinzu.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-220">The compiler adds a timestamp, and a GUID generated from random numbers.</span></span> <span data-ttu-id="5a2ae-221">Sie können diese Option verwenden, wenn Sie die Byte für Byte Ausgabe vergleichen möchten, um die Konsistenz über Builds hinweg sicherzustellen.</span><span class="sxs-lookup"><span data-stu-id="5a2ae-221">You use this option if you want to compare the byte-for-byte output to ensure consistency across builds.</span></span>

<span data-ttu-id="5a2ae-222">Weitere Informationen finden Sie im Artikel zur Compileroption [-deterministic](../language-reference/compiler-options/deterministic-compiler-option.md).</span><span class="sxs-lookup"><span data-stu-id="5a2ae-222">For more information, see the [-deterministic compiler option](../language-reference/compiler-options/deterministic-compiler-option.md) article.</span></span>
