---
title: Neuerungen in C# 9.0 – C#-Leitfaden
description: Überblick über die neuen Features von C# 9.0
ms.date: 09/04/2020
ms.openlocfilehash: c256c03831ac759bc45467f38e85fd3a2884dda4
ms.sourcegitcommit: 532b03d5bbab764d63356193b04cd2281bc01239
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 10/26/2020
ms.locfileid: "92526584"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="2c09a-103">Neuerungen in C# 9.0</span><span class="sxs-lookup"><span data-stu-id="2c09a-103">What's new in C# 9.0</span></span>

<span data-ttu-id="2c09a-104">Mit Version 9.0 wird die Sprache C# um die folgenden Features und Verbesserungen erweitert:</span><span class="sxs-lookup"><span data-stu-id="2c09a-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- [<span data-ttu-id="2c09a-105">Datensätze</span><span class="sxs-lookup"><span data-stu-id="2c09a-105">Records</span></span>](#record-types)
- [<span data-ttu-id="2c09a-106">init-only-Setter</span><span class="sxs-lookup"><span data-stu-id="2c09a-106">Init only setters</span></span>](#init-only-setters)
- [<span data-ttu-id="2c09a-107">Top-Level-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="2c09a-107">Top-level statements</span></span>](#top-level-statements)
- [<span data-ttu-id="2c09a-108">Verbesserungen am Musterabgleich:</span><span class="sxs-lookup"><span data-stu-id="2c09a-108">Pattern matching enhancements</span></span>](#pattern-matching-enhancements)
- <span data-ttu-id="2c09a-109">Integerwerte mit nativer Größe</span><span class="sxs-lookup"><span data-stu-id="2c09a-109">Native sized integers</span></span>
- <span data-ttu-id="2c09a-110">Funktionszeiger</span><span class="sxs-lookup"><span data-stu-id="2c09a-110">Function pointers</span></span>
- <span data-ttu-id="2c09a-111">Unterdrücken der Ausgabe des Flags „localsinit“</span><span class="sxs-lookup"><span data-stu-id="2c09a-111">Suppress emitting localsinit flag</span></span>
- <span data-ttu-id="2c09a-112">Zieltypisierte neue Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="2c09a-112">Target-typed new expressions</span></span>
- <span data-ttu-id="2c09a-113">Statische anonyme Funktionen</span><span class="sxs-lookup"><span data-stu-id="2c09a-113">static anonymous functions</span></span>
- <span data-ttu-id="2c09a-114">Bedingter Ausdruck mit Zieltyp</span><span class="sxs-lookup"><span data-stu-id="2c09a-114">Target-typed conditional expressions</span></span>
- <span data-ttu-id="2c09a-115">Kovariante Rückgabetypen</span><span class="sxs-lookup"><span data-stu-id="2c09a-115">Covariant return types</span></span>
- <span data-ttu-id="2c09a-116">Unterstützung für die Erweiterung `GetEnumerator` in `foreach`-Schleifen</span><span class="sxs-lookup"><span data-stu-id="2c09a-116">Extension `GetEnumerator` support for `foreach` loops</span></span>
- <span data-ttu-id="2c09a-117">Parameter zum Verwerfen von Lambdafunktion</span><span class="sxs-lookup"><span data-stu-id="2c09a-117">Lambda discard parameters</span></span>
- <span data-ttu-id="2c09a-118">Attribute in lokalen Funktionen</span><span class="sxs-lookup"><span data-stu-id="2c09a-118">Attributes on local functions</span></span>
- <span data-ttu-id="2c09a-119">Modulinitialisierer</span><span class="sxs-lookup"><span data-stu-id="2c09a-119">Module initializers</span></span>
- <span data-ttu-id="2c09a-120">Neue Features für partielle Methoden</span><span class="sxs-lookup"><span data-stu-id="2c09a-120">New features for partial methods</span></span>

<span data-ttu-id="2c09a-121">C# 9.0 wird in **.NET 5** unterstützt.</span><span class="sxs-lookup"><span data-stu-id="2c09a-121">C# 9.0 is supported on **.NET 5** .</span></span> <span data-ttu-id="2c09a-122">Weitere Informationen finden Sie unter [C#-Sprachversionsverwaltung](../language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="2c09a-122">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

## <a name="record-types"></a><span data-ttu-id="2c09a-123">Eintragstypen</span><span class="sxs-lookup"><span data-stu-id="2c09a-123">Record types</span></span>

<span data-ttu-id="2c09a-124">In C# 9.0 werden \* *_Datensatztypen_* _ eingeführt. Hierbei handelt es sich um einen Verweistyp, der synthetisierte Methoden bereitstellt, die mithilfe von Wertsemantik Gleichheitsbeziehungen herstellen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-124">C# 9.0 introduces \* *_record types_* _, which are a reference type that provides synthesized methods to provide value semantics for equality.</span></span> <span data-ttu-id="2c09a-125">Datensätze sind immer unveränderbar.</span><span class="sxs-lookup"><span data-stu-id="2c09a-125">Records are immutable by default.</span></span>

<span data-ttu-id="2c09a-126">Sie vereinfachen die Erstellung von unveränderbaren Verweistypen in .NET.</span><span class="sxs-lookup"><span data-stu-id="2c09a-126">Record types make it easy to create immutable reference types in .NET.</span></span> <span data-ttu-id="2c09a-127">In der Vergangenheit wurden .NET-Typen größtenteils als Verweistypen (einschließlich Klassen und anonyme Typen) und Werttypen (einschließlich Strukturen und Tupeln) klassifiziert.</span><span class="sxs-lookup"><span data-stu-id="2c09a-127">Historically, .NET types are largely classified as reference types (including classes and anonymous types) and value types (including structs and tuples).</span></span> <span data-ttu-id="2c09a-128">Obwohl unveränderbare Werttypen empfohlen werden, führen veränderbare Werttypen nur selten zu Fehlern.</span><span class="sxs-lookup"><span data-stu-id="2c09a-128">While immutable value types are recommended, mutable value types don’t often introduce errors.</span></span> <span data-ttu-id="2c09a-129">Werttypvariablen speichern Werte, sodass Änderungen an einer Kopie der ursprünglichen Daten vorgenommen werden, wenn Werttypen an Methoden übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-129">Value type variables hold the values so changes are made to a copy of the original data when value types are passed to methods.</span></span>

<span data-ttu-id="2c09a-130">Auch unveränderbare Verweistypen weisen viele Vorteile auf.</span><span class="sxs-lookup"><span data-stu-id="2c09a-130">There are many advantages to immutable reference types as well.</span></span> <span data-ttu-id="2c09a-131">Diese kommen vor allem in gleichzeitig ausgeführten Programmen mit freigegebenen Daten zum Tragen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-131">These advantages are more pronounced in concurrent programs with shared data.</span></span> <span data-ttu-id="2c09a-132">Bisher mussten Entwickler in C# immer etwas zusätzlichen Code schreiben, um unveränderbare Verweistypen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-132">Unfortunately, C# forced you to write quite a bit of extra code to create immutable reference types.</span></span> <span data-ttu-id="2c09a-133">Dank der Datensätze gibt es nun eine Typdeklaration für unveränderbare Verweistypen, die Gleichheit mithilfe von Wertsemantik herstellt.</span><span class="sxs-lookup"><span data-stu-id="2c09a-133">Records provide a type declaration for an immutable reference type that uses value semantics for equality.</span></span> <span data-ttu-id="2c09a-134">Für die synthetisierten Methoden, die Gleichheitsbeziehungen und Hashcodes generieren, gelten zwei Datensätze als gleich, wenn alle ihre Eigenschaften übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-134">The synthesized methods for equality and hash codes consider two records equal if their properties are all equal.</span></span> <span data-ttu-id="2c09a-135">Sehen Sie sich folgende Definition an:</span><span class="sxs-lookup"><span data-stu-id="2c09a-135">Consider this definition:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordDefinition":::

<span data-ttu-id="2c09a-136">Diese Datensatzdefinition erstellt den Typ `Person`, der zwei schreibgeschützte Eigenschaften aufweist: `FirstName` und `LastName`.</span><span class="sxs-lookup"><span data-stu-id="2c09a-136">The record definition creates a `Person` type that contains two readonly properties: `FirstName` and `LastName`.</span></span> <span data-ttu-id="2c09a-137">Bei dem Typ `Person` handelt es sich um einen Verweistyp.</span><span class="sxs-lookup"><span data-stu-id="2c09a-137">The `Person` type is a reference type.</span></span> <span data-ttu-id="2c09a-138">Wenn Sie sich die Zwischensprache (Intermediate Language, IL) ansehen, handelt es sich um eine Klasse.</span><span class="sxs-lookup"><span data-stu-id="2c09a-138">If you looked at the IL, it’s a class.</span></span> <span data-ttu-id="2c09a-139">Der Typ ist insofern unveränderbar, als dass keine seiner Eigenschaften nach seiner Erstellung geändert werden kann.</span><span class="sxs-lookup"><span data-stu-id="2c09a-139">It’s immutable in that none of the properties can be modified once it's been created.</span></span> <span data-ttu-id="2c09a-140">Wenn Sie einen Datensatztyp definieren, synthetisiert der Compiler verschiedene weitere Methoden für Sie:</span><span class="sxs-lookup"><span data-stu-id="2c09a-140">When you define a record type, the compiler synthesizes several other methods for you:</span></span>

- <span data-ttu-id="2c09a-141">Methoden für wertbasierte Gleichheitsvergleiche</span><span class="sxs-lookup"><span data-stu-id="2c09a-141">Methods for value-based equality comparisons</span></span>
- <span data-ttu-id="2c09a-142">Überschreibungen für <xref:System.Object.GetHashCode></span><span class="sxs-lookup"><span data-stu-id="2c09a-142">Override for <xref:System.Object.GetHashCode></span></span>
- <span data-ttu-id="2c09a-143">Methoden zum Kopieren und Klonen von Membern</span><span class="sxs-lookup"><span data-stu-id="2c09a-143">Copy and Clone members</span></span>
- <span data-ttu-id="2c09a-144">`PrintMembers` und <xref:System.Object.ToString></span><span class="sxs-lookup"><span data-stu-id="2c09a-144">`PrintMembers` and <xref:System.Object.ToString></span></span>

<span data-ttu-id="2c09a-145">Datensätze unterstützen die Vererbung.</span><span class="sxs-lookup"><span data-stu-id="2c09a-145">Records support inheritance.</span></span> <span data-ttu-id="2c09a-146">Ein neuer, von `Person` abgeleiteter Datensatz wird wie folgt deklariert:</span><span class="sxs-lookup"><span data-stu-id="2c09a-146">You can declare a new record derived from `Person` as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="InheritedRecord":::

<span data-ttu-id="2c09a-147">Sie können Datensätze auch versiegeln, um eine weitere Ableitung zu verhindern:</span><span class="sxs-lookup"><span data-stu-id="2c09a-147">You can also seal records to prevent further derivation:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="SealedRecord":::

<span data-ttu-id="2c09a-148">Der Compiler synthetisiert verschiedene Versionen der oben genannten Methoden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-148">The compiler synthesizes different versions of the methods above.</span></span> <span data-ttu-id="2c09a-149">Die Methodensignaturen hängen davon ab, ob der Datensatztyp versiegelt ist und ob die direkte Basisklasse „object“ lautet.</span><span class="sxs-lookup"><span data-stu-id="2c09a-149">The method signatures depend on if the record type is sealed and if the direct base class is object.</span></span> <span data-ttu-id="2c09a-150">Datensätze sollten die folgenden Funktionen aufweisen:</span><span class="sxs-lookup"><span data-stu-id="2c09a-150">Records should have the following capabilities:</span></span>

- <span data-ttu-id="2c09a-151">Die Gleichheit ist wertbasiert, und der Datensatz verfügt über eine Überprüfung, die sicherstellt, dass die Typen übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-151">Equality is value-based, and includes a check that the types match.</span></span> <span data-ttu-id="2c09a-152">`Student` kann beispielsweise nicht gleich `Person` sein, obwohl beide Datensätze denselben Namen enthalten.</span><span class="sxs-lookup"><span data-stu-id="2c09a-152">For example, a `Student` can't be equal to a `Person`, even if the two records share the same name.</span></span>
- <span data-ttu-id="2c09a-153">Für Datensätze wird eine konsistente Zeichenfolgendarstellung für Sie generiert.</span><span class="sxs-lookup"><span data-stu-id="2c09a-153">Records have a consistent string representation generated for you.</span></span>
- <span data-ttu-id="2c09a-154">Datensätze unterstützen die Erstellung von Kopien.</span><span class="sxs-lookup"><span data-stu-id="2c09a-154">Records support copy construction.</span></span> <span data-ttu-id="2c09a-155">Bei einer ordnungsgemäßen Erstellung von Kopien müssen Vererbungshierarchien und von Entwicklern hinzugefügte Eigenschaften berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-155">Correct copy construction must include inheritance hierarchies, and properties added by developers.</span></span>
- <span data-ttu-id="2c09a-156">Datensätze können mit Änderungen kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-156">Records can be copied with modification.</span></span> <span data-ttu-id="2c09a-157">Diese Kopier- und Änderungsvorgänge unterstützen nicht-destruktive Bearbeitungen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-157">These copy and modify operations supports non-destructive mutation.</span></span>

<span data-ttu-id="2c09a-158">Zusätzlich zu den bekannten `Equals`-Überladungen, dem `operator ==` sowie dem `operator !=` synthetisiert der Compiler eine neue `EqualityContract`-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2c09a-158">In addition to the familiar `Equals` overloads, `operator ==`, and `operator !=`, the compiler synthesizes a new `EqualityContract` property.</span></span> <span data-ttu-id="2c09a-159">Die Eigenschaft gibt ein `Type`-Objekt zurück, das mit dem Typ des Datensatzes übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="2c09a-159">The property returns a `Type` object that matches the type of the record.</span></span> <span data-ttu-id="2c09a-160">Wenn der Basistyp `object` entspricht, lautet die Eigenschaft `virtual`.</span><span class="sxs-lookup"><span data-stu-id="2c09a-160">If the base type is `object`, the property is `virtual`.</span></span> <span data-ttu-id="2c09a-161">Wenn der Basistyp einem anderen Datensatztyp entspricht, lautet die Eigenschaft `override`.</span><span class="sxs-lookup"><span data-stu-id="2c09a-161">If the base type is another record type, the property is an `override`.</span></span> <span data-ttu-id="2c09a-162">Wenn der Datensatztyp `sealed` entspricht, lautet die Eigenschaft `sealed`.</span><span class="sxs-lookup"><span data-stu-id="2c09a-162">If the record type is `sealed`, the property is `sealed`.</span></span> <span data-ttu-id="2c09a-163">Die synthetisierte `GetHashCode`-Methode verwendet die `GetHashCode`-Methode aus allen Eigenschaften und Feldern, die im Basis- und im Datensatztyp deklariert wurden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-163">The synthesized `GetHashCode` uses the `GetHashCode` from all properties and fields declared in the base type and the record type.</span></span> <span data-ttu-id="2c09a-164">Diese synthetisierten Methoden erzwingen wertbasierte Gleichheitsbeziehungen für eine gesamte Vererbungshierarchie.</span><span class="sxs-lookup"><span data-stu-id="2c09a-164">These synthesized methods enforce value-based equality throughout an inheritance hierarchy.</span></span> <span data-ttu-id="2c09a-165">Dies bedeutet, dass `Student` niemals als identisch mit `Person` gilt, wenn beide den gleichen Namen enthalten.</span><span class="sxs-lookup"><span data-stu-id="2c09a-165">That means a `Student` will never be considered equal to a `Person` with the same name.</span></span> <span data-ttu-id="2c09a-166">Die Typen sowie auch alle Eigenschaften müssen ebenfalls übereinstimmen, wenn Datensatztypen als gleich gelten sollen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-166">The types of the two records must match as well as all properties shared among the record types being equal.</span></span>

<span data-ttu-id="2c09a-167">Datensätze verfügen außerdem über einen synthetisierten Konstruktor und eine „Klonmethode“ zum Erstellen von Kopien.</span><span class="sxs-lookup"><span data-stu-id="2c09a-167">Records also have a synthesized constructor and a "clone" method for creating copies.</span></span> <span data-ttu-id="2c09a-168">Der synthetisierte Konstruktor verfügt über ein Argument des Datensatztyps.</span><span class="sxs-lookup"><span data-stu-id="2c09a-168">The synthesized constructor has one argument of the record type.</span></span> <span data-ttu-id="2c09a-169">Er generiert einen neuen Datensatz, der für alle Eigenschaften dieselben Werte wie der alte aufweist.</span><span class="sxs-lookup"><span data-stu-id="2c09a-169">It produces a new record with the same values for all properties of the record.</span></span> <span data-ttu-id="2c09a-170">Dieser Konstruktor ist privat, wenn der Datensatz versiegelt ist. Andernfalls ist er geschützt.</span><span class="sxs-lookup"><span data-stu-id="2c09a-170">This constructor is private if the record is sealed, otherwise it's protected.</span></span> <span data-ttu-id="2c09a-171">Die synthetisierte „Klonmethode“ unterstützt die Kopieerstellung für Datensatzhierarchien.</span><span class="sxs-lookup"><span data-stu-id="2c09a-171">The synthesized "clone" method supports copy construction for record hierarchies.</span></span> <span data-ttu-id="2c09a-172">Der Begriff „klonen“ ist in Anführungszeichen gesetzt, weil der tatsächliche Name vom Compiler generiert wird.</span><span class="sxs-lookup"><span data-stu-id="2c09a-172">The term "clone" is in quotes because the actual name is compiler generated.</span></span> <span data-ttu-id="2c09a-173">Es ist nicht möglich, eine Methode namens `Clone` in einem Datensatztyp zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-173">You can't create a method named `Clone` in a record type.</span></span> <span data-ttu-id="2c09a-174">Die synthetisierte „Klonmethode“ gibt den Datensatztyp zurück, der mithilfe der virtuellen Bindung kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="2c09a-174">The synthesized "clone" method returns the type of record being copied using virtual dispatch.</span></span> <span data-ttu-id="2c09a-175">Der Compiler fügt der „Klonmethode“ je nach Zugriffsmodifizierer des Datensatzes (`record`) verschiedene Modifizierer hinzu:</span><span class="sxs-lookup"><span data-stu-id="2c09a-175">The compiler adds different modifiers for the "clone" method depending on the access modifiers on the `record`:</span></span>

- <span data-ttu-id="2c09a-176">Wenn der Datensatztyp `abstract` ist, ist auch die „Klonmethode“ `abstract`.</span><span class="sxs-lookup"><span data-stu-id="2c09a-176">If the record type is `abstract`, the "clone" method is also `abstract`.</span></span> <span data-ttu-id="2c09a-177">Wenn der Basistyp nicht `object` entspricht, ist die Methode ebenfalls `override`.</span><span class="sxs-lookup"><span data-stu-id="2c09a-177">If the base type isn't `object`, the method is also `override`.</span></span>
- <span data-ttu-id="2c09a-178">Für Datensatztypen, die nicht `abstract` sind, wenn der Basistyp `object` lautet, gilt:</span><span class="sxs-lookup"><span data-stu-id="2c09a-178">For record types that aren't `abstract` when the base type is `object`:</span></span>
  - <span data-ttu-id="2c09a-179">Wenn der Datensatz `sealed` ist, werden der „Klonmethode“ keine weiteren Modifizierer hinzugefügt (was bedeutet, dass sie nicht `virtual` ist).</span><span class="sxs-lookup"><span data-stu-id="2c09a-179">If the record is `sealed`, no additional modifiers are added to the "clone" method (meaning it is not `virtual`).</span></span>
  - <span data-ttu-id="2c09a-180">Wenn der Datensatztyp nicht `sealed` ist, ist die „Klonmethode“ `virtual`.</span><span class="sxs-lookup"><span data-stu-id="2c09a-180">If the record isn't `sealed`, the "clone" method is `virtual`.</span></span>
- <span data-ttu-id="2c09a-181">Für Datensatztypen, die nicht `abstract` sind, wenn der Basistyp nicht `object` lautet, gilt:</span><span class="sxs-lookup"><span data-stu-id="2c09a-181">For record types that aren't `abstract` when the base type is not `object`:</span></span>
  - <span data-ttu-id="2c09a-182">Wenn der Datensatz `sealed` ist, ist auch die „Klonmethode“ `sealed`.</span><span class="sxs-lookup"><span data-stu-id="2c09a-182">If the record is `sealed`, the "clone" method is also `sealed`.</span></span>
  - <span data-ttu-id="2c09a-183">Wenn der Datensatztyp nicht `sealed` ist, ist die „Klonmethode“ `override`.</span><span class="sxs-lookup"><span data-stu-id="2c09a-183">If the record isn't `sealed`, the "clone" method is `override`.</span></span>

<span data-ttu-id="2c09a-184">Diese Regeln führen dazu, dass Gleichheit in jeder Hierarchie von Datensatztypen konsistent implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="2c09a-184">The result of all these rules is the equality is implemented consistently across any hierarchy of record types.</span></span> <span data-ttu-id="2c09a-185">Zwei Datensätze sind gleich, wenn ihre Eigenschaften gleich sind und ihre Typen übereinstimmen. Dies wird im folgenden Beispiel veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="2c09a-185">Two records are equal to each other if their properties are equal and their types are the same, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordsEquality":::

<span data-ttu-id="2c09a-186">Der Compiler synthetisiert zwei Methoden, die eine Druck- oder Bildschirmausgabe unterstützen: eine <xref:System.Object.ToString>-Überschreibung und die Methode `PrintMembers`.</span><span class="sxs-lookup"><span data-stu-id="2c09a-186">The compiler synthesizes two methods that support printed output: a <xref:System.Object.ToString> override, and `PrintMembers`.</span></span> <span data-ttu-id="2c09a-187">`PrintMembers` nimmt <xref:System.Text.StringBuilder?displayProperty=nameWithType> als Argument.</span><span class="sxs-lookup"><span data-stu-id="2c09a-187">The `PrintMembers` takes a <xref:System.Text.StringBuilder?displayProperty=nameWithType> as its argument.</span></span> <span data-ttu-id="2c09a-188">Die Methode fügt eine durch Trennzeichen getrennte Liste von Eigenschaftsnamen und -werten für alle Eigenschaften im Datensatztyp an.</span><span class="sxs-lookup"><span data-stu-id="2c09a-188">It appends a comma-separated list of property names and values for all properties in the record type.</span></span> <span data-ttu-id="2c09a-189">`PrintMembers` ruft die Basisimplementierung aller Datensätze ab, die von anderen Datensätzen abgeleitet wurden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-189">`PrintMembers` calls the base implementation for any records derived from other records.</span></span> <span data-ttu-id="2c09a-190">Die <xref:System.Object.ToString>-Überschreibung gibt die Zeichenfolge in geschweiften Klammern (`{` und `}`) zurück, die von `PrintMembers` erzeugt wurde.</span><span class="sxs-lookup"><span data-stu-id="2c09a-190">The <xref:System.Object.ToString> override returns the string produced by `PrintMembers`, surrounded by `{` and `}`.</span></span> <span data-ttu-id="2c09a-191">Die Methode <xref:System.Object.ToString> für `Student` gibt beispielsweise eine Zeichenfolge (`string`) wie im folgenden Beispielcode zurück:</span><span class="sxs-lookup"><span data-stu-id="2c09a-191">For example, the <xref:System.Object.ToString> method for `Student` returns a `string` like the following code:</span></span>

```csharp
"Student { LastName = Wagner, FirstName = Bill, Level = 11 }"
```

<span data-ttu-id="2c09a-192">In den bisher gezeigten Beispielen wird eine herkömmliche Syntax für die Deklaration von Eigenschaften verwendet.</span><span class="sxs-lookup"><span data-stu-id="2c09a-192">The examples shown so far use traditional syntax to declare properties.</span></span> <span data-ttu-id="2c09a-193">Es gibt eine prägnantere Lösung namens _*_positionelle Datensätze_*_ .</span><span class="sxs-lookup"><span data-stu-id="2c09a-193">There's a more concise form called _*_positional records_*_ .</span></span>  <span data-ttu-id="2c09a-194">Nachstehend finden Sie die drei Datensatztypen, die zuvor als positionelle Datensätze definiert wurden:</span><span class="sxs-lookup"><span data-stu-id="2c09a-194">Here are the three record types defined earlier as positional records:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="PositionalRecords":::

<span data-ttu-id="2c09a-195">Diese Deklarationen erstellen die gleiche Funktionalität wie die frühere Version (mit einigen zusätzlichen Features, die im folgenden Abschnitt behandelt werden).</span><span class="sxs-lookup"><span data-stu-id="2c09a-195">These declarations create the same functionality as the earlier version (with a couple extra features covered in the following section).</span></span> <span data-ttu-id="2c09a-196">Diese Deklarationen enden mit einem Semikolon anstelle von Klammern, da diese Datensätze keine zusätzlichen Methoden hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-196">These declarations end with a semicolon instead of brackets because these records don't add additional methods.</span></span> <span data-ttu-id="2c09a-197">Sie können einen Körper und beliebige zusätzliche Methoden einfügen:</span><span class="sxs-lookup"><span data-stu-id="2c09a-197">You can add a body, and include any additional methods as well:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="RecordsWithMethods":::

<span data-ttu-id="2c09a-198">Der Compiler erstellt eine `Deconstruct`-Methode für positionelle Datensätze.</span><span class="sxs-lookup"><span data-stu-id="2c09a-198">The compiler produces a `Deconstruct` method for positional records.</span></span> <span data-ttu-id="2c09a-199">Die `Deconstruct`-Methode verfügt über Parameter, die mit den Namen aller öffentlichen Eigenschaften im Datensatztyp übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-199">The `Deconstruct` method has parameters that match the names of all public properties in the record type.</span></span> <span data-ttu-id="2c09a-200">Mithilfe der `Deconstruct`-Methode kann der Datensatz in seine Komponenteneigenschaften dekonstruiert werden:</span><span class="sxs-lookup"><span data-stu-id="2c09a-200">The `Deconstruct` method can be used to deconstruct the record into its component properties:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="DeconstructRecord":::

<span data-ttu-id="2c09a-201">Datensätze unterstützen auch _*_with-Ausdrücke_*_ .</span><span class="sxs-lookup"><span data-stu-id="2c09a-201">Finally, records support _*_with-expressions_*_ .</span></span> <span data-ttu-id="2c09a-202">Ein _*_with-Ausdruck_*_ weist den Compiler an, eine Kopie eines Datensatzes _mit\* (engl.: „with“) bestimmten geänderten Eigenschaften zu erstellen:</span><span class="sxs-lookup"><span data-stu-id="2c09a-202">A _*_with-expression_*_ instructs the compiler to create a copy of a record, but _with\* specified properties modified:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="Wither":::

<span data-ttu-id="2c09a-203">In der obigen Zeile wird ein neuer `Person`-Datensatz erstellt, bei dem die `LastName`-Eigenschaft eine Kopie von `person` ist und `FirstName` „Paul“ entspricht.</span><span class="sxs-lookup"><span data-stu-id="2c09a-203">The above line creates a new `Person` record where the `LastName` property is a copy of `person`, and the `FirstName` is "Paul".</span></span> <span data-ttu-id="2c09a-204">Sie können in with-Ausdrücken eine beliebige Anzahl von Eigenschaften festlegen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-204">You can set any number of properties in a with-expression.</span></span>  <span data-ttu-id="2c09a-205">Jeder dieser synthetisierten Member, außer der „Klonmethode“, kann von Ihnen selbst geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-205">Any of the synthesized members except the "clone" method may be written by you.</span></span> <span data-ttu-id="2c09a-206">Wenn ein Datensatztyp über eine Methode verfügt, die mit der Signatur einer beliebigen synthetisierten Methode übereinstimmt, wird diese Methode vom Compiler nicht synthetisiert.</span><span class="sxs-lookup"><span data-stu-id="2c09a-206">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span> <span data-ttu-id="2c09a-207">Der zuvor verwendete Beispieldatensatz `Dog` enthält eine manuell geschriebene <xref:System.String.ToString>-Methode als Beispiel.</span><span class="sxs-lookup"><span data-stu-id="2c09a-207">The earlier `Dog` record example contains a hand coded <xref:System.String.ToString> method as an example.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="2c09a-208">init-only-Setter</span><span class="sxs-lookup"><span data-stu-id="2c09a-208">Init only setters</span></span>

<span data-ttu-id="2c09a-209">\***Nur-init-Setter** _ bieten eine konsistente Syntax zum Initialisieren von Objektmembern.</span><span class="sxs-lookup"><span data-stu-id="2c09a-209">\***Init only setters** _ provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="2c09a-210">Eigenschafteninitialisierer verdeutlichen, welcher Wert welche Eigenschaft festlegt.</span><span class="sxs-lookup"><span data-stu-id="2c09a-210">Property initializers make it clear which value is setting which property.</span></span> <span data-ttu-id="2c09a-211">Der Nachteil ist, dass diese Eigenschaften festlegbar sein müssen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-211">The downside is that those properties must be settable.</span></span> <span data-ttu-id="2c09a-212">Ab C# 9.0 können Sie `init`-Zugriffsmethoden anstelle von `set`-Zugriffsmethoden für Eigenschaften und Indexer erstellen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-212">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="2c09a-213">Aufrufer können diese Werte mithilfe der Syntax von Eigenschafteninitialisierern in Erstellungsausdrücken festlegen. Diese Eigenschaften sind jedoch nach Abschluss der Erstellung schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="2c09a-213">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="2c09a-214">Nur-init-Setter bieten Ihnen die Möglichkeit, den Zustand innerhalb eines bestimmten Zeitfensters zu ändern.</span><span class="sxs-lookup"><span data-stu-id="2c09a-214">Init only setters provide a window to change state.</span></span> <span data-ttu-id="2c09a-215">Dieses Zeitfenster schließt sich nach Abschluss der Konstruktionsphase.</span><span class="sxs-lookup"><span data-stu-id="2c09a-215">That window closes when the construction phase ends.</span></span> <span data-ttu-id="2c09a-216">Die Konstruktionsphase endet effektiv, nachdem die gesamte Initialisierung, einschließlich aller Eigenschafteninitialisierer und with-Ausdrücke, abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="2c09a-216">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="2c09a-217">Sie können Nur-`init`-Setter in einem jedem Typ deklarieren, den Sie schreiben.</span><span class="sxs-lookup"><span data-stu-id="2c09a-217">You can declare `init` only setters in any type you write.</span></span> <span data-ttu-id="2c09a-218">Die folgende Struktur definiert z. B. eine Struktur zur Wetterbeobachtung:</span><span class="sxs-lookup"><span data-stu-id="2c09a-218">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="2c09a-219">Aufrufer können die Werte mithilfe der Syntax von Eigenschafteninitialisierern festlegen und gleichzeitig die Unveränderlichkeit wahren:</span><span class="sxs-lookup"><span data-stu-id="2c09a-219">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="2c09a-220">Die Änderung einer Beobachtung nach der Initialisierung führt jedoch zu einem Fehler, da eine Nur-init-Eigenschaft außerhalb der Initialisierung zugewiesen wird:</span><span class="sxs-lookup"><span data-stu-id="2c09a-220">But, changing an observation after initialization is an error by assigning to an init-only property outside of initialization:</span></span>

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

<span data-ttu-id="2c09a-221">Nur-init-Setter können nützlich sein, um Basisklasseneigenschaften von abgeleiteten Klassen festzulegen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-221">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="2c09a-222">Sie können auch mithilfe von Hilfsprogrammen abgeleitete Eigenschaften in einer Basisklasse festlegen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-222">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="2c09a-223">Positionelle Datensätze deklarieren Eigenschaften mithilfe von Nur-init-Settern.</span><span class="sxs-lookup"><span data-stu-id="2c09a-223">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="2c09a-224">Diese Setter werden in with-Ausdrücken verwendet.</span><span class="sxs-lookup"><span data-stu-id="2c09a-224">Those setters are used in with-expressions.</span></span> <span data-ttu-id="2c09a-225">Sie können Nur-init-Setter für alle Klassen (`class`) oder Strukturen (`struct`) deklarieren, die Sie definieren.</span><span class="sxs-lookup"><span data-stu-id="2c09a-225">You can declare init only setters for any `class` or `struct` you define.</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="2c09a-226">Top-Level-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="2c09a-226">Top-level statements</span></span>

<span data-ttu-id="2c09a-227">Mithilfe von _*_allgemeinen Anweisungen_*_ lässt sich der Code in vielen Anwendungen stark verkürzen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-227">_*_Top-level statements_*_ remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="2c09a-228">Dies ist das kanonische</span><span class="sxs-lookup"><span data-stu-id="2c09a-228">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="2c09a-229">Hallo-Welt-Programm („Hello World“):</span><span class="sxs-lookup"><span data-stu-id="2c09a-229">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="2c09a-230">Nur eine der Codezeilen ruft eine Aktion hervor.</span><span class="sxs-lookup"><span data-stu-id="2c09a-230">There’s only one line of code that does anything.</span></span> <span data-ttu-id="2c09a-231">Mit allgemeinen Anweisungen können Sie all diese Codebausteine durch die `using`-Anweisung und die eine Zeile ersetzen, die die Aktion verursacht:</span><span class="sxs-lookup"><span data-stu-id="2c09a-231">With top-level statements, you can replace all that boilerplate with the `using` statement and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="2c09a-232">Wenn Sie ein einzeiliges Programm schreiben möchten, können Sie die `using`-Anweisung auch entfernen und den vollqualifizierten Typnamen verwenden:</span><span class="sxs-lookup"><span data-stu-id="2c09a-232">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="2c09a-233">Allgemeine Anweisungen dürfen nur einer Anwendungsdatei eingesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-233">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="2c09a-234">Wenn der Compiler in mehreren Quelldateien allgemeine Anweisungen findet, führt dies zu einem Fehler.</span><span class="sxs-lookup"><span data-stu-id="2c09a-234">If the compiler finds top-level statements in multiple source files, it’s an error.</span></span> <span data-ttu-id="2c09a-235">Ein Fehler wird ebenfalls zurückgegeben, wenn Sie allgemeine Anweisungen mit einer deklarierten Einstiegspunktmethode des Programms kombinieren (in der Regel eine `Main`-Methode).</span><span class="sxs-lookup"><span data-stu-id="2c09a-235">It’s also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="2c09a-236">Sie können sich dies vorstellen, als ob eine Datei die Anweisungen enthält, die normalerweise in die `Main`-Methode einer `Program`-Klasse geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-236">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="2c09a-237">Einer der häufigsten Anwendungsfälle für dieses Feature ist die Erstellung von Lehrmaterial.</span><span class="sxs-lookup"><span data-stu-id="2c09a-237">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="2c09a-238">Angehende C#-Entwickler können die kanonische Hallo-Welt-Anwendung</span><span class="sxs-lookup"><span data-stu-id="2c09a-238">Beginner C# developers can write the canonical “Hello World!”</span></span> <span data-ttu-id="2c09a-239">in einer oder zwei Codezeilen schreiben.</span><span class="sxs-lookup"><span data-stu-id="2c09a-239">in one or two lines of code.</span></span> <span data-ttu-id="2c09a-240">Keiner der zusätzlichen Codebausteine ist erforderlich.</span><span class="sxs-lookup"><span data-stu-id="2c09a-240">None of the extra ceremony is needed.</span></span> <span data-ttu-id="2c09a-241">Aber auch erfahrene Entwickler werden viele Verwendungsmöglichkeiten für dieses Feature finden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-241">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="2c09a-242">Allgemeine Anweisungen bieten skriptähnliche Experimentierfunktionen, ähnlich wie Jupyter Notebook-Instanzen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-242">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="2c09a-243">Allgemeine Anweisungen eignen sich auch hervorragend für kleine Konsolenprogramme und Hilfsprogramme.</span><span class="sxs-lookup"><span data-stu-id="2c09a-243">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="2c09a-244">Azure-Funktionen sind ein idealer Anwendungsfall für allgemeine Anweisungen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-244">Azure functions are an ideal use case for top-level statements.</span></span>

<span data-ttu-id="2c09a-245">Vor allem schränken allgemeine Anweisungen weder den Umfang noch die Komplexität einer Anwendung ein.</span><span class="sxs-lookup"><span data-stu-id="2c09a-245">Most importantly, top-level statements don't limit your application’s scope or complexity.</span></span> <span data-ttu-id="2c09a-246">Diese Anweisungen können auf jede beliebige .NET-Klasse zugreifen oder diese verwenden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-246">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="2c09a-247">Außerdem schränken sie nicht die Verwendung von Befehlszeilenargumenten oder Rückgabewerten ein.</span><span class="sxs-lookup"><span data-stu-id="2c09a-247">They also don’t limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="2c09a-248">Allgemeine Anweisungen können auf ein Zeichenfolgenarray namens „args“ zugreifen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-248">Top-level statements can access an array of strings named args.</span></span> <span data-ttu-id="2c09a-249">Wenn allgemeine Anweisungen einen ganzzahligen Wert zurückgeben, wird dieser Wert zum ganzzahligen Rückgabecode einer synthetisierten `Main`-Methode.</span><span class="sxs-lookup"><span data-stu-id="2c09a-249">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="2c09a-250">Allgemeine Anweisungen können async-Ausdrücke enthalten.</span><span class="sxs-lookup"><span data-stu-id="2c09a-250">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="2c09a-251">In diesem Fall gibt der synthetisierte Einstiegspunkt `Task` oder `Task<int>` zurück.</span><span class="sxs-lookup"><span data-stu-id="2c09a-251">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="2c09a-252">Verbesserungen am Musterabgleich:</span><span class="sxs-lookup"><span data-stu-id="2c09a-252">Pattern matching enhancements</span></span>

<span data-ttu-id="2c09a-253">C# 9 enthält neue Verbesserungen am Musterabgleich:</span><span class="sxs-lookup"><span data-stu-id="2c09a-253">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="2c09a-254">_*_Typmuster_*_ gleichen eine Variable mit einem Typ ab.</span><span class="sxs-lookup"><span data-stu-id="2c09a-254">_*_Type patterns_*_ match a variable is a type</span></span>
- <span data-ttu-id="2c09a-255">_*_In Klammern gesetzte Muster_*_ erzwingen den Vorrang von Musterkombinationen oder heben diesen hervor.</span><span class="sxs-lookup"><span data-stu-id="2c09a-255">_*_Parenthesized patterns_*_ enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="2c09a-256">In _*_konjunktiven `and`-Mustern_*_ müssen beide Muster übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-256">_*_Conjunctive `and` patterns_*_ require both patterns to match</span></span>
- <span data-ttu-id="2c09a-257">In _*_disjunktiven `or`-Mustern_*_ muss eines von beiden Mustern übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-257">_*_Disjunctive `or` patterns_*_ require either pattern to match</span></span>
- <span data-ttu-id="2c09a-258">In _*_negierten `not`-Mustern_*_ darf ein Muster nicht übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-258">_*_Negated `not` patterns_*_ require that a pattern doesn’t match</span></span>
- <span data-ttu-id="2c09a-259">In _*_relationalen Mustern_*_ muss die Eingabe kleiner als, größer als, kleiner gleich oder größer gleich einer angegebenen Konstante sein.</span><span class="sxs-lookup"><span data-stu-id="2c09a-259">_*_Relational patterns_*_ require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="2c09a-260">Diese Muster erweitern die Mustersyntax.</span><span class="sxs-lookup"><span data-stu-id="2c09a-260">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="2c09a-261">Sehen Sie sich die folgenden Beispiele an:</span><span class="sxs-lookup"><span data-stu-id="2c09a-261">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="2c09a-262">Dies ist eine alternative Schreibweise mit optionalen Klammern, die verdeutlichen, dass `and` Vorrang vor `or` hat:</span><span class="sxs-lookup"><span data-stu-id="2c09a-262">Alternatively, with optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="2c09a-263">Einer der gängigsten Anwendungsfälle ist eine neue Syntax für NULL-Überprüfungen:</span><span class="sxs-lookup"><span data-stu-id="2c09a-263">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="2c09a-264">Jedes dieser Muster kann in jedem Kontext verwendet werden, in dem Muster zulässig sind: `is`-Musterausdrücke, `switch`-Ausdrücke, geschachtelte Muster und das Muster einer `case`-Bezeichnung einer `switch`-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="2c09a-264">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement’s `case` label.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="2c09a-265">Leistung und Interop</span><span class="sxs-lookup"><span data-stu-id="2c09a-265">Performance and interop</span></span>

<span data-ttu-id="2c09a-266">Diese drei neuen Features verbessern die Unterstützung für die native Interop und spezifische Bibliotheken, die eine hohe Leistung erfordern: ganze Zahlen mit nativer Größe, Funktionszeiger und das Auslassen des `localsinit`-Flags.</span><span class="sxs-lookup"><span data-stu-id="2c09a-266">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="2c09a-267">Ganze Zahlen mit nativer Größe, `nint` und `nuint`, sind ganzzahlige Typen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-267">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="2c09a-268">Sie werden durch die zugrunde liegenden Typen <xref:System.IntPtr?displayProperty=nameWithType> und <xref:System.UIntPtr?displayProperty=nameWithType> ausgedrückt.</span><span class="sxs-lookup"><span data-stu-id="2c09a-268">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2c09a-269">Der Compiler gibt zusätzliche Konvertierungen und Vorgänge für diese Typen als native ganze Zahlen aus.</span><span class="sxs-lookup"><span data-stu-id="2c09a-269">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="2c09a-270">Integer mit nativer Größe definieren die Eigenschaften für `MaxValue` oder `MinValue`.</span><span class="sxs-lookup"><span data-stu-id="2c09a-270">Native sized integers define properties for `MaxValue` or `MinValue`.</span></span> <span data-ttu-id="2c09a-271">Diese Werte können nicht als Kompilierzeitkonstanten ausgedrückt werden, da sie von der nativen Größe einer ganzen Zahl auf dem Zielcomputer abhängen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-271">These values can't be expressed as compile time constants because they depend on the native size of an integer on the target machine.</span></span> <span data-ttu-id="2c09a-272">Diese Werte sind zur Laufzeit schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="2c09a-272">Those values are readonly at runtime.</span></span> <span data-ttu-id="2c09a-273">Konstantenwerte können für `nint` in folgendem Bereich verwendet werden: [`int.MinValue` ...</span><span class="sxs-lookup"><span data-stu-id="2c09a-273">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="2c09a-274">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="2c09a-274">`int.MaxValue`].</span></span> <span data-ttu-id="2c09a-275">Konstantenwerte können für `nuint` in folgendem Bereich verwendet werden: [`uint.MinValue` ...</span><span class="sxs-lookup"><span data-stu-id="2c09a-275">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="2c09a-276">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="2c09a-276">`uint.MaxValue`].</span></span> <span data-ttu-id="2c09a-277">Der Compiler führt eine konstante Faltung aller unären und binären Operatoren mithilfe der Typen <xref:System.Int32?displayProperty=nameWithType> und <xref:System.UInt32?displayProperty=nameWithType> durch.</span><span class="sxs-lookup"><span data-stu-id="2c09a-277">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="2c09a-278">Wenn das Ergebnis nicht in 32 Bit passt, wird der Vorgang zur Laufzeit ausgeführt und nicht als Konstante angesehen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-278">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="2c09a-279">Ganze Zahlen mit nativer Größe können die Leistung in Szenarios steigern, in denen ganzzahlige Mathematik intensiv angewendet und die schnellstmögliche Leistung benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="2c09a-279">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span>

<span data-ttu-id="2c09a-280">Funktionszeiger bieten eine einfache Syntax für den Zugriff auf die IL-Opcodes `ldftn` und `calli`.</span><span class="sxs-lookup"><span data-stu-id="2c09a-280">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="2c09a-281">Sie können Funktionszeiger mithilfe der neuen `delegate_`-Syntax deklarieren.</span><span class="sxs-lookup"><span data-stu-id="2c09a-281">You can declare function pointers using new `delegate_` syntax.</span></span> <span data-ttu-id="2c09a-282">Ein `delegate*`-Typ ist ein Typ von Zeiger.</span><span class="sxs-lookup"><span data-stu-id="2c09a-282">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="2c09a-283">Bei einem Aufruf des `delegate*`-Typs wird `calli` verwendet. Dies ist ein Unterschied zu einem Delegaten, der `callvirt` für die `Invoke()`-Methode verwendet.</span><span class="sxs-lookup"><span data-stu-id="2c09a-283">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="2c09a-284">Syntaktisch sind die Aufrufe identisch.</span><span class="sxs-lookup"><span data-stu-id="2c09a-284">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="2c09a-285">Bei Aufrufen von Funktionszeigern wird die `managed`-Aufrufkonvention verwendet.</span><span class="sxs-lookup"><span data-stu-id="2c09a-285">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="2c09a-286">Wenn Sie deklarieren möchten, dass Sie die `unmanaged`-Aufrufkonvention benötigen, müssen Sie nach der `delegate*`-Syntax das Schlüsselwort `unmanaged` einfügen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-286">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="2c09a-287">Andere Aufrufkonventionen können mithilfe von Attributen in der `delegate*`-Deklaration angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-287">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span>

<span data-ttu-id="2c09a-288">Schließlich können Sie <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> hinzufügen, um den Compiler anzuweisen, das `localsinit`-Flag nicht auszugeben.</span><span class="sxs-lookup"><span data-stu-id="2c09a-288">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="2c09a-289">Dieses Flag weist die Common Language Runtime an, alle lokalen Variablen mit 0 (Null) zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="2c09a-289">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="2c09a-290">Das `localsinit`-Flag ist das Standardverhalten von C# seit Version 1.0.</span><span class="sxs-lookup"><span data-stu-id="2c09a-290">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="2c09a-291">Die zusätzliche Nullinitialisierung kann jedoch in einigen Szenarios zu nachweisbaren Leistungseinbußen führen,</span><span class="sxs-lookup"><span data-stu-id="2c09a-291">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="2c09a-292">insbesondere wenn Sie `stackalloc` verwenden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-292">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="2c09a-293">In diesen Fällen können Sie <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute> hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-293">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="2c09a-294">Sie können die Klasse einer einzelnen Methode oder Eigenschaft, zu `class`/`struct`/`interface` oder sogar zu einem Modul hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-294">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="2c09a-295">Dieses Attribut hat keine Auswirkung auf `abstract`-Methoden. Es beeinflusst den für die Implementierung generierten Code.</span><span class="sxs-lookup"><span data-stu-id="2c09a-295">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span>

<span data-ttu-id="2c09a-296">Diese Features können die Leistung in einigen Szenarios verbessern.</span><span class="sxs-lookup"><span data-stu-id="2c09a-296">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="2c09a-297">Sie sollten jedoch nur nach einem sorgfältigen Leistungsvergleich vor und nach der Einführung eingesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-297">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="2c09a-298">Code, der ganze Zahlen in nativer Größe enthält, muss auf mehreren Zielplattformen mit unterschiedlichen Größen von ganzen Zahlen getestet werden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-298">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="2c09a-299">Die anderen Features erfordern unsicheren Code.</span><span class="sxs-lookup"><span data-stu-id="2c09a-299">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="2c09a-300">Anpassen und Fertigstellen von Features</span><span class="sxs-lookup"><span data-stu-id="2c09a-300">Fit and finish features</span></span>

<span data-ttu-id="2c09a-301">Viele der anderen Features helfen Ihnen, Code effizienter zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="2c09a-301">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="2c09a-302">In C# 9.0 können Sie den Typ in einem neuen [`new`-Ausdruck](../language-reference/operators/new-operator.md) weglassen, wenn der Typ des erstellten Objekts bereits bekannt ist.</span><span class="sxs-lookup"><span data-stu-id="2c09a-302">In C# 9.0, you can omit the type in a [`new` expression](../language-reference/operators/new-operator.md) when the created object's type is already known.</span></span> <span data-ttu-id="2c09a-303">Die häufigste Anwendungsfall hierfür sind Felddeklarationen:</span><span class="sxs-lookup"><span data-stu-id="2c09a-303">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="2c09a-304">Der Zieltyp `new` kann auch verwendet werden, wenn Sie ein neues Objekt erstellen müssen, das als Argument an eine Methode übergeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="2c09a-304">Target-typed `new` can also be used when you need to create a new object to pass as an argument to a method.</span></span> <span data-ttu-id="2c09a-305">In diesem Fall können Sie eine `ForecastFor()`-Methode mit der folgenden Signatur implementieren:</span><span class="sxs-lookup"><span data-stu-id="2c09a-305">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="2c09a-306">Sie können sie wie folgt aufrufen:</span><span class="sxs-lookup"><span data-stu-id="2c09a-306">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="2c09a-307">Ein weiterer nützlicher Anwendungsfall für dieses Feature ist die Kombination mit Nur-init-Eigenschaften, um ein neues Objekt zu initialisieren:</span><span class="sxs-lookup"><span data-stu-id="2c09a-307">Another nice use for this feature is to combine it with init only properties to initialize a new object:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="2c09a-308">Mithilfe einer `return new();`-Anweisung können Sie eine Instanz zurückgeben, die vom Standardkonstruktor erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="2c09a-308">You can return an instance created by the default constructor using a `return new();` statement.</span></span>

<span data-ttu-id="2c09a-309">Ein ähnliches Feature verbessert die Zieltypauflösung von [bedingten Ausdrücken](../language-reference/operators/conditional-operator.md).</span><span class="sxs-lookup"><span data-stu-id="2c09a-309">A similar feature improves the target type resolution of [conditional expressions](../language-reference/operators/conditional-operator.md).</span></span> <span data-ttu-id="2c09a-310">Aufgrund dieser Änderung müssen die beiden Ausdrücke keine implizite Konvertierung von einem in den anderen aufweisen, sondern können beide über implizite Konvertierungen in einen Zieltyp verfügen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-310">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a target type.</span></span> <span data-ttu-id="2c09a-311">Diese Änderung wird Ihnen wahrscheinlich nicht auffallen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-311">You likely won’t notice this change.</span></span> <span data-ttu-id="2c09a-312">Was Sie bemerken werden, ist, dass einige bedingte Ausdrücke, die zuvor eine Umwandlung erforderten oder nicht kompiliert werden konnten, jetzt funktionieren.</span><span class="sxs-lookup"><span data-stu-id="2c09a-312">What you will notice is that some conditional expressions that previously required casts or wouldn’t compile now just work.</span></span>

<span data-ttu-id="2c09a-313">Ab C# 9.0 können Sie [Lambdaausdrücken](../language-reference/operators/lambda-expressions.md) oder [anonymen Methoden](../language-reference/operators/delegate-operator.md) den Modifizierer `static` hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-313">Starting in C# 9.0, you can add the `static` modifier to [lambda expressions](../language-reference/operators/lambda-expressions.md) or [anonymous methods](../language-reference/operators/delegate-operator.md).</span></span> <span data-ttu-id="2c09a-314">Statische Lambdaausdrücke entsprechen den lokalen `static`-Funktionen: Eine statische Lambdafunktion oder anonyme Methode kann weder lokale Variablen noch den Instanzzustand erfassen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-314">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous method can't capture local variables or instance state.</span></span> <span data-ttu-id="2c09a-315">Der Modifizierer `static` verhindert, dass versehentlich andere Variablen erfasst werden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-315">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="2c09a-316">Kovariante Rückgabetypen flexibilisieren die Rückgabetypen von [override](../language-reference/keywords/override.md)-Methoden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-316">Covariant return types provide flexibility for the return types of [override](../language-reference/keywords/override.md) methods.</span></span> <span data-ttu-id="2c09a-317">Eine override-Methode kann einen Typ zurückgeben, der vom Rückgabetyp der überschriebenen Basismethode abgeleitet wurde.</span><span class="sxs-lookup"><span data-stu-id="2c09a-317">An override method can return a type derived from the return type of the overridden base method.</span></span> <span data-ttu-id="2c09a-318">Dies kann sowohl für Datensätze als auch für andere Typen nützlich sein, die virtuelle Klon- oder Factorymethoden unterstützen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-318">This can be useful for records and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="2c09a-319">Außerdem erkennen und verwenden [`foreach`-Schleifen](../language-reference/keywords/foreach-in.md) eine `GetEnumerator`-Erweiterungsmethode, die ansonsten das `foreach`-Muster erfüllt.</span><span class="sxs-lookup"><span data-stu-id="2c09a-319">In addition, the [`foreach` loop](../language-reference/keywords/foreach-in.md) will recognize and use an extension method `GetEnumerator` that otherwise satisfies the `foreach` pattern.</span></span> <span data-ttu-id="2c09a-320">Diese Änderung bedeutet, dass `foreach` mit anderen musterbasierten Konstruktionen, z. B. mit dem async-Muster, sowie der musterbasierten Dekonstruktion konsistent ist.</span><span class="sxs-lookup"><span data-stu-id="2c09a-320">This change means `foreach` is consistent with other pattern-based constructions such as the async pattern, and pattern-based deconstruction.</span></span> <span data-ttu-id="2c09a-321">In der Praxis bedeutet diese Änderung, dass Sie jedem Typ `foreach`-Unterstützung hinzufügen können.</span><span class="sxs-lookup"><span data-stu-id="2c09a-321">In practice, this change means you can add `foreach` support to any type.</span></span> <span data-ttu-id="2c09a-322">Sie sollten die Verwendung von „foreach“ jedoch auf die Fälle beschränken, in denen die Enumeration eines Objekts in Ihrem Softwareentwurf sinnvoll ist.</span><span class="sxs-lookup"><span data-stu-id="2c09a-322">You should limit its use to when enumerating an object makes sense in your design.</span></span>

<span data-ttu-id="2c09a-323">Sie können auch Ausschussvariablen als Parameter für Lambdaausdrücke verwenden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-323">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="2c09a-324">So müssen Sie das Argument nicht mehr benennen, und der Compiler muss es unter Umständen gar nicht verwenden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-324">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="2c09a-325">Sie nutzen einfach `_` für alle Argumente.</span><span class="sxs-lookup"><span data-stu-id="2c09a-325">You use the `_` for any argument.</span></span> <span data-ttu-id="2c09a-326">Weitere Informationen finden Sie im Abschnitt [Eingabeparameter eines Lambdaausdrucks](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) des Artikels [Lambdaausdrücke](../language-reference/operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="2c09a-326">For more information, see the [Input parameters of a lambda expression](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](../language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="2c09a-327">Schließlich haben Sie nun die Möglichkeit, Attribute auf [lokale Funktionen](../programming-guide/classes-and-structs/local-functions.md) anzuwenden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-327">Finally, you can now apply attributes to [local functions](../programming-guide/classes-and-structs/local-functions.md).</span></span> <span data-ttu-id="2c09a-328">Sie können beispielsweise [Nullable-Attributanmerkungen](../language-reference/attributes/nullable-analysis.md) auf lokale Funktionen anwenden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-328">For example, you can apply [nullable attribute annotations](../language-reference/attributes/nullable-analysis.md) to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="2c09a-329">Unterstützung für Code-Generatoren</span><span class="sxs-lookup"><span data-stu-id="2c09a-329">Support for code generators</span></span>

<span data-ttu-id="2c09a-330">Die beiden letzten Features dienen der Unterstützung von C#-Code-Generatoren.</span><span class="sxs-lookup"><span data-stu-id="2c09a-330">Two final features support C# code generators.</span></span> <span data-ttu-id="2c09a-331">C#-Code-Generatoren sind eine Komponente, die Sie selbst schreiben können und die einem Roslyn-Analysetool oder einem Codefix ähnelt.</span><span class="sxs-lookup"><span data-stu-id="2c09a-331">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="2c09a-332">Der Unterschied besteht darin, dass Code-Generatoren Code analysieren und im Rahmen der Kompilierung neue Quellcodedateien schreiben.</span><span class="sxs-lookup"><span data-stu-id="2c09a-332">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="2c09a-333">Ein typischer Code-Generator durchsucht Code nach Attributen oder weiteren Konventionen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-333">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="2c09a-334">Ein Code-Generator liest Attribute oder andere Codeelemente mithilfe der Roslyn-Analyse-APIs.</span><span class="sxs-lookup"><span data-stu-id="2c09a-334">A code generator read attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="2c09a-335">Auf Grundlage dieser Informationen fügt er der Kompilierung neuen Code hinzu.</span><span class="sxs-lookup"><span data-stu-id="2c09a-335">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="2c09a-336">Quell-Generatoren können nur Code hinzufügen. Sie sind nicht berechtigt, vorhandenen Code während der Kompilierung zu ändern.</span><span class="sxs-lookup"><span data-stu-id="2c09a-336">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="2c09a-337">Bei den beiden Features für Code-Generatoren sind handelt es sich um Erweiterungen für die \* **partielle Methodensyntax** _ und für _*_Modulinitialisierer_*_ .</span><span class="sxs-lookup"><span data-stu-id="2c09a-337">The two features added for code generators are extensions to \* **partial method syntax** _, and _*_module initializers_*_ .</span></span> <span data-ttu-id="2c09a-338">Zuerst zu den Änderungen an partiellen Methoden:</span><span class="sxs-lookup"><span data-stu-id="2c09a-338">First, the changes to partial methods.</span></span> <span data-ttu-id="2c09a-339">Vor C# 9.0 waren partielle Methoden privat (`private`) und konnten weder einen Zugriffsmodifizierer angeben noch über eine leere Rückgabe (`void`) oder `out`-Parameter verfügen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-339">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="2c09a-340">Diese Einschränkungen führten dazu, dass der Compiler alle Aufrufe von partiellen Methoden entfernte, wenn keine Methodenimplementierung bereitgestellt wurde.</span><span class="sxs-lookup"><span data-stu-id="2c09a-340">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="2c09a-341">In C# 9.0 werden diese Einschränkungen behoben. Deklarationen von partiellen Methoden müssen jetzt jedoch implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="2c09a-341">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="2c09a-342">Code-Generatoren können diese Implementierung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-342">Code generators can provide that implementation.</span></span> <span data-ttu-id="2c09a-343">Damit kein Breaking Change eingeführt wird, befolgt der Compiler bei jeder partiellen Methode, die keinen Zugriffsmodifizierer aufweist, die alten Regeln.</span><span class="sxs-lookup"><span data-stu-id="2c09a-343">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="2c09a-344">Wenn die partielle Methode den Zugriffsmodifizierer `private` enthält, unterliegt die partielle Methode den neuen Regeln.</span><span class="sxs-lookup"><span data-stu-id="2c09a-344">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span>

<span data-ttu-id="2c09a-345">Das zweite neue Feature für Code-Generatoren sind _\* _Modulinitialisierer_ \*\*.</span><span class="sxs-lookup"><span data-stu-id="2c09a-345">The second new feature for code generators is _\* _module initializers_ \*\*.</span></span> <span data-ttu-id="2c09a-346">Modulinitialisierer sind Methoden, an die das Attribut <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> angefügt wurde.</span><span class="sxs-lookup"><span data-stu-id="2c09a-346">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="2c09a-347">Diese Methoden werden von der Runtime aufgerufen, wenn die Assembly geladen wird.</span><span class="sxs-lookup"><span data-stu-id="2c09a-347">These methods will be called by the runtime when the assembly loads.</span></span> <span data-ttu-id="2c09a-348">Ein Modulinitialisierer:</span><span class="sxs-lookup"><span data-stu-id="2c09a-348">A module initializer method:</span></span>

- <span data-ttu-id="2c09a-349">muss statisch sein</span><span class="sxs-lookup"><span data-stu-id="2c09a-349">Must be static</span></span>
- <span data-ttu-id="2c09a-350">muss parameterlos sein</span><span class="sxs-lookup"><span data-stu-id="2c09a-350">Must be parameterless</span></span>
- <span data-ttu-id="2c09a-351">muss eine leere Rückgabe („void“) zurückgeben</span><span class="sxs-lookup"><span data-stu-id="2c09a-351">Must return void</span></span>
- <span data-ttu-id="2c09a-352">darf keine generische Methode sein</span><span class="sxs-lookup"><span data-stu-id="2c09a-352">Must not be a generic method</span></span>
- <span data-ttu-id="2c09a-353">darf nicht in einer generischen Klasse enthalten sein</span><span class="sxs-lookup"><span data-stu-id="2c09a-353">Must not be contained in a generic class</span></span>
- <span data-ttu-id="2c09a-354">muss für das Modul zugänglich sein, in dem er enthalten ist</span><span class="sxs-lookup"><span data-stu-id="2c09a-354">Must be accessible from the containing module</span></span>

<span data-ttu-id="2c09a-355">Der letzte Aufzählungspunkt bedeutet, dass die Methode und die Klasse, in der die Methode enthalten ist, intern oder öffentlich sein müssen.</span><span class="sxs-lookup"><span data-stu-id="2c09a-355">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="2c09a-356">Diese Methode darf keine lokale Funktion sein.</span><span class="sxs-lookup"><span data-stu-id="2c09a-356">The method can't be a local function.</span></span>
