---
title: Musterabgleich – Leitfaden für C#
description: Erfahren Sie mehr über Musterabgleichausdrücke in C#.
ms.date: 04/10/2019
ms.technology: csharp-fundamentals
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 2dd1401e3ef22a02f327e44ff884182ee3e22278
ms.sourcegitcommit: b1f4756120deaecb8b554477bb040620f69a4209
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 09/03/2020
ms.locfileid: "89414993"
---
# <a name="pattern-matching"></a><span data-ttu-id="eb8f6-103">Musterabgleich</span><span class="sxs-lookup"><span data-stu-id="eb8f6-103">Pattern Matching</span></span>

<span data-ttu-id="eb8f6-104">Muster testen, ob ein Wert eine bestimmte *Form* hat, und können Informationen vom Wert *extrahieren*, wenn er die entsprechende Form hat.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="eb8f6-105">Der Musterabgleich stellt eine kürzere Syntax für Algorithmen bereit, die Sie bereits verwenden.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="eb8f6-106">Sie erstellen bereits mithilfe vorhandener Syntax Musterabgleichalgorithmen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="eb8f6-107">Sie schreiben `if`- oder `switch`-Anweisungen, die Werte testen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="eb8f6-108">Wenn diese Anweisungen anschließend übereinstimmen, extrahieren und verwenden Sie die Informationen von diesem Wert.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="eb8f6-109">Die neuen Syntaxelemente sind Erweiterungen für Anweisungen, mit denen Sie bereits vertraut sind: `is` und `switch`.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-109">The new syntax elements are extensions to statements you're already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="eb8f6-110">Diese neuen Erweiterungen kombinieren das Testen von Werten mit dem Extrahieren dieser Information.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="eb8f6-111">In diesem Artikel wird die neue Syntax betrachtet, um Ihnen zu zeigen, wie dadurch ein lesbarer, kurzer Code ermöglicht wird.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-111">In this article, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="eb8f6-112">Ein Musterabgleich ermöglicht Idiome, bei denen Daten und der Code getrennt sind, im Gegensatz zu objektorientierten Entwürfen, bei denen Daten und die Methoden, die sie bearbeiten, eng gekoppelt sind.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-112">Pattern matching enables idioms where data and the code are separated, unlike object-oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="eb8f6-113">Wir arbeiten mit Strukturen, die geometrische Formen mithilfe Musterabgleichanweisungen darstellen, um diese neuen Idiome zu veranschaulichen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="eb8f6-114">Sie sind wahrscheinlich mit dem Erstellen von Klassenhierarchien und dem Erstellen [virtueller und überschriebener Methoden](methods.md#inherited) vertraut, um Objektverhalten anhand des Laufzeittyps des Objekts anzupassen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-114">You're probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="eb8f6-115">Diese Techniken sind nicht für Daten geeignet, die nicht in einer Klassenhierarchie strukturiert sind.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="eb8f6-116">Wenn Daten und Methoden getrennt sind, benötigen Sie andere Tools.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="eb8f6-117">Die neuen *Musterabgleichkonstrukte* ermöglichen eine saubere Syntax, um Daten zu untersuchen und anhand jeder Bedingung dieser Daten Steuerungsflüsse zu bearbeiten.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="eb8f6-118">Sie schreiben bereits `if`-Anweisungen und `switch`, die den Wert einer Variable testen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="eb8f6-119">Sie schreiben `is`-Anweisungen, die einen Typ einer Variable testen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="eb8f6-120">*Musterabgleich* fügt neue Funktionen zu diesen Anweisungen hinzu.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="eb8f6-121">In diesem Artikel erstellen Sie eine Methode, die den Bereich der verschiedenen geometrischen Formen berechnet.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-121">In this article, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="eb8f6-122">Aber Sie tun dies, ohne auf objektorientierte Techniken zurückzugreifen und eine Klassenhierarchie für die verschiedenen Formen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-122">But, you'll do it without resorting to object-oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="eb8f6-123">Sie verwenden stattdessen *Musterabgleich*.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-123">You'll use *pattern matching* instead.</span></span>
<span data-ttu-id="eb8f6-124">Während Sie dieses Beispiel bearbeiten, vergleichen Sie diesen Code damit, wie er als Objekthierarchie strukturiert wäre.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-124">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="eb8f6-125">Wenn die Klasse, die Sie abfragen und bearbeiten müssen, keine Klassenhierarchie ist, ermöglicht Musterabgleich elegante Entwürfe.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-125">When the data you must query and manipulate isn't a class hierarchy, pattern matching enables elegant designs.</span></span>

<span data-ttu-id="eb8f6-126">Anstatt mit einer Definition einer abstrakten Form zu starten und verschiedene bestimmte Formklassen hinzuzufügen, beginnen wir mit einfachen reinen Datendefinitionen für jede der geometrischen Formen:</span><span class="sxs-lookup"><span data-stu-id="eb8f6-126">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/snippets/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="eb8f6-127">Wir schreiben von diesen Strukturen eine Methode, die den Bereich einiger Formen berechnet.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-127">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="eb8f6-128">Der Musterausdruck des `is`-Typs</span><span class="sxs-lookup"><span data-stu-id="eb8f6-128">The `is` type pattern expression</span></span>

<span data-ttu-id="eb8f6-129">Vor C# 7.0 mussten Sie jeden Typ in einer Reihe von `if`- und `is`-Anweisungen testen:</span><span class="sxs-lookup"><span data-stu-id="eb8f6-129">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="eb8f6-130">Der oben stehende Code ist ein klassischer Ausdruck des *Typmusters*: Sie testen eine Variable, um ihren Typ zu bestimmen, und handeln anhand dieses Typs unterschiedlich.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-130">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="eb8f6-131">Dieser Code wird einfacher, indem Sie Erweiterungen für den `is`-Ausdruck verwenden, um eine Variable zuzuweisen, wenn der Test erfolgreich ausgeführt wird:</span><span class="sxs-lookup"><span data-stu-id="eb8f6-131">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="eb8f6-132">In dieser aktualisierten Version testet der `is`-Ausdruck die Variable und weist sie einer neuen Variablen des richtigen Typs zu.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-132">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="eb8f6-133">Beachten Sie ebenfalls, dass die Version den `Rectangle`-Typ enthält, der ein `struct` ist.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-133">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="eb8f6-134">Der neue `is`-Ausdruck funktioniert mit Werttypen sowie mit Verweistypen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-134">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="eb8f6-135">Sprachregeln für Musterabgleichausdrücke helfen Ihnen, das Ergebnis eines Musterausdrucks nicht falsch zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-135">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="eb8f6-136">Im obigen Beispiel sind die Variablen `s`, `c` und `r` nur im Geltungsbereich und werden definitiv zugewiesen, wenn die entsprechenden Musterabgleichausdrücke `true`-Ergebnisse haben.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-136">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="eb8f6-137">Wenn Sie versuchen, eine der Variablen an einem anderen Ort zu verwenden, erzeugt Ihr Code Compilerfehler.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-137">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="eb8f6-138">Betrachten wir beide dieser Regeln im Detail, beginnend mit dem Geltungsbereich.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-138">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="eb8f6-139">Die Variable `c` ist im Geltungsbereich nur im `else`-Zweig der ersten `if`-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-139">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="eb8f6-140">Die Variable `s` liegt im Geltungsbereich in der Methode `ComputeAreaModernIs`.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-140">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="eb8f6-141">Jeder Zweig einer `if`-Anweisung bildet nämlich einen separaten Geltungsbereich für Variablen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-141">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="eb8f6-142">Die eigentliche `if`-Anweisung macht dies jedoch nicht.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-142">However, the `if` statement itself doesn't.</span></span> <span data-ttu-id="eb8f6-143">Das bedeutet, dass Variablen, die in der `if`-Anweisung deklariert wurden, im gleichen Gültigkeitsbereich der `if`-Anweisung sind (in diesem Fall die Methode).</span><span class="sxs-lookup"><span data-stu-id="eb8f6-143">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case).</span></span> <span data-ttu-id="eb8f6-144">Dieses Verhalten ist nicht spezifisch für den Musterabgleich, entspricht jedoch dem definierten Verhalten für variable Geltungsbereiche sowie für `if`- und `else`-Anweisungen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-144">This behavior isn't specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="eb8f6-145">Die Variablen `c` und `s` werden zugewiesen, wenn die jeweiligen `if`-Anweisungen aufgrund des definitiv zugewiesenen „when true“-Mechanismus „true“ sind.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-145">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="eb8f6-146">Die Beispiele in diesem Thema verwenden die empfohlenen Konstrukte, bei denen ein `is`-Ausdruck des Musterabgleichs definitiv die Mustervariable im `true`-Zweig der `if`-Anweisung zuweist.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-146">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="eb8f6-147">Sie können die Logik umdrehen, indem Sie sagen, dass `if (!(shape is Square s))` und die Variable `s` definitiv nur im `false`-Zweig zugewiesen seien.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-147">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="eb8f6-148">Obwohl das in C# gültig ist, wird es nicht empfohlen, da diese Logik komplizierter ist.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-148">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="eb8f6-149">Diese Regeln bedeuten, dass Sie wahrscheinlich nicht versehentlich auf das Ergebnis eines Musterabgleichausdrucks zugreifen, wenn das Muster nicht erfüllt wurde.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-149">These rules mean that you're unlikely to accidentally access the result of a pattern match expression when that pattern wasn't met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="eb8f6-150">Musterabgleich mit `switch`-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="eb8f6-150">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="eb8f6-151">Im Laufe der Zeit müssen Sie vielleicht andere Formtypen unterstützen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-151">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="eb8f6-152">Mit der steigenden Anzahl von Bedingungen, die Sie testen, werden Sie feststellen, dass die Verwendung der `is`-Musterabgleichausdrücke sehr umständlich werden kann.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-152">As the number of conditions you're testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="eb8f6-153">Zusätzlich zum Bedarf an `if`-Ausdrücken für jeden Typ, den Sie testen möchten, schränken die `is`-Ausdrücke das Testen ein, wenn die Eingabe mit einem einzigen Typ übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-153">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="eb8f6-154">In diesem Fall stellen Sie fest, dass die Musterabgleichausdrücke `switch` zu einer besseren Wahl werden.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-154">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span>

<span data-ttu-id="eb8f6-155">Die herkömmliche `switch`-Anweisung war ein Musterausdruck: Sie unterstützte das Konstantenmuster.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-155">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="eb8f6-156">Sie können eine Variable mit einer beliebigen Konstante vergleichen, die in einer `case`-Anweisung verwendet wird:</span><span class="sxs-lookup"><span data-stu-id="eb8f6-156">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="eb8f6-157">Das einzige Muster, das von der `switch`-Anweisung unterstützt wurde, war das Konstantenmuster.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-157">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="eb8f6-158">Sie war zudem auf numerische Typen und den `string`-Typ beschränkt.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-158">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="eb8f6-159">Diese Einschränkungen wurden entfernt, und Sie können nun eine `switch`-Anweisung mit dem Typmuster schreiben:</span><span class="sxs-lookup"><span data-stu-id="eb8f6-159">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="eb8f6-160">Die `switch`-Anweisung des Musterabgleichs verwendet ähnliche Syntax für Entwickler, die die `switch`-Anweisung im klassischen C-Stil verwendet haben.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-160">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="eb8f6-161">Jede `case` wird ausgewertet und der Code unterhalb der Bedingung, die mit der Eingabevariablen übereinstimmt, wird ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-161">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="eb8f6-162">Die Codeausführung kann nicht von einem case-Ausdruck in den nächsten „fortfahren“; die Syntax der `case`-Anweisung erfordert, dass jede `case` mit `break`, `return` oder `goto` endet.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-162">Code execution can't "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="eb8f6-163">Die `goto`-Anweisungen, die auf eine andere Bezeichnung springen, sind nur für das Konstantenmuster, die klassische switch-Anweisung, gültig.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-163">The `goto` statements to jump to another label are valid only for the constant pattern (the classic switch statement).</span></span>

<span data-ttu-id="eb8f6-164">Es gibt wichtige neue Regeln für die `switch`-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-164">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="eb8f6-165">Die Beschränkungen für den Typ der Variablen im `switch`-Ausdruck sind entfernt worden.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-165">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="eb8f6-166">Jeder Typ wie `object` in diesem Beispiel kann verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-166">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="eb8f6-167">Die case-Ausdrücke sind nicht mehr auf konstante Werte beschränkt.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-167">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="eb8f6-168">Das Entfernen dieser Beschränkung bedeutet, dass das Neuanordnen von `switch`-Abschnitten das Verhalten eines Programms verändern kann.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-168">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="eb8f6-169">Solange sie auf konstante Werte beschränkt waren, konnte nicht mehr als eine `case`-Bezeichnung mit dem Wert des `switch`-Ausdrucks übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-169">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="eb8f6-170">Verbinden Sie das mit der Regel, das jeder `switch`-Abschnitt nicht im nächsten Abschnitt fortfahren darf, und daraus folgt, dass die `switch`-Abschnitte in jeder Reihenfolge neu angeordnet werden konnten, ohne das Verhalten zu beeinflussen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-170">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="eb8f6-171">Nun spielt die Reihenfolge von jedem Abschnitt mit verallgemeinerten `switch`-Ausdrücken eine Rolle.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-171">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="eb8f6-172">Die `switch`-Ausdrücke werden in der Reihenfolge ausgewertet, in der sie im Text auftreten.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-172">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="eb8f6-173">Die Ausführung wechselt zur ersten `switch`-Bezeichnung, die mit dem `switch`-Ausdruck übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-173">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="eb8f6-174">Der `default`-case wird nur ausgeführt, wenn keine andere case-Bezeichnung übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-174">The `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="eb8f6-175">Der `default`-case wird zuletzt bewertet, unabhängig von der Reihenfolge im Text.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-175">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="eb8f6-176">Wenn kein `default`-case existiert und keine anderen `case`-Ausdrücke übereinstimmen, wird die Ausführung an der Anweisung nach der `switch`-Anweisung fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-176">If there's no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="eb8f6-177">Kein Code der `case`-Bezeichnungen wird ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-177">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="eb8f6-178">`when`-Klauseln in `case`-Ausdrücken</span><span class="sxs-lookup"><span data-stu-id="eb8f6-178">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="eb8f6-179">Sie können Sonderfälle für diese Formen erstellen, die einen 0-Bereich haben, indem Sie eine `when`-Klausel in der `case`-Bezeichnung verwenden.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-179">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="eb8f6-180">Ein Quadrat mit einer Seitenlänge von 0 oder ein Kreis mit einem Radius von 0 hat einen 0-Bereich.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-180">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="eb8f6-181">Sie geben diese Bedingung mithilfe einer `when`-Klausel für die `case`-Bezeichnung an:</span><span class="sxs-lookup"><span data-stu-id="eb8f6-181">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="eb8f6-182">Diese Änderung veranschaulicht einige wichtige Punkte hinsichtlich der neuen Syntax.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-182">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="eb8f6-183">Zuerst können mehrere `case`-Bezeichnungen auf den `switch`-Abschnitt angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-183">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="eb8f6-184">Der Anweisungsblock wird ausgeführt, wenn eine dieser Bezeichnungen `true` ist.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-184">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="eb8f6-185">Wenn in diesem Fall der `switch`-Ausdruck entweder ein Kreis oder ein Quadrat mit einem 0-Bereich ist, gibt die Methode die Konstante 0 zurück.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-185">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="eb8f6-186">In diesem Beispiel werden zwei verschiedene Variablen in den zwei `case`-Bezeichnungen für den ersten `switch`-Block ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-186">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="eb8f6-187">Beachten Sie, dass die Anweisungen in diesem `switch`-Block weder die Variablen `c` (für den Kreis) noch `s` (für das Quadrat) verwenden.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-187">Notice that the statements in this `switch` block don't use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="eb8f6-188">Keine dieser Variablen wird definitiv in diesem `switch`-Block zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-188">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="eb8f6-189">Wenn einer der Fälle übereinstimmt, wurde eindeutig eine der Variablen zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-189">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="eb8f6-190">Allerdings ist es unmöglich zu sagen, *welche* während der Kompilierung zugewiesen wurde, da beide Fälle zur Laufzeit übereinstimmen könnten.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-190">However, it's impossible to tell *which* has been assigned at compile time, because either case could match at runtime.</span></span> <span data-ttu-id="eb8f6-191">Wenn Sie aus diesem Grund meistens mehrere `case`-Bezeichnungen für denselben Block verwenden, werden Sie keine neue Variable in die `case`-Anweisung einführen oder die Variable nur in der `when`-Klausel verwenden.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-191">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you'll only use the variable in the `when` clause.</span></span>

<span data-ttu-id="eb8f6-192">Nachdem diese Formen mit 0-Bereich hinzugefügt wurden, werden wir ein paar weitere Formtypen einfügen: ein Rechteck und ein Dreieck:</span><span class="sxs-lookup"><span data-stu-id="eb8f6-192">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="eb8f6-193">Dieser Satz von Änderungen fügt `case`-Bezeichnungen für den degenerierten case und Bezeichnungen und Blöcke für jede der neuen Formen hinzu.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-193">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span>

<span data-ttu-id="eb8f6-194">Zuletzt können Sie einen `null`-case hinzufügen, um sicherzustellen, dass das Argument nicht `null` ist:</span><span class="sxs-lookup"><span data-stu-id="eb8f6-194">Finally, you can add a `null` case to ensure the argument isn't `null`:</span></span>

[!code-csharp[NullCase](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="eb8f6-195">Das besondere Verhalten für das `null`-Muster ist interessant, weil die Konstante `null` im Muster keinen Typ aufweist, aber in einen beliebigen Verweis- oder Nullable-Typ konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-195">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern doesn't have a type but can be converted to any reference type or nullable value type.</span></span> <span data-ttu-id="eb8f6-196">Statt `null` in einen beliebigen Typ zu konvertieren, definiert die Sprache, dass ein `null`-Wert keinem Typmuster entspricht, unabhängig Typ zur Kompilierzeit der Variablen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-196">Rather than convert a `null` to any type, the language defines that a `null` value won't match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="eb8f6-197">Dieses Verhalten macht das neue `switch`-basierte Typmuster konsistent mit der `is`-Anweisung: `is`-Anweisungen geben stets `false` zurück, wenn der überprüfte Wert `null` ist.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-197">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="eb8f6-198">Außerdem ist es einfacher: Nachdem Sie den Typ überprüft haben, ist keine zusätzliche NULL-Überprüfung erforderlich.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-198">It's also simpler: once you've checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="eb8f6-199">Das erkennen Sie daran, dass in keinem der Case-Blocks oben genannten Beispiele NULL-Überprüfungen durchgeführt werden: Sie sind schlicht nicht erforderlich, da der Abgleich des Typmusters einen Wert ungleich NULL garantiert.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-199">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they aren't necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="eb8f6-200">`var`-Deklarationen in `case`-Ausdrücken</span><span class="sxs-lookup"><span data-stu-id="eb8f6-200">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="eb8f6-201">Mit der Einführung von `var` als Übereinstimmungsausdruck werden neue Regeln für den Musterabgleich eingeführt.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-201">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="eb8f6-202">Die erste Regel ist, dass die `var`-Deklaration den normalen Typinferenzregeln folgt: Der Typ wird als statischer Typ des Switch-Ausdrucks abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-202">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="eb8f6-203">Dieser Regel entsprechend stimmt der Typ immer überein.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-203">From that rule, the type always matches.</span></span>

<span data-ttu-id="eb8f6-204">Die zweite Regel lautet, dass eine `var`-Deklaration keine NULL-Überprüfung umfasst, die in anderen Typmusterausdrücken enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-204">The second rule is that a `var` declaration doesn't have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="eb8f6-205">Dies bedeutet, dass die Variable NULL sein kann, und eine NULL-Überprüfung ist in diesem Fall erforderlich.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-205">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="eb8f6-206">Diese zwei Regeln bedeuten, dass in vielen Fällen eine `var`-Deklaration in einem `case`-Ausdruck dieselben Bedingungen erfüllt wie ein `default`-Ausdruck.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-206">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="eb8f6-207">Weil nicht standardmäßige Fälle dem `default`-case vorgezogen werden, wird der `default`-case nie ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-207">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="eb8f6-208">Der Compiler gibt keine Warnung in Fällen aus, in denen ein `default`-case geschrieben, aber nie ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-208">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="eb8f6-209">Dies entspricht dem aktuellen Verhalten der `switch`-Anweisung, bei der alle möglichen Fälle aufgelistet werden.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-209">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="eb8f6-210">Die dritte Regel führt Verwendungen ein, in denen ein `var`-case nützlich sein kann.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-210">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="eb8f6-211">Angenommen, Sie führen einen Musterabgleich durch, bei dem die Eingabe eine Zeichenfolge ist und Sie nach bekannten Befehlswerten suchen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-211">Imagine that you're doing a pattern match where the input is a string and you're searching for known command values.</span></span> <span data-ttu-id="eb8f6-212">Sie könnten etwa folgenden Code schreiben:</span><span class="sxs-lookup"><span data-stu-id="eb8f6-212">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/snippets/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="eb8f6-213">Der `var`-case entspricht `null`, der leeren Zeichenfolge oder einer beliebigen Zeichenfolge, die nur Leerraum enthält.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-213">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="eb8f6-214">Beachten Sie, dass im vorstehenden Code der `?.`-Operator verwendet wird, um sicherzustellen, dass nicht versehentlich eine <xref:System.NullReferenceException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-214">Notice that the preceding code uses the `?.` operator to ensure that it doesn't accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="eb8f6-215">Der `default`-case behandelt alle anderen Zeichenfolgenwerte, die nicht von diesem Befehlsparser verstanden werden.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-215">The `default` case handles any other string values that aren't understood by this command parser.</span></span>

<span data-ttu-id="eb8f6-216">Dies ist ein Beispiel, bei dem Sie einen `var`-case-Ausdruck erwägen können, der sich von einem `default`-Ausdruck unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-216">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="eb8f6-217">Zusammenfassung</span><span class="sxs-lookup"><span data-stu-id="eb8f6-217">Conclusions</span></span>

<span data-ttu-id="eb8f6-218">*Musterabgleichkonstrukte* helfen Ihnen, den Steuerungsfluss zwischen verschiedenen Variablen und Typen, die nicht durch eine Vererbungshierarchie verknüpft sind, einfach zu verwalten.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-218">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that aren't related by an inheritance hierarchy.</span></span> <span data-ttu-id="eb8f6-219">Sie können auch die Logik steuern, um jede Bedingung, die Sie testen, in der Variable zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-219">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="eb8f6-220">Das ermöglicht Ihnen Muster und Idiome, die Sie häufiger brauchen werden, wenn Sie mehr verteilte Anwendungen entwickeln, bei denen Daten und die Methoden, die diese Daten bearbeiten, getrennt sind.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-220">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="eb8f6-221">Sie werden bemerken, dass die Formstrukturen, die in diesem Beispiel verwendet wurden, keine Methoden enthält, sondern nur schreibgeschützte Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-221">You'll notice that the shape structs used in this sample don't contain any methods, just read-only properties.</span></span>
<span data-ttu-id="eb8f6-222">Musterabgleich funktioniert mit jedem Datentyp.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-222">Pattern Matching works with any data type.</span></span> <span data-ttu-id="eb8f6-223">Sie erstellen Ausdrücke, die das Objekt untersuchen und Steuerungsflussentscheidungen anhand dieser Bedingungen treffen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-223">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="eb8f6-224">Vergleichen Sie den Code in diesem Beispiel mit dem Entwurf, der aus dem Erstellen einer Klassenhierarchie für eine abstrakte `Shape` und spezifisch abgeleitete Formen folgen würde, von denen jede ihre eigene Implementierung einer virtuellen Methode hat, um den Bereich zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-224">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="eb8f6-225">Sie werden häufig feststellen, dass Musterabgleichausdrücke sehr nützlich sein können, wenn Sie mit Daten arbeiten und die Datenspeicherprobleme von den Verhaltensproblemen trennen möchten.</span><span class="sxs-lookup"><span data-stu-id="eb8f6-225">You'll often find that pattern matching expressions can be a very useful tool when you're working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

## <a name="see-also"></a><span data-ttu-id="eb8f6-226">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="eb8f6-226">See also</span></span>

- [<span data-ttu-id="eb8f6-227">Tutorial: Verwenden von Features für den Musterabgleich, um Datentypen zu erweitern</span><span class="sxs-lookup"><span data-stu-id="eb8f6-227">Tutorial: Using pattern matching features to extend data types</span></span>](tutorials/pattern-matching.md)
