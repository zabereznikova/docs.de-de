---
title: Abfragesyntax und Methodensyntax in LINQ (C#)
ms.date: 07/20/2015
helpviewer_keywords:
- LINQ [C#], query syntax vs. method syntax
- queries [LINQ in C#], syntax comparisons
ms.assetid: eedd6dd9-fec2-428c-9581-5b8783810ded
ms.openlocfilehash: 6b943da442d2ec1210911cb9f4b6a0d56c7216d7
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 05/04/2018
---
# <a name="query-syntax-and-method-syntax-in-linq-c"></a><span data-ttu-id="c23ef-102">Abfragesyntax und Methodensyntax in LINQ (C#)</span><span class="sxs-lookup"><span data-stu-id="c23ef-102">Query Syntax and Method Syntax in LINQ (C#)</span></span>
<span data-ttu-id="c23ef-103">Die meisten Abfragen in der einführenden Dokumentation der Language Integrated Query ([!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]) wurden mithilfe der deklarierten Abfragesyntax von LINQ geschrieben.</span><span class="sxs-lookup"><span data-stu-id="c23ef-103">Most queries in the introductory Language Integrated Query ([!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]) documentation are written by using the LINQ declarative query syntax.</span></span> <span data-ttu-id="c23ef-104">Die Abfragesyntax muss jedoch in Methodenaufrufe für die .NET Common Language Runtime (CLR) übersetzt werden, wenn der Code kompiliert wird.</span><span class="sxs-lookup"><span data-stu-id="c23ef-104">However, the query syntax must be translated into method calls for the .NET common language runtime (CLR) when the code is compiled.</span></span> <span data-ttu-id="c23ef-105">Diese Methodenaufrufe rufen die Standardabfrageoperatoren auf, die z.B. folgende Namen haben: `Where`, `Select`, `GroupBy`, `Join`, `Max` und `Average`.</span><span class="sxs-lookup"><span data-stu-id="c23ef-105">These method calls invoke the standard query operators, which have names such as `Where`, `Select`, `GroupBy`, `Join`, `Max`, and `Average`.</span></span> <span data-ttu-id="c23ef-106">Sie können sie direkt mithilfe der Methodensyntax anstatt der Abfragesyntax aufrufen.</span><span class="sxs-lookup"><span data-stu-id="c23ef-106">You can call them directly by using method syntax instead of query syntax.</span></span>  
  
 <span data-ttu-id="c23ef-107">Abfragesyntax und Methodensyntax sind semantisch identisch, aber viele Benutzer finden die Abfragesyntax einfacher und leichter zu lesen.</span><span class="sxs-lookup"><span data-stu-id="c23ef-107">Query syntax and method syntax are semantically identical, but many people find query syntax simpler and easier to read.</span></span> <span data-ttu-id="c23ef-108">Einige Abfragen müssen als Methodenaufrufe ausgedrückt werden.</span><span class="sxs-lookup"><span data-stu-id="c23ef-108">Some queries must be expressed as method calls.</span></span> <span data-ttu-id="c23ef-109">Sie müssen z.B. einen Methodenaufruf verwenden, um eine Abfrage auszudrücken, die die Anzahl der Elemente abruft, die einer angegebenen Bedingung entsprechen.</span><span class="sxs-lookup"><span data-stu-id="c23ef-109">For example, you must use a method call to express a query that retrieves the number of elements that match a specified condition.</span></span> <span data-ttu-id="c23ef-110">Sie müssen einen Methodenaufruf auch für eine Abfrage verwenden, die das Element abruft, das den Maximalwert in der Quellsequenz hat.</span><span class="sxs-lookup"><span data-stu-id="c23ef-110">You also must use a method call for a query that retrieves the element that has the maximum value in a source sequence.</span></span> <span data-ttu-id="c23ef-111">In der Referenzdokumentation für die Standardabfrageoperatoren im <xref:System.Linq>-Namespace wird im Allgemeinen die Methodensyntax verwendet.</span><span class="sxs-lookup"><span data-stu-id="c23ef-111">The reference documentation for the standard query operators in the <xref:System.Linq> namespace generally uses method syntax.</span></span> <span data-ttu-id="c23ef-112">Daher ist es sinnvoll, sich mit der Verwendung der Methodensyntax in Abfragen und Abfrageausdrücken selbst vertraut zu machen, auch wenn man mit dem Schreiben von [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]-Abfragen beginnt.</span><span class="sxs-lookup"><span data-stu-id="c23ef-112">Therefore, even when getting started writing [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] queries, it is useful to be familiar with how to use method syntax in queries and in query expressions themselves.</span></span>  
  
## <a name="standard-query-operator-extension-methods"></a><span data-ttu-id="c23ef-113">Erweiterungsmethoden von Standardabfrageoperatoren</span><span class="sxs-lookup"><span data-stu-id="c23ef-113">Standard Query Operator Extension Methods</span></span>  
 <span data-ttu-id="c23ef-114">Im folgenden Beispiel wird ein einfacher *Abfrageausdruck* und die semantisch äquivalente Abfrage gezeigt, die als *methodenbasierte Abfrage* geschrieben ist.</span><span class="sxs-lookup"><span data-stu-id="c23ef-114">The following example shows a simple *query expression* and the semantically equivalent query written as a *method-based query*.</span></span>  
  
 [!code-csharp[csLINQGettingStarted#22](../../../../csharp/programming-guide/concepts/linq/codesnippet/CSharp/query-syntax-and-method-syntax-in-linq_1.cs)]  
  
 <span data-ttu-id="c23ef-115">Die Ausgabe der beiden Beispiele ist identisch.</span><span class="sxs-lookup"><span data-stu-id="c23ef-115">The output from the two examples is identical.</span></span> <span data-ttu-id="c23ef-116">Sie sehen, dass der Typ der Abfragevariable in beiden Formen der gleiche ist: <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="c23ef-116">You can see that the type of the query variable is the same in both forms: <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="c23ef-117">Betrachten Sie die methodenbasierte Abfrage genauer, um sie besser zu verstehen.</span><span class="sxs-lookup"><span data-stu-id="c23ef-117">To understand the method-based query, let's examine it more closely.</span></span> <span data-ttu-id="c23ef-118">Beachten Sie, dass die `where`-Klausel auf der rechten Seite des Ausdrucks jetzt als Instanzmethode des `numbers`-Objekts ausgedrückt wird. Sie erinnern sich sicher, dass diese über einen `IEnumerable<int>`-Typ verfügt.</span><span class="sxs-lookup"><span data-stu-id="c23ef-118">On the right side of the expression, notice that the `where` clause is now expressed as an instance method on the `numbers` object, which as you will recall has a type of `IEnumerable<int>`.</span></span> <span data-ttu-id="c23ef-119">Wenn Sie mit der generischen <xref:System.Collections.Generic.IEnumerable%601>-Schnittstelle vertraut sind, wissen Sie, dass sie über keine `Where`-Methode verfügt.</span><span class="sxs-lookup"><span data-stu-id="c23ef-119">If you are familiar with the generic <xref:System.Collections.Generic.IEnumerable%601> interface, you know that it does not have a `Where` method.</span></span> <span data-ttu-id="c23ef-120">Wenn Sie jedoch die IntelliSense-Vervollständigungsliste in der Visual Studio IDE aufrufen, sehen Sie nicht nur eine `Where`-Methode, sondern viele andere Methoden, z.B. `Select`, `SelectMany`, `Join` und `Orderby`.</span><span class="sxs-lookup"><span data-stu-id="c23ef-120">However, if you invoke the IntelliSense completion list in the Visual Studio IDE, you will see not only a `Where` method, but many other methods such as `Select`, `SelectMany`, `Join`, and `Orderby`.</span></span> <span data-ttu-id="c23ef-121">Sie sind alle Standardabfrageoperatoren.</span><span class="sxs-lookup"><span data-stu-id="c23ef-121">These are all the standard query operators.</span></span>  
  
 <span data-ttu-id="c23ef-122">![Standardabfrageoperatoren in Intellisense](../../../../csharp/programming-guide/concepts/linq/media/standardqueryops.png "StandardQueryOps")</span><span class="sxs-lookup"><span data-stu-id="c23ef-122">![Standard Query Operators in Intellisense](../../../../csharp/programming-guide/concepts/linq/media/standardqueryops.png "StandardQueryOps")</span></span>  
  
 <span data-ttu-id="c23ef-123">Obwohl es so scheint, als sei <xref:System.Collections.Generic.IEnumerable%601> neu definiert worden, um diese zusätzlichen Methoden zu enthalten, ist dies tatsächlich nicht der Fall.</span><span class="sxs-lookup"><span data-stu-id="c23ef-123">Although it looks as if <xref:System.Collections.Generic.IEnumerable%601> has been redefined to include these additional methods, in fact this is not the case.</span></span> <span data-ttu-id="c23ef-124">Die Standardabfrageoperatoren werden als eine neue Methodenart, die als *Erweiterungsmethoden* bezeichnet werden, implementiert.</span><span class="sxs-lookup"><span data-stu-id="c23ef-124">The standard query operators are implemented as a new kind of method called *extension methods*.</span></span> <span data-ttu-id="c23ef-125">Erweiterungsmethoden „erweitern“ einen vorhandenen Typ; sie können aufgerufen werden, als wären sie Instanzmethoden für den Typ.</span><span class="sxs-lookup"><span data-stu-id="c23ef-125">Extensions methods "extend" an existing type; they can be called as if they were instance methods on the type.</span></span> <span data-ttu-id="c23ef-126">Die Standardabfrageoperatoren erweitern <xref:System.Collections.Generic.IEnumerable%601>, weshalb Sie `numbers.Where(...)` schreiben können.</span><span class="sxs-lookup"><span data-stu-id="c23ef-126">The standard query operators extend <xref:System.Collections.Generic.IEnumerable%601> and that is why you can write `numbers.Where(...)`.</span></span>  
  
 <span data-ttu-id="c23ef-127">Um mit der Verwendung von [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] zu beginnen, müssen Sie nur wissen, wie Sie Erweiterungsmethoden in Ihrer Anwendung mithilfe der richtigen `using`-Anweisungen in den Geltungsbereich einbinden können.</span><span class="sxs-lookup"><span data-stu-id="c23ef-127">To get started using [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], all that you really have to know about extension methods is how to bring them into scope in your application by using the correct `using` directives.</span></span> <span data-ttu-id="c23ef-128">Aus Sicht Ihrer Anwendung sind eine Erweiterungsmethode und eine reguläre Instanzmethode identisch.</span><span class="sxs-lookup"><span data-stu-id="c23ef-128">From your application's point of view, an extension method and a regular instance method are the same.</span></span>  
  
 <span data-ttu-id="c23ef-129">Weitere Informationen zu Erweiterungsmethoden finden Sie unter [Extension Methods (Erweiterungsmethoden)](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="c23ef-129">For more information about extension methods, see [Extension Methods](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md).</span></span> <span data-ttu-id="c23ef-130">Weitere Informationen über Standardabfrageoperatoren finden Sie unter [Standard Query Operators Overview (C#) (Übersicht über Standardabfrageoperatoren (C#))](../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md).</span><span class="sxs-lookup"><span data-stu-id="c23ef-130">For more information about standard query operators, see [Standard Query Operators Overview (C#)](../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md).</span></span> <span data-ttu-id="c23ef-131">Einige [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]-Anbieter, z.B. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] und [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], implementieren ihre eigenen Standardabfrageoperatoren und zusätzliche Erweiterungsmethoden für andere Typen neben <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="c23ef-131">Some [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] providers, such as [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] and [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], implement their own standard query operators and additional extension methods for other types besides <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
## <a name="lambda-expressions"></a><span data-ttu-id="c23ef-132">Lambda-Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="c23ef-132">Lambda Expressions</span></span>  
 <span data-ttu-id="c23ef-133">Beachten Sie im vorherigen Beispiel, dass der bedingte Ausdruck `num % 2 == 0` als Inlineargument an die `Where`-Methode übergeben wird: `Where(num => num % 2 == 0).`. Dieser Inlineausdruck wird als Lambdaausdruck bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="c23ef-133">In the previous example, notice that the conditional expression (`num % 2 == 0`) is passed as an in-line argument to the `Where` method: `Where(num => num % 2 == 0).` This inline expression is called a lambda expression.</span></span> <span data-ttu-id="c23ef-134">Dies ist eine einfache Möglichkeit, Code zu schreiben, der sonst auf einem unpraktischeren Weg als anonyme Methode, generischer Delegat oder Ausdrucksbaumstruktur geschrieben werden müsste.</span><span class="sxs-lookup"><span data-stu-id="c23ef-134">It is a convenient way to write code that would otherwise have to be written in more cumbersome form as an anonymous method or a generic delegate or an expression tree.</span></span> <span data-ttu-id="c23ef-135">In C# ist der Lambdaoperator `=>`, der als „wird zu“ gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="c23ef-135">In C# `=>` is the lambda operator, which is read as "goes to".</span></span> <span data-ttu-id="c23ef-136">`num` auf der linken Seite des Operators ist die Eingabevariable, die `num` im Eingabeausdruck entspricht.</span><span class="sxs-lookup"><span data-stu-id="c23ef-136">The `num` on the left of the operator is the input variable which corresponds to `num` in the query expression.</span></span> <span data-ttu-id="c23ef-137">Der Compiler kann den Typ von `num` ableiten, da er weiß, dass es sich bei `numbers` um einen generischen <xref:System.Collections.Generic.IEnumerable%601>-Typ handelt.</span><span class="sxs-lookup"><span data-stu-id="c23ef-137">The compiler can infer the type of `num` because it knows that `numbers` is a generic <xref:System.Collections.Generic.IEnumerable%601> type.</span></span> <span data-ttu-id="c23ef-138">Der Text des Lambdaausdrucks entspricht genau dem Ausdruck in der Abfragesyntax, in einem anderen Ausdruck oder in einer Anweisung in C#; er kann Methodenaufrufe und andere komplexe Logik enthalten.</span><span class="sxs-lookup"><span data-stu-id="c23ef-138">The body of the lambda is just the same as the expression in query syntax or in any other C# expression or statement; it can include method calls and other complex logic.</span></span> <span data-ttu-id="c23ef-139">Der „Rückgabewert“ ist nur das Ergebnis des Ausdrucks.</span><span class="sxs-lookup"><span data-stu-id="c23ef-139">The "return value" is just the expression result.</span></span>  
  
 <span data-ttu-id="c23ef-140">Sie müssen Lambdaausdrücke nicht häufig verwenden, wenn Sie mit der Verwendung von [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] beginnen.</span><span class="sxs-lookup"><span data-stu-id="c23ef-140">To get started using [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], you do not have to use lambdas extensively.</span></span> <span data-ttu-id="c23ef-141">Allerdings können bestimme Abfragen nur in der Methodensyntax ausgedrückt werden, und einige von ihnen benötigen Lambdaausdrücke.</span><span class="sxs-lookup"><span data-stu-id="c23ef-141">However, certain queries can only be expressed in method syntax and some of those require lambda expressions.</span></span> <span data-ttu-id="c23ef-142">Wenn Sie sich mit Lambdaausdrücken besser vertraut gemacht haben, werden Sie sehen, dass sie ein leistungsstarkes und flexibles Tool in Ihrer [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]-Toolbox sind.</span><span class="sxs-lookup"><span data-stu-id="c23ef-142">After you become more familiar with lambdas, you will find that they are a powerful and flexible tool in your [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] toolbox.</span></span> <span data-ttu-id="c23ef-143">Weitere Informationen finden Sie unter [Lambdaausdrücke](../../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="c23ef-143">For more information, see [Lambda Expressions](../../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span></span>  
  
## <a name="composability-of-queries"></a><span data-ttu-id="c23ef-144">Zusammensetzbarkeit von Abfragen</span><span class="sxs-lookup"><span data-stu-id="c23ef-144">Composability of Queries</span></span>  
 <span data-ttu-id="c23ef-145">Beachten Sie im vorherigen Codebeispiel, dass die `OrderBy`-Methode durch Verwendung des Punktoperators auf dem Aufruf von `Where` aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="c23ef-145">In the previous code example, note that the `OrderBy` method is invoked by using the dot operator on the call to `Where`.</span></span> <span data-ttu-id="c23ef-146">`Where` erzeugt eine gefilterte Sequenz, und `Orderby` bearbeitet sie anschließend durch Sortierung.</span><span class="sxs-lookup"><span data-stu-id="c23ef-146">`Where` produces a filtered sequence, and then `Orderby` operates on that sequence by sorting it.</span></span> <span data-ttu-id="c23ef-147">Da Abfragen `IEnumerable` zurückgeben, erstellen Sie sie in der Methodensyntax durch Verkettung von Methodenaufrufen miteinander.</span><span class="sxs-lookup"><span data-stu-id="c23ef-147">Because queries return an `IEnumerable`, you compose them in method syntax by chaining the method calls together.</span></span> <span data-ttu-id="c23ef-148">Das führt auch der Compiler im Hintergrund aus, wenn Sie über die Abfragesyntax Abfragen erstellen.</span><span class="sxs-lookup"><span data-stu-id="c23ef-148">This is what the compiler does behind the scenes when you write queries by using query syntax.</span></span> <span data-ttu-id="c23ef-149">Da die Abfragevariable die Ergebnisse der Abfrage nicht speichert, können Sie sie jederzeit ändern oder als Basis für eine neue Abfrage verwenden, sogar, wenn sie bereits ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="c23ef-149">And because a query variable does not store the results of the query, you can modify it or use it as the basis for a new query at any time, even after it has been executed.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c23ef-150">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="c23ef-150">See Also</span></span>  
 [<span data-ttu-id="c23ef-151">Erste Schritte mit LINQ in C#</span><span class="sxs-lookup"><span data-stu-id="c23ef-151">Getting Started with LINQ in C#</span></span>](../../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)
