---
title: Polymorphismus – C#-Programmierhandbuch
ms.date: 02/08/2020
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: 58980bd0d70d8a778cdb208f56d31ee8465871a4
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/14/2020
ms.locfileid: "79170168"
---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="0dbca-102">Polymorphismus (C#-Programmierhandbuch)</span><span class="sxs-lookup"><span data-stu-id="0dbca-102">Polymorphism (C# Programming Guide)</span></span>

<span data-ttu-id="0dbca-103">Polymorphismus wird häufig nach der Kapselung und der Vererbung als die dritte Säule der objektorientierten Programmierung bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="0dbca-103">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="0dbca-104">Es handelt sich dabei um ein griechisches Wort, das "Vielgestaltigkeit" bedeutet und zwei verschiedene Aspekte umfasst:</span><span class="sxs-lookup"><span data-stu-id="0dbca-104">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>
  
- <span data-ttu-id="0dbca-105">In Methodenparametern, Auflistungen und Arrays können Objekte einer abgeleiteten Klasse zur Laufzeit als Objekte einer Basisklasse behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="0dbca-105">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="0dbca-106">Wenn diese Polymorphie auftritt, entspricht der deklarierte Typ des Objekts nicht mehr dem Runtimetyp.</span><span class="sxs-lookup"><span data-stu-id="0dbca-106">When this polymorphism occurs, the object's declared type is no longer identical to its run-time type.</span></span>
- <span data-ttu-id="0dbca-107">Basisklassen können [virtuelle](../../language-reference/keywords/virtual.md) *Methoden* definieren und implementieren und können von abgeleiteten Klassen [überschrieben](../../language-reference/keywords/override.md) werden, was bedeutet, dass sie ihre eigene Definition und Implementierung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="0dbca-107">Base classes may define and implement [virtual](../../language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="0dbca-108">Zur Laufzeit, wenn die Methode von Clientcode aufgerufen wird, sucht die CLR den Laufzeittyp des Objekts und ruft die Überschreibung der virtuellen Methode auf.</span><span class="sxs-lookup"><span data-stu-id="0dbca-108">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="0dbca-109">In Ihrem Quellcode können Sie eine Methode in einer Basisklasse aufrufen und bewirken, dass die Methodenversion der abgeleiteten Klasse ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="0dbca-109">In your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>

<span data-ttu-id="0dbca-110">Dank virtueller Methoden können Sie auf einheitliche Weise mit Gruppen verwandter Objekte arbeiten.</span><span class="sxs-lookup"><span data-stu-id="0dbca-110">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="0dbca-111">Nehmen Sie beispielsweise an, Sie haben eine Zeichenanwendung, mit der ein Benutzer verschiedene Arten von Formen auf einer Zeichenoberfläche erstellen kann.</span><span class="sxs-lookup"><span data-stu-id="0dbca-111">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="0dbca-112">Zur Kompilierzeit wissen Sie nicht, welche spezifischen Typen von Formen der Benutzer erstellen wird.</span><span class="sxs-lookup"><span data-stu-id="0dbca-112">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="0dbca-113">Die Anwendung muss jedoch alle verschiedenen Formentypen, die erstellt werden, nachverfolgen und diese als Antwort auf die Mausaktionen des Benutzers aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="0dbca-113">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="0dbca-114">Sie können Polymorphismus verwenden, um dieses Problem mithilfe von zwei einfachen Schritten zu lösen:</span><span class="sxs-lookup"><span data-stu-id="0dbca-114">You can use polymorphism to solve this problem in two basic steps:</span></span>

1. <span data-ttu-id="0dbca-115">Erstellen Sie eine Klassenhierarchie, in der jede spezifische Formenklasse von einer gemeinsamen Basisklasse abgeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="0dbca-115">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>
1. <span data-ttu-id="0dbca-116">Verwenden Sie eine virtuelle Methode, um die entsprechende Methode in einer abgeleiteten Klasse durch einen einzigen Aufruf der Basisklassenmethode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0dbca-116">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>

<span data-ttu-id="0dbca-117">Erstellen Sie zuerst eine Basisklasse namens `Shape` und abgeleitete Klassen, wie z. B. `Rectangle`, `Circle` und `Triangle`.</span><span class="sxs-lookup"><span data-stu-id="0dbca-117">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="0dbca-118">Geben Sie der `Shape`-Klasse eine virtuelle Methode namens `Draw`, und überschreiben Sie sie in jeder abgeleiteten Klasse, um die jeweilige Form zu zeichnen, die die Klasse darstellt.</span><span class="sxs-lookup"><span data-stu-id="0dbca-118">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="0dbca-119">Erstellen Sie ein `List<Shape>`-Objekt, und fügen Sie die abgeleiteten Klassen `Circle`, `Triangle` und `Rectangle` hinzu.</span><span class="sxs-lookup"><span data-stu-id="0dbca-119">Create a `List<Shape>` object and add a `Circle`, `Triangle`, and `Rectangle` to it.</span></span>

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#PolymorphismOverview)]

<span data-ttu-id="0dbca-120">Um die Zeichenoberfläche zu aktualisieren, verwenden Sie eine [foreach](../../language-reference/keywords/foreach-in.md)-Schleife, um die Liste zu durchlaufen und die `Draw`-Methode für jedes `Shape`-Objekt in der Liste aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0dbca-120">To update the drawing surface, use a [foreach](../../language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="0dbca-121">Obwohl jedes Objekt in der Liste einen deklarierten `Shape`-Typ aufweist, wird der Runtimetyp (die überschriebene Version der Methode in jeder abgeleiteten Klasse) aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="0dbca-121">Even though each object in the list has a declared type of `Shape`, it's the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UsePolymorphism)]

<span data-ttu-id="0dbca-122">In C# ist jeder Typ polymorph, da alle Typen, einschließlich benutzerdefinierten Typen, von <xref:System.Object> erben.</span><span class="sxs-lookup"><span data-stu-id="0dbca-122">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  

## <a name="polymorphism-overview"></a><span data-ttu-id="0dbca-123">Übersicht über Polymorphie</span><span class="sxs-lookup"><span data-stu-id="0dbca-123">Polymorphism overview</span></span>

### <a name="virtual-members"></a><span data-ttu-id="0dbca-124">Virtuelle Member</span><span class="sxs-lookup"><span data-stu-id="0dbca-124">Virtual members</span></span>

<span data-ttu-id="0dbca-125">Wenn eine abgeleitete Klasse von einer Basisklasse erbt, erhält sie alle Methoden, Felder, Eigenschaften und Ereignisse der Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="0dbca-125">When a derived class inherits from a base class, it gains all the methods, fields, properties, and events of the base class.</span></span> <span data-ttu-id="0dbca-126">Der Designer der abgeleiteten Klasse kann verschiedene Optionen für das Verhalten der virtuellen Methoden festlegen:</span><span class="sxs-lookup"><span data-stu-id="0dbca-126">The designer of the derived class can different choices for the behavior of virtual methods:</span></span>

- <span data-ttu-id="0dbca-127">Die abgeleitete Klasse kann virtuelle Member in der Basisklasse überschreiben, wodurch ein neues Verhalten definiert wird.</span><span class="sxs-lookup"><span data-stu-id="0dbca-127">The derived class may override virtual members in the base class, defining new behavior.</span></span>
- <span data-ttu-id="0dbca-128">Die abgeleitete Klasse erbt die nächstgelegene Basisklassenmethode, ohne diese zu überschreiben. Das vorhandene Verhalten wird beibehalten, jedoch können weitere Klassen die Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="0dbca-128">The derived class inherit the closest base class method without overriding it, preserving the existing behavior but enabling further derived classes to override the method.</span></span>
- <span data-ttu-id="0dbca-129">Die abgeleitete Klasse kann neue nicht virtuelle Implementierungen der Member definieren, die die Basisklassenimplementierungen verbergen.</span><span class="sxs-lookup"><span data-stu-id="0dbca-129">The derived class may define new non-virtual implementation of those members that hide the base class implementations.</span></span>

<span data-ttu-id="0dbca-130">Eine abgeleitete Klasse kann einen Basisklassenmember nur überschreiben, wenn der Basisklassenmember als [virtuell](../../language-reference/keywords/virtual.md) oder [abstrakt](../../language-reference/keywords/abstract.md) deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="0dbca-130">A derived class can override a base class member only if the base class member is declared as [virtual](../../language-reference/keywords/virtual.md) or [abstract](../../language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="0dbca-131">Der abgeleitete Member muss das [override](../../language-reference/keywords/override.md)-Schlüsselwort verwenden, um explizit anzugeben, dass die Methode an dem virtuellen Aufruf beteiligt sein soll.</span><span class="sxs-lookup"><span data-stu-id="0dbca-131">The derived member must use the [override](../../language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="0dbca-132">Der folgende Code veranschaulicht dies:</span><span class="sxs-lookup"><span data-stu-id="0dbca-132">The following code provides an example:</span></span>

[!code-csharp[Virtual overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#VirtualMethods)]

<span data-ttu-id="0dbca-133">Anders als Methoden, Eigenschaften, Ereignisse und Indexer können Felder nicht virtuell sein.</span><span class="sxs-lookup"><span data-stu-id="0dbca-133">Fields cannot be virtual; only methods, properties, events, and indexers can be virtual.</span></span> <span data-ttu-id="0dbca-134">Wenn eine abgeleitete Klasse einen virtuellen Member überschreibt, wird dieser Member auch dann aufgerufen, wenn auf eine Instanz dieser Klasse als Instanz der Basisklasse zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="0dbca-134">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="0dbca-135">Der folgende Code veranschaulicht dies:</span><span class="sxs-lookup"><span data-stu-id="0dbca-135">The following code provides an example:</span></span>

[!code-csharp[Virtual overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#VirtualMethods)]

<span data-ttu-id="0dbca-136">Mithilfe virtueller Methoden und Eigenschaften können abgeleitete Klassen eine Basisklasse erweitern, ohne die Basisklassenimplementierung einer Methode verwenden zu müssen.</span><span class="sxs-lookup"><span data-stu-id="0dbca-136">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="0dbca-137">Weitere Informationen finden Sie unter [Versionsverwaltung mit den Schlüsselwörtern „override“ und „new“](./versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="0dbca-137">For more information, see [Versioning with the Override and New Keywords](./versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="0dbca-138">Eine Schnittstelle bietet eine weitere Möglichkeit zur Definition einer Methode bzw. einer Gruppe von Methoden, deren Implementierung von abgeleiteten Klassen übernommen wird.</span><span class="sxs-lookup"><span data-stu-id="0dbca-138">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="0dbca-139">Weitere Informationen finden Sie unter [Schnittstellen](../interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="0dbca-139">For more information, see [Interfaces](../interfaces/index.md).</span></span>

### <a name="hide-base-class-members-with-new-members"></a><span data-ttu-id="0dbca-140">Ausblenden von Basisklassenmembern für neue Member</span><span class="sxs-lookup"><span data-stu-id="0dbca-140">Hide base class members with new members</span></span>

<span data-ttu-id="0dbca-141">Wenn Sie möchten, dass Ihre abgeleiteten Klassen einen Member mit demselben Namen wie ein Member in einer Basisklasse enthalten, können Sie das Schlüsselwort [new](../../language-reference/keywords/new-modifier.md) verwenden, um den Basisklassenmember auszublenden.</span><span class="sxs-lookup"><span data-stu-id="0dbca-141">If you want your derived class to have a member with the same name as a member in a base class, you can use the [new](../../language-reference/keywords/new-modifier.md) keyword to hide the base class member.</span></span> <span data-ttu-id="0dbca-142">Das `new`-Schlüsselwort wird dem Rückgabetyp eines Klassenmembers vorangestellt, der ersetzt wird.</span><span class="sxs-lookup"><span data-stu-id="0dbca-142">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="0dbca-143">Der folgende Code veranschaulicht dies:</span><span class="sxs-lookup"><span data-stu-id="0dbca-143">The following code provides an example:</span></span>

[!code-csharp[New method overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#NewMethods)]

<span data-ttu-id="0dbca-144">Auf ausgeblendete Klassenmember kann vom Clientcode immer noch zugegriffen werden, indem die Instanz der abgeleiteten Klasse in eine Instanz der Basisklasse umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="0dbca-144">Hidden base class members may be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="0dbca-145">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="0dbca-145">For example:</span></span>

[!code-csharp[New method overview usage](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UseNewMethods)]

### <a name="prevent-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="0dbca-146">Verhindern der Überschreibung virtueller Member durch abgeleitete Klassen</span><span class="sxs-lookup"><span data-stu-id="0dbca-146">Prevent derived classes from overriding virtual members</span></span>  

<span data-ttu-id="0dbca-147">Virtuelle Member bleiben virtuell, unabhängig davon, wie viele Klassen zwischen dem virtuellen Member und der Klasse deklariert werden, die ihn ursprünglich deklariert hat.</span><span class="sxs-lookup"><span data-stu-id="0dbca-147">Virtual members remain virtual, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="0dbca-148">Wenn die Klasse `A` einen virtuellen Member deklariert, die Klasse `B` von `A` abgeleitet und die Klasse `C` von `B` abgeleitet wird, erbt die Klasse `C` den virtuellen Member und kann diesen überschreiben, unabhängig davon, ob die Klasse `B` eine Überschreibung für diesen Member deklariert hat.</span><span class="sxs-lookup"><span data-stu-id="0dbca-148">If class `A` declares a virtual member, and class `B` derives from `A`, and class `C` derives from `B`, class `C` inherits the virtual member, and may override it, regardless of whether class `B` declared an override for that member.</span></span> <span data-ttu-id="0dbca-149">Der folgende Code veranschaulicht dies:</span><span class="sxs-lookup"><span data-stu-id="0dbca-149">The following code provides an example:</span></span>

[!code-csharp[Basic hierarchy](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#FirstHierarchy)]

<span data-ttu-id="0dbca-150">Eine abgeleitete Klasse kann die virtuelle Vererbung stoppen, indem das Überschreiben als [versiegelt](../../language-reference/keywords/sealed.md) deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="0dbca-150">A derived class can stop virtual inheritance by declaring an override as [sealed](../../language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="0dbca-151">Zum Beenden der Vererbung muss das Schlüsselwort `sealed` vor dem Schlüsselwort `override` in der Klassenmemberdeklaration eingefügt werden.</span><span class="sxs-lookup"><span data-stu-id="0dbca-151">Stopping inheritance requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="0dbca-152">Der folgende Code veranschaulicht dies:</span><span class="sxs-lookup"><span data-stu-id="0dbca-152">The following code provides an example:</span></span>

[!code-csharp[A sealed overridden member](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#SealedOverride)]

<span data-ttu-id="0dbca-153">Im vorherigen Beispiel ist die Methode `DoWork` für Klassen, die von `C` abgeleitet wurden, nicht mehr virtuell.</span><span class="sxs-lookup"><span data-stu-id="0dbca-153">In the previous example, the method `DoWork` is no longer virtual to any class derived from `C`.</span></span> <span data-ttu-id="0dbca-154">Für Instanzen von `C` wird sie weiterhin als virtuell betrachtet, auch wenn die Instanzen in den `B`- oder `A`-Typ umgewandelt werden.</span><span class="sxs-lookup"><span data-stu-id="0dbca-154">It's still virtual for instances of `C`, even if they're cast to type `B` or type `A`.</span></span> <span data-ttu-id="0dbca-155">Versiegelte Methoden können durch abgeleitete Klassen ersetzt werden, indem das Schlüsselwort `new` wie im folgenden Beispiel gezeigt verwendet wird:</span><span class="sxs-lookup"><span data-stu-id="0dbca-155">Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>

[!code-csharp[New method declaration](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#NewDeclaration)]

<span data-ttu-id="0dbca-156">Wenn `DoWork` für `D` mithilfe einer Variable vom Typ `D` aufgerufen wird, wird in diesem Fall die neue `DoWork`-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="0dbca-156">In this case, if `DoWork` is called on `D` using a variable of type `D`, the new `DoWork` is called.</span></span> <span data-ttu-id="0dbca-157">Wenn eine Variable vom Typ `C`, `B` oder `A` zum Zugreifen auf eine Instanz von `D` verwendet wird, befolgt ein Aufruf von `DoWork` die Regeln der virtuellen Vererbung, und diese Aufrufe werden an die Implementierung von `DoWork` für die Klasse `C` weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="0dbca-157">If a variable of type `C`, `B`, or `A` is used to access an instance of `D`, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class `C`.</span></span>

### <a name="access-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="0dbca-158">Zugreifen auf virtuelle Basisklassenmember über abgeleitete Klassen</span><span class="sxs-lookup"><span data-stu-id="0dbca-158">Access base class virtual members from derived classes</span></span>

<span data-ttu-id="0dbca-159">Eine abgeleitete Klasse, die eine Methode oder Eigenschaft ersetzt oder überschrieben hat, kann immer noch auf die Methode oder Eigenschaft in der Basisklasse mithilfe des `base`-Schlüsselworts zugreifen.</span><span class="sxs-lookup"><span data-stu-id="0dbca-159">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the `base` keyword.</span></span> <span data-ttu-id="0dbca-160">Der folgende Code veranschaulicht dies:</span><span class="sxs-lookup"><span data-stu-id="0dbca-160">The following code provides an example:</span></span>

```csharp
public class Base
{
    public virtual void DoWork() {/*...*/ }
}
public class Derived : Base
{
    public override void DoWork()
    {
        //Perform Derived's work here
        //...
        // Call DoWork on base class
        base.DoWork();
    }
}
```

<span data-ttu-id="0dbca-161">Weitere Informationen finden Sie unter [base](../../language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="0dbca-161">For more information, see [base](../../language-reference/keywords/base.md).</span></span>

> [!NOTE]
> <span data-ttu-id="0dbca-162">Es wird empfohlen, dass virtuelle Member `base` verwenden, um die Basisklassenimplementierung dieses Members in seiner eigenen Implementierung aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="0dbca-162">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="0dbca-163">Durch Zulassen des Basisklassenverhaltens kann sich die abgeleitete Klasse auf die Implementierung von Verhalten konzentrieren, das spezifisch für die abgeleitete Klasse ist.</span><span class="sxs-lookup"><span data-stu-id="0dbca-163">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="0dbca-164">Wenn die Basisklassenimplementierung nicht aufgerufen wird, liegt es an der abgeleiteten Klasse, ihr Verhalten kompatibel mit dem Verhalten der Basisklasse zu gestalten.</span><span class="sxs-lookup"><span data-stu-id="0dbca-164">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="0dbca-165">In diesem Abschnitt</span><span class="sxs-lookup"><span data-stu-id="0dbca-165">In this section</span></span>

- [<span data-ttu-id="0dbca-166">Versionsverwaltung mit den Schlüsselwörtern "override" und "new"</span><span class="sxs-lookup"><span data-stu-id="0dbca-166">Versioning with the Override and New Keywords</span></span>](./versioning-with-the-override-and-new-keywords.md)
- [<span data-ttu-id="0dbca-167">Wann müssen die Schlüsselwörter "override" und "new" verwendet werden?</span><span class="sxs-lookup"><span data-stu-id="0dbca-167">Knowing When to Use Override and New Keywords</span></span>](./knowing-when-to-use-override-and-new-keywords.md)
- [<span data-ttu-id="0dbca-168">Überschreiben der ToString-Methode</span><span class="sxs-lookup"><span data-stu-id="0dbca-168">How to override the ToString method</span></span>](./how-to-override-the-tostring-method.md)

## <a name="see-also"></a><span data-ttu-id="0dbca-169">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="0dbca-169">See also</span></span>

- [<span data-ttu-id="0dbca-170">C#-Programmierhandbuch</span><span class="sxs-lookup"><span data-stu-id="0dbca-170">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="0dbca-171">Vererbung</span><span class="sxs-lookup"><span data-stu-id="0dbca-171">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="0dbca-172">Abstrakte und versiegelte Klassen und Klassenmember</span><span class="sxs-lookup"><span data-stu-id="0dbca-172">Abstract and Sealed Classes and Class Members</span></span>](./abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="0dbca-173">Methoden</span><span class="sxs-lookup"><span data-stu-id="0dbca-173">Methods</span></span>](./methods.md)
- [<span data-ttu-id="0dbca-174">Ereignisse</span><span class="sxs-lookup"><span data-stu-id="0dbca-174">Events</span></span>](../events/index.md)
- [<span data-ttu-id="0dbca-175">Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="0dbca-175">Properties</span></span>](./properties.md)
- [<span data-ttu-id="0dbca-176">Indexer</span><span class="sxs-lookup"><span data-stu-id="0dbca-176">Indexers</span></span>](../indexers/index.md)
- [<span data-ttu-id="0dbca-177">Typen</span><span class="sxs-lookup"><span data-stu-id="0dbca-177">Types</span></span>](../types/index.md)
