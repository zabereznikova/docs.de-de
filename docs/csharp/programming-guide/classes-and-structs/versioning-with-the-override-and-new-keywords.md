---
title: Versionsverwaltung mit den Schlüsselwörtern „override“ und „new“ – C#-Programmierhandbuch
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- C# language, versioning
- C# language, override and new
ms.assetid: 88247d07-bd0d-49e9-a619-45ccbbfdf0c5
ms.openlocfilehash: ddb34fd32d13224faed92bd8ba01933ca19c04a9
ms.sourcegitcommit: bdd930b5df20a45c29483d905526a2a3e4d17c5b
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 12/11/2018
ms.locfileid: "53241534"
---
# <a name="versioning-with-the-override-and-new-keywords-c-programming-guide"></a><span data-ttu-id="5a616-102">Versionsverwaltung mit den Schlüsselwörtern "override" und "new" (C#-Programmierhandbuch)</span><span class="sxs-lookup"><span data-stu-id="5a616-102">Versioning with the Override and New Keywords (C# Programming Guide)</span></span>
<span data-ttu-id="5a616-103">Die C#-Sprache wurde entwickelt, damit die Versionierung von [base](../../../csharp/language-reference/keywords/base.md)- (Basis-) und abgeleiteten Klassen in unterschiedlichen Bibliotheken weiterentwickelt und die Abwärtskompatibilität aufrechterhalten werden kann.</span><span class="sxs-lookup"><span data-stu-id="5a616-103">The C# language is designed so that versioning between [base](../../../csharp/language-reference/keywords/base.md) and derived classes in different libraries can evolve and maintain backward compatibility.</span></span> <span data-ttu-id="5a616-104">Das bedeutet z.B., dass die Einführung eines neuen Members in einer [Basisklasse](../../../csharp/language-reference/keywords/class.md) mit demselben Name wie ein Member in einer abgeleiteten Klasse von C# vollständig unterstützt wird und nicht zu unerwartetem Verhalten führt.</span><span class="sxs-lookup"><span data-stu-id="5a616-104">This means, for example, that the introduction of a new member in a base [class](../../../csharp/language-reference/keywords/class.md) with the same name as a member in a derived class is completely supported by C# and does not lead to unexpected behavior.</span></span> <span data-ttu-id="5a616-105">Das bedeutet auch, dass eine Klasse explizit angeben muss, ob eine Methode für das außer Kraft setzen einer geerbten Methode vorgesehen ist, oder ob eine Methode eine neue Methode ist, die eine Methode mit ähnlichem Namen verbirgt.</span><span class="sxs-lookup"><span data-stu-id="5a616-105">It also means that a class must explicitly state whether a method is intended to override an inherited method, or whether a method is a new method that hides a similarly named inherited method.</span></span>  
  
 <span data-ttu-id="5a616-106">In C# können abgeleitete Klassen Methoden mit dem gleichen Namen wie Basisklassen-Methoden enthalten.</span><span class="sxs-lookup"><span data-stu-id="5a616-106">In C#, derived classes can contain methods with the same name as base class methods.</span></span>  
  
-   <span data-ttu-id="5a616-107">Die Basisklasse muss als [virtual](../../../csharp/language-reference/keywords/virtual.md) definiert werden.</span><span class="sxs-lookup"><span data-stu-id="5a616-107">The base class method must be defined [virtual](../../../csharp/language-reference/keywords/virtual.md).</span></span>  
  
-   <span data-ttu-id="5a616-108">Wenn der Methode in der abgeleiteten Klasse nicht die Schlüsselwörter [new](../../../csharp/language-reference/keywords/new.md) oder [override](../../../csharp/language-reference/keywords/override.md) vorangestellt sind, gibt der Compiler eine Warnung aus, und die Methode verhält sich, als ob das Schlüsselwort `new` vorhanden wäre.</span><span class="sxs-lookup"><span data-stu-id="5a616-108">If the method in the derived class is not preceded by [new](../../../csharp/language-reference/keywords/new.md) or [override](../../../csharp/language-reference/keywords/override.md) keywords, the compiler will issue a warning and the method will behave as if the `new` keyword were present.</span></span>  
  
-   <span data-ttu-id="5a616-109">Wenn der Methode in der abgeleiteten Klasse das Schlüsselwort `new` vorangestellt ist, wird die Methode als unabhängig von der Methode in der Basisklasse definiert.</span><span class="sxs-lookup"><span data-stu-id="5a616-109">If the method in the derived class is preceded with the `new` keyword, the method is defined as being independent of the method in the base class.</span></span>  
  
-   <span data-ttu-id="5a616-110">Wenn der Methode in der abgeleiteten Klasse das Schlüsselwort `override` vorangestellt ist, rufen Objekte der abgeleiteten Klasse diese Methode anstatt der Methode der Basisklasse auf.</span><span class="sxs-lookup"><span data-stu-id="5a616-110">If the method in the derived class is preceded with the `override` keyword, objects of the derived class will call that method instead of the base class method.</span></span>  
  
-   <span data-ttu-id="5a616-111">Die Methode der Basisklasse kann mithilfe des Schlüsselworts `base` aus der Basisklasse heraus aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="5a616-111">The base class method can be called from within the derived class using the `base` keyword.</span></span>  
  
-   <span data-ttu-id="5a616-112">Die Schlüsselwörter `override`, `virtual` und `new` können auch auf Eigenschaften, Indexer und Ereignisse angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="5a616-112">The `override`, `virtual`, and `new` keywords can also be applied to properties, indexers, and events.</span></span>  
  
 <span data-ttu-id="5a616-113">Standardmäßig sind C#-Methoden nicht virtuell.</span><span class="sxs-lookup"><span data-stu-id="5a616-113">By default, C# methods are not virtual.</span></span> <span data-ttu-id="5a616-114">Wenn eine Methode als virtuell deklariert wird, kann jede Klasse, die die Methode erbt, ihre eigene Version implementieren.</span><span class="sxs-lookup"><span data-stu-id="5a616-114">If a method is declared as virtual, any class inheriting the method can implement its own version.</span></span> <span data-ttu-id="5a616-115">Um eine Methode in eine virtuelle Methode zu transformieren, wird der Modifizierer `virtual` in der Methodendeklaration der Basisklasse verwendet.</span><span class="sxs-lookup"><span data-stu-id="5a616-115">To make a method virtual, the `virtual` modifier is used in the method declaration of the base class.</span></span> <span data-ttu-id="5a616-116">Die abgeleitete Klasse kann anschließend die virtuelle Methode der Basisklasse mithilfe des Schlüsselworts `override` überschreiben oder die virtuelle Methode in der Basisklasse mithilfe des Schlüsselworts `new` verbergen.</span><span class="sxs-lookup"><span data-stu-id="5a616-116">The derived class can then override the base virtual method by using the `override` keyword or hide the virtual method in the base class by using the `new` keyword.</span></span> <span data-ttu-id="5a616-117">Wenn weder das Schlüsselwort `override` noch das Schlüsselwort `new` angegeben ist, gibt der Compiler eine Warnung aus, und die Methode in der abgeleiteten Klasse verbirgt die Methode in der Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="5a616-117">If neither the `override` keyword nor the `new` keyword is specified, the compiler will issue a warning and the method in the derived class will hide the method in the base class.</span></span>  
  
 <span data-ttu-id="5a616-118">Nehmen wir zur Veranschaulichung dieser Vorgehensweise für einen Moment an, dass die Firma A eine Klasse mit dem Namen `GraphicsClass` erstellt, die Ihr Programm benutzt.</span><span class="sxs-lookup"><span data-stu-id="5a616-118">To demonstrate this in practice, assume for a moment that Company A has created a class named `GraphicsClass`, which your program uses.</span></span> <span data-ttu-id="5a616-119">Die folgende Datei ist `GraphicsClass`:</span><span class="sxs-lookup"><span data-stu-id="5a616-119">The following is `GraphicsClass`:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#27](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_1.cs)]  
  
 <span data-ttu-id="5a616-120">Ihr Unternehmen verwendet diese Klasse, und Sie verwenden sie zum Ableiten einer Klasse oder zum Hinzufügen einer neuen Methode:</span><span class="sxs-lookup"><span data-stu-id="5a616-120">Your company uses this class, and you use it to derive your own class, adding a new method:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#28](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_2.cs)]  
  
 <span data-ttu-id="5a616-121">Ihre Anwendung wird ohne Probleme verwendet, bis Firma A eine neue Version von `GraphicsClass` herausgibt, die dem folgenden Code ähnelt:</span><span class="sxs-lookup"><span data-stu-id="5a616-121">Your application is used without problems, until Company A releases a new version of `GraphicsClass`, which resembles the following code:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#29](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_3.cs)]  
  
 <span data-ttu-id="5a616-122">Die neue Version von `GraphicsClass` enthält jetzt eine Methode namens `DrawRectangle`.</span><span class="sxs-lookup"><span data-stu-id="5a616-122">The new version of `GraphicsClass` now contains a method named `DrawRectangle`.</span></span> <span data-ttu-id="5a616-123">Anfänglich geschieht nichts.</span><span class="sxs-lookup"><span data-stu-id="5a616-123">Initially, nothing occurs.</span></span> <span data-ttu-id="5a616-124">Die neue Version ist immer noch binärkompatibel mit der alten Version.</span><span class="sxs-lookup"><span data-stu-id="5a616-124">The new version is still binary compatible with the old version.</span></span> <span data-ttu-id="5a616-125">Jede Software, die Sie entwickelt haben, funktioniert weiterhin, sogar wenn die neue Klasse auf diesen Computersystemen installiert ist.</span><span class="sxs-lookup"><span data-stu-id="5a616-125">Any software that you have deployed will continue to work, even if the new class is installed on those computer systems.</span></span> <span data-ttu-id="5a616-126">Aufgrund vorhandener Aufrufe der Methode verweist `DrawRectangle` weiterhin auf Ihre Version in Ihrer abgeleiteten Klasse.</span><span class="sxs-lookup"><span data-stu-id="5a616-126">Any existing calls to the method `DrawRectangle` will continue to reference your version, in your derived class.</span></span>  
  
 <span data-ttu-id="5a616-127">Sobald Sie Ihre Anwendung aber mit der neuen Version von `GraphicsClass` neu kompilieren, erhalten Sie vom Compiler eine Warnung, CS0108.</span><span class="sxs-lookup"><span data-stu-id="5a616-127">However, as soon as you recompile your application by using the new version of `GraphicsClass`, you will receive a warning from the compiler, CS0108.</span></span> <span data-ttu-id="5a616-128">Diese Warnung informiert Sie darüber, dass Sie das gewünschte Verhalten der `DrawRectangle`-Methode in Ihrer Anwendung bestimmen müssen.</span><span class="sxs-lookup"><span data-stu-id="5a616-128">This warning informs you that you have to consider how you want your `DrawRectangle` method to behave in your application.</span></span>  
  
 <span data-ttu-id="5a616-129">Wenn Sie möchten, dass Ihre Methode die neue Basisklassenmethode außer Kraft setzt, verwenden Sie das Schlüsselwort `override`:</span><span class="sxs-lookup"><span data-stu-id="5a616-129">If you want your method to override the new base class method, use the `override` keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#30](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_4.cs)]  
  
 <span data-ttu-id="5a616-130">Das Schlüsselwort `override` stellt sicher, dass alle Objekte, die von `YourDerivedGraphicsClass` abgeleitet sind, die Version von `DrawRectangle` der abgeleiteten Klasse verwenden.</span><span class="sxs-lookup"><span data-stu-id="5a616-130">The `override` keyword makes sure that any objects derived from `YourDerivedGraphicsClass` will use the derived class version of `DrawRectangle`.</span></span> <span data-ttu-id="5a616-131">Objekte, die von `YourDerivedGraphicsClass` abgeleitet sind, können auf die Basisklassenversion von `DrawRectangle` mithilfe des base-Schlüsselworts zugreifen:</span><span class="sxs-lookup"><span data-stu-id="5a616-131">Objects derived from `YourDerivedGraphicsClass` can still access the base class version of `DrawRectangle` by using the base keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#44](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_5.cs)]  
  
 <span data-ttu-id="5a616-132">Wenn Sie nicht möchten, dass Ihre Methode die neue Basisklassenmethode außer Kraft setzt, gelten die folgenden Überlegungen.</span><span class="sxs-lookup"><span data-stu-id="5a616-132">If you do not want your method to override the new base class method, the following considerations apply.</span></span> <span data-ttu-id="5a616-133">Sie können Ihre Methode umbenennen, um Verwechslungen zwischen den beiden Methoden zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="5a616-133">To avoid confusion between the two methods, you can rename your method.</span></span> <span data-ttu-id="5a616-134">Dies kann zeitaufwändig und fehleranfällig sein und ist in einigen Fällen einfach nicht praktikabel.</span><span class="sxs-lookup"><span data-stu-id="5a616-134">This can be time-consuming and error-prone, and just not practical in some cases.</span></span> <span data-ttu-id="5a616-135">Wenn das Projekt aber relativ klein ist, können Sie die Refactoring-Optionen von Visual Studio verwenden, um die Methode umzubenennen.</span><span class="sxs-lookup"><span data-stu-id="5a616-135">However, if your project is relatively small, you can use Visual Studio's Refactoring options to rename the method.</span></span> <span data-ttu-id="5a616-136">Weitere Informationen finden Sie unter [Refactoring von Klassen und Typen (Klassen-Designer)](/visualstudio/ide/refactoring-classes-and-types-class-designer).</span><span class="sxs-lookup"><span data-stu-id="5a616-136">For more information, see [Refactoring Classes and Types (Class Designer)](/visualstudio/ide/refactoring-classes-and-types-class-designer).</span></span>  
  
 <span data-ttu-id="5a616-137">Alternativ können Sie die Warnung vermeiden, indem Sie in der Definition Ihrer abgeleiteten Klasse das Schlüsselwort `new` verwenden:</span><span class="sxs-lookup"><span data-stu-id="5a616-137">Alternatively, you can prevent the warning by using the keyword `new` in your derived class definition:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#31](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_6.cs)]  
  
 <span data-ttu-id="5a616-138">Mit dem Schlüsselwort `new` teilt der Compiler mit, dass Ihre Definition die Definition ausblendet, die in der Basisklasse enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="5a616-138">Using the `new` keyword tells the compiler that your definition hides the definition that is contained in the base class.</span></span> <span data-ttu-id="5a616-139">Dies ist das Standardverhalten.</span><span class="sxs-lookup"><span data-stu-id="5a616-139">This is the default behavior.</span></span>  
  
## <a name="override-and-method-selection"></a><span data-ttu-id="5a616-140">Überschreiben und Methodenauswahl</span><span class="sxs-lookup"><span data-stu-id="5a616-140">Override and Method Selection</span></span>  
 <span data-ttu-id="5a616-141">Wenn eine Methode in einer Klasse benannt wird, wählt der C#-Compiler die beste Methode zum Aufrufen aus, wenn mehr als eine Methode mit dem Aufruf kompatibel ist, z.B. wenn es zwei Methoden mit dem gleichen Namen und Parameter gibt, die mit dem übergebenen Parameter kompatibel sind.</span><span class="sxs-lookup"><span data-stu-id="5a616-141">When a method is named on a class, the C# compiler selects the best method to call if more than one method is compatible with the call, such as when there are two methods with the same name, and parameters that are compatible with the parameter passed.</span></span> <span data-ttu-id="5a616-142">Die folgenden Methoden wären kompatibel:</span><span class="sxs-lookup"><span data-stu-id="5a616-142">The following methods would be compatible:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#32](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_7.cs)]  
  
 <span data-ttu-id="5a616-143">Wenn `DoWork` für eine Instanz von `Derived` aufgerufen wird, versucht der C#-Compiler zuerst, den Aufruf mit den Versionen von `DoWork` kompatibel zu machen, die ursprünglich für `Derived` deklariert wurden.</span><span class="sxs-lookup"><span data-stu-id="5a616-143">When `DoWork` is called on an instance of `Derived`, the C# compiler will first try to make the call compatible with the versions of `DoWork` declared originally on `Derived`.</span></span> <span data-ttu-id="5a616-144">Override-Methoden werden nicht als Methoden angesehen, die für eine Klasse deklariert sind. Stattdessen sind sie neue Implementierungen einer Methode, die für eine Basisklasse deklariert wurde.</span><span class="sxs-lookup"><span data-stu-id="5a616-144">Override methods are not considered as declared on a class, they are new implementations of a method declared on a base class.</span></span> <span data-ttu-id="5a616-145">Nur wenn der C#-Compiler keine Übereinstimmung des Methodenaufrufs mit dem Aufruf einer ursprünglichen Methode in `Derived` feststellen kann, versucht er, den Aufruf mit einer überschriebenen Methode mit dem gleichen Namen und kompatiblen Parametern übereinzustimmen.</span><span class="sxs-lookup"><span data-stu-id="5a616-145">Only if the C# compiler cannot match the method call to an original method on `Derived` will it try to match the call to an overridden method with the same name and compatible parameters.</span></span> <span data-ttu-id="5a616-146">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="5a616-146">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#33](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_8.cs)]  
  
 <span data-ttu-id="5a616-147">Da die Variable `val` implizit in einen Double-Wert konvertiert werden kann, ruft der C#-Compiler `DoWork(double)` anstelle von `DoWork(int)` auf.</span><span class="sxs-lookup"><span data-stu-id="5a616-147">Because the variable `val` can be converted to a double implicitly, the C# compiler calls `DoWork(double)` instead of `DoWork(int)`.</span></span> <span data-ttu-id="5a616-148">Es gibt zwei Möglichkeiten, das zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="5a616-148">There are two ways to avoid this.</span></span> <span data-ttu-id="5a616-149">Vermeiden Sie zuerst das Deklarieren neuer Methoden mit dem gleichen Namen wie virtuelle Methoden.</span><span class="sxs-lookup"><span data-stu-id="5a616-149">First, avoid declaring new methods with the same name as virtual methods.</span></span> <span data-ttu-id="5a616-150">Zweitens können Sie den C#-Compiler anweisen, die virtuelle Methode aufzurufen, indem Sie eine Suche nach der Liste der Basisklassenmethode durchführen lassen. Dies geschieht durch umwandeln der Instanz von `Derived` in `Base`.</span><span class="sxs-lookup"><span data-stu-id="5a616-150">Second, you can instruct the C# compiler to call the virtual method by making it search the base class method list by casting the instance of `Derived` to `Base`.</span></span> <span data-ttu-id="5a616-151">Da es sich um eine virtuelle Methode handelt, wird die Implementierung von `DoWork(int)` auf `Derived` aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="5a616-151">Because the method is virtual, the implementation of `DoWork(int)` on `Derived` will be called.</span></span> <span data-ttu-id="5a616-152">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="5a616-152">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#34](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/versioning-with-the-override-and-new-keywords_9.cs)]  
  
 <span data-ttu-id="5a616-153">Weitere Beispiele für `new` und `override` finden Sie unter [Wann müssen die Schlüsselwörter „override“ und „new“ verwendet werden?](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="5a616-153">For more examples of `new` and `override`, see [Knowing When to Use Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5a616-154">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="5a616-154">See Also</span></span>

- [<span data-ttu-id="5a616-155">C#-Programmierhandbuch</span><span class="sxs-lookup"><span data-stu-id="5a616-155">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
- [<span data-ttu-id="5a616-156">Klassen und Strukturen</span><span class="sxs-lookup"><span data-stu-id="5a616-156">Classes and Structs</span></span>](../../../csharp/programming-guide/classes-and-structs/index.md)  
- [<span data-ttu-id="5a616-157">Methoden</span><span class="sxs-lookup"><span data-stu-id="5a616-157">Methods</span></span>](../../../csharp/programming-guide/classes-and-structs/methods.md)  
- [<span data-ttu-id="5a616-158">Vererbung</span><span class="sxs-lookup"><span data-stu-id="5a616-158">Inheritance</span></span>](../../../csharp/programming-guide/classes-and-structs/inheritance.md)
