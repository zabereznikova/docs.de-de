---
title: Lokale Funktionen – C#-Programmierhandbuch
description: Lokale Funktionen in C# sind private Methoden, die in einem anderen Member geschachtelt sind und aus dem enthaltenden Member aufgerufen werden können.
ms.date: 10/16/2020
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: 75accda2e40443073274ece4d8964c13a0945dad
ms.sourcegitcommit: dfcbc096ad7908cd58a5f0aeabd2256f05266bac
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 10/21/2020
ms.locfileid: "92332899"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="1cdf1-103">Lokale Funktionen (C#-Programmierhandbuch)</span><span class="sxs-lookup"><span data-stu-id="1cdf1-103">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="1cdf1-104">Ab C#-7.0 unterstützt C# *lokale Funktionen* .</span><span class="sxs-lookup"><span data-stu-id="1cdf1-104">Starting with C# 7.0, C# supports *local functions* .</span></span> <span data-ttu-id="1cdf1-105">Lokale Funktionen sind private Methoden eines Typs, die in einem anderen Member geschachtelt sind.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-105">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="1cdf1-106">Sie können nur aus ihrem enthaltenden Member aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-106">They can only be called from their containing member.</span></span> <span data-ttu-id="1cdf1-107">Lokale Funktionen können deklariert und aufgerufen werden aus:</span><span class="sxs-lookup"><span data-stu-id="1cdf1-107">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="1cdf1-108">Methoden, insbesondere Iteratormethoden und Async-Methoden</span><span class="sxs-lookup"><span data-stu-id="1cdf1-108">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="1cdf1-109">Konstruktoren</span><span class="sxs-lookup"><span data-stu-id="1cdf1-109">Constructors</span></span>
- <span data-ttu-id="1cdf1-110">Eigenschaftenaccessoren</span><span class="sxs-lookup"><span data-stu-id="1cdf1-110">Property accessors</span></span>
- <span data-ttu-id="1cdf1-111">Ereignisaccessoren</span><span class="sxs-lookup"><span data-stu-id="1cdf1-111">Event accessors</span></span>
- <span data-ttu-id="1cdf1-112">Anonymen Methoden</span><span class="sxs-lookup"><span data-stu-id="1cdf1-112">Anonymous methods</span></span>
- <span data-ttu-id="1cdf1-113">Lambdaausdrücke</span><span class="sxs-lookup"><span data-stu-id="1cdf1-113">Lambda expressions</span></span>
- <span data-ttu-id="1cdf1-114">Finalizer</span><span class="sxs-lookup"><span data-stu-id="1cdf1-114">Finalizers</span></span>
- <span data-ttu-id="1cdf1-115">Anderen lokalen Funktionen</span><span class="sxs-lookup"><span data-stu-id="1cdf1-115">Other local functions</span></span>

<span data-ttu-id="1cdf1-116">Lokale Funktionen können jedoch nicht in einem Ausdruckskörpermember deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-116">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="1cdf1-117">In einigen Fällen können Sie einen Lambdaausdruck zum Implementieren von Funktionen verwenden, die auch von einer lokalen Funktion unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-117">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="1cdf1-118">Einen Vergleich finden Sie unter [Lokale Funktionen im Vergleich zu Lambdaausdrücken](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="1cdf1-118">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="1cdf1-119">Lokale Funktionen machen den Zweck Ihres Codes deutlich.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-119">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="1cdf1-120">Beim Lesen des Codes wird deutlich, dass die Methode nur von der enthaltenden Methode aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-120">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="1cdf1-121">Bei Teamprojekten wird auch verhindert, dass ein anderer Entwickler die Methode versehentlich direkt an anderer Stelle in der Klasse oder Struktur aufruft.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-121">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="1cdf1-122">Syntax einer lokalen Funktion</span><span class="sxs-lookup"><span data-stu-id="1cdf1-122">Local function syntax</span></span>

<span data-ttu-id="1cdf1-123">Eine lokale Funktion wird definiert als eine geschachtelte Methode in einem enthaltenden Member.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-123">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="1cdf1-124">Ihre Definition besitzt die folgende Syntax:</span><span class="sxs-lookup"><span data-stu-id="1cdf1-124">Its definition has the following syntax:</span></span>

```csharp
<modifiers> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="1cdf1-125">Sie können die folgenden Modifizierer mit einer lokalen Funktion verwenden:</span><span class="sxs-lookup"><span data-stu-id="1cdf1-125">You can use the following modifiers with a local function:</span></span>

- [`async`](../../language-reference/keywords/async.md)
- [`unsafe`](../../language-reference/keywords/unsafe.md)
- <span data-ttu-id="1cdf1-126">[`static`](../../language-reference/keywords/static.md) (in C# 8.0 und höher).</span><span class="sxs-lookup"><span data-stu-id="1cdf1-126">[`static`](../../language-reference/keywords/static.md) (in C# 8.0 and later).</span></span> <span data-ttu-id="1cdf1-127">Eine statische lokale Funktion kann keine lokalen Variablen oder den Instanzzustand erfassen.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-127">A static local function can't capture local variables or instance state.</span></span>
- <span data-ttu-id="1cdf1-128">[`extern`](../../language-reference/keywords/extern.md) (in C# 9.0 und höher).</span><span class="sxs-lookup"><span data-stu-id="1cdf1-128">[`extern`](../../language-reference/keywords/extern.md) (in C# 9.0 and later).</span></span> <span data-ttu-id="1cdf1-129">Eine externe lokale Funktion muss `static` sein.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-129">An external local function must be `static`.</span></span>

<span data-ttu-id="1cdf1-130">Alle im enthaltenden Member definierten lokalen Variablen, einschließlich der Methodenparameter, sind in einer nicht statischen lokalen Funktion zugänglich.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-130">All local variables that are defined in the containing member, including its method parameters, are accessible in a non-static local function.</span></span>

<span data-ttu-id="1cdf1-131">Im Gegensatz zu einer Methodendefinition kann die Definition einer lokalen Funktion keinen Memberzugriffsmodifizierer enthalten.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-131">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="1cdf1-132">Da alle lokale Funktionen privat sind, generiert das Verwenden eines Zugriffsmodifizierers wie etwa das Schlüsselwort `private` den Compilerfehler CS0106 „Der Modifizierer ‚private‘ ist für dieses Element nicht gültig“.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-132">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

<span data-ttu-id="1cdf1-133">Das folgende Beispiel definiert eine lokale Funktion mit dem Namen `AppendPathSeparator`, die für eine Methode mit dem Namen `GetText` privat ist:</span><span class="sxs-lookup"><span data-stu-id="1cdf1-133">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="Basic" :::

<span data-ttu-id="1cdf1-134">Ab C# 9.0 können Sie Attribute auf eine lokale Funktion, ihre Parameter und Typparameter anwenden. Sehen Sie sich dazu das folgende Beispiel an:</span><span class="sxs-lookup"><span data-stu-id="1cdf1-134">Beginning with C# 9.0, you can apply attributes to a local function, its parameters and type parameters, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="WithAttributes" :::

<span data-ttu-id="1cdf1-135">Im vorherigen Beispiel wird ein [spezielles Attribut](../../language-reference/attributes/nullable-analysis.md) verwendet, um den Compiler bei der statischen Analyse in einem Nullable-Kontext zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-135">The preceding example uses a [special attribute](../../language-reference/attributes/nullable-analysis.md) to assist the compiler in static analysis in a nullable context.</span></span>

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="1cdf1-136">Lokale Funktionen und Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="1cdf1-136">Local functions and exceptions</span></span>

<span data-ttu-id="1cdf1-137">Eine nützliche Funktion von lokalen Funktionen ist die Tatsache, dass sie Ausnahmen sofort verfügbar machen können.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-137">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="1cdf1-138">Bei Methodeniteratoren werden Ausnahmen erst eingeblendet, wenn die zurückgegebene Sequenz aufgelistet wird, und nicht, wenn der Iterator abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-138">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="1cdf1-139">Bei async-Methoden werden Ausnahmen festgestellt, wenn die zurückgegebene Aufgabe erwartet wird.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-139">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="1cdf1-140">Das folgende Beispiel definiert eine `OddSequence`-Methode, die ungerade Zahlen in einem angegebenen Bereich aufzählt.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-140">The following example defines an `OddSequence` method that enumerates odd numbers in a specified range.</span></span> <span data-ttu-id="1cdf1-141">Da eine Zahl größer als 100 an die `OddSequence`-Enumeratormethode übergeben wird, wird <xref:System.ArgumentOutOfRangeException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-141">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="1cdf1-142">Die Ausgabe des Beispiels zeigt, dass die Ausnahme erst beim Durchlaufen der Zahlen und nicht beim Abrufen des Enumerators eingeblendet wird.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-142">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithoutLocal.cs" :::

<span data-ttu-id="1cdf1-143">Wenn Sie Iteratorlogik in eine lokale Funktion platzieren, werden Ausnahmen bei der Argumentvalidierung ausgelöst, wenn Sie den Enumerator abrufen. Sehen Sie sich dazu das folgende Beispiel an:</span><span class="sxs-lookup"><span data-stu-id="1cdf1-143">If you put iterator logic into a local function, argument validation exceptions are thrown when you retrieve the enumerator, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithLocal.cs" :::

<span data-ttu-id="1cdf1-144">Sie können lokale Funktionen auf ähnliche Weise wie asynchrone Vorgänge nutzen.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-144">You can use local functions in a similar way with asynchronous operations.</span></span> <span data-ttu-id="1cdf1-145">Ausnahmen, die in einer asynchronen Methode ausgelöst werden, treten auf, wenn der entsprechende Task erwartet wird.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-145">Exceptions thrown in an async method surface when the corresponding task is awaited.</span></span> <span data-ttu-id="1cdf1-146">Lokale Funktionen ermöglichen einen schnellen Abbruch Ihres Codes. Ihre Ausnahme kann sowohl synchron ausgelöst als auch beobachtet werden.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-146">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="1cdf1-147">Im folgenden Beispiel wird eine asynchrone Methode mit dem Namen `GetMultipleAsync` verwendet, um für eine bestimmte Anzahl von Sekunden anzuhalten und ein zufälliges Vielfaches dieser Sekundenanzahl zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-147">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="1cdf1-148">Die maximale Verzögerung beträgt 5 Sekunden. <xref:System.ArgumentOutOfRangeException> wird ausgegeben, wenn der Wert größer als 5 ist.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-148">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="1cdf1-149">Wie das folgende Beispiel zeigt, tritt die Ausnahme, die ausgelöst wird, wenn an die `GetMultipleAsync`-Methode ein Wert von 6 übergeben wird, nur dann auf, wenn der Task erwartet wird.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-149">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is observed only when the task is awaited.</span></span>

:::code language="csharp" source="snippets/local-functions/AsyncWithoutLocal.cs" :::

<span data-ttu-id="1cdf1-150">Wie beim Methodeniterator können Sie das vorherige Beispiel umgestalten und den Code eines asynchronen Vorgangs in eine lokale Funktion platzieren.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-150">Like with the method iterator, you can refactor the preceding example and put the code of asynchronous operation in a local function.</span></span> <span data-ttu-id="1cdf1-151">Wie die Ausgabe des folgenden Beispiels zeigt, wird <xref:System.ArgumentOutOfRangeException> ausgelöst, sobald die `GetMultiple`-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-151">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is thrown as soon as the `GetMultiple` method is called.</span></span>

:::code language="csharp" source="snippets/local-functions/AsyncWithLocal.cs" :::

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="1cdf1-152">Lokale Funktionen im Vergleich zu Lambdaausdrücken</span><span class="sxs-lookup"><span data-stu-id="1cdf1-152">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="1cdf1-153">Auf den ersten Blick sind lokale Funktionen und [Lambdaausdrücke](../../language-reference/operators/lambda-expressions.md) sehr ähnlich.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-153">At first glance, local functions and [lambda expressions](../../language-reference/operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="1cdf1-154">In vielen Fällen ist die Entscheidung zwischen Lamdaausdrücken und lokalen Funktionen eine Frage des Formats und persönlicher Präferenz.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-154">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="1cdf1-155">Es gibt allerdings tatsächliche Unterschiede, wann das eine oder das andere verwendet werden kann. Diese sollten Ihnen bekannt sein.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-155">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="1cdf1-156">Sehen wir uns die Unterschiede zwischen der Implementierungen des Fakultätsalgorithmus als lokale Funktion und als Lambdaausdruck an.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-156">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="1cdf1-157">Dies ist die Version mit einer lokalen Funktion:</span><span class="sxs-lookup"><span data-stu-id="1cdf1-157">Here's the version using a local function:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLocal" :::

<span data-ttu-id="1cdf1-158">Diese Version verwendet Lambdaausdrücke:</span><span class="sxs-lookup"><span data-stu-id="1cdf1-158">This version uses lambda expressions:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLambda" :::

### <a name="naming"></a><span data-ttu-id="1cdf1-159">Benennung</span><span class="sxs-lookup"><span data-stu-id="1cdf1-159">Naming</span></span>

<span data-ttu-id="1cdf1-160">Lokale Funktionen werden explizit wie Methoden benannt.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-160">Local functions are explicitly named like methods.</span></span> <span data-ttu-id="1cdf1-161">Lambdaausdrücke sind anonyme Methoden und müssen Variablen eines `delegate`-Typs zugewiesen werden. In der Regel handelt es sich entweder um `Action`- oder `Func`-Typen.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-161">Lambda expressions are anonymous methods and need to be assigned to variables of a `delegate` type, typically either `Action` or `Func` types.</span></span> <span data-ttu-id="1cdf1-162">Die Deklaration einer lokalen Funktion erfolgt so ähnlich wie das Schreiben einer normalen Methode. Sie müssen dazu einen Rückgabetyp und eine Funktionssignatur deklarieren.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-162">When you declare a local function, the process is like writing a normal method; you declare a return type and a function signature.</span></span>

### <a name="function-signatures-and-lambda-expression-types"></a><span data-ttu-id="1cdf1-163">Funktionssignaturen und Typen für Lambdaausdrücke</span><span class="sxs-lookup"><span data-stu-id="1cdf1-163">Function signatures and lambda expression types</span></span>

<span data-ttu-id="1cdf1-164">Beim Bestimmen der Argument- und Rückgabetypen sind Lambdaausdrücke auf den Typ der `Action`/`Func`-Variablen angewiesen, der sie zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-164">Lambda expressions rely on the type of the `Action`/`Func` variable that they're assigned to determine the argument and return types.</span></span> <span data-ttu-id="1cdf1-165">Da die Syntax in lokalen Funktionen stark einer normalen Methode ähnelt, sind die Argumenttypen und der Rückgabetyp bereits Teil der Funktionsdeklaration.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-165">In local functions, since the syntax is much like writing a normal method, argument types and return type are already part of the function declaration.</span></span>

### <a name="definite-assignment"></a><span data-ttu-id="1cdf1-166">Definite assignment (Festgelegte Zuweisung)</span><span class="sxs-lookup"><span data-stu-id="1cdf1-166">Definite assignment</span></span>

<span data-ttu-id="1cdf1-167">Lambdaausdrücke sind Objekte, die zur Laufzeit deklariert und zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-167">Lambda expressions are objects that are declared and assigned at runtime.</span></span> <span data-ttu-id="1cdf1-168">Damit ein Lambdaausdruck verwendet werden kann, muss er definitiv zugewiesen werden: die `Action`/`Func`-Variable, der er zugewiesen wird, muss deklariert werden. Anschließend muss der Lambdaausdruck der Variablen zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-168">In order for a lambda expression to be used, it needs to be definitely assigned: the `Action`/`Func` variable that it will be assigned to must be declared and the lambda expression assigned to it.</span></span> <span data-ttu-id="1cdf1-169">Beachten Sie, dass `LambdaFactorial` den Lambdaausdruck `nthFactorial` deklarieren und initialisieren muss, bevor dieser definiert wird.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-169">Notice that `LambdaFactorial` must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="1cdf1-170">Wird das nicht gemacht, führt dies zu einem Kompilierzeitfehler, weil auf `nthFactorial` verwiesen wurde, bevor es zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-170">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>

<span data-ttu-id="1cdf1-171">Lokale Funktionen werden zur Kompilierzeit definiert.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-171">Local functions are defined at compile time.</span></span> <span data-ttu-id="1cdf1-172">Da sie keinen Variablen zugewiesen werden, kann an jeder Stelle im Code **innerhalb des Gültigkeitsbereichs der Funktion** darauf verwiesen werden. Im ersten Beispiel `LocalFunctionFactorial` konnten Sie die lokale Funktion entweder oberhalb oder unterhalb der `return`-Anweisung deklarieren, ohne Compilerfehler auszulösen.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-172">As they're not assigned to variables, they can be referenced from any code location **where it is in scope** ; in our first example `LocalFunctionFactorial`, we could declare our local function either above or below the `return` statement and not trigger any compiler errors.</span></span>

<span data-ttu-id="1cdf1-173">Diese Unterschiede bedeuten, dass rekursive Algorithmen mit lokalen Funktionen leichter erstellt werden können.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-173">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="1cdf1-174">Sie können eine lokale Funktion deklarieren und definieren, die sich selbst aufruft.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-174">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="1cdf1-175">Lambdaausdrücke müssen deklariert werden, und dann muss ihnen ein Standardwert zugewiesen werden, bevor sie erneut einem Text zugewiesen werden können, der auf den gleichen Lambdaausdruck verweist.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-175">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

### <a name="implementation-as-a-delegate"></a><span data-ttu-id="1cdf1-176">Implementierung als Delegat</span><span class="sxs-lookup"><span data-stu-id="1cdf1-176">Implementation as a delegate</span></span>

<span data-ttu-id="1cdf1-177">Lambdaausdrücke werden bei der Deklaration in Delegate konvertiert.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-177">Lambda expressions are converted to delegates when they're declared.</span></span> <span data-ttu-id="1cdf1-178">Lokale Funktionen sind flexibler, da sie wie eine herkömmliche Methode *oder* als Delegat geschrieben werden können.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-178">Local functions are more flexible in that they can be written like a traditional method *or* as a delegate.</span></span> <span data-ttu-id="1cdf1-179">Lokale Funktionen werden nur dann in Delegate konvertiert, wenn sie als Delegate ***verwendet*** werden.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-179">Local functions are only converted to delegates when ***used*** as a delegate.</span></span>

<span data-ttu-id="1cdf1-180">Wenn Sie eine lokale Funktion deklarieren und nur darauf verweisen, indem Sie sie wie eine Methode aufrufen, wird sie nicht in einen Delegaten konvertiert.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-180">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span>

### <a name="variable-capture"></a><span data-ttu-id="1cdf1-181">Erfassung von Variablen</span><span class="sxs-lookup"><span data-stu-id="1cdf1-181">Variable capture</span></span>

<span data-ttu-id="1cdf1-182">Die Regeln für [definitive Zuweisungen](../../../../_csharplang/spec/variables.md#definite-assignment) gelten auch für alle Variablen, die von der lokalen Funktion oder dem Lambdaausdruck erfasst werden.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-182">The rules of [definite assignment](../../../../_csharplang/spec/variables.md#definite-assignment) also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="1cdf1-183">Zudem kann der Compiler statische Analysen durchführen, mit denen lokale Funktionen erfasste Variablen im einschließenden Gültigkeitsbereich definitiv zuweisen können.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-183">The compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="1cdf1-184">Betrachten Sie das folgende Beispiel:</span><span class="sxs-lookup"><span data-stu-id="1cdf1-184">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="1cdf1-185">Der Compiler kann festlegen, dass `LocalFunction``y` bei Aufruf definitiv zuweist.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-185">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="1cdf1-186">Da `LocalFunction` vor der `return`-Anweisung aufgerufen wird, wird `y` definitiv bei der `return`-Anweisung zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-186">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="1cdf1-187">Beachten Sie, dass die lokale Funktion als Delegattyp implementiert wird, wenn diese lokale Funktion Variablen im einschließenden Gültigkeitsbereich erfasst.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-187">Note that when a local function captures variables in the enclosing scope, the local function is implemented as a delegate type.</span></span>

### <a name="heap-allocations"></a><span data-ttu-id="1cdf1-188">Heapzuweisungen</span><span class="sxs-lookup"><span data-stu-id="1cdf1-188">Heap allocations</span></span>

<span data-ttu-id="1cdf1-189">Je nach Verwendung können lokale Funktionen Heapzuweisungen vermeiden, die immer für Lambdaausdrücke erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-189">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="1cdf1-190">Wenn eine lokale Funktion nie in einen Delegaten konvertiert wird und keine der von der lokalen Funktion erfassten Variablen von anderen Lambdaausdrücken oder lokalen Funktionen, die in Delegate konvertiert werden, erfasst wird, kann der Compiler Heapzuweisungen vermeiden.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-190">If a local function is never converted to a delegate, and none of the variables captured by the local function are captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="1cdf1-191">Betrachten Sie das folgende asynchrone Beispiel:</span><span class="sxs-lookup"><span data-stu-id="1cdf1-191">Consider this async example:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLambda" :::

<span data-ttu-id="1cdf1-192">Der Abschluss dieses Lambdaausdrucks enthält die Variablen `address`, `index` und `name`.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-192">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="1cdf1-193">Im Fall von lokalen Funktionen ist das Objekt, das den Abschluss implementiert, möglicherweise vom Typ `struct`.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-193">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="1cdf1-194">Dieser struct-Typ würde per Verweis an die lokale Funktion übergeben.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-194">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="1cdf1-195">Dieser Unterschied bei der Implementierung würde bei einer Zuweisung gespart.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-195">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="1cdf1-196">Die für Lambdaausdrücke erforderliche Instanziierung bedeutet zusätzliche Speicherbelegung, was ein Leistungsfaktor in zeitkritischen Codepfaden sein kann.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-196">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="1cdf1-197">Lokale Funktionen erfordern diesen Mehraufwand nicht.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-197">Local functions do not incur this overhead.</span></span> <span data-ttu-id="1cdf1-198">Im obigen Beispiel hat die Version mit der lokalen Funktion zwei Zuordnungen weniger als die Version mit dem Lambdaausdruck.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-198">In the example above, the local functions version has two fewer allocations than the lambda expression version.</span></span>

<span data-ttu-id="1cdf1-199">Wenn Sie wissen, dass Ihre lokale Funktion nicht in einen Delegaten konvertiert wird und dass keine der von ihr erfassten Variablen auch von anderen Lambdaausdrücken oder lokalen Funktionen, die in Delegate konvertiert werden, erfasst wird, können Sie durch Deklarieren der lokalen Funktion als statisch (`static`) verhindern, dass Ihre lokale Funktion im Heap zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-199">If you know that your local function won't be converted to a delegate and none of the variables captured by it are captured by other lambdas or local functions that are converted to delegates, you can guarantee that your local function avoids being allocated on the heap by declaring it as a `static` local function.</span></span> <span data-ttu-id="1cdf1-200">Beachten Sie, dass dieses Feature in C# 8.0 und höher verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-200">Note that this feature is available in C# 8.0 and newer.</span></span>

> [!NOTE]
> <span data-ttu-id="1cdf1-201">Die Entsprechung dieser Methode mit der lokalen Funktion verwendet auch eine Klasse für den Abschluss.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-201">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="1cdf1-202">Ob der Abschluss für eine lokale Funktion als `class` oder `struct` implementiert wird, ist ein Implementierungsdetail.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-202">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="1cdf1-203">Eine lokale Funktion verwendet möglicherweise `struct`, während ein Lambdaausdruck immer `class` nutzt.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-203">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLocal" :::

### <a name="usage-of-the-yield-keyword"></a><span data-ttu-id="1cdf1-204">Verwendung des Schlüsselworts `yield`</span><span class="sxs-lookup"><span data-stu-id="1cdf1-204">Usage of the `yield` keyword</span></span>

<span data-ttu-id="1cdf1-205">Eine letzter Vorteil, der in diesem Beispiel zu kurz gekommen ist, besteht darin, dass lokale Funktionen mithilfe der `yield return`-Syntax als Iteratoren implementiert werden können, um eine Sequenz von Werten zu erzeugen.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-205">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="YieldReturn" :::

<span data-ttu-id="1cdf1-206">Die `yield return`-Anweisung ist in Lambdaausdrücken unzulässig. Weitere Informationen finden Sie unter [Compilerfehler CS1621](../../misc/cs1621.md).</span><span class="sxs-lookup"><span data-stu-id="1cdf1-206">The `yield return` statement is not allowed in lambda expressions, see [compiler error CS1621](../../misc/cs1621.md).</span></span>

<span data-ttu-id="1cdf1-207">Während lokale Funktionen für Lambdaausdrücke als überflüssig erscheinen, dienen sie tatsächlich anderen Zwecken und haben unterschiedliche Verwendungen.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-207">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="1cdf1-208">Lokale Funktionen sind effizienter, im Fall dass Sie eine Funktion schreiben möchten, die nur aus dem Kontext einer anderen Methode abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1cdf1-208">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="1cdf1-209">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="1cdf1-209">See also</span></span>

- [<span data-ttu-id="1cdf1-210">Methoden</span><span class="sxs-lookup"><span data-stu-id="1cdf1-210">Methods</span></span>](methods.md)
