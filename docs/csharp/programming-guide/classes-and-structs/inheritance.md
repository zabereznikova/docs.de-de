---
title: Vererbung – C#-Programmierhandbuch
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- abstract methods [C#]
- abstract classes [C#]
- inheritance [C#]
- derived classes [C#]
- virtual methods [C#]
- C# language, inheritance
ms.assetid: 81d64ee4-50f9-4d6c-a8dc-257c348d2eea
ms.openlocfilehash: 9ad7253fb9efc891e1f0fdea118e1fe7bde6a857
ms.sourcegitcommit: 16aefeb2d265e69c0d80967580365fabf0c5d39a
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/18/2019
ms.locfileid: "58125914"
---
# <a name="inheritance-c-programming-guide"></a><span data-ttu-id="c1f64-102">Vererbung (C#-Programmierhandbuch)</span><span class="sxs-lookup"><span data-stu-id="c1f64-102">Inheritance (C# Programming Guide)</span></span>

<span data-ttu-id="c1f64-103">Die Vererbung ist, zusammen mit der Kapselung und der Polymorphie, eines der drei primären Charakteristika des objektorientierten Programmierens.</span><span class="sxs-lookup"><span data-stu-id="c1f64-103">Inheritance, together with encapsulation and polymorphism, is one of the three primary characteristics of object-oriented programming.</span></span> <span data-ttu-id="c1f64-104">Die Vererbung ermöglicht die Erstellung neuer Klassen, die in anderen Klassen definiertes Verhalten wieder verwenden, erweitern und ändern.</span><span class="sxs-lookup"><span data-stu-id="c1f64-104">Inheritance enables you to create new classes that reuse, extend, and modify the behavior that is defined in other classes.</span></span> <span data-ttu-id="c1f64-105">Die Klasse, deren Member vererbt werden, wird *Basisklasse* genannt, und die Klasse, die diese Member erbt, wird *abgeleitete Klasse* genannt.</span><span class="sxs-lookup"><span data-stu-id="c1f64-105">The class whose members are inherited is called the *base class*, and the class that inherits those members is called the *derived class*.</span></span> <span data-ttu-id="c1f64-106">Eine abgeleitete Klasse kann nur eine direkte Basisklasse haben.</span><span class="sxs-lookup"><span data-stu-id="c1f64-106">A derived class can have only one direct base class.</span></span> <span data-ttu-id="c1f64-107">Doch die Vererbung ist transitiv.</span><span class="sxs-lookup"><span data-stu-id="c1f64-107">However, inheritance is transitive.</span></span> <span data-ttu-id="c1f64-108">Wenn Klasse C von Klasse B abgeleitet wird, und Klasse B von Klasse A abgeleitet wird, erbt Klasse C die in Klasse B und A deklarierten Member.</span><span class="sxs-lookup"><span data-stu-id="c1f64-108">If ClassC is derived from ClassB, and ClassB is derived from ClassA, ClassC inherits the members declared in ClassB and ClassA.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c1f64-109">Strukturen unterstützen die Vererbung nicht, aber sie können Schnittstellen implementieren.</span><span class="sxs-lookup"><span data-stu-id="c1f64-109">Structs do not support inheritance, but they can implement interfaces.</span></span> <span data-ttu-id="c1f64-110">Weitere Informationen finden Sie unter [Schnittstellen](../../../csharp/programming-guide/interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="c1f64-110">For more information, see [Interfaces](../../../csharp/programming-guide/interfaces/index.md).</span></span>  
  
 <span data-ttu-id="c1f64-111">Konzeptuell gesehen ist die abgeleitete Klasse eine Spezialisierung der Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="c1f64-111">Conceptually, a derived class is a specialization of the base class.</span></span> <span data-ttu-id="c1f64-112">Wenn Sie beispielsweise eine Basisklasse `Animal` haben, haben Sie möglicherweise eine abgeleitete Klasse mit dem Namen `Mammal` und eine andere abgeleitete Klasse mit dem Namen `Reptile`.</span><span class="sxs-lookup"><span data-stu-id="c1f64-112">For example, if you have a base class `Animal`, you might have one derived class that is named `Mammal` and another derived class that is named `Reptile`.</span></span> <span data-ttu-id="c1f64-113">Ein `Mammal` ist ein `Animal`, und ein `Reptile` ist ein `Animal`, aber jede abgeleitete Klasse repräsentiert unterschiedliche Spezialisierungen der Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="c1f64-113">A `Mammal` is an `Animal`, and a `Reptile` is an `Animal`, but each derived class represents different specializations of the base class.</span></span>  
  
 <span data-ttu-id="c1f64-114">Wenn Sie eine Klasse definieren, die von einer anderen Klasse abgeleitet werden soll, erhält die abgeleitete Klasse implizit alle Member der Basisklasse – ausgenommen davon sind deren Konstruktoren und Finalizern.</span><span class="sxs-lookup"><span data-stu-id="c1f64-114">When you define a class to derive from another class, the derived class implicitly gains all the members of the base class, except for its constructors and finalizers.</span></span> <span data-ttu-id="c1f64-115">Die abgeleitete Klasse kann so den Code der Basisklasse wiederverwenden, ohne diesen erneut implementieren zu müssen.</span><span class="sxs-lookup"><span data-stu-id="c1f64-115">The derived class can thereby reuse the code in the base class without having to re-implement it.</span></span> <span data-ttu-id="c1f64-116">Sie können der abgeleiteten Klasse mehr Member hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="c1f64-116">In the derived class, you can add more members.</span></span> <span data-ttu-id="c1f64-117">Auf diese Art erweitert die abgeleitete Klasse die Funktionalität der Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="c1f64-117">In this manner, the derived class extends the functionality of the base class.</span></span>  
  
 <span data-ttu-id="c1f64-118">Die folgende Abbildung zeigt eine Klasse `WorkItem`, die ein Arbeitselement in einem Geschäftsprozess repräsentiert.</span><span class="sxs-lookup"><span data-stu-id="c1f64-118">The following illustration shows a class `WorkItem` that represents an item of work in some business process.</span></span> <span data-ttu-id="c1f64-119">Wie alle Klassen leitet es sich von <xref:System.Object?displayProperty=nameWithType> ab und erbt dessen Methoden.</span><span class="sxs-lookup"><span data-stu-id="c1f64-119">Like all classes, it derives from <xref:System.Object?displayProperty=nameWithType> and inherits all its methods.</span></span> <span data-ttu-id="c1f64-120">`WorkItem` fügt von allein fünf Member hinzu.</span><span class="sxs-lookup"><span data-stu-id="c1f64-120">`WorkItem` adds five members of its own.</span></span> <span data-ttu-id="c1f64-121">Diese beinhalten einen Konstruktor, weil Konstruktoren nicht vererbt werden.</span><span class="sxs-lookup"><span data-stu-id="c1f64-121">These include a constructor, because constructors are not inherited.</span></span> <span data-ttu-id="c1f64-122">Die Klasse `ChangeRequest` erbt von `WorkItem` und repräsentiert eine bestimmt Art von Arbeitselementen.</span><span class="sxs-lookup"><span data-stu-id="c1f64-122">Class `ChangeRequest` inherits from `WorkItem` and represents a particular kind of work item.</span></span> <span data-ttu-id="c1f64-123">`ChangeRequest` fügt den von `WorkItem` und <xref:System.Object> geerbten Membern zwei weitere Member hinzu.</span><span class="sxs-lookup"><span data-stu-id="c1f64-123">`ChangeRequest` adds two more members to the members that it inherits from `WorkItem` and from <xref:System.Object>.</span></span> <span data-ttu-id="c1f64-124">Es muss seinen eigenen Konstruktor hinzufügen, und es fügt auch `originalItemID` hinzu.</span><span class="sxs-lookup"><span data-stu-id="c1f64-124">It must add its own constructor, and it also adds `originalItemID`.</span></span> <span data-ttu-id="c1f64-125">Die Eigenschaft `originalItemID` ermöglicht es der `ChangeRequest`-Instanz, mit dem ursprünglichen `WorkItem` verknüpft zu werden, für das die Änderungsanforderung gilt.</span><span class="sxs-lookup"><span data-stu-id="c1f64-125">Property `originalItemID` enables the `ChangeRequest` instance to be associated with the original `WorkItem` to which the change request applies.</span></span>  
  
 ![Diagramm, das die Klassenvererbung zeigt](./media/inheritance/class-inheritance-diagram.png)  
  
 <span data-ttu-id="c1f64-127">Das folgende Beispiel zeigt, wie die in der oben stehenden Abbildung veranschaulichten Klassenbeziehungen in C# ausgedrückt werden.</span><span class="sxs-lookup"><span data-stu-id="c1f64-127">The following example shows how the class relationships demonstrated in the previous illustration are expressed in C#.</span></span> <span data-ttu-id="c1f64-128">Das Beispiel zeigt auch, wie `WorkItem` die virtuelle Methode <xref:System.Object.ToString%2A?displayProperty=nameWithType> außer Kraft setzt, und wie die `ChangeRequest`-Klasse die `WorkItem`-Implementierung der Methode erbt.</span><span class="sxs-lookup"><span data-stu-id="c1f64-128">The example also shows how `WorkItem` overrides the virtual method <xref:System.Object.ToString%2A?displayProperty=nameWithType>, and how the `ChangeRequest` class inherits the `WorkItem` implementation of the method.</span></span>  
  
 [!code-csharp[csProgGuideInheritance#49](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#49)]  
  
## <a name="abstract-and-virtual-methods"></a><span data-ttu-id="c1f64-129">Abstrakte und virtuelle Methoden</span><span class="sxs-lookup"><span data-stu-id="c1f64-129">Abstract and Virtual Methods</span></span>  
 <span data-ttu-id="c1f64-130">Wenn eine Basisklasse eine Methode als [virtuell](../../../csharp/language-reference/keywords/virtual.md) deklariert, kann eine abgeleitete Klasse die Methode mit ihrer eigenen Implementierung [außer Kraft setzen](../../../csharp/language-reference/keywords/override.md).</span><span class="sxs-lookup"><span data-stu-id="c1f64-130">When a base class declares a method as [virtual](../../../csharp/language-reference/keywords/virtual.md), a derived class can [override](../../../csharp/language-reference/keywords/override.md) the method with its own implementation.</span></span> <span data-ttu-id="c1f64-131">Wenn eine Basisklasse eine Methode als [abstrakt](../../../csharp/language-reference/keywords/abstract.md) deklariert, muss diese Methode in jeder nicht abstrakten Klasse außer Kraft gesetzt werden, die direkt von dieser Klasse erbt.</span><span class="sxs-lookup"><span data-stu-id="c1f64-131">If a base class declares a member as [abstract](../../../csharp/language-reference/keywords/abstract.md), that method must be overridden in any non-abstract class that directly inherits from that class.</span></span> <span data-ttu-id="c1f64-132">Wenn eine abgeleitete Klasse selbst abstrakt ist, erbt sie abstrakte Member, ohne diese zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="c1f64-132">If a derived class is itself abstract, it inherits abstract members without implementing them.</span></span> <span data-ttu-id="c1f64-133">Abstrakte und virtuelle Member sind die Basis für Polymorphie, die das zweite charakteristische Merkmal des objektorientierten Programmierens ist.</span><span class="sxs-lookup"><span data-stu-id="c1f64-133">Abstract and virtual members are the basis for polymorphism, which is the second primary characteristic of object-oriented programming.</span></span> <span data-ttu-id="c1f64-134">Weitere Informationen finden Sie unter [Polymorphie](../../../csharp/programming-guide/classes-and-structs/polymorphism.md).</span><span class="sxs-lookup"><span data-stu-id="c1f64-134">For more information, see [Polymorphism](../../../csharp/programming-guide/classes-and-structs/polymorphism.md).</span></span>  
  
## <a name="abstract-base-classes"></a><span data-ttu-id="c1f64-135">Abstrakte Basisklassen</span><span class="sxs-lookup"><span data-stu-id="c1f64-135">Abstract Base Classes</span></span>  
 <span data-ttu-id="c1f64-136">Sie können eine Klasse als [abstrakt](../../../csharp/language-reference/keywords/abstract.md) deklarieren, wenn Sie die direkte Instanziierung mit dem Schlüsselwort [new](../../../csharp/language-reference/keywords/new.md) vermeiden möchten.</span><span class="sxs-lookup"><span data-stu-id="c1f64-136">You can declare a class as [abstract](../../../csharp/language-reference/keywords/abstract.md) if you want to prevent direct instantiation by using the [new](../../../csharp/language-reference/keywords/new.md) keyword.</span></span> <span data-ttu-id="c1f64-137">Wenn Sie dies machen, kann die Klasse nur verwendet werden, wenn eine neue Klasse von ihr abgeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="c1f64-137">If you do this, the class can be used only if a new class is derived from it.</span></span> <span data-ttu-id="c1f64-138">Eine abstrakte Klasse kann mindestens eine Methodensignatur enthalten, die selbst auch als abstrakt deklariert wurden.</span><span class="sxs-lookup"><span data-stu-id="c1f64-138">An abstract class can contain one or more method signatures that themselves are declared as abstract.</span></span> <span data-ttu-id="c1f64-139">Diese Signaturen geben die Parameter und Rückgabewerte an, verfügen aber über keine Implementierung (Methodenkörper).</span><span class="sxs-lookup"><span data-stu-id="c1f64-139">These signatures specify the parameters and return value but have no implementation (method body).</span></span> <span data-ttu-id="c1f64-140">Eine abstrakte Klasse muss nicht zwangsläufig abstrakte Member enthalten; wenn eine Klasse allerdings einen abstrakten Member enthält, muss die Klasse an sich auch als abstrakt deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="c1f64-140">An abstract class does not have to contain abstract members; however, if a class does contain an abstract member, the class itself must be declared as abstract.</span></span> <span data-ttu-id="c1f64-141">Abgeleitete Klassen, die nicht selbst abstrakt sind, müssen eine Implementierung für jede beliebige abstrakte Methode aus einer abstrakten Basisklasse bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="c1f64-141">Derived classes that are not abstract themselves must provide the implementation for any abstract methods from an abstract base class.</span></span> <span data-ttu-id="c1f64-142">Weitere Informationen finden Sie unter [Abstrakte und versiegelte Klassen und Klassenmember](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="c1f64-142">For more information, see [Abstract and Sealed Classes and Class Members](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md).</span></span>  
  
## <a name="interfaces"></a><span data-ttu-id="c1f64-143">Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="c1f64-143">Interfaces</span></span>  
 <span data-ttu-id="c1f64-144">Eine *Schnittstelle* ist ein Verweistyp, der einer abstrakten Basisklasse leicht ähnelt, die nur aus zwei abstrakten Membern besteht.</span><span class="sxs-lookup"><span data-stu-id="c1f64-144">An *interface* is a reference type that is somewhat similar to an abstract base class that consists of only abstract members.</span></span> <span data-ttu-id="c1f64-145">Wenn eine Klasse eine Schnittstelle implementiert, muss sie eine Implementierung für alle Member der Schnittstelle bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="c1f64-145">When a class implements an interface, it must provide an implementation for all the members of the interface.</span></span> <span data-ttu-id="c1f64-146">Eine Klasse kann mehrere Schnittstellen implementieren, auch wenn sie nur von einer einzelnen direkten Basisklasse ableiten kann.</span><span class="sxs-lookup"><span data-stu-id="c1f64-146">A class can implement multiple interfaces even though it can derive from only a single direct base class.</span></span>  
  
 <span data-ttu-id="c1f64-147">Schnittstellen werden verwendet, um bestimmte Funktionen zu definieren, die nicht unbedingt in einer „ist ein“-Beziehung zueinander stehen.</span><span class="sxs-lookup"><span data-stu-id="c1f64-147">Interfaces are used to define specific capabilities for classes that do not necessarily have an "is a" relationship.</span></span> <span data-ttu-id="c1f64-148">Die <xref:System.IEquatable%601?displayProperty=nameWithType> -Schnittstelle kann z.B. von jeder beliebigen Klasse oder Struktur implementiert werden, die es Clientcode ermöglichen muss, ermitteln zu können, ob zwei Objekte des Typs äquivalent sind (allerdings definiert der Typ Äquivalenz).</span><span class="sxs-lookup"><span data-stu-id="c1f64-148">For example, the <xref:System.IEquatable%601?displayProperty=nameWithType> interface can be implemented by any class or struct that has to enable client code to determine whether two objects of the type are equivalent (however the type defines equivalence).</span></span> <span data-ttu-id="c1f64-149"><xref:System.IEquatable%601> impliziert nicht dieselbe Art einer „ist ein“-Beziehung, wie sie zwischen einer Basis- und einer abgeleiteten Klasse besteht (z.B. ist ein `Mammal` ein `Animal`).</span><span class="sxs-lookup"><span data-stu-id="c1f64-149"><xref:System.IEquatable%601> does not imply the same kind of "is a" relationship that exists between a base class and a derived class (for example, a `Mammal` is an `Animal`).</span></span> <span data-ttu-id="c1f64-150">Weitere Informationen finden Sie unter [Schnittstellen](../../../csharp/programming-guide/interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="c1f64-150">For more information, see [Interfaces](../../../csharp/programming-guide/interfaces/index.md).</span></span>  
  
## <a name="preventing-further-derivation"></a><span data-ttu-id="c1f64-151">Weitere Ableitung verhindern</span><span class="sxs-lookup"><span data-stu-id="c1f64-151">Preventing Further Derivation</span></span>  
 <span data-ttu-id="c1f64-152">Eine Klasse kann andere Klassen daran hindern, von ihr oder einem ihrer Member zu erben, indem sie sich selbst oder den Member als [versiegelt](../../../csharp/language-reference/keywords/sealed.md) deklariert.</span><span class="sxs-lookup"><span data-stu-id="c1f64-152">A class can prevent other classes from inheriting from it, or from any of its members, by declaring itself or the member as [sealed](../../../csharp/language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="c1f64-153">Weitere Informationen zu abstrakten Klassen finden Sie unter [Abstrakte und versiegelte Klassen und Klassenmember](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="c1f64-153">For more information, see [Abstract and Sealed Classes and Class Members](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md).</span></span>  
  
## <a name="derived-class-hiding-of-base-class-members"></a><span data-ttu-id="c1f64-154">Das Verbergen von Membern der Basisklasse in einer abgeleiteten Klasse</span><span class="sxs-lookup"><span data-stu-id="c1f64-154">Derived Class Hiding of Base Class Members</span></span>  
 <span data-ttu-id="c1f64-155">Eine abgeleitete Klasse kann Basisklassenmember verbergen, indem sie Member mit demselben Namen und derselben Signatur deklariert.</span><span class="sxs-lookup"><span data-stu-id="c1f64-155">A derived class can hide base class members by declaring members with the same name and signature.</span></span> <span data-ttu-id="c1f64-156">Der Modifizierer [new](../../../csharp/language-reference/keywords/new.md) kann verwendet werden, um explizit anzugeben, dass der Member nicht dazu vorgesehen ist, den Basismember außer Kraft zu setzen.</span><span class="sxs-lookup"><span data-stu-id="c1f64-156">The [new](../../../csharp/language-reference/keywords/new.md) modifier can be used to explicitly indicate that the member is not intended to be an override of the base member.</span></span> <span data-ttu-id="c1f64-157">Das Verwenden von [new](../../../csharp/language-reference/keywords/new.md) ist nicht erforderlich, aber es wird eine Compilerwarnung generiert, wenn [new](../../../csharp/language-reference/keywords/new.md) nicht verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="c1f64-157">The use of [new](../../../csharp/language-reference/keywords/new.md) is not required, but a compiler warning will be generated if [new](../../../csharp/language-reference/keywords/new.md) is not used.</span></span> <span data-ttu-id="c1f64-158">Weitere Informationen finden Sie unter [Versionsverwaltung mit den Schlüsselwörtern „override“ und „new“](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md) und [Wann müssen die Schlüsselwörter „override“ und „new“ verwendet werden?](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="c1f64-158">For more information, see [Versioning with the Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md) and [Knowing When to Use Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c1f64-159">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="c1f64-159">See also</span></span>

- [<span data-ttu-id="c1f64-160">C#-Programmierhandbuch</span><span class="sxs-lookup"><span data-stu-id="c1f64-160">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)
- [<span data-ttu-id="c1f64-161">Klassen und Strukturen</span><span class="sxs-lookup"><span data-stu-id="c1f64-161">Classes and Structs</span></span>](../../../csharp/programming-guide/classes-and-structs/index.md)
- [<span data-ttu-id="c1f64-162">class</span><span class="sxs-lookup"><span data-stu-id="c1f64-162">class</span></span>](../../../csharp/language-reference/keywords/class.md)
- [<span data-ttu-id="c1f64-163">struct</span><span class="sxs-lookup"><span data-stu-id="c1f64-163">struct</span></span>](../../../csharp/language-reference/keywords/struct.md)
