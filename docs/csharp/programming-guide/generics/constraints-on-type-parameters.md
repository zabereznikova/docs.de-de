---
title: Einschränkungen für Typparameter – C#-Programmierhandbuch
description: Erfahren Sie mehr über Einschränkungen für Typparameter. Einschränkungen informieren den Compiler darüber, über welche Funktionen ein Typargument verfügen muss.
ms.date: 04/12/2018
helpviewer_keywords:
- generics [C#], type constraints
- type constraints [C#]
- type parameters [C#], constraints
- unbound type parameter [C#]
ms.openlocfilehash: 8230dfed11bb4ba21e922827cc1a525ce45ba3e5
ms.sourcegitcommit: 9d525bb8109216ca1dc9e39c149d4902f4b43da5
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 12/04/2020
ms.locfileid: "96599114"
---
# <a name="constraints-on-type-parameters-c-programming-guide"></a><span data-ttu-id="625d3-104">Einschränkungen für Typparameter (C#-Programmierhandbuch)</span><span class="sxs-lookup"><span data-stu-id="625d3-104">Constraints on type parameters (C# Programming Guide)</span></span>

<span data-ttu-id="625d3-105">Einschränkungen informieren den Compiler über die Funktionen, über die ein Typargument verfügen muss.</span><span class="sxs-lookup"><span data-stu-id="625d3-105">Constraints inform the compiler about the capabilities a type argument must have.</span></span> <span data-ttu-id="625d3-106">Ohne Einschränkungen könnte das Typargument jedes beliebige Argument sein.</span><span class="sxs-lookup"><span data-stu-id="625d3-106">Without any constraints, the type argument could be any type.</span></span> <span data-ttu-id="625d3-107">Der Compiler kann nur die <xref:System.Object?displayProperty=nameWithType>-Elemente annehmen. Dies ist die übergeordnete Basisklasse für jeden beliebigen .NET-Typ.</span><span class="sxs-lookup"><span data-stu-id="625d3-107">The compiler can only assume the members of <xref:System.Object?displayProperty=nameWithType>, which is the ultimate base class for any .NET type.</span></span> <span data-ttu-id="625d3-108">Weitere Informationen finden Sie unter [Weshalb Einschränkungen?](#why-use-constraints).</span><span class="sxs-lookup"><span data-stu-id="625d3-108">For more information, see [Why use constraints](#why-use-constraints).</span></span> <span data-ttu-id="625d3-109">Wenn Clientcode einen Typ verwendet, der einen Constraint nicht erfüllt, gibt der Compiler einen Fehler aus.</span><span class="sxs-lookup"><span data-stu-id="625d3-109">If client code uses a type that doesn't satisfy a constraint, the compiler issues an error.</span></span> <span data-ttu-id="625d3-110">Constraints werden mit dem kontextuellen Schlüsselwort `where` angegeben.</span><span class="sxs-lookup"><span data-stu-id="625d3-110">Constraints are specified by using the `where` contextual keyword.</span></span> <span data-ttu-id="625d3-111">In der folgenden Tabelle werden die verschiedenen Einschränkungstypen aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="625d3-111">The following table lists the various types of constraints:</span></span>

|<span data-ttu-id="625d3-112">Constraint</span><span class="sxs-lookup"><span data-stu-id="625d3-112">Constraint</span></span>|<span data-ttu-id="625d3-113">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="625d3-113">Description</span></span>|
|----------------|-----------------|
|`where T : struct`|<span data-ttu-id="625d3-114">Das Typargument muss ein Non-Nullable-[Werttyp](../../language-reference/builtin-types/value-types.md) sein.</span><span class="sxs-lookup"><span data-stu-id="625d3-114">The type argument must be a non-nullable [value type](../../language-reference/builtin-types/value-types.md).</span></span> <span data-ttu-id="625d3-115">Weitere Informationen zu Nullable-Werttypen finden Sie unter [Nullable-Werttypen](../../language-reference/builtin-types/nullable-value-types.md).</span><span class="sxs-lookup"><span data-stu-id="625d3-115">For information about nullable value types, see [Nullable value types](../../language-reference/builtin-types/nullable-value-types.md).</span></span> <span data-ttu-id="625d3-116">Da alle Werttypen einen parameterlosen Konstruktor aufweisen, auf den zugegriffen werden kann, impliziert die `struct`-Einschränkung die `new()`-Einschränkung und kann nicht mit der `new()`-Einschränkung kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-116">Because all value types have an accessible parameterless constructor, the `struct` constraint implies the `new()` constraint and can't be combined with the `new()` constraint.</span></span> <span data-ttu-id="625d3-117">Ferner kann der `struct`-Constraint nicht mit dem `unmanaged`-Constraint kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-117">You can't combine the `struct` constraint with the `unmanaged` constraint.</span></span>|
|`where T : class`|<span data-ttu-id="625d3-118">Das Typargument muss ein Verweistyp sein.</span><span class="sxs-lookup"><span data-stu-id="625d3-118">The type argument must be a reference type.</span></span> <span data-ttu-id="625d3-119">Diese Einschränkung gilt auch für jede Klasse, Schnittstelle, jeden Delegaten oder Arraytyp.</span><span class="sxs-lookup"><span data-stu-id="625d3-119">This constraint applies also to any class, interface, delegate, or array type.</span></span> <span data-ttu-id="625d3-120">In einem Nullable-Kontext in C# 8.0 oder höher muss `T` ein Non-Nullable-Verweistyp sein.</span><span class="sxs-lookup"><span data-stu-id="625d3-120">In a nullable context in C# 8.0 or later, `T` must be a non-nullable reference type.</span></span> |
|`where T : class?`|<span data-ttu-id="625d3-121">Das Typargument muss ein Nullable- oder ein Non-Nullable-Verweistyp sein.</span><span class="sxs-lookup"><span data-stu-id="625d3-121">The type argument must be a reference type, either nullable or non-nullable.</span></span> <span data-ttu-id="625d3-122">Diese Einschränkung gilt auch für jede Klasse, Schnittstelle, jeden Delegaten oder Arraytyp.</span><span class="sxs-lookup"><span data-stu-id="625d3-122">This constraint applies also to any class, interface, delegate, or array type.</span></span>|
|`where T : notnull`|<span data-ttu-id="625d3-123">Das Typargument muss ein Nicht-Nullable-Typ sein.</span><span class="sxs-lookup"><span data-stu-id="625d3-123">The type argument must be a non-nullable type.</span></span> <span data-ttu-id="625d3-124">Das Argument kann ein Non-Nullable-Verweistyp in C# 8.0 oder höher oder ein Non-Nullable-Werttyp sein.</span><span class="sxs-lookup"><span data-stu-id="625d3-124">The argument can be a non-nullable reference type in C# 8.0 or later, or a non-nullable value type.</span></span> |
|`where T : unmanaged`|<span data-ttu-id="625d3-125">Das Typargument muss ein [nicht verwalteter Non-Nullable-Typ](../../language-reference/builtin-types/unmanaged-types.md) sein.</span><span class="sxs-lookup"><span data-stu-id="625d3-125">The type argument must be a non-nullable [unmanaged type](../../language-reference/builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="625d3-126">Die `unmanaged`-Einschränkung impliziert die `struct`-Einschränkung und kann weder mit der `struct`- noch mit der `new()`-Einschränkung kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-126">The `unmanaged` constraint implies the `struct` constraint and can't be combined with either the `struct` or `new()` constraints.</span></span>|
|`where T : new()`|<span data-ttu-id="625d3-127">Das Typargument muss einen öffentlichen, parameterlosen Konstruktor aufweisen.</span><span class="sxs-lookup"><span data-stu-id="625d3-127">The type argument must have a public parameterless constructor.</span></span> <span data-ttu-id="625d3-128">Beim gemeinsamen Verwenden anderen Constraints muss der `new()`-Constraint zuletzt angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-128">When used together with other constraints, the `new()` constraint must be specified last.</span></span> <span data-ttu-id="625d3-129">Die `new()`-Einschränkung kann nicht mit der `struct`- oder `unmanaged`-Einschränkung kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-129">The `new()` constraint can't be combined with the `struct` and `unmanaged` constraints.</span></span>|
|<span data-ttu-id="625d3-130">`where T :` *\<base class name>*</span><span class="sxs-lookup"><span data-stu-id="625d3-130">`where T :` *\<base class name>*</span></span>|<span data-ttu-id="625d3-131">Das Typargument muss die angegebene Basisklasse sein oder von dieser abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-131">The type argument must be or derive from the specified base class.</span></span> <span data-ttu-id="625d3-132">In einem Nullable-Kontext in C# 8.0 und höher muss `T` ein Non-Nullable-Verweistyp sein, der von der angegebenen Basisklasse abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="625d3-132">In a nullable context in C# 8.0 and later, `T` must be a non-nullable reference type derived from the specified base class.</span></span> |
|<span data-ttu-id="625d3-133">`where T :` *\<base class name>?*</span><span class="sxs-lookup"><span data-stu-id="625d3-133">`where T :` *\<base class name>?*</span></span>|<span data-ttu-id="625d3-134">Das Typargument muss die angegebene Basisklasse sein oder von dieser abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-134">The type argument must be or derive from the specified base class.</span></span> <span data-ttu-id="625d3-135">In einem Nullable-Kontext in C# 8.0 und höher kann `T` entweder ein Nullable- oder ein Non-Nullable-Typ sein, der von der angegebenen Basisklasse abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="625d3-135">In a nullable context in C# 8.0 and later, `T` may be either a nullable or non-nullable type derived from the specified base class.</span></span> |
|<span data-ttu-id="625d3-136">`where T :` *\<interface name>*</span><span class="sxs-lookup"><span data-stu-id="625d3-136">`where T :` *\<interface name>*</span></span>|<span data-ttu-id="625d3-137">Das Typargument muss die angegebene Schnittstelle sein oder diese implementieren.</span><span class="sxs-lookup"><span data-stu-id="625d3-137">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="625d3-138">Es können mehrere Schnittstelleneinschränkungen angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-138">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="625d3-139">Die einschränkende Schnittstelle kann auch generisch sein.</span><span class="sxs-lookup"><span data-stu-id="625d3-139">The constraining interface can also be generic.</span></span> <span data-ttu-id="625d3-140">In einem Nullable-Kontext in C# 8.0 und höher muss `T` ein Non-Nullable-Typ sein, der die angegebenen Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="625d3-140">In a nullable context in C# 8.0 and later, `T` must be a non-nullable type that implements the specified interface.</span></span>|
|<span data-ttu-id="625d3-141">`where T :` *\<interface name>?*</span><span class="sxs-lookup"><span data-stu-id="625d3-141">`where T :` *\<interface name>?*</span></span>|<span data-ttu-id="625d3-142">Das Typargument muss die angegebene Schnittstelle sein oder diese implementieren.</span><span class="sxs-lookup"><span data-stu-id="625d3-142">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="625d3-143">Es können mehrere Schnittstelleneinschränkungen angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-143">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="625d3-144">Die einschränkende Schnittstelle kann auch generisch sein.</span><span class="sxs-lookup"><span data-stu-id="625d3-144">The constraining interface can also be generic.</span></span> <span data-ttu-id="625d3-145">In einem Nullable-Kontext in C# 8.0 kann `T` ein Nullable-Verweistyp, ein Non-Nullable-Verweistyp oder ein Werttyp sein.</span><span class="sxs-lookup"><span data-stu-id="625d3-145">In a nullable context in C# 8.0, `T` may be a nullable reference type, a non-nullable reference type, or a value type.</span></span> <span data-ttu-id="625d3-146">`T` darf kein Nullable-Werttyp sein.</span><span class="sxs-lookup"><span data-stu-id="625d3-146">`T` may not be a nullable value type.</span></span>|
|`where T : U`|<span data-ttu-id="625d3-147">Das Typargument, das für `T` angegeben wird, muss das für `U` angegebene Argument sein oder von diesem abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-147">The type argument supplied for `T` must be or derive from the argument supplied for `U`.</span></span> <span data-ttu-id="625d3-148">Wenn in einem Nullable-Kontext `U` ein Non-Nullable-Verweistyp ist, muss `T` ein Non-Nullable-Verweistyp sein.</span><span class="sxs-lookup"><span data-stu-id="625d3-148">In a nullable context, if `U` is a non-nullable reference type, `T` must be non-nullable reference type.</span></span> <span data-ttu-id="625d3-149">Wenn `U` ein Nullable-Verweistyp ist, kann `T` entweder ein Nullable- oder ein Non-Nullable-Typ sein.</span><span class="sxs-lookup"><span data-stu-id="625d3-149">If `U` is a nullable reference type, `T` may be either nullable or non-nullable.</span></span> |

## <a name="why-use-constraints"></a><span data-ttu-id="625d3-150">Weshalb Einschränkungen?</span><span class="sxs-lookup"><span data-stu-id="625d3-150">Why use constraints</span></span>

<span data-ttu-id="625d3-151">Constraints geben die Funktionen und Erwartungen eines Typparameters an.</span><span class="sxs-lookup"><span data-stu-id="625d3-151">Constraints specify the capabilities and expectations of a type parameter.</span></span> <span data-ttu-id="625d3-152">Das Deklarieren von Constraints bedeutet, dass Sie die Vorgänge und Methodenaufrufe des einschränkenden Typs verwenden können.</span><span class="sxs-lookup"><span data-stu-id="625d3-152">Declaring those constraints means you can use the operations and method calls of the constraining type.</span></span> <span data-ttu-id="625d3-153">Wenn Ihre generischen Klassen oder Methoden Vorgänge für generische Member durchführen sollen, die über das einfache Zuweisen und Aufrufen von Methoden hinausgehen, die nicht von <xref:System.Object?displayProperty=nameWithType> unterstützt werden, müssen Sie Constraints auf den Typparameter anwenden.</span><span class="sxs-lookup"><span data-stu-id="625d3-153">If your generic class or method uses any operation on the generic members beyond simple assignment or calling any methods not supported by <xref:System.Object?displayProperty=nameWithType>, you'll have to apply constraints to the type parameter.</span></span> <span data-ttu-id="625d3-154">Der Basisklassenconstraint sagt dem Compiler z.B., dass nur Objekte dieses Typs oder Objekte, die von diesem Typ abgeleitet werden, als Typargumente verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-154">For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.</span></span> <span data-ttu-id="625d3-155">Sobald der Compiler diese Garantie hat, kann er erlauben, dass Methoden dieses Typs in der generischen Klasse aufgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="625d3-155">Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.</span></span> <span data-ttu-id="625d3-156">Im folgenden Codebeispiel wird die Funktionalität veranschaulicht, die der `GenericList<T>`-Klasse durch das Anwenden einer Basisklasseneinschränkung hinzugefügt werden kann (in [Einführung in Generics](../../../standard/generics/index.md)).</span><span class="sxs-lookup"><span data-stu-id="625d3-156">The following code example demonstrates the functionality you can add to the `GenericList<T>` class (in [Introduction to Generics](../../../standard/generics/index.md)) by applying a base class constraint.</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#9)]

<span data-ttu-id="625d3-157">Die Einschränkung ermöglicht der generischen Klasse, die `Employee.Name`-Eigenschaft zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="625d3-157">The constraint enables the generic class to use the `Employee.Name` property.</span></span> <span data-ttu-id="625d3-158">Die Einschränkung gibt an, dass alle Elemente des Typs `T` entweder ein `Employee`-Objekt oder ein Objekt sind, das von `Employee` erbt.</span><span class="sxs-lookup"><span data-stu-id="625d3-158">The constraint specifies that all items of type `T` are guaranteed to be either an `Employee` object or an object that inherits from `Employee`.</span></span>

<span data-ttu-id="625d3-159">Mehrere Constraints können wie folgt auf den gleichen Typenparameter angewendet werden, und die Contraints können selbst generische Typen sein:</span><span class="sxs-lookup"><span data-stu-id="625d3-159">Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#10)]

<span data-ttu-id="625d3-160">Wenn Sie den Constraint `where T : class` anwenden, vermeiden Sie das Verwenden der Operatoren `==` und `!=` mit dem Typparameter, da diese nur auf Verweisidentität und nicht auf Wertgleichheit prüfen.</span><span class="sxs-lookup"><span data-stu-id="625d3-160">When applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality.</span></span> <span data-ttu-id="625d3-161">Dieses Verhalten tritt auch auf, wenn diese Operatoren in einem Typ überladen werden, der als Argument verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="625d3-161">This behavior occurs even if these operators are overloaded in a type that is used as an argument.</span></span> <span data-ttu-id="625d3-162">Der folgende Code veranschaulicht diesen Aspekt. Die Ausgabe ist FALSE, obwohl die <xref:System.String>-Klasse den `==`-Operator überlädt.</span><span class="sxs-lookup"><span data-stu-id="625d3-162">The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator.</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#11)]

<span data-ttu-id="625d3-163">Der Compiler weiß erst zur Kompilierzeit, dass `T` ein Verweistyp ist und die für alle Verweistypen zulässigen Standardoperatoren verwendet werden müssen.</span><span class="sxs-lookup"><span data-stu-id="625d3-163">The compiler only knows that `T` is a reference type at compile time and must use the default operators that are valid for all reference types.</span></span> <span data-ttu-id="625d3-164">Wenn Sie auf Wertgleichheit prüfen müssen, wird empfohlen, dass Sie die `where T : IEquatable<T>`- oder `where T : IComparable<T>`-Einschränkung anwenden und die Schnittstelle in jeder Klasse implementieren, die verwendet wird, um die generische Klasse zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="625d3-164">If you must test for value equality, the recommended way is to also apply the `where T : IEquatable<T>` or `where T : IComparable<T>` constraint and implement the interface in any class that will be used to construct the generic class.</span></span>

## <a name="constraining-multiple-parameters"></a><span data-ttu-id="625d3-165">Einschränken mehrerer Parameter</span><span class="sxs-lookup"><span data-stu-id="625d3-165">Constraining multiple parameters</span></span>

<span data-ttu-id="625d3-166">Sie können wie im folgenden Beispiel gezeigt Constraints auf mehrere Parameter und mehrere Constraints auf einen einzelnen Parameter anwenden:</span><span class="sxs-lookup"><span data-stu-id="625d3-166">You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#12)]

## <a name="unbounded-type-parameters"></a><span data-ttu-id="625d3-167">Ungebundene Typparameter</span><span class="sxs-lookup"><span data-stu-id="625d3-167">Unbounded type parameters</span></span>

 <span data-ttu-id="625d3-168">Typparameter, auf die keine Constraints angewendet wurden, wie z.B. T in der öffentlichen Klasse `SampleClass<T>{}`, werden als ungebundene Typparameter bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="625d3-168">Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters.</span></span> <span data-ttu-id="625d3-169">Für ungebundene Typparameter gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="625d3-169">Unbounded type parameters have the following rules:</span></span>

- <span data-ttu-id="625d3-170">Die Operatoren `!=` und `==` können nicht verwendet werden, weil es keine Garantie dafür gibt, dass das jeweilige Typargument diese auch unterstützt.</span><span class="sxs-lookup"><span data-stu-id="625d3-170">The `!=` and `==` operators can't be used because there's no guarantee that the concrete type argument will support these operators.</span></span>
- <span data-ttu-id="625d3-171">Sie können in und aus `System.Object` oder implizit in einen Schnittstellentyp konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-171">They can be converted to and from `System.Object` or explicitly converted to any interface type.</span></span>
- <span data-ttu-id="625d3-172">Sie können sie mit [NULL](../../language-reference/keywords/null.md) vergleichen.</span><span class="sxs-lookup"><span data-stu-id="625d3-172">You can compare them to [null](../../language-reference/keywords/null.md).</span></span> <span data-ttu-id="625d3-173">Wenn ein ungebundener Parameter mit `null` verglichen wird, gibt der Vergleich immer FALSE zurück, wenn das Typargument ein Werttyp ist.</span><span class="sxs-lookup"><span data-stu-id="625d3-173">If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type.</span></span>

## <a name="type-parameters-as-constraints"></a><span data-ttu-id="625d3-174">Typparameter als Einschränkungen</span><span class="sxs-lookup"><span data-stu-id="625d3-174">Type parameters as constraints</span></span>

<span data-ttu-id="625d3-175">Es ist nützlich, einen Typparameter wie in folgendem Beispiel gezeigt als Constraint zu verwenden, wenn eine Memberfunktion mit ihren eigenen Typparametern diesen Parameter auf den Typparameter des enthaltenden Typs einschränken muss:</span><span class="sxs-lookup"><span data-stu-id="625d3-175">The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#13)]

<span data-ttu-id="625d3-176">Im vorherigen Beispiel ist `T` ein Typconstraint im Kontext der `Add`-Methode und ein ungebundener Typparameter im Kontext der `List`-Klasse.</span><span class="sxs-lookup"><span data-stu-id="625d3-176">In the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class.</span></span>

<span data-ttu-id="625d3-177">Typparameter können auch in generischen Klassendefinitionen als Constraints verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-177">Type parameters can also be used as constraints in generic class definitions.</span></span> <span data-ttu-id="625d3-178">Der Typparameter in spitzen Klammern muss zusammen mit allen anderen Typparametern deklariert werden:</span><span class="sxs-lookup"><span data-stu-id="625d3-178">The type parameter must be declared within the angle brackets together with any other type parameters:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#14)]

<span data-ttu-id="625d3-179">Das Verwenden von Typparametern als Einschränkungen für generische Klassen ist nur bis zu einem gewissen Punkt nützlich, da der Compiler keine Informationen über den Typparameter annehmen kann, nur dass er von `System.Object` abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="625d3-179">The usefulness of type parameters as constraints with generic classes is limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`.</span></span> <span data-ttu-id="625d3-180">Sie sollten Typparameter als Constraints dann verwenden, wenn Sie eine Vererbungsbeziehung zwischen zwei Typparametern erzwingen möchten.</span><span class="sxs-lookup"><span data-stu-id="625d3-180">Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.</span></span>

## <a name="notnull-constraint"></a><span data-ttu-id="625d3-181">NotNull-Einschränkung</span><span class="sxs-lookup"><span data-stu-id="625d3-181">NotNull constraint</span></span>

<span data-ttu-id="625d3-182">Ab C# 8.0 können Sie in einem Nullable-Kontext mit dem `notnull`-Constraint angeben, dass das Typargument ein Non-Nullable-Werttyp oder -Verweistyp sein muss.</span><span class="sxs-lookup"><span data-stu-id="625d3-182">Beginning with C# 8.0 in a nullable context, you can use the `notnull` constraint to specify that the type argument must be a non-nullable value type or non-nullable reference type.</span></span> <span data-ttu-id="625d3-183">Die `notnull`-Einschränkung kann nur in einem `nullable enable`-Kontext verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-183">The `notnull` constraint can only be used in a `nullable enable` context.</span></span> <span data-ttu-id="625d3-184">Der Compiler generiert eine Warnung, wenn Sie die `notnull`-Einschränkung in einem Kontext hinzufügen, in dem nicht bekannt ist, ob NULL-Werte zugelassen sind.</span><span class="sxs-lookup"><span data-stu-id="625d3-184">The compiler generates a warning if you add the `notnull` constraint in a nullable oblivious context.</span></span>

<span data-ttu-id="625d3-185">Im Gegensatz zu anderen Einschränkungen generiert der Compiler eine Warnung, wenn ein Typargument die `notnull`-Einschränkung verletzt und dieser Code in einem `nullable enable`-Kontext kompiliert wird.</span><span class="sxs-lookup"><span data-stu-id="625d3-185">Unlike other constraints, when a type argument violates the `notnull` constraint, the compiler generates a warning when that code is compiled in a `nullable enable` context.</span></span> <span data-ttu-id="625d3-186">Wenn der Code in einem Kontext kompiliert wird, in dem nicht bekannt ist, ob NULL-Werte zugelassen sind, generiert der Compiler keine Warnungen oder Fehler.</span><span class="sxs-lookup"><span data-stu-id="625d3-186">If the code is compiled in a nullable oblivious context, the compiler doesn't generate any warnings or errors.</span></span>

<span data-ttu-id="625d3-187">Ab C# 8.0 können Sie den `class`-Constraint verwenden, um anzugeben, dass das Typargument ein Non-Nullable-Wert- oder -Verweistyp sein muss.</span><span class="sxs-lookup"><span data-stu-id="625d3-187">Beginning with C# 8.0 in a nullable context, the `class` constraint specifies that the type argument must be a non-nullable reference type.</span></span> <span data-ttu-id="625d3-188">In einem Nullable-Kontext gibt der Compiler eine Warnung aus, wenn ein Typparameter ein Nullable-Verweistyp ist.</span><span class="sxs-lookup"><span data-stu-id="625d3-188">In a nullable context, when a type parameter is a nullable reference type, the compiler generates a warning.</span></span>

## <a name="unmanaged-constraint"></a><span data-ttu-id="625d3-189">Nicht verwaltete Einschränkungen</span><span class="sxs-lookup"><span data-stu-id="625d3-189">Unmanaged constraint</span></span>

<span data-ttu-id="625d3-190">Ab C# 7.3 können Sie die `unmanaged`-Einschränkung nutzen, um anzugeben, dass der Typparameter ein [nicht verwalteter Non-Nullable-Typ](../../language-reference/builtin-types/unmanaged-types.md) sein muss.</span><span class="sxs-lookup"><span data-stu-id="625d3-190">Beginning with C# 7.3, you can use the `unmanaged` constraint to specify that the type parameter must be a non-nullable [unmanaged type](../../language-reference/builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="625d3-191">Die `unmanaged`-Einschränkung ermöglicht Ihnen das Schreiben von wiederverwendbarer Routinen zum Arbeiten mit Typen, die als Speicherblöcke bearbeitet werden können, wie im folgenden Beispiel gezeigt:</span><span class="sxs-lookup"><span data-stu-id="625d3-191">The `unmanaged` constraint enables you to write reusable routines to work with types that can be manipulated as blocks of memory, as shown in the following example:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#15)]

<span data-ttu-id="625d3-192">Die vorherige Methode muss in einen `unsafe`-Kontext kompiliert werden, da sie den `sizeof`-Operator für einen nicht bekannten Typ verwendet, der ein integrierter Typ ist.</span><span class="sxs-lookup"><span data-stu-id="625d3-192">The preceding method must be compiled in an `unsafe` context because it uses the `sizeof` operator on a type not known to be a built-in type.</span></span> <span data-ttu-id="625d3-193">Ohne die `unmanaged`-Einschränkung ist der `sizeof`-Operator nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="625d3-193">Without the `unmanaged` constraint, the `sizeof` operator is unavailable.</span></span>

<span data-ttu-id="625d3-194">Die `unmanaged`-Einschränkung impliziert die `struct`-Einschränkung und kann nicht mit ihr kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-194">The `unmanaged` constraint implies the `struct` constraint and can't be combined with it.</span></span> <span data-ttu-id="625d3-195">Da die `struct`-Einschränkung die `new()`-Einschränkung impliziert, kann die `unmanaged`-Einschränkung ebenso wenig mit der `new()`-Einschränkung kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="625d3-195">Because the `struct` constraint implies the `new()` constraint, the `unmanaged` constraint can't be combined with the `new()` constraint as well.</span></span>

## <a name="delegate-constraints"></a><span data-ttu-id="625d3-196">Delegieren von Einschränkungen</span><span class="sxs-lookup"><span data-stu-id="625d3-196">Delegate constraints</span></span>

<span data-ttu-id="625d3-197">Ab C# 7.3 können Sie auch <xref:System.Delegate?displayProperty=nameWithType> oder <xref:System.MulticastDelegate?displayProperty=nameWithType> als Basisklasseneinschränkung verwenden.</span><span class="sxs-lookup"><span data-stu-id="625d3-197">Also beginning with C# 7.3, you can use <xref:System.Delegate?displayProperty=nameWithType> or <xref:System.MulticastDelegate?displayProperty=nameWithType> as a base class constraint.</span></span> <span data-ttu-id="625d3-198">Die CLR lässt diese Einschränkung immer zu, aber die C#-Sprache lässt sie nicht zu.</span><span class="sxs-lookup"><span data-stu-id="625d3-198">The CLR always allowed this constraint, but the C# language disallowed it.</span></span> <span data-ttu-id="625d3-199">Die `System.Delegate`-Einschränkung ermöglicht es Ihnen, Code zu schreiben, der mit Delegaten in einer typsicheren Weise funktioniert.</span><span class="sxs-lookup"><span data-stu-id="625d3-199">The `System.Delegate` constraint enables you to write code that works with delegates in a type-safe manner.</span></span> <span data-ttu-id="625d3-200">Der folgende Code definiert eine Erweiterungsmethode, die zwei Delegaten kombiniert, sofern diese vom gleichen Typ sind:</span><span class="sxs-lookup"><span data-stu-id="625d3-200">The following code defines an extension method that combines two delegates provided they're the same type:</span></span>

[!code-csharp[using the delegate constraint](snippets/GenericWhereConstraints.cs#16)]

<span data-ttu-id="625d3-201">Sie können die oben dargestellte Methode verwenden, um Delegaten vom selben Typ zu kombinieren:</span><span class="sxs-lookup"><span data-stu-id="625d3-201">You can use the above method to combine delegates that are the same type:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#17)]

<span data-ttu-id="625d3-202">Wenn Sie den Kommentar der letzten Zeile entfernen, findet die Kompilation nicht statt.</span><span class="sxs-lookup"><span data-stu-id="625d3-202">If you uncomment the last line, it won't compile.</span></span> <span data-ttu-id="625d3-203">Sowohl `first` als auch `test` sind Delegattypen, aber sie sind unterschiedlich.</span><span class="sxs-lookup"><span data-stu-id="625d3-203">Both `first` and `test` are delegate types, but they're different delegate types.</span></span>

## <a name="enum-constraints"></a><span data-ttu-id="625d3-204">Enumerationseinschränkungen</span><span class="sxs-lookup"><span data-stu-id="625d3-204">Enum constraints</span></span>

<span data-ttu-id="625d3-205">Ab C# 7.3 können Sie auch den <xref:System.Enum?displayProperty=nameWithType>-Typ als Basisklasseneinschränkung angeben.</span><span class="sxs-lookup"><span data-stu-id="625d3-205">Beginning in C# 7.3, you can also specify the <xref:System.Enum?displayProperty=nameWithType> type as a base class constraint.</span></span> <span data-ttu-id="625d3-206">Die CLR lässt diese Einschränkung immer zu, aber die C#-Sprache lässt sie nicht zu.</span><span class="sxs-lookup"><span data-stu-id="625d3-206">The CLR always allowed this constraint, but the C# language disallowed it.</span></span> <span data-ttu-id="625d3-207">Generics, die `System.Enum` verwenden, bieten typsichere Programmierung zum Zwischenspeichern von Ergebnissen aus der Verwendung der statischen Methoden in `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="625d3-207">Generics using `System.Enum` provide type-safe programming to cache results from using the static methods in `System.Enum`.</span></span> <span data-ttu-id="625d3-208">Im folgenden Beispiel werden alle gültigen Werte für einen Enumerationstyp gefunden, und dann ein Wörterbuch erstellt, das diese Werte ihrer Zeichenfolgendarstellung zuordnet.</span><span class="sxs-lookup"><span data-stu-id="625d3-208">The following sample finds all the valid values for an enum type, and then builds a dictionary that maps those values to its string representation.</span></span>

[!code-csharp[using the enum constraint](snippets/GenericWhereConstraints.cs#18)]

<span data-ttu-id="625d3-209">`Enum.GetValues` und `Enum.GetName` nutzen Reflektion, die Auswirkungen auf die Leistung hat.</span><span class="sxs-lookup"><span data-stu-id="625d3-209">`Enum.GetValues` and `Enum.GetName` use reflection, which has performance implications.</span></span> <span data-ttu-id="625d3-210">Sie können `EnumNamedValues` aufrufen, um eine Sammlung zu erstellen, die zwischengespeichert und wiederverwendet wird, anstatt die Aufrufe zu wiederholen, die eine Reflektion erfordern.</span><span class="sxs-lookup"><span data-stu-id="625d3-210">You can call `EnumNamedValues` to build a collection that is cached and reused rather than repeating the calls that require reflection.</span></span>

<span data-ttu-id="625d3-211">Sie könnten dies wie im folgenden Beispiel gezeigt verwenden, um eine Enumeration und ein Wörterbuch der Werte und Namen zu erstellen:</span><span class="sxs-lookup"><span data-stu-id="625d3-211">You could use it as shown in the following sample to create an enum and build a dictionary of its values and names:</span></span>

[!code-csharp[enum definition](snippets/GenericWhereConstraints.cs#19)]

[!code-csharp[using the enum constrained method](snippets/GenericWhereConstraints.cs#20)]

## <a name="see-also"></a><span data-ttu-id="625d3-212">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="625d3-212">See also</span></span>

- <xref:System.Collections.Generic>
- [<span data-ttu-id="625d3-213">C#-Programmierhandbuch</span><span class="sxs-lookup"><span data-stu-id="625d3-213">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="625d3-214">Einführung in Generics</span><span class="sxs-lookup"><span data-stu-id="625d3-214">Introduction to Generics</span></span>](./index.md)
- [<span data-ttu-id="625d3-215">Generische Klassen</span><span class="sxs-lookup"><span data-stu-id="625d3-215">Generic Classes</span></span>](./generic-classes.md)
- [<span data-ttu-id="625d3-216">new-Einschränkung</span><span class="sxs-lookup"><span data-stu-id="625d3-216">new Constraint</span></span>](../../language-reference/keywords/new-constraint.md)
