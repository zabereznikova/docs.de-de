---
title: Migrieren von WPF-Apps zu .NET Core 3.0
description: Erfahren Sie, wie Sie eine Windows Presentation Foundation-App (WPF) zu .NET Core 3.0 migrieren.
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: fda4f618ddb4a3edbe6f2dd9fba0b10bc618e88d
ms.sourcegitcommit: 71b8f5a2108a0f1a4ef1d8d75c5b3e129ec5ca1e
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 05/29/2020
ms.locfileid: "84201560"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="141c9-103">Migrieren von WPF-Apps zu .NET Core</span><span class="sxs-lookup"><span data-stu-id="141c9-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="141c9-104">In diesem Artikel werden die erforderlichen Schritte zum Migrieren einer Windows Presentation Foundation-App (WPF) von .NET Framework zu .NET Core 3.0 beschrieben.</span><span class="sxs-lookup"><span data-stu-id="141c9-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="141c9-105">Wenn Sie keine WPF-Anwendung zum Portieren zur Verfügung haben, den Prozess aber ausprobieren möchten, können Sie die Beispiel-App **Bean Trader** verwenden, die auf [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="141c9-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="141c9-106">Die ursprüngliche App (für .NET Framework 4.7.2) ist im Ordner „NetFx\BeanTraderClient“ verfügbar.</span><span class="sxs-lookup"><span data-stu-id="141c9-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="141c9-107">Zuerst werden die erforderlichen Schritte zum Portieren von Apps im Allgemeinen erläutert. Anschließend werden die spezifischen Änderungen schrittweise beschrieben, die für das Beispiel **Bean Trader** gelten.</span><span class="sxs-lookup"><span data-stu-id="141c9-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="141c9-108">Zum Migrieren zu .NET Core müssen Sie zuerst Folgendes ausführen:</span><span class="sxs-lookup"><span data-stu-id="141c9-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="141c9-109">Verstehen und Aktualisieren von NuGet-Abhängigkeiten:</span><span class="sxs-lookup"><span data-stu-id="141c9-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="141c9-110">Aktualisieren Sie NuGet-Abhängigkeiten, um das `<PackageReference>`-Format zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="141c9-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="141c9-111">Überprüfen Sie die NuGet-Abhängigkeiten der obersten Ebene auf .NET Core- oder .NET Standard-Kompatibilität.</span><span class="sxs-lookup"><span data-stu-id="141c9-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="141c9-112">Aktualisieren Sie die NuGet-Pakete auf neuere Versionen.</span><span class="sxs-lookup"><span data-stu-id="141c9-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="141c9-113">Verwenden Sie [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md), um .NET-Abhängigkeiten zu verstehen.</span><span class="sxs-lookup"><span data-stu-id="141c9-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="141c9-114">Migrieren der Projektdatei in das neue Format im SDK-Stil:</span><span class="sxs-lookup"><span data-stu-id="141c9-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="141c9-115">Wählen Sie aus, ob Sie sowohl .NET Core als auch .NET Framework oder nur .NET Core als Ziel verwenden möchten.</span><span class="sxs-lookup"><span data-stu-id="141c9-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="141c9-116">Kopieren Sie relevante Projektdateieigenschaften und -elemente in die neue Projektdatei.</span><span class="sxs-lookup"><span data-stu-id="141c9-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="141c9-117">Beheben von Buildproblemen:</span><span class="sxs-lookup"><span data-stu-id="141c9-117">Fix build issues:</span></span>

    01. <span data-ttu-id="141c9-118">Fügen Sie einen Verweis auf das [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/)-Paket hinzu.</span><span class="sxs-lookup"><span data-stu-id="141c9-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="141c9-119">Suchen und beheben Sie Unterschiede auf API-Ebene.</span><span class="sxs-lookup"><span data-stu-id="141c9-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="141c9-120">Entfernen Sie *app.config*-Abschnitte mit Ausnahme von `appSettings` oder `connectionStrings`.</span><span class="sxs-lookup"><span data-stu-id="141c9-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="141c9-121">Generieren Sie ggf. generierten Code neu.</span><span class="sxs-lookup"><span data-stu-id="141c9-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="141c9-122">Laufzeittests:</span><span class="sxs-lookup"><span data-stu-id="141c9-122">Runtime testing:</span></span>

    01. <span data-ttu-id="141c9-123">Bestätigen Sie, dass die portierte App erwartungsgemäß funktioniert.</span><span class="sxs-lookup"><span data-stu-id="141c9-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="141c9-124">Beachten Sie <xref:System.NotSupportedException>-Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="141c9-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="141c9-125">Über das Beispiel</span><span class="sxs-lookup"><span data-stu-id="141c9-125">About the sample</span></span>

<span data-ttu-id="141c9-126">In diesem Artikel wird auf die Beispiel-App [Bean Trader](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) verwiesen, da sie eine Vielzahl von Abhängigkeiten verwendet, die denen von echten WPF-Apps ähneln.</span><span class="sxs-lookup"><span data-stu-id="141c9-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="141c9-127">Die App ist nicht groß, soll aber in Bezug auf Komplexität einen Schritt weiter gehen als „Hello World“.</span><span class="sxs-lookup"><span data-stu-id="141c9-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="141c9-128">Die App zeigt einige Probleme, die bei der Portierung von echten Apps auftreten können.</span><span class="sxs-lookup"><span data-stu-id="141c9-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="141c9-129">Die App kommuniziert mit einem WCF-Dienst. Damit sie ordnungsgemäß ausgeführt werden kann, müssen Sie das BeanTraderServer-Projekt (verfügbar im gleichen GitHub-Repository) ausführen und sicherstellen, dass die BeanTraderClient-Konfiguration auf den richtigen Endpunkt verweist.</span><span class="sxs-lookup"><span data-stu-id="141c9-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="141c9-130">(Standardmäßig nimmt das Beispiel an, dass der Server auf demselben Computer unter `http://localhost:8090` ausgeführt wird, was zutrifft, wenn Sie BeanTraderServer lokal starten.)</span><span class="sxs-lookup"><span data-stu-id="141c9-130">(By default, the sample assumes the server is running on the same machine at `http://localhost:8090`, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="141c9-131">Beachten Sie, dass diese Beispiel-App dazu gedacht ist, Herausforderungen bei der .NET Core-Portierung zu zeigen und-Lösungen zu veranschaulichen.</span><span class="sxs-lookup"><span data-stu-id="141c9-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="141c9-132">Er soll keine bewährten Methoden für WPF zeigen.</span><span class="sxs-lookup"><span data-stu-id="141c9-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="141c9-133">Tatsächlich enthält es absichtlich einige Antimuster, um sicherzustellen, dass Sie bei der Portierung mit einigen interessanten Herausforderungen konfrontiert werden.</span><span class="sxs-lookup"><span data-stu-id="141c9-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="141c9-134">Vorbereitung</span><span class="sxs-lookup"><span data-stu-id="141c9-134">Getting ready</span></span>

<span data-ttu-id="141c9-135">Die Hauptaufgabe der Migration einer .NET Framework-App zu .NET Core besteht darin, dass ihre Abhängigkeiten möglicherweise anders oder überhaupt nicht funktionieren.</span><span class="sxs-lookup"><span data-stu-id="141c9-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="141c9-136">Die Migration ist viel einfacher als früher: Viele NuGet-Pakete verwenden jetzt .NET-Standard als Ziel.</span><span class="sxs-lookup"><span data-stu-id="141c9-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="141c9-137">Ab .NET Core 2.0 sind die .NET Framework- und .NET Core-Oberflächenbereiche ähnlich.</span><span class="sxs-lookup"><span data-stu-id="141c9-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="141c9-138">Dennoch bleiben einige Unterschiede (sowohl bei der Unterstützung von NuGet-Paketen als auch bei den verfügbaren .NET-APIs) bestehen.</span><span class="sxs-lookup"><span data-stu-id="141c9-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="141c9-139">Der erste Schritt bei der Migration besteht darin, die Abhängigkeiten der App zu überprüfen und sicherzustellen, dass Verweise in einem Format vorliegen, das leicht zu .NET Core migriert werden kann.</span><span class="sxs-lookup"><span data-stu-id="141c9-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="141c9-140">Upgrade auf `<PackageReference>`-NuGet-Verweise</span><span class="sxs-lookup"><span data-stu-id="141c9-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="141c9-141">Ältere .NET Framework-Projekte enthalten in der Regel Ihre NuGet-Abhängigkeiten in einer Datei *packages.config*.</span><span class="sxs-lookup"><span data-stu-id="141c9-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="141c9-142">Das neue Projektdateiformat im SDK-Stil verweist auf NuGet-Pakete als [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files)-Elemente in der CSPROJ-Datei selbst anstatt in einer separaten Konfigurationsdatei.</span><span class="sxs-lookup"><span data-stu-id="141c9-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="141c9-143">Bei der Migration gibt es zwei Vorteile bei der Verwendung von Verweisen im `<PackageReference>`-Format:</span><span class="sxs-lookup"><span data-stu-id="141c9-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="141c9-144">Dies ist das Format des NuGet-Verweises, das für die neue .NET Core-Projektdatei erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="141c9-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="141c9-145">Wenn Sie `<PackageReference>` bereits verwenden, können diese Projektdateielemente kopiert und direkt in das neue Projekt eingefügt werden.</span><span class="sxs-lookup"><span data-stu-id="141c9-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="141c9-146">Im Gegensatz zu einer Datei „packages.config“ verweisen `<PackageReference>`-Elemente nur auf die Abhängigkeiten auf oberster Ebene, von denen Ihr Projekt direkt abhängig ist.</span><span class="sxs-lookup"><span data-stu-id="141c9-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="141c9-147">Alle anderen transitiven NuGet-Pakete werden zum Zeitpunkt der Wiederherstellung bestimmt und in der automatisch generierten Datei „obj\project.assets.json“ aufgezeichnet.</span><span class="sxs-lookup"><span data-stu-id="141c9-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="141c9-148">Dies erleichtert es erheblich, zu ermitteln, welche Abhängigkeiten Ihr Projekt aufweist. Dies ist nützlich, wenn Sie bestimmen, ob die erforderlichen Abhängigkeiten für .NET Core funktionieren.</span><span class="sxs-lookup"><span data-stu-id="141c9-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="141c9-149">Der erste Schritt bei der Migration einer .NET Framework-App zu .NET Core besteht darin, sie so zu aktualisieren, dass `<PackageReference>`-NuGet-Verweise verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="141c9-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="141c9-150">In Visual Studio ist dies ganz einfach.</span><span class="sxs-lookup"><span data-stu-id="141c9-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="141c9-151">Klicken Sie im **Projektmappen-Explorer** von Visual Studio einfach mit der rechten Maustaste auf die Datei *packages.config* des Projekts, und wählen Sie dann **packages.config zu PackageReference migrieren** aus.</span><span class="sxs-lookup"><span data-stu-id="141c9-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![Aktualisieren auf PackageReference](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="141c9-153">Es wird ein Dialogfeld mit berechneten NuGet-Abhängigkeiten auf oberster Ebene angezeigt, und Sie werden gefragt, welche anderen NuGet-Pakete auf die oberste Ebene höher gestuft werden sollen.</span><span class="sxs-lookup"><span data-stu-id="141c9-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="141c9-154">Keines dieser anderen Pakete muss für das Bean Trader-Beispiel auf oberster Ebene sein, sodass Sie alle diese Felder deaktivieren können.</span><span class="sxs-lookup"><span data-stu-id="141c9-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="141c9-155">Klicken Sie dann auf **OK**. Die Datei *packages.config* wird entfernt, und `<PackageReference>`-Elemente werden der Projektdatei hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="141c9-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="141c9-156">Verweise im `<PackageReference>`-Format speichern keine NuGet-Pakete lokal in einem Paketordner.</span><span class="sxs-lookup"><span data-stu-id="141c9-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="141c9-157">Stattdessen werden Sie global als eine Optimierung gespeichert.</span><span class="sxs-lookup"><span data-stu-id="141c9-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="141c9-158">Nachdem die Migration abgeschlossen ist, bearbeiten Sie die CSPROJ-Datei, und entfernen Sie alle `<Analyzer>`-Elemente, die auf die Analyzer verweisen, die zuvor im Verzeichnis *..\packages* enthalten waren.</span><span class="sxs-lookup"><span data-stu-id="141c9-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="141c9-159">Keine Sorge: Da Sie noch über die NuGet-Paketverweise verfügen, werden die Analyzer in das Projekt eingebunden.</span><span class="sxs-lookup"><span data-stu-id="141c9-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="141c9-160">Sie müssen nur die alten `<Analyzer>`-Elemente im packages.config-Format bereinigen.</span><span class="sxs-lookup"><span data-stu-id="141c9-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="141c9-161">Überprüfen von NuGet-Paketen</span><span class="sxs-lookup"><span data-stu-id="141c9-161">Review NuGet packages</span></span>

<span data-ttu-id="141c9-162">Nun können Sie die NuGet-Pakete der obersten Ebene sehen, von denen das Projekt abhängt, und Sie können überprüfen, ob diese Pakete für .NET Core verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="141c9-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="141c9-163">Sie können ermitteln, ob ein Paket .NET Core unterstützt, indem Sie seine Abhängigkeiten auf [nuget.org](https://www.nuget.org/) untersuchen. Die von der Community erstellte Website [fuget.org](https://www.fuget.org/) zeigt diese Informationen hervorgehoben am oberen Rand der Seite mit den Paketinformationen an.</span><span class="sxs-lookup"><span data-stu-id="141c9-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="141c9-164">Wenn .NET Core 3.0 als Zielplattform verwendet wird, sollten alle Pakete für .NET Core oder .NET Standard funktionieren (da .NET Core den .NET Standard-Oberflächenbereich implementiert).</span><span class="sxs-lookup"><span data-stu-id="141c9-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="141c9-165">In einigen Fällen ist die spezifische Version eines Pakets, das verwendet wird, nicht für .NET Core oder .NET Standard geeignet, neuere Versionen sind es jedoch schon.</span><span class="sxs-lookup"><span data-stu-id="141c9-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="141c9-166">In diesem Fall sollten Sie ein Upgrade auf die neueste Version des Pakets in Erwägung ziehen.</span><span class="sxs-lookup"><span data-stu-id="141c9-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="141c9-167">Sie können auch Pakete für .NET Framework verwenden, dies birgt aber ein gewisses Risiko.</span><span class="sxs-lookup"><span data-stu-id="141c9-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="141c9-168">Abhängigkeiten zwischen .NET Core und .NET Framework sind zulässig, da sich die Oberflächenbereiche von .NET Core und .NET Framework so ähnlich sind, dass solche Abhängigkeiten *häufig* funktionieren.</span><span class="sxs-lookup"><span data-stu-id="141c9-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="141c9-169">Wenn das Paket jedoch versucht, eine .NET-API zu verwenden, die in .NET Core nicht vorhanden ist, tritt eine Laufzeitausnahme auf.</span><span class="sxs-lookup"><span data-stu-id="141c9-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="141c9-170">Aus diesem Grund sollten Sie nur dann auf .NET Framework-Pakete verweisen, wenn keine anderen Optionen verfügbar sind, und es muss Ihnen bewusst sein, dass dies eine Testbelastung darstellt.</span><span class="sxs-lookup"><span data-stu-id="141c9-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="141c9-171">Wenn es Pakete gibt, auf die verwiesen wird, die nicht für .NET Core oder .NET Standard vorgesehen sind, müssen Sie über andere Alternativen nachdenken:</span><span class="sxs-lookup"><span data-stu-id="141c9-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="141c9-172">Gibt es andere ähnliche Pakete, die stattdessen verwendet werden können?</span><span class="sxs-lookup"><span data-stu-id="141c9-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="141c9-173">Manchmal veröffentlichen NuGet-Autoren separate „Core“-Versionen ihrer Bibliotheken, die speziell auf .NET Core abzielen.</span><span class="sxs-lookup"><span data-stu-id="141c9-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="141c9-174">Enterprise Library-Pakete sind ein Beispiel für die Veröffentlichung von „.NetCore“-Alternativen durch die Community.</span><span class="sxs-lookup"><span data-stu-id="141c9-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="141c9-175">In anderen Fällen sind neuere SDKs für einen bestimmten Dienst (manchmal mit unterschiedlichen Paketnamen) für .NET Standard verfügbar.</span><span class="sxs-lookup"><span data-stu-id="141c9-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="141c9-176">Wenn keine Alternativen verfügbar sind, können Sie mit den .NET Framework-Zielpaketen fortfahren. Dabei sollten Sie bedenken, dass Sie diese bei Ausführung unter .NET Core gründlich testen müssen.</span><span class="sxs-lookup"><span data-stu-id="141c9-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="141c9-177">Das Bean Trader-Beispiel weist die folgenden NuGet-Abhängigkeiten auf oberster Ebene auf:</span><span class="sxs-lookup"><span data-stu-id="141c9-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="141c9-178">**Castle.Windsor, Version 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="141c9-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="141c9-179">Dieses Paket ist auf .NET Standard 1.6 ausgerichtet, sodass es unter .NET Core funktioniert.</span><span class="sxs-lookup"><span data-stu-id="141c9-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="141c9-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, Version 2.6.3**</span><span class="sxs-lookup"><span data-stu-id="141c9-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="141c9-181">Da es sich um ein Metapaket handelt, ist nicht sofort ersichtlich, welche Plattformen unterstützt werden, aber aus der [Dokumentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) geht hervor, dass die neueste Version (2.9.2) sowohl für .NET Framework als auch für .NET Core funktioniert.</span><span class="sxs-lookup"><span data-stu-id="141c9-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="141c9-182">**Nito.AsyncEx, Version 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="141c9-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="141c9-183">Dieses Paket ist nicht für .NET Core bestimmt, die neuere Version 5.0 hingegen schon.</span><span class="sxs-lookup"><span data-stu-id="141c9-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="141c9-184">Dies ist bei der Migration häufig der Fall, da viele NuGet-Pakete in letzter Zeit Unterstützung für den .NET-Standard hinzugefügt haben, ältere Projektversionen jedoch nur auf .NET-Framework abzielen.</span><span class="sxs-lookup"><span data-stu-id="141c9-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="141c9-185">Wenn sich der Versionsunterschied nur auf eine Nebenversion bezieht, ist es häufig einfach, ein Upgrade auf die neuere Version durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="141c9-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="141c9-186">Da dies eine Hauptversionsänderung ist, müssen Sie beim Upgrade vorsichtig sein, da das Paket möglicherweise Breaking Changes aufweist.</span><span class="sxs-lookup"><span data-stu-id="141c9-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="141c9-187">Es ist jedoch ein Vorwärtspfad vorhanden, was gut ist.</span><span class="sxs-lookup"><span data-stu-id="141c9-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="141c9-188">**MahApps.Metro, Version 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="141c9-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="141c9-189">Dieses Paket ist ebenfalls nicht für .NET Core gedacht, die neuere Vorabversion (2.0-alpha) jedoch schon.</span><span class="sxs-lookup"><span data-stu-id="141c9-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="141c9-190">Auch hier müssen Sie nach Breaking Changes suchen, aber das neuere Paket ist ermutigend.</span><span class="sxs-lookup"><span data-stu-id="141c9-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="141c9-191">Die NuGet-Abhängigkeiten des Bean Trader-Beispiels zielen alle entweder auf .NET Standard/.NET Core ab oder verfügen über neuere Versionen, bei denen dies der Fall ist, sodass es hier wahrscheinlich keine Blockierungsprobleme geben wird.</span><span class="sxs-lookup"><span data-stu-id="141c9-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="141c9-192">Aktualisieren von NuGet-Paketen</span><span class="sxs-lookup"><span data-stu-id="141c9-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="141c9-193">Wenn möglich, wäre es gut, die Versionen aller Pakete, die nur auf .NET Core oder .NET Standard abzielen, zu diesem Zeitpunkt mit neueren Versionen zu aktualisieren (wobei das Projekt immer noch auf .NET Framework abzielt), um eventuelle Breaking Changes frühzeitig zu entdecken und zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="141c9-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="141c9-194">Wenn Sie keine Materialänderungen an der vorhandenen .NET Framework-Version der App vornehmen möchten, kann dies warten, bis Sie über eine neue Projektdatei verfügen, die für .NET Core gedacht ist.</span><span class="sxs-lookup"><span data-stu-id="141c9-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="141c9-195">Ein vorzeitiges Upgrade der NuGet-Pakete auf .NET Core-kompatible Versionen macht den Migrationsprozess nach Erstellung der neuen Projektdatei jedoch noch einfacher und verringert die Anzahl der Unterschiede zwischen den .NET Framework- und .NET Core-Versionen der App.</span><span class="sxs-lookup"><span data-stu-id="141c9-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="141c9-196">Mit dem Bean Trader-Beispiel können alle erforderlichen Upgrades einfach (unter Verwendung des NuGet-Paket-Managers von Visual Studio) durchgeführt werden. Dabei gibt es eine Ausnahme: Ein Upgrade von **MahApps.Metro 1.6.5** auf Version **2.0** bedeutet Breaking Changes in Bezug auf Design- und Akzentverwaltungs-APIs.</span><span class="sxs-lookup"><span data-stu-id="141c9-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="141c9-197">Im Idealfall wird die App so aktualisiert, dass sie die neuere Version des Pakets verwendet (da diese wahrscheinlicher in .NET Core funktioniert).</span><span class="sxs-lookup"><span data-stu-id="141c9-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="141c9-198">In einigen Fällen ist dies jedoch ggf. nicht möglich.</span><span class="sxs-lookup"><span data-stu-id="141c9-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="141c9-199">In diesen Fällen sollten Sie **MahApps.Metro** nicht aktualisieren, da die erforderlichen Änderungen nicht trivial sind. Dieses Tutorial konzentriert sich nur auf die Migration zu .NET Core 3, nicht zu **MahApps.Metro**.</span><span class="sxs-lookup"><span data-stu-id="141c9-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="141c9-200">Dies ist auch eine .NET Framework-Abhängigkeit mit geringem Risiko, weil die Bean Trader-App nur einen kleinen Teil von **MahApps.Metro** verwendet.</span><span class="sxs-lookup"><span data-stu-id="141c9-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="141c9-201">Natürlich sind Tests erforderlich, um sicherzustellen, dass alles funktioniert, nachdem die Migration abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="141c9-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="141c9-202">Wenn es sich um ein reales Szenario handeln würde, wäre es sinnvoll, ein Problem zu melden, um die Aufgaben beim Umstieg auf **MahApps.Metro** Version 2.0 nachzuverfolgen, da die Nichtdurchführung der Migration nun eine technische Schuld hinterlässt.</span><span class="sxs-lookup"><span data-stu-id="141c9-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="141c9-203">Nachdem die NuGet-Pakete auf die neuesten Versionen aktualisiert wurden, sollte die `<PackageReference>`-Elementgruppe in der Projektdatei des Bean Trader-Beispiels wie folgt aussehen.</span><span class="sxs-lookup"><span data-stu-id="141c9-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="141c9-204">.NET Framework-Portabilitätsanalyse</span><span class="sxs-lookup"><span data-stu-id="141c9-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="141c9-205">Wenn Sie den Status der NuGet-Abhängigkeiten Ihres Projekts verstanden haben, müssen Sie als nächstes .NET Framework-API-Abhängigkeiten berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="141c9-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="141c9-206">Mit dem Tool [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) können Sie ermitteln, welche der .NET-APIs, die Ihr Projekt verwendet, auf anderen .NET-Plattformen verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="141c9-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="141c9-207">Das Tool ist als [Visual Studio-Plug-In](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), als [Befehlszeilentool](https://github.com/Microsoft/dotnet-apiport/releases) oder mit einer [einfachen grafischen Benutzeroberfläche](https://github.com/Microsoft/dotnet-apiport-ui) verfügbar, die seine Optionen vereinfacht.</span><span class="sxs-lookup"><span data-stu-id="141c9-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="141c9-208">Weitere Informationen zur Verwendung von .NET Portability Analyzer (API Port) über die grafische Benutzeroberfläche finden Sie im Blogbeitrag [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) (Portieren von Desktop-Apps zu .NET Core).</span><span class="sxs-lookup"><span data-stu-id="141c9-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="141c9-209">Wenn Sie lieber die Befehlszeile verwenden möchten, sind die folgenden Schritte erforderlich:</span><span class="sxs-lookup"><span data-stu-id="141c9-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="141c9-210">Laden Sie den [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) herunter, wenn dies noch nicht geschehen ist.</span><span class="sxs-lookup"><span data-stu-id="141c9-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="141c9-211">Stellen Sie sicher, dass die zu portierende .NET Framework-App erfolgreich erstellt wurde (dies ist immer eine gute Idee vor der Migration).</span><span class="sxs-lookup"><span data-stu-id="141c9-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="141c9-212">Führen Sie API Port mit einer Befehlszeile wie dieser aus.</span><span class="sxs-lookup"><span data-stu-id="141c9-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="141c9-213">Das `-f`-Argument gibt den Pfad an, der die zu analysierenden Binärdateien enthält.</span><span class="sxs-lookup"><span data-stu-id="141c9-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="141c9-214">Das `-r`-Argument gibt das gewünschte Ausgabedateiformat an.</span><span class="sxs-lookup"><span data-stu-id="141c9-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="141c9-215">Das `-t`-Argument gibt an, mit welcher .NET-Plattform die API-Verwendung analysiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="141c9-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="141c9-216">In diesem Fall geben Sie .NET Core an.</span><span class="sxs-lookup"><span data-stu-id="141c9-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="141c9-217">Wenn Sie den HTML-Bericht öffnen, werden im ersten Abschnitt alle analysierten Binärdateien und der Prozentsatz der von ihnen verwendeten .NET-APIs aufgeführt, die auf der Zielplattform verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="141c9-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="141c9-218">Der Prozentsatz allein ist nicht aussagekräftig.</span><span class="sxs-lookup"><span data-stu-id="141c9-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="141c9-219">Hilfreicher ist es, die spezifischen APIs anzuzeigen, die fehlen.</span><span class="sxs-lookup"><span data-stu-id="141c9-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="141c9-220">Wählen Sie hierzu entweder einen Assemblynamen aus, oder scrollen Sie nach unten zu den Berichten, um einzelne Assemblys anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="141c9-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="141c9-221">Konzentrieren Sie sich auf die Assemblys, für die Sie Besitzer des Quellcodes sind.</span><span class="sxs-lookup"><span data-stu-id="141c9-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="141c9-222">Im ApiPort-Bericht des Bean Trader-Beispiels werden beispielsweise zahlreiche Binärdateien aufgelistet, aber die meisten von ihnen gehören zu NuGet-Paketen.</span><span class="sxs-lookup"><span data-stu-id="141c9-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="141c9-223">`Castle.Windsor` zeigt, dass eine Abhängigkeit von einigen System.Web-APIs besteht, die in .NET Core fehlen.</span><span class="sxs-lookup"><span data-stu-id="141c9-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="141c9-224">Dies ist kein Problem, da Sie zuvor bestätigt haben, dass `Castle.Windsor` .NET Core unterstützt.</span><span class="sxs-lookup"><span data-stu-id="141c9-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="141c9-225">Es ist üblich, dass NuGet-Pakete unterschiedliche Binärdateien für die Verwendung mit verschiedenen .NET-Plattformen aufweisen, sodass es irrelevant ist, ob die .NET Framework-Version von `Castle.Windsor` System.Web APIs verwendet oder nicht, solange das Paket auch auf .NET Standard oder .NET Core abzielt (was der Fall ist).</span><span class="sxs-lookup"><span data-stu-id="141c9-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="141c9-226">Bei dem Bean Trader-Beispiel ist die einzige Binärdatei, die Sie berücksichtigen müssen, **BeanTraderClient**, und der Bericht zeigt, dass nur zwei .NET-APIs fehlen: `System.ServiceModel.ClientBase<T>.Close` und `System.ServiceModel.ClientBase<T>.Open`.</span><span class="sxs-lookup"><span data-stu-id="141c9-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![BeanTraderClient-Portabilitätsbericht](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="141c9-228">Es ist unwahrscheinlich, dass es sich dabei um blockierende Probleme handelt, da WCF-Client-APIs (meistens) unter .NET Core unterstützt werden, sodass es Alternativen für diese zentralen APIs geben muss.</span><span class="sxs-lookup"><span data-stu-id="141c9-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="141c9-229">Wenn Sie sich die .NET Core-Oberfläche von `System.ServiceModel` ansehen (unter Verwendung von <https://apisof.net>), erkennen Sie tatsächlich, dass es stattdessen asynchrone Alternativen in .NET Core gibt.</span><span class="sxs-lookup"><span data-stu-id="141c9-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="141c9-230">Basierend auf diesem Bericht und der vorherigen NuGet-Abhängigkeitsanalyse sieht es so aus, als sollte es keine größeren Probleme bei der Migration des Bean Trader-Beispiels zu .NET Core geben.</span><span class="sxs-lookup"><span data-stu-id="141c9-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="141c9-231">Sie sind bereit für den nächsten Schritt, in dem Sie die Migration tatsächlich starten.</span><span class="sxs-lookup"><span data-stu-id="141c9-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="141c9-232">Migrieren der Projektdatei</span><span class="sxs-lookup"><span data-stu-id="141c9-232">Migrating the project file</span></span>

<span data-ttu-id="141c9-233">Wenn Ihre App nicht das neue [Projektdateiformat im SDK-Stil](../../core/tools/csproj.md) verwendet, benötigen Sie eine neue Projektdatei für .NET Core.</span><span class="sxs-lookup"><span data-stu-id="141c9-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="141c9-234">Sie können die vorhandene CSPROJ-Datei ersetzen oder, wenn Sie es vorziehen, das vorhandene Projekt in seinem aktuellen Zustand unverändert zu belassen, eine neue CSPROJ-Datei hinzufügen, die auf .NET Core abzielt.</span><span class="sxs-lookup"><span data-stu-id="141c9-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="141c9-235">Sie können Versionen der App für .NET Framework und .NET Core mit einer einzelnen Projektdatei im SDK-Stil erstellen, indem Sie [mehrere Zielversionen](../../standard/library-guidance/cross-platform-targeting.md) angeben (mehrere `<TargetFrameworks>`-Ziele angeben).</span><span class="sxs-lookup"><span data-stu-id="141c9-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="141c9-236">Um die neue Projektdatei zu erstellen, können Sie ein neues WPF-Projekt in Visual Studio erstellen oder den Befehl `dotnet new wpf` in einem temporären Verzeichnis verwenden, um die Projektdatei zu generieren und sie dann an den richtigen Speicherort zu kopieren bzw. umzubenennen.</span><span class="sxs-lookup"><span data-stu-id="141c9-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="141c9-237">Es gibt auch ein von der Community erstelltes Tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), mit dem ein Teil der Projektdateimigration automatisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="141c9-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="141c9-238">Das Tool ist hilfreich, benötigt aber trotzdem eine Überprüfung der Ergebnisse durch einen Menschen, um sicherzustellen, dass alle Details der Migration richtig sind.</span><span class="sxs-lookup"><span data-stu-id="141c9-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="141c9-239">Ein bestimmter Bereich, den das Tool nicht optimal behandelt, ist das Migrieren von NuGet-Paketen aus *packages.config*-Dateien.</span><span class="sxs-lookup"><span data-stu-id="141c9-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="141c9-240">Wenn das Tool für eine Projektdatei ausgeführt wird, die noch eine Datei *packages.config* verwendet, um auf NuGet-Pakete zu verweisen, migriert es automatisch zu `<PackageReference>`-Elementen, fügt aber `<PackageReference>`-Elemente für *alle* Pakete anstatt nur für die Pakete der obersten Ebene hinzu.</span><span class="sxs-lookup"><span data-stu-id="141c9-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="141c9-241">Wenn Sie bereits mit Visual Studio zu `<PackageReference>`-Elementen migriert sind (wie in diesem Beispiel geschehen), kann Sie das Tool bei der restlichen Konvertierung unterstützen.</span><span class="sxs-lookup"><span data-stu-id="141c9-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="141c9-242">Wie Scott Hanselman in [diesem Blogbeitrag zum Migrieren von CSPROJ-Dateien empfiehlt](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), ist das manuelle Portieren lehrreich und führt zu besseren Ergebnissen, wenn Sie nur einige wenige Projekte portieren müssen.</span><span class="sxs-lookup"><span data-stu-id="141c9-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="141c9-243">Wenn Sie jedoch Dutzende oder Hunderte von Projektdateien portieren, kann ein Tool wie [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017) hilfreich sein.</span><span class="sxs-lookup"><span data-stu-id="141c9-243">But if you're porting dozens or hundreds of project files, then a tool like [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017) can be a help.</span></span>

<span data-ttu-id="141c9-244">Um eine neue Projektdatei für das Bean Trader-Beispiel zu erstellen, führen Sie `dotnet new wpf` in einem temporären Verzeichnis, verschieben Sie die generierte *CSPROJ*-Datei in den Ordner *BeanTraderClient*, und benennen Sie sie dann in **BeanTraderClient.Core.csproj** um.</span><span class="sxs-lookup"><span data-stu-id="141c9-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="141c9-245">Da das neue Projektdateiformat automatisch C#-Dateien, *RESX*-Dateien und XAML-Dateien einschließt, die es in oder unter seinem Verzeichnis findet, ist die Projektdatei bereits fast vollständig!</span><span class="sxs-lookup"><span data-stu-id="141c9-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="141c9-246">Um die Migration abzuschließen, öffnen Sie die alte und die neue Projektdatei nebeneinander, und sehen Sie die alte Datei durch, um zu ermitteln, ob irgendwelche darin enthaltenen Informationen migriert werden müssen.</span><span class="sxs-lookup"><span data-stu-id="141c9-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="141c9-247">Im Bean Trader-Beispielfall sollten die folgenden Elemente in das neue Projekt kopiert werden:</span><span class="sxs-lookup"><span data-stu-id="141c9-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="141c9-248">Die Eigenschaften `<RootNamespace>`, `<AssemblyName>` und `<ApplicationIcon>` sollten kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="141c9-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="141c9-249">Außerdem müssen Sie der neuen Projektdatei eine `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>`-Eigenschaft hinzufügen, da das Bean Trader-Beispiel Attribute auf Assemblyebene (wie `[AssemblyTitle]`) in einer Datei „AssemblyInfo.cs“ enthält.</span><span class="sxs-lookup"><span data-stu-id="141c9-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="141c9-250">Standardmäßig generieren Projekte im neuen SDK-Stil diese Attribute automatisch basierend auf den Eigenschaften in der CSPROJ-Datei.</span><span class="sxs-lookup"><span data-stu-id="141c9-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="141c9-251">Da Sie nicht möchten, dass dies in diesem Fall geschieht (die automatisch generierten Attribute würden mit denen aus „AssemblyInfo.cs“ in Konflikt geraten), deaktivieren Sie die automatisch generierten Attribute mit `<GenerateAssemblyInfo>`.</span><span class="sxs-lookup"><span data-stu-id="141c9-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="141c9-252">Obwohl *RESX*-Dateien automatisch als eingebettete Ressourcen eingeschlossen werden, gilt dies für andere `<Resource>`-Elemente wie Bilder nicht.</span><span class="sxs-lookup"><span data-stu-id="141c9-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="141c9-253">Kopieren Sie daher die `<Resource>`-Elemente zum Einbetten von Bild- und Symboldateien.</span><span class="sxs-lookup"><span data-stu-id="141c9-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="141c9-254">Sie können die PNG-Verweise auf eine einzelne Zeile vereinfachen, indem Sie die Unterstützung des neuen Projektdateiformats für Globmuster verwenden: `<Resource Include="**\*.png" />`.</span><span class="sxs-lookup"><span data-stu-id="141c9-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="141c9-255">Ebenso werden `<None>`-Elemente automatisch eingeschlossen, jedoch nicht standardmäßig in das Ausgabeverzeichnis kopiert.</span><span class="sxs-lookup"><span data-stu-id="141c9-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="141c9-256">Da das Bean Trader-Projekt ein `<None>`-Element enthält, das (mit `PreserveNewest` Verhalten) in das Ausgabeverzeichnis kopiert *wird*, müssen Sie das automatisch aufgefüllte `<None>`-Element für diese Datei wie hier gezeigt aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="141c9-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="141c9-257">Das Bean Trader-Beispiel enthält eine XAML-Datei (Default.Accent.xaml) als `Content` (anstatt als `Page`), da in dieser Datei definierte Designs und Akzente zur Laufzeit aus dem XAML-Code der Datei geladen werden, anstatt in die App selbst eingebettet zu werden.</span><span class="sxs-lookup"><span data-stu-id="141c9-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="141c9-258">Das neue Projektsystem schließt diese Datei jedoch automatisch als `<Page>` ein, da es sich um eine XAML-Datei handelt.</span><span class="sxs-lookup"><span data-stu-id="141c9-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="141c9-259">Daher müssen Sie die XAML-Datei als Seite (`<Page Remove="**\Default.Accent.xaml" />`) entfernen und als Inhalt hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="141c9-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="141c9-260">Fügen Sie schließlich NuGet-Verweise hinzu, indem Sie die `<ItemGroup>` mit allen `<PackageReference>`-Elementen kopieren.</span><span class="sxs-lookup"><span data-stu-id="141c9-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="141c9-261">Wenn Sie die NuGet-Pakete zuvor nicht auf mit .NET Core kompatible Versionen aktualisiert haben, kann dies jetzt geschehen, da die Paketverweise in einem .NET Core-spezifischen Projekt enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="141c9-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="141c9-262">An diesem Punkt sollte es möglich sein, das neue Projekt der BeanTrader-Projektmappe hinzuzufügen und in Visual Studio zu öffnen.</span><span class="sxs-lookup"><span data-stu-id="141c9-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="141c9-263">Das Projekt sollte im **Projektmappen-Explorer** ordnungsgemäß aussehen, und `dotnet restore BeanTraderClient.Core.csproj` sollte Pakete erfolgreich wiederherstellen (mit zwei erwarteten Warnungen in Bezug auf die von Ihnen verwendete MahApps.Metro-Version, die auf .NET Framework abzielt).</span><span class="sxs-lookup"><span data-stu-id="141c9-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="141c9-264">Obwohl es möglich ist, beide Projektdateien nebeneinander zu verwalten (und dies vielleicht sogar wünschenswert ist, wenn Sie das alte Projekt weiterhin genau so erstellen möchten, wie es zuvor war), erschwert es den Migrationsprozess (die beiden Projekte werden versuchen, die gleichen bin- und obj-Ordner zu verwenden) und ist normalerweise nicht notwendig.</span><span class="sxs-lookup"><span data-stu-id="141c9-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="141c9-265">Wenn Sie das Projekt sowohl für .NET Core- als auch für .NET Framework-Ziele erstellen möchten, können Sie die `<TargetFramework>netcoreapp3.0</TargetFramework>`-Eigenschaft in der neuen Projektdatei stattdessen durch `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` ersetzen.</span><span class="sxs-lookup"><span data-stu-id="141c9-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="141c9-266">Löschen Sie für das Bean Trader-Beispiel die alte Projektdatei („BeanTraderClient.csproj“), da sie nicht mehr benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="141c9-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="141c9-267">Wenn Sie beide Projektdateien beibehalten möchten, müssen Sie sicherstellen, dass der Buildvorgang in andere Ausgabe- und Zwischenausgabepfade erfolgt.</span><span class="sxs-lookup"><span data-stu-id="141c9-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="141c9-268">Beheben von Buildproblemen</span><span class="sxs-lookup"><span data-stu-id="141c9-268">Fix build issues</span></span>

<span data-ttu-id="141c9-269">Der dritte Schritt des Portierungsvorgangs besteht darin, das Projekt zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="141c9-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="141c9-270">Einige Apps werden bereits erfolgreich erstellt, sobald die Projektdatei in ein Projekt im SDK-Stil konvertiert wurde.</span><span class="sxs-lookup"><span data-stu-id="141c9-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="141c9-271">Wenn dies für Ihre App der Fall ist, herzlichen Glückwunsch!</span><span class="sxs-lookup"><span data-stu-id="141c9-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="141c9-272">Sie können mit Schritt 4 fortfahren.</span><span class="sxs-lookup"><span data-stu-id="141c9-272">You can go on to Step 4.</span></span> <span data-ttu-id="141c9-273">Andere Apps benötigen einige Updates, damit sie für .NET Core erstellt werden können.</span><span class="sxs-lookup"><span data-stu-id="141c9-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="141c9-274">Wenn Sie jetzt beispielsweise versuchen, `dotnet build` für das Bean Trader-Beispielprojekt auszuführen (oder es in Visual Studio zu erstellen), werden viele Fehler auftreten, die aber schnell behoben werden können.</span><span class="sxs-lookup"><span data-stu-id="141c9-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="141c9-275">System.ServiceModel-Verweise und Microsoft.Windows.Compatibility</span><span class="sxs-lookup"><span data-stu-id="141c9-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="141c9-276">Eine häufige Fehlerquelle sind fehlende Verweise auf APIs, die für .NET Core verfügbar sind, aber nicht automatisch im .NET Core-App-Metapaket enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="141c9-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="141c9-277">Um dieses Problem zu beheben, sollten Sie auf das `Microsoft.Windows.Compatibility`-Paket verweisen.</span><span class="sxs-lookup"><span data-stu-id="141c9-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="141c9-278">Das Kompatibilitätspaket umfasst eine breite Palette von APIs, die in Windows-Desktop-Apps üblich sind, etwa einen WCF-Client, Verzeichnisdienste, Registrierung, Konfiguration, ACL-APIs und vieles mehr.</span><span class="sxs-lookup"><span data-stu-id="141c9-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="141c9-279">Beim Bean Trader-Beispiel ist die Mehrzahl der Buildfehler auf fehlende <xref:System.ServiceModel>-Typen zurückzuführen.</span><span class="sxs-lookup"><span data-stu-id="141c9-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="141c9-280">Diese können durch Verweisen auf die erforderlichen WCF NuGet-Pakete behoben werden.</span><span class="sxs-lookup"><span data-stu-id="141c9-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="141c9-281">WCF-Client-APIs gehören jedoch zu den APIs, die im `Microsoft.Windows.Compatibility`-Paket enthalten sind, sodass ein Verweis auf das Kompatibilitätspaket eine noch bessere Lösung darstellt (da es auch alle Probleme im Zusammenhang mit APIs sowie Lösungen für die WCF-Probleme behandelt, die das Kompatibilitätspaket zur Verfügung stellt).</span><span class="sxs-lookup"><span data-stu-id="141c9-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="141c9-282">Das `Microsoft.Windows.Compatibility`-Paket hilft bei den meisten .NET Core 3.0 WPF- und WinForms-Portierungsszenarien.</span><span class="sxs-lookup"><span data-stu-id="141c9-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="141c9-283">Nach dem Hinzufügen des NuGet-Verweises zu `Microsoft.Windows.Compatibility`wird nur noch ein Buildfehler ausgegeben!</span><span class="sxs-lookup"><span data-stu-id="141c9-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="141c9-284">Bereinigen von nicht verwendeten Dateien</span><span class="sxs-lookup"><span data-stu-id="141c9-284">Cleaning up unused files</span></span>

<span data-ttu-id="141c9-285">Eine Art von Migrationsproblem, das häufig auftritt, bezieht sich auf C#- und XAML-Dateien, die zuvor nicht im Build enthalten waren und von den neuen Projekten im SDK-Stil, die *alle* Quelldateien automatisch enthalten, übernommen werden.</span><span class="sxs-lookup"><span data-stu-id="141c9-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="141c9-286">Der nächste Buildfehler, den Sie im Bean Trader-Beispiel sehen, bezieht sich auf eine fehlerhafte Schnittstellenimplementierung in *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="141c9-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="141c9-287">Der Dateiname ist ein Hinweis, aber bei der Überprüfung werden Sie feststellen, dass diese Quelldatei falsch ist.</span><span class="sxs-lookup"><span data-stu-id="141c9-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="141c9-288">Sie hat bisher keine Probleme verursacht, weil sie nicht im ursprünglichen .NET Framework-Projekt enthalten war.</span><span class="sxs-lookup"><span data-stu-id="141c9-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="141c9-289">Quelldateien, die auf dem Datenträger vorhanden waren, aber nicht in der alten *CSPROJ*-Datei, werden jetzt automatisch eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="141c9-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="141c9-290">Bei einmaligen Problemen wie diesem ist es einfach, einen Vergleich mit der vorherigen *CSPROJ*-Datei vorzunehmen, um zu bestätigen, dass die Datei nicht mehr benötigt wird, und dann entweder `<Compile Remove="" />` zu verwenden oder sie zu löschen, wenn die Quelldatei nicht mehr benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="141c9-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="141c9-291">In diesem Fall ist es sicher, nur *OldUnusedViewModel.cs* zu löschen.</span><span class="sxs-lookup"><span data-stu-id="141c9-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="141c9-292">Wenn Sie über viele Quelldateien verfügen, die auf diese Weise ausgeschlossen werden müssten, können Sie die automatische Einbindung von C#-Dateien deaktivieren, indem Sie die `<EnableDefaultCompileItems>`-Eigenschaft in der Projektdatei auf FALSE festlegen.</span><span class="sxs-lookup"><span data-stu-id="141c9-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="141c9-293">Anschließend können Sie `<Compile Include>`-Elemente aus der alten Projektdatei in die neue Projektdatei kopieren, um nur die Quellen zu erstellen, die Sie einschließen möchten.</span><span class="sxs-lookup"><span data-stu-id="141c9-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="141c9-294">Ebenso kann `<EnableDefaultPageItems>` verwendet werden, um die automatische Einbindung von XAML-Seiten zu deaktivieren, und `<EnableDefaultItems>` kann beides mit einer einzelnen Eigenschaft steuern.</span><span class="sxs-lookup"><span data-stu-id="141c9-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="141c9-295">Eine kurze Anmerkung zu Multipass-Compilern</span><span class="sxs-lookup"><span data-stu-id="141c9-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="141c9-296">Nachdem Sie die beanstandete Datei aus dem Bean Trader-Beispiel entfernt haben, können Sie die Datei neu erstellen und erhalten vier Fehler.</span><span class="sxs-lookup"><span data-stu-id="141c9-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="141c9-297">Zuvor war es doch nur ein Fehler?</span><span class="sxs-lookup"><span data-stu-id="141c9-297">Didn't you have one before?</span></span> <span data-ttu-id="141c9-298">Warum ist die Anzahl der Fehler angestiegen?</span><span class="sxs-lookup"><span data-stu-id="141c9-298">Why did the number of errors go up?</span></span> <span data-ttu-id="141c9-299">Der C#-Compiler ist ein [Multipass-Compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span><span class="sxs-lookup"><span data-stu-id="141c9-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="141c9-300">Dies bedeutet, dass die einzelnen Quelldateien zwei Mal durchlaufen werden.</span><span class="sxs-lookup"><span data-stu-id="141c9-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="141c9-301">Zuerst prüft der Compiler nur die Metadaten und Deklarationen in jeder Quelldatei und identifiziert alle Probleme auf Deklarationsebene.</span><span class="sxs-lookup"><span data-stu-id="141c9-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="141c9-302">Dies sind die Fehler, die Sie korrigiert haben.</span><span class="sxs-lookup"><span data-stu-id="141c9-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="141c9-303">Anschließend durchläuft er den Code erneut, um die C#-Quelle in IL zu erstellen. Dabei entsteht der zweite Fehlersatz, den Sie jetzt sehen.</span><span class="sxs-lookup"><span data-stu-id="141c9-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="141c9-304">Der C#-Compiler führt [mehr als nur zwei Durchläufe](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes) aus, aber das Endergebnis besteht darin, dass Compilerfehler für große Codeänderungen wie diese in der Regel in zwei Wellen auftreten.</span><span class="sxs-lookup"><span data-stu-id="141c9-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="141c9-305">Abhängigkeitskorrekturen von Drittanbietern (Castle.Windsor)</span><span class="sxs-lookup"><span data-stu-id="141c9-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="141c9-306">Eine weitere Problemklasse, die in einigen Migrationsszenarien auftritt, sind API-Unterschiede zwischen .NET Framework und .NET Core-Versionen von Abhängigkeiten.</span><span class="sxs-lookup"><span data-stu-id="141c9-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="141c9-307">Auch wenn ein NuGet-Paket sowohl .NET Framework als auch .NET Standard oder .NET Core als Ziel besitzt, können verschiedene Bibliotheken für die Verwendung mit verschiedenen .NET-Zielen vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="141c9-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="141c9-308">Dies ermöglicht es den Paketen, viele verschiedene .NET-Plattformen zu unterstützen, die möglicherweise verschiedene Implementierungen erfordern.</span><span class="sxs-lookup"><span data-stu-id="141c9-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="141c9-309">Dies bedeutet auch, dass es für verschiedene .NET-Plattformen zu kleinen API-Unterschieden in den Bibliotheken kommen kann.</span><span class="sxs-lookup"><span data-stu-id="141c9-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="141c9-310">Die nächste Reihe von Fehlern, die im Bean Trader-Beispiel angezeigt werden, beziehen sich auf `Castle.Windsor`-APIs.</span><span class="sxs-lookup"><span data-stu-id="141c9-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="141c9-311">Das .NET Core-Bean Trader-Projekt verwendet dieselbe Version von `Castle.Windsor` wie das Projekt mit dem Ziel .NET Framework (4.1.1), aber die Implementierungen für diese beiden Plattformen unterscheiden sich geringfügig.</span><span class="sxs-lookup"><span data-stu-id="141c9-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="141c9-312">In diesem Fall treten die folgenden Probleme auf, die behoben werden müssen:</span><span class="sxs-lookup"><span data-stu-id="141c9-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="141c9-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` ist unter .NET Core nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="141c9-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="141c9-314">Es ist jedoch eine ähnliche API `Classes.FromAssemblyContaining` verfügbar, sodass wir beide Verwendungsmöglichkeiten von `Classes.FromThisAssembly()` durch Aufrufe von `Classes.FromAssemblyContaining(t)` ersetzen können, wobei `t` der Typ ist, der den Aufruf ausführt.</span><span class="sxs-lookup"><span data-stu-id="141c9-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="141c9-315">Ähnlich in *Bootstrapper.cs*: `Castle.Windsor.Installer.FromAssembly`. Dies ist unter .NET Core nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="141c9-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="141c9-316">Stattdessen kann der Aufruf durch `FromAssembly.Containing(typeof(Bootstrapper))` ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="141c9-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="141c9-317">Aktualisieren der WCF-Clientsyntax</span><span class="sxs-lookup"><span data-stu-id="141c9-317">Updating WCF client usage</span></span>

<span data-ttu-id="141c9-318">Wenn Sie die `Castle.Windsor`-Unterschiede korrigiert haben, ist der letzte verbleibende Buildfehler im .NET Core-Bean Trader-Projekt, dass `BeanTraderServiceClient` (von `DuplexClientBase`abgeleitet) keine `Open`-Methode aufweist.</span><span class="sxs-lookup"><span data-stu-id="141c9-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="141c9-319">Dies ist nicht überraschend, da es sich um eine API handelt, die zu Beginn dieses Migrationsvorgangs von .NET Portability Analyzer hervorgehoben wurde.</span><span class="sxs-lookup"><span data-stu-id="141c9-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="141c9-320">Der Blick auf `BeanTraderServiceClient` lenkt unsere Aufmerksamkeit jedoch auf ein größeres Problem.</span><span class="sxs-lookup"><span data-stu-id="141c9-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="141c9-321">Dieser WCF-Client wurde vom Tool [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) automatisch generiert.</span><span class="sxs-lookup"><span data-stu-id="141c9-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="141c9-322">**WCF-Clients, die von Svcutil generiert werden, sind für die Verwendung in .NET Framework gedacht.**</span><span class="sxs-lookup"><span data-stu-id="141c9-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="141c9-323">Lösungen, die von Svcutil generierte WCF-Clients verwenden, müssen mit .NET Standard kompatible Clients für die Verwendung mit .NET Core neu generieren.</span><span class="sxs-lookup"><span data-stu-id="141c9-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="141c9-324">Einer der Hauptgründe, warum die alten Clients nicht funktionieren, besteht darin, dass sie von der App-Konfiguration zum Definieren von WCF-Bindungen und -Endpunkten abhängen.</span><span class="sxs-lookup"><span data-stu-id="141c9-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="141c9-325">Da .NET Standard-WCF-APIs plattformübergreifend arbeiten können (wo System.Configuration-APIs nicht verfügbar sind), müssen WCF-Clients für .NET Core- und .NET Standard-Szenarien Bindungen und Endpunkte programmgesteuert anstatt in der Konfiguration definieren.</span><span class="sxs-lookup"><span data-stu-id="141c9-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="141c9-326">Tatsächlich muss jede WCF-Clientsyntax, die vom Abschnitt `<system.serviceModel>` der Datei „app.config“ abhängig ist (unabhängig davon, ob mit Svcutil oder manuell erstellt), geändert werden, damit sie unter .NET Core funktioniert.</span><span class="sxs-lookup"><span data-stu-id="141c9-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="141c9-327">Es gibt zwei Möglichkeiten, mit .NET Standard kompatible WCF-Clients automatisch zu generieren:</span><span class="sxs-lookup"><span data-stu-id="141c9-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="141c9-328">Das Tool `dotnet-svcutil` ist ein .NET-Tool, mit dem WCF-Clients auf eine Weise generiert werden, die Svcutil ähnelt.</span><span class="sxs-lookup"><span data-stu-id="141c9-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="141c9-329">Visual Studio kann WCF-Clients mithilfe der Option [WCF-Webdienstverweis](../../core/additional-tools/wcf-web-service-reference-guide.md) des Features „Verbundene Dienste“ generieren.</span><span class="sxs-lookup"><span data-stu-id="141c9-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="141c9-330">Beide Ansätze funktionieren gut.</span><span class="sxs-lookup"><span data-stu-id="141c9-330">Either approach works well.</span></span> <span data-ttu-id="141c9-331">Natürlich können Sie den WCF-Clientcode auch selbst schreiben.</span><span class="sxs-lookup"><span data-stu-id="141c9-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="141c9-332">In diesem Beispiel habe ich mich für die Verwendung des Features „Verbundene Dienste“ von Visual Studio entschieden.</span><span class="sxs-lookup"><span data-stu-id="141c9-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="141c9-333">Klicken Sie hierzu im Projektmappen-Explorer von Visual Studio mit der rechten Maustaste auf das Projekt *BeanTraderClient.Core*, und wählen Sie **Hinzufügen** > **Verbundener Dienst** aus.</span><span class="sxs-lookup"><span data-stu-id="141c9-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="141c9-334">Wählen Sie dann den Anbieter für den WCF-Webdienstverweis aus.</span><span class="sxs-lookup"><span data-stu-id="141c9-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="141c9-335">Daraufhin wird ein Dialogfeld angezeigt, in dem Sie die Adresse des Back-End-Bean Trader-Webdiensts angeben können (`localhost:8080`, wenn Sie den Server lokal ausführen), sowie den Namespace, den die generierten Typen verwenden sollten (z. B. **BeanTrader.Service**).</span><span class="sxs-lookup"><span data-stu-id="141c9-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![Dialogfeld „WCF-Webdienstverweis“ für „Verbundener Dienst“](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="141c9-337">Nachdem Sie die Schaltfläche **Fertigstellen** ausgewählt haben, wird dem Projekt ein neuer Knoten „Verbundene Dienste“ und unter diesem Knoten eine Datei „Reference.cs“ hinzugefügt, die den neuen .NET Standard-WCF-Client für den Zugriff auf den Bean Trader-Dienst enthält.</span><span class="sxs-lookup"><span data-stu-id="141c9-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="141c9-338">Wenn Sie sich die `GetEndpointAddress`- oder `GetBindingForEndpoint`-Methoden in dieser Datei ansehen, werden Sie feststellen, dass Bindungen und Endpunkte jetzt programmgesteuert (anstatt über die App-Konfiguration) generiert werden.</span><span class="sxs-lookup"><span data-stu-id="141c9-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="141c9-339">Die Funktion „Verbundene Dienste hinzufügen“ kann auch Verweise auf einige System.ServiceModell-Pakete in der Projektdatei hinzufügen, die nicht benötigt werden, da alle erforderlichen WCF-Pakete über Microsoft.Windows.Compatibility enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="141c9-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="141c9-340">Überprüfen Sie die CSPROJ-Datei, um festzustellen, ob zusätzliche `<PackageReference>`-Elemente von System.ServiceModel hinzugefügt wurden. Wenn dies der Fall ist, entfernen Sie diese.</span><span class="sxs-lookup"><span data-stu-id="141c9-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="141c9-341">Unser Projekt verfügt jetzt über neue WCF-Clientklassen (in *Reference.cs*), aber auch weiterhin über die alten (in „BeanTrader.cs“).</span><span class="sxs-lookup"><span data-stu-id="141c9-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="141c9-342">An diesem Punkt gibt es zwei Optionen:</span><span class="sxs-lookup"><span data-stu-id="141c9-342">There are two options at this point:</span></span>

- <span data-ttu-id="141c9-343">Wenn Sie in der Lage sein möchten, das ursprüngliche .NET Framework-Projekt (neben dem neuen .NET Core-Projekt) zu erstellen, können Sie ein `<Compile Remove="BeanTrader.cs" />`-Element in der CSPROJ-Datei des NET Core-Projekts verwenden, damit die .NET Framework-Version und die .NET Core-Version der App unterschiedliche WCF-Clients verwenden.</span><span class="sxs-lookup"><span data-stu-id="141c9-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="141c9-344">Dies hat den Vorteil, das vorhandene .NET Framework-Projekt unverändert zu belassen, aber den Nachteil, dass Code, der die generierten WCF-Clients verwendet, im .NET Core-Fall etwas anders sein muss als im .NET Framework-Projekt, sodass Sie wahrscheinlich `#if`-Anweisungen verwenden müssen, um WCF-Clientsyntax (z. B. das Erstellen von Clients) bedingt zu kompilieren, damit sie bei der Erstellung für .NET Core auf die eine Weise und bei der Erstellung für .NET Framework auf eine andere Weise funktionieren.</span><span class="sxs-lookup"><span data-stu-id="141c9-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="141c9-345">Wenn andererseits eine gewisse Codeänderung im vorhandenen .NET Framework-Projekt akzeptabel ist, können Sie *BeanTrader.cs* insgesamt entfernen.</span><span class="sxs-lookup"><span data-stu-id="141c9-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="141c9-346">Da der neue WCF-Client für .NET Standard erstellt wird, funktioniert er sowohl in .NET Core- als auch in .NET Framework-Szenarien.</span><span class="sxs-lookup"><span data-stu-id="141c9-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="141c9-347">Wenn Sie für .NET Framework zusätzlich zu .NET Core Builds erstellen (durch Angeben mehrerer Ziele oder durch zwei CSPROJ-Dateien), können Sie diese neue Datei *Reference.cs* für beide Ziele verwenden.</span><span class="sxs-lookup"><span data-stu-id="141c9-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="141c9-348">Dieser Ansatz hat den Vorteil, dass der Code nicht gegabelt werden muss, um zwei verschiedene WCF-Clients zu unterstützen. Es wird überall derselbe Code verwendet.</span><span class="sxs-lookup"><span data-stu-id="141c9-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="141c9-349">Der Nachteil besteht darin, dass das (vermutlich stabile) .NET Framework-Projekt geändert werden muss.</span><span class="sxs-lookup"><span data-stu-id="141c9-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="141c9-350">Im Fall des Bean Trader-Beispiels können Sie kleine Änderungen am ursprünglichen Projekt vornehmen, wenn dies die Migration erleichtert. Befolgen Sie also diese Schritte, um die WCF-Clientsyntax abzustimmen:</span><span class="sxs-lookup"><span data-stu-id="141c9-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="141c9-351">Fügen Sie die neue Datei „Reference.cs“ mithilfe des Kontextmenüs „Vorhandenes Element hinzufügen“ im Projektmappen-Explorer dem .NET Framework-Projekt *BeanTraderClient.csproj* hinzu.</span><span class="sxs-lookup"><span data-stu-id="141c9-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="141c9-352">Stellen Sie sicher, dass Sie sie „als Link“ hinzufügen, damit dieselbe Datei von beiden Projekten verwendet wird (im Gegensatz zum Kopieren der C#-Datei).</span><span class="sxs-lookup"><span data-stu-id="141c9-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="141c9-353">Wenn Sie sowohl für .NET Core als auch für .NET Framework mit einer einzelnen CSPROJ-Datei (unter Angabe mehrerer Zielplattformen) Builds erstellen, ist dieser Schritt nicht erforderlich.</span><span class="sxs-lookup"><span data-stu-id="141c9-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="141c9-354">Löschen Sie *BeanTrader.cs*.</span><span class="sxs-lookup"><span data-stu-id="141c9-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="141c9-355">Der neue WCF-Client ähnelt dem alten, aber eine Reihe von Namespaces im generierten Code unterscheiden sich.</span><span class="sxs-lookup"><span data-stu-id="141c9-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="141c9-356">Aus diesem Grund ist es erforderlich, das Projekt zu aktualisieren, sodass WCF-Clienttypen aus BeanTrader.Service (oder einem beliebigen von Ihnen gewählten Namespacenamen) anstelle von BeanTrader.Model oder ohne einen Namespace verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="141c9-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="141c9-357">Wenn Sie *BeanTraderClient.Core.csproj* erstellen, können Sie ermitteln, wo diese Änderungen vorgenommen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="141c9-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="141c9-358">Korrekturen werden sowohl in C#- als auch in XAML-Quelldateien erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="141c9-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="141c9-359">Schließlich werden Sie feststellen, dass ein Fehler in *BeanTraderServiceClientFactory.cs* vorliegt, weil sich die verfügbaren Konstruktoren für den `BeanTraderServiceClient`-Typ geändert haben.</span><span class="sxs-lookup"><span data-stu-id="141c9-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="141c9-360">Früher war es möglich, ein `InstanceContext`-Argument anzugeben (das mit einem `CallbackHandler` aus dem `Castle.Windsor`-IoC-Container erstellt wurde).</span><span class="sxs-lookup"><span data-stu-id="141c9-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="141c9-361">Die neuen Konstruktoren erstellen neue `CallbackHandler`.</span><span class="sxs-lookup"><span data-stu-id="141c9-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="141c9-362">Es gibt jedoch Konstruktoren im Basistyp von `BeanTraderServiceClient`, die Ihren Anforderungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="141c9-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="141c9-363">Da der automatisch generierte WCF-Clientcode vollständig in partielle Klassen vorliegt, können Sie ihn leicht erweitern.</span><span class="sxs-lookup"><span data-stu-id="141c9-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="141c9-364">Erstellen Sie zu diesem Zweck eine neue Datei namens *BeanTraderServiceClient.cs*, und erstellen Sie dann eine partielle Klasse mit dem gleichen Namen (mit dem BeanTrader.Service-Namespace).</span><span class="sxs-lookup"><span data-stu-id="141c9-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="141c9-365">Fügen Sie dann wie hier gezeigt dem partiellen Typ einen Konstruktor hinzu.</span><span class="sxs-lookup"><span data-stu-id="141c9-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="141c9-366">Nachdem diese Änderungen vorgenommen wurden, verwendet das Bean Trader-Beispiel jetzt einen neuen, mit .NET-Standard kompatiblen WCF-Client, und Sie können die endgültige Korrektur vornehmen, indem Sie den `Open`-Aufruf in *TradingService.cs* so ändern, dass stattdessen `await OpenAsync` verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="141c9-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="141c9-367">Da die WCF-Probleme behoben sind, wird die .NET Core-Version des Bean Trader-Beispiels nun ordnungsgemäß erstellt!</span><span class="sxs-lookup"><span data-stu-id="141c9-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="141c9-368">Laufzeittests</span><span class="sxs-lookup"><span data-stu-id="141c9-368">Runtime testing</span></span>

<span data-ttu-id="141c9-369">Es wird leicht vergessen, dass die Migrationsarbeiten nicht abgeschlossen sind, sobald das Projekt ordnungsgemäß unter .NET Core erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="141c9-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="141c9-370">Es ist wichtig, auch Zeit für das Testen der portierten App vorzusehen.</span><span class="sxs-lookup"><span data-stu-id="141c9-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="141c9-371">Sobald der Build erfolgreich abgeschlossen wurde, stellen Sie sicher, dass die App wie erwartet ausgeführt wird und funktioniert, insbesondere wenn Sie Pakete verwenden, die auf .NET Framework abzielen.</span><span class="sxs-lookup"><span data-stu-id="141c9-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="141c9-372">Versuchen wir, die portierte Bean Trader-App zu starten, und sehen wir, was passiert.</span><span class="sxs-lookup"><span data-stu-id="141c9-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="141c9-373">Die App kommt nicht weit, bevor sie mit der folgenden Ausnahme fehlschlägt.</span><span class="sxs-lookup"><span data-stu-id="141c9-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="141c9-374">Das macht natürlich Sinn.</span><span class="sxs-lookup"><span data-stu-id="141c9-374">This makes sense, of course.</span></span> <span data-ttu-id="141c9-375">Erinnern Sie sich daran, dass WCF keine Anwendungskonfiguration mehr verwendet, weshalb der alte Abschnitt system.serviceModel der Datei „app.config“ entfernt werden muss.</span><span class="sxs-lookup"><span data-stu-id="141c9-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="141c9-376">Der aktualisierte WCF-Client enthält diese gesamten Informationen im Code, sodass der Konfigurationsabschnitt nicht mehr benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="141c9-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="141c9-377">Wenn Sie möchten, dass der WCF-Endpunkt in „app.config“ konfigurierbar ist, könnten Sie ihn als App-Einstellung hinzufügen und den WCF-Clientcode aktualisieren, um den WCF-Dienstendpunkt aus der Konfiguration abzurufen.</span><span class="sxs-lookup"><span data-stu-id="141c9-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="141c9-378">Nach dem Entfernen des Abschnitts system.serviceModel aus *app.config* wird die App gestartet, schlägt aber mit einer weiteren Ausnahme fehl, wenn sich ein Benutzer anmeldet.</span><span class="sxs-lookup"><span data-stu-id="141c9-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="141c9-379">Die nicht unterstützte API ist `Func<T>.BeginInvoke`.</span><span class="sxs-lookup"><span data-stu-id="141c9-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="141c9-380">Wie in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940) erläutert, unterstützt .NET Core die Methoden `BeginInvoke` und `EndInvoke` für Delegiertentypen aufgrund der zugrunde liegenden Remotingabhängigkeiten nicht.</span><span class="sxs-lookup"><span data-stu-id="141c9-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="141c9-381">Dieses Problem und seine Behebung werden im Blogbeitrag [Migrating Delegate.beginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) (Migrieren von Delegate.beginInvoke-Aufrufen für .NET Core) ausführlicher erläutert, aber der Kerngedanke ist, dass `BeginInvoke`- und `EndInvoke`-Aufrufe durch `Task.Run` ersetzt werden sollten (oder asynchrone Alternativen, wenn möglich).</span><span class="sxs-lookup"><span data-stu-id="141c9-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="141c9-382">Wenn Sie die allgemeine Lösung hier anwenden, kann der `BeginInvoke`-Befehl durch einen `Invoke`-Befehl ersetzt werden, der von `Task.Run` aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="141c9-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="141c9-383">Nachdem Sie die `BeginInvoke`-Syntax entfernt haben, wird die Bean Trader-App unter .NET Core erfolgreich ausgeführt!</span><span class="sxs-lookup"><span data-stu-id="141c9-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![Unter .NET Core ausgeführte Bean Trader-App](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="141c9-385">Alle Anwendungen sind unterschiedlich, so dass die spezifischen Schritte, die für die Migration Ihrer eigenen Apps zu .NET Core erforderlich sind, abweichen können.</span><span class="sxs-lookup"><span data-stu-id="141c9-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="141c9-386">Hoffentlich zeigt das Bean Trader-Beispiel jedoch den allgemeinen Workflow und die Arten von Problemen, die zu erwarten sind.</span><span class="sxs-lookup"><span data-stu-id="141c9-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="141c9-387">Und trotz der Länge dieses Artikels waren die tatsächlich erforderlichen Änderungen im Bean Trader-Beispiel, damit es unter .NET Core funktioniert, ziemlich gering.</span><span class="sxs-lookup"><span data-stu-id="141c9-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="141c9-388">Viele Anwendungen werden auf die gleiche Weise zu .NET Core migriert, wobei nur eingeschränkte oder gar keine Codeänderungen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="141c9-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
