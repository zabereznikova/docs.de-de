---
title: Definieren benutzerdefinierter Typen für die Verwendung in .NET-XAML-Diensten
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 2c0578b5397172814c708706173c69ef69f91b2a
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/15/2020
ms.locfileid: "90551777"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="9f285-102">Definieren von benutzerdefinierten Typen für die Verwendung mit .net XAML-Diensten</span><span class="sxs-lookup"><span data-stu-id="9f285-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="9f285-103">Wenn Sie benutzerdefinierte Typen definieren, bei denen es sich um Geschäftsobjekte handelt oder es sich um Typen handelt, die keine Abhängigkeit von bestimmten Frameworks aufweisen, gibt es bestimmte bewährte Methoden für XAML, denen Sie folgen können.</span><span class="sxs-lookup"><span data-stu-id="9f285-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="9f285-104">Wenn Sie diese Vorgehensweisen befolgen, können .net XAML-Dienste und deren XAML-Reader und XAML-Writer die XAML-Merkmale Ihres Typs ermitteln und eine entsprechende Darstellung in einem XAML-knotenstream mit dem XAML-Typsystem erhalten.</span><span class="sxs-lookup"><span data-stu-id="9f285-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="9f285-105">In diesem Thema werden bewährte Methoden für Typdefinitionen, Element Definitionen und CLR-Attributierung von Typen oder Membern beschrieben.</span><span class="sxs-lookup"><span data-stu-id="9f285-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="9f285-106">Konstruktormuster und Typdefinitionen für XAML</span><span class="sxs-lookup"><span data-stu-id="9f285-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="9f285-107">Eine benutzerdefinierte Klasse muss die folgenden Anforderungen erfüllen, damit Sie als Objekt Element in XAML instanziiert werden kann:</span><span class="sxs-lookup"><span data-stu-id="9f285-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="9f285-108">Die benutzerdefinierte Klasse muss öffentlich sein und muss einen Parameter losen öffentlichen Konstruktor verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="9f285-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="9f285-109">(Hinweise zu Strukturen finden Sie im folgenden Abschnitt.)</span><span class="sxs-lookup"><span data-stu-id="9f285-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="9f285-110">Die benutzerdefinierte Klasse darf keine nicht-Klasse sein.</span><span class="sxs-lookup"><span data-stu-id="9f285-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="9f285-111">Durch den zusätzlichen "Punkt" im Pfad des vollständigen Namens ist die Division der Klasse "Namespace" mehrdeutig, und es werden andere XAML-Funktionen wie z. b. angefügte Eigenschaften beeinträchtigt.</span><span class="sxs-lookup"><span data-stu-id="9f285-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="9f285-112">Wenn ein Objekt als Objekt Element instanziiert werden kann, kann das erstellte Objekt das Eigenschafts Element Formular aller Eigenschaften ausfüllen, die das Objekt als zugrunde liegenden Typ annehmen.</span><span class="sxs-lookup"><span data-stu-id="9f285-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="9f285-113">Sie können weiterhin Objektwerte für Typen bereitstellen, die diese Kriterien nicht erfüllen, wenn Sie einen Wert Konverter aktivieren.</span><span class="sxs-lookup"><span data-stu-id="9f285-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="9f285-114">Weitere Informationen finden Sie unter [Typkonverter und Markup Erweiterungen für XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="9f285-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="9f285-115">Strukturen</span><span class="sxs-lookup"><span data-stu-id="9f285-115">Structures</span></span>

<span data-ttu-id="9f285-116">Strukturen können in XAML nach CLR-Definition erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="9f285-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="9f285-117">Dies liegt daran, dass ein CLR-Compiler implizit einen Parameter losen Konstruktor für eine Struktur erstellt.</span><span class="sxs-lookup"><span data-stu-id="9f285-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="9f285-118">Dieser Konstruktor initialisiert alle Eigenschaftswerte mit ihren Standardwerten.</span><span class="sxs-lookup"><span data-stu-id="9f285-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="9f285-119">In einigen Fällen ist das standardmäßige Konstruktions Verhalten für eine Struktur nicht wünschenswert.</span><span class="sxs-lookup"><span data-stu-id="9f285-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="9f285-120">Dies kann daran liegen, dass die-Struktur zum Auffüllen von Werten und zum Konzept der Funktionsweise als Union vorgesehen ist.</span><span class="sxs-lookup"><span data-stu-id="9f285-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="9f285-121">Als Union können die enthaltenen Werte sich gegenseitig ausschließende Interpretationen befinden, sodass keine ihrer Eigenschaften festgelegt werden kann.</span><span class="sxs-lookup"><span data-stu-id="9f285-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="9f285-122">Ein Beispiel für eine solche Struktur im WPF-Vokabular ist <xref:System.Windows.GridLength> .</span><span class="sxs-lookup"><span data-stu-id="9f285-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="9f285-123">Diese Strukturen sollten einen Typkonverter implementieren, damit die Werte in Attribut Form mithilfe von Zeichen folgen Konventionen ausgedrückt werden können, die die verschiedenen Interpretationen oder Modi der Struktur Werte erstellen.</span><span class="sxs-lookup"><span data-stu-id="9f285-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="9f285-124">Die Struktur sollte auch ähnliches Verhalten für die Code Erstellung durch einen nicht parameterlosen Konstruktor verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="9f285-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="9f285-125">Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="9f285-125">Interfaces</span></span>

<span data-ttu-id="9f285-126">Schnittstellen können als zugrunde liegende Typen von Membern verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="9f285-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="9f285-127">Das XAML-Typsystem überprüft die Zuweisungs Liste und erwartet, dass das Objekt, das als-Wert bereitgestellt wird, der-Schnittstelle zugewiesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="9f285-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="9f285-128">Es gibt kein Konzept, wie die Schnittstelle als XAML-Typ dargestellt werden muss, solange ein relevanter zustellbaren Typ die XAML-Konstruktionsanforderungen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="9f285-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="9f285-129">Factorymethoden</span><span class="sxs-lookup"><span data-stu-id="9f285-129">Factory Methods</span></span>

<span data-ttu-id="9f285-130">Factorymethoden sind ein XAML 2009-Feature.</span><span class="sxs-lookup"><span data-stu-id="9f285-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="9f285-131">Sie ändern das XAML-Prinzip, dass Objekte Parameter lose Konstruktoren aufweisen müssen.</span><span class="sxs-lookup"><span data-stu-id="9f285-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="9f285-132">Factorymethoden werden in diesem Artikel nicht dokumentiert.</span><span class="sxs-lookup"><span data-stu-id="9f285-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="9f285-133">Siehe [x:factorymethod-Direktive](xfactorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="9f285-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="9f285-134">Enumerationen</span><span class="sxs-lookup"><span data-stu-id="9f285-134">Enumerations</span></span>

<span data-ttu-id="9f285-135">Enumerationen haben ein System eigenes XAML-Typkonvertierungs Verhalten.</span><span class="sxs-lookup"><span data-stu-id="9f285-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="9f285-136">In XAML angegebene enumerationskonstantennamen werden für den zugrunde liegenden Enumerationstyp aufgelöst und geben den Enumerationswert an einen XAML-objektwriter zurück.</span><span class="sxs-lookup"><span data-stu-id="9f285-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="9f285-137">XAML unterstützt eine Flags-Verwendung für Enumerationen mit <xref:System.FlagsAttribute> angewendeten.</span><span class="sxs-lookup"><span data-stu-id="9f285-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="9f285-138">Weitere Informationen finden Sie [in der XAML-Syntax im Detail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail).</span><span class="sxs-lookup"><span data-stu-id="9f285-138">For more information, see [XAML Syntax In Detail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail).</span></span> <span data-ttu-id="9f285-139">(Die[XAML-Syntax wird im Detail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail) für die WPF-Zielgruppe geschrieben, aber die meisten Informationen in diesem Thema sind für XAML relevant, das nicht spezifisch für ein bestimmtes implementierungsframework ist.)</span><span class="sxs-lookup"><span data-stu-id="9f285-139">([XAML Syntax In Detail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="9f285-140">Element Definitionen</span><span class="sxs-lookup"><span data-stu-id="9f285-140">Member Definitions</span></span>

<span data-ttu-id="9f285-141">Typen können Member für die XAML-Verwendung definieren.</span><span class="sxs-lookup"><span data-stu-id="9f285-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="9f285-142">Es ist möglich, dass Typen Elemente definieren, die XAML-verwendbar sind, auch wenn dieser bestimmte Typ nicht XAML-verwendbar ist.</span><span class="sxs-lookup"><span data-stu-id="9f285-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="9f285-143">Dies ist aufgrund der CLR-Vererbung möglich.</span><span class="sxs-lookup"><span data-stu-id="9f285-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="9f285-144">Solange ein Typ, der den Member erbt, die XAML-Verwendung als Typ unterstützt, und der Member die XAML-Verwendung für den zugrunde liegenden Typ unterstützt oder eine systemeigene XAML-Syntax verfügbar ist, ist dieser Member XAML-verwendbar.</span><span class="sxs-lookup"><span data-stu-id="9f285-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="9f285-145">Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="9f285-145">Properties</span></span>

<span data-ttu-id="9f285-146">Wenn Sie Eigenschaften als öffentliche CLR-Eigenschaft mit den typischen CLR `get` -und `set` accessormustern und der sprach passenden Key-Formulierung definieren, kann das XAML-Typsystem die Eigenschaft als Member mit den entsprechenden Informationen, die für Eigenschaften bereitgestellt werden <xref:System.Xaml.XamlMember> , z <xref:System.Xaml.XamlMember.IsReadPublic%2A> . b. und, melden <xref:System.Xaml.XamlMember.IsWritePublic%2A> .</span><span class="sxs-lookup"><span data-stu-id="9f285-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="9f285-147">Bestimmte Eigenschaften können eine Text Syntax durch Anwenden von aktivieren <xref:System.ComponentModel.TypeConverterAttribute> .</span><span class="sxs-lookup"><span data-stu-id="9f285-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="9f285-148">Weitere Informationen finden Sie unter [Typkonverter und Markup Erweiterungen für XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="9f285-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="9f285-149">Wenn keine Text Syntax oder systemeigene XAML-Konvertierung vorhanden ist und keine weitere Dereferenzierung (z. b. eine Markup Erweiterungs Verwendung) vorhanden ist, muss der Typ einer Eigenschaft ( <xref:System.Xaml.XamlMember.TargetType%2A> im XAML-Typsystem) in der Lage sein, eine Instanz an einen XAML-objektwriter zurückzugeben, indem der Zieltyp als CLR-Typ behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="9f285-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="9f285-150">Wenn Sie XAML 2009 verwenden, kann die [x:Reference-Markup Erweiterung](xreference-markup-extension.md) verwendet werden, um Werte bereitzustellen, wenn die vorherigen Überlegungen nicht erfüllt sind. Dies ist jedoch eher ein Verwendungs Problem als ein typdefinitions Problem.</span><span class="sxs-lookup"><span data-stu-id="9f285-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="9f285-151">Ereignisse</span><span class="sxs-lookup"><span data-stu-id="9f285-151">Events</span></span>

<span data-ttu-id="9f285-152">Wenn Sie Ereignisse als öffentliches CLR-Ereignis definieren, kann das XAML-Typsystem das Ereignis als Member mit <xref:System.Xaml.XamlMember.IsEvent%2A> As melden `true` .</span><span class="sxs-lookup"><span data-stu-id="9f285-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="9f285-153">Das Verknüpfen der Ereignishandler liegt nicht innerhalb des Bereichs der .net XAML-Dienstfunktionen. die Verknüpfung wird an bestimmte Frameworks und Implementierungen übergegangen.</span><span class="sxs-lookup"><span data-stu-id="9f285-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="9f285-154">Methoden</span><span class="sxs-lookup"><span data-stu-id="9f285-154">Methods</span></span>

<span data-ttu-id="9f285-155">Inline Code für Methoden ist keine XAML-Standardfunktion.</span><span class="sxs-lookup"><span data-stu-id="9f285-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="9f285-156">In den meisten Fällen verweisen Sie nicht direkt auf Methoden Elemente aus XAML, und die Rolle von Methoden in XAML besteht nur darin, die Unterstützung für bestimmte XAML-Muster bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="9f285-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="9f285-157">die [x:factorymethod-Direktive](xfactorymethod-directive.md) ist eine Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="9f285-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="9f285-158">Felder</span><span class="sxs-lookup"><span data-stu-id="9f285-158">Fields</span></span>

<span data-ttu-id="9f285-159">Die CLR-Entwurfs Richtlinien verhindern nicht statische Felder.</span><span class="sxs-lookup"><span data-stu-id="9f285-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="9f285-160">Für statische Felder können Sie nur über die [x:statische Markup Erweiterung](xstatic-markup-extension.md)auf statische Feldwerte zugreifen. in diesem Fall werden Sie in der CLR-Definition nichts Besonderes tun, um ein Feld für [x:static](xstatic-markup-extension.md) -Verwendungen verfügbar zu machen.</span><span class="sxs-lookup"><span data-stu-id="9f285-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="9f285-161">Anfügbare Member</span><span class="sxs-lookup"><span data-stu-id="9f285-161">Attachable Members</span></span>

<span data-ttu-id="9f285-162">Anfügbare Member werden für XAML über ein Accessor-Methoden Muster für einen definierenden Typ verfügbar gemacht.</span><span class="sxs-lookup"><span data-stu-id="9f285-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="9f285-163">Der definierende Typ selbst muss nicht XAML-verwendbar als Objekt sein.</span><span class="sxs-lookup"><span data-stu-id="9f285-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="9f285-164">Tatsächlich ist es ein gängiges Muster, eine Dienstklasse zu deklarieren, deren Rolle dem anfügbaren Member angehören und das zugehörige Verhalten implementiert, aber keine andere Funktion, wie z. b. eine Benutzeroberflächen Darstellung, bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="9f285-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="9f285-165">In den folgenden Abschnitten stellt der Platzhalter *propertyName* den Namen Ihres anfügbaren Members dar.</span><span class="sxs-lookup"><span data-stu-id="9f285-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="9f285-166">Dieser Name muss in der [XamlName-Grammatik](xamlname-grammar.md)gültig sein.</span><span class="sxs-lookup"><span data-stu-id="9f285-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="9f285-167">Seien Sie vorsichtig bei Namenskollisionen zwischen diesen Mustern und anderen Methoden eines Typs.</span><span class="sxs-lookup"><span data-stu-id="9f285-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="9f285-168">Wenn ein Member vorhanden ist, der mit einem der Muster übereinstimmt, kann er als anfügbare Element Verwendungs Pfad von einem XAML-Prozessor interpretiert werden, auch wenn dies nicht beabsichtigt war.</span><span class="sxs-lookup"><span data-stu-id="9f285-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="9f285-169">Der GetPropertyName-Accessor</span><span class="sxs-lookup"><span data-stu-id="9f285-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="9f285-170">Die Signatur für den- `GetPropertyName` Accessor muss wie folgt lauten:</span><span class="sxs-lookup"><span data-stu-id="9f285-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="9f285-171">Das `target`-Objekt kann als spezifischerer Typ in Ihrer Implementierung angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="9f285-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="9f285-172">Sie können dies verwenden, um die Verwendung Ihres anfügbaren Members festzustellen. für Verwendungen außerhalb des vorgesehenen Bereichs werden ungültige Umwandlungs Ausnahmen ausgelöst, die dann durch einen XAML-Analysefehler angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="9f285-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="9f285-173">Der Parameter Name `target` ist nicht erforderlich, wird jedoch `target` in den meisten Implementierungen in der Konvention benannt.</span><span class="sxs-lookup"><span data-stu-id="9f285-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="9f285-174">Der Rückgabewert kann als spezifischerer Typ in Ihrer Implementierung angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="9f285-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="9f285-175">Um eine <xref:System.ComponentModel.TypeConverter> aktivierte Text Syntax für die Attribut Verwendung des anfügbaren Members zu unterstützen, wenden <xref:System.ComponentModel.TypeConverterAttribute> Sie auf den- `GetPropertyName` Accessor an.</span><span class="sxs-lookup"><span data-stu-id="9f285-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="9f285-176">Die Anwendung `get` von auf anstelle von `set` mag nicht intuitiv erscheinen. diese Konvention kann jedoch das Konzept Schreib geschützter anfügbarer Member unterstützen, die serialisierbar sind, was in Designer-Szenarien nützlich ist.</span><span class="sxs-lookup"><span data-stu-id="9f285-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="9f285-177">Der SetPropertyName-Accessor</span><span class="sxs-lookup"><span data-stu-id="9f285-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="9f285-178">Die Signatur für den- `SetPropertyName` Accessor muss wie folgt lauten:</span><span class="sxs-lookup"><span data-stu-id="9f285-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="9f285-179">Das `target` -Objekt kann in der-Implementierung als spezifischeren Typ angegeben werden, mit der gleichen Logik und den Folgen, wie im vorherigen Abschnitt beschrieben.</span><span class="sxs-lookup"><span data-stu-id="9f285-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="9f285-180">Das `value`-Objekt kann als spezifischerer Typ in Ihrer Implementierung angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="9f285-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="9f285-181">Beachten Sie, dass der Wert für diese Methode die Eingabe aus der XAML-Verwendung ist, in der Regel in Attribut Form.</span><span class="sxs-lookup"><span data-stu-id="9f285-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="9f285-182">Aus dem Attribut Formular muss die Unterstützung von Wert Konvertern für eine Text Syntax und das Attribut für den `GetPropertyName` e-Accessor sein.</span><span class="sxs-lookup"><span data-stu-id="9f285-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="9f285-183">Anfügbare Member Stores</span><span class="sxs-lookup"><span data-stu-id="9f285-183">Attachable Member Stores</span></span>

<span data-ttu-id="9f285-184">Die Accessormethoden reichen in der Regel nicht aus, um ein Mittel zum Platzieren von anfügbaren Element Werten in einem Objekt Diagramm oder zum Abrufen von Werten aus dem Objekt Diagramm und zum ordnungsgemäßen Serialisieren der Werte bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="9f285-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="9f285-185">Um diese Funktionalität bereitzustellen, `target` müssen die Objekte in den vorherigen Accessor-Signaturen in der Lage sein, Werte zu speichern.</span><span class="sxs-lookup"><span data-stu-id="9f285-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="9f285-186">Der Speichermechanismus sollte mit dem anfügbaren Member-Prinzip konsistent sein, dass der Member an Ziele anfügbar ist, wo sich der anfügbare Member nicht in der Liste der Mitglieder befindet.</span><span class="sxs-lookup"><span data-stu-id="9f285-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="9f285-187">.Net XAML-Dienste bieten eine Implementierungs Technik für anfügbare Element Speicher über die APIs <xref:System.Xaml.IAttachedPropertyStore> und <xref:System.Xaml.AttachablePropertyServices> .</span><span class="sxs-lookup"><span data-stu-id="9f285-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="9f285-188"><xref:System.Xaml.IAttachedPropertyStore> wird von den XAML-Writern zum Ermitteln der Speicher Implementierung verwendet und sollte für den Typ implementiert werden, der die der `target` Accessoren ist.</span><span class="sxs-lookup"><span data-stu-id="9f285-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="9f285-189">Die statischen <xref:System.Xaml.AttachablePropertyServices> APIs werden innerhalb des Texts der Accessoren verwendet und beziehen sich auf den anfügbaren Member durch seine <xref:System.Xaml.AttachableMemberIdentifier> .</span><span class="sxs-lookup"><span data-stu-id="9f285-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="9f285-190">XAML-bezogene CLR-Attribute</span><span class="sxs-lookup"><span data-stu-id="9f285-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="9f285-191">Das ordnungsgemäße Zuweisen von Typen, Membern und Assemblys ist wichtig, um XAML-typsysteminformationen an .net XAML-Dienste zu melden.</span><span class="sxs-lookup"><span data-stu-id="9f285-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="9f285-192">Informationen zu XAML-Typsystem Informationen sind relevant, wenn eine der folgenden Situationen zutrifft:</span><span class="sxs-lookup"><span data-stu-id="9f285-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="9f285-193">Sie beabsichtigen, ihre Typen für XAML-Systeme zu verwenden, die direkt auf .net XAML-Diensten XAML-Readern und XAML-Writern basieren.</span><span class="sxs-lookup"><span data-stu-id="9f285-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="9f285-194">Sie definieren oder verwenden ein XAML-basiertes Framework, das auf diesen XAML-Readern und XAML-Writern basiert.</span><span class="sxs-lookup"><span data-stu-id="9f285-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="9f285-195">Eine Auflistung der einzelnen XAML-bezogenen Attribute, die für die XAML-Unterstützung der benutzerdefinierten Typen relevant sind, finden Sie unter [XAML-bezogene CLR-Attribute für benutzerdefinierte Typen und Bibliotheken](clr-attributes-with-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="9f285-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="9f285-196">Verbrauch</span><span class="sxs-lookup"><span data-stu-id="9f285-196">Usage</span></span>

<span data-ttu-id="9f285-197">Die Verwendung benutzerdefinierter Typen erfordert, dass der Markup Autor ein Präfix für die Assembly und den CLR-Namespace zuordnen muss, die den benutzerdefinierten Typ enthalten.</span><span class="sxs-lookup"><span data-stu-id="9f285-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="9f285-198">Dieses Verfahren ist in diesem Thema nicht dokumentiert.</span><span class="sxs-lookup"><span data-stu-id="9f285-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="9f285-199">Zugriffsebene</span><span class="sxs-lookup"><span data-stu-id="9f285-199">Access Level</span></span>

<span data-ttu-id="9f285-200">Mit XAML können Typen geladen und instanziiert werden, die über eine `internal` Zugriffsebene verfügen.</span><span class="sxs-lookup"><span data-stu-id="9f285-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="9f285-201">Diese Funktion wird bereitgestellt, damit Benutzercode eigene Typen definieren und diese Klassen aus Markup instanziieren kann, das auch Teil desselben Benutzercode Bereichs ist.</span><span class="sxs-lookup"><span data-stu-id="9f285-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="9f285-202">Ein Beispiel für WPF ist, wenn Benutzercode eine definiert, die <xref:System.Windows.Controls.UserControl> als Möglichkeit zum Umgestalten eines UI-Verhaltens gedacht ist, aber nicht als Teil eines möglichen Erweiterungsmechanismus, der möglicherweise durch Deklarieren der unterstützenden Klasse mit `public` Zugriffsebene impliziert wird.</span><span class="sxs-lookup"><span data-stu-id="9f285-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="9f285-203">Ein solcher <xref:System.Windows.Controls.UserControl> kann mit Access deklariert werden, `internal` Wenn der Unterstützungs Code in dieselbe Assembly kompiliert wird, aus der er als XAML-Typ referenziert wird.</span><span class="sxs-lookup"><span data-stu-id="9f285-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="9f285-204">Für eine Anwendung, die XAML unter voller Vertrauenswürdigkeit lädt und verwendet <xref:System.Xaml.XamlObjectWriter> , ist das Laden von Klassen mit `internal` Zugriffsebene immer aktiviert.</span><span class="sxs-lookup"><span data-stu-id="9f285-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="9f285-205">Für eine Anwendung, die XAML mit teilweiser Vertrauenswürdigkeit lädt, können Sie die Eigenschaften der Zugriffsebene mithilfe der- <xref:System.Xaml.Permissions.XamlAccessLevel> API steuern.</span><span class="sxs-lookup"><span data-stu-id="9f285-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="9f285-206">Außerdem müssen zurückstellungs Mechanismen (z. b. das WPF-Vorlagen System) in der Lage sein, alle Zugriffsebenen-Berechtigungen weiterzugeben und Sie für die Evaluierungs Versionen der Laufzeit zu erhalten. Dies wird intern durch übergeben der <xref:System.Xaml.Permissions.XamlAccessLevel> Informationen gehandhabt.</span><span class="sxs-lookup"><span data-stu-id="9f285-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="9f285-207">WPF-Implementierung</span><span class="sxs-lookup"><span data-stu-id="9f285-207">WPF Implementation</span></span>

<span data-ttu-id="9f285-208">WPF-XAML verwendet ein teilweise vertrauenswürdiges Zugriffs Modell, bei dem BAML unter teilweiser Vertrauenswürdigkeit geladen wird <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> . der Zugriff ist für die Assembly, die die BAML-Quelle ist, auf eingeschränkt.</span><span class="sxs-lookup"><span data-stu-id="9f285-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="9f285-209">Zur Verzögerung verwendet WPF <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> als Mechanismus zum übergeben der zugriffsesinformationen.</span><span class="sxs-lookup"><span data-stu-id="9f285-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="9f285-210">In der WPF-XAML-Terminologie ist ein *interner Typ* ein Typ, der durch dieselbe Assembly definiert wird, die auch die verweisende XAML enthält.</span><span class="sxs-lookup"><span data-stu-id="9f285-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="9f285-211">Ein solcher Typ kann über einen XAML-Namespace zugeordnet werden, der den Assembly =-Teil einer Zuordnung absichtlich auslässt, z `xmlns:local="clr-namespace:WPFApplication1"` . b..</span><span class="sxs-lookup"><span data-stu-id="9f285-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="9f285-212">Wenn BAML auf einen internen Typ verweist und dieser Typ über eine `internal` Zugriffsebene verfügt, wird hierdurch eine `GeneratedInternalTypeHelper` Klasse für die Assembly generiert.</span><span class="sxs-lookup"><span data-stu-id="9f285-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="9f285-213">Wenn Sie dies vermeiden möchten `GeneratedInternalTypeHelper` , müssen Sie entweder `public` die Zugriffsebene verwenden oder die relevante Klasse in eine separate Assembly einbeziehen und diese Assembly abhängig machen.</span><span class="sxs-lookup"><span data-stu-id="9f285-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="9f285-214">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="9f285-214">See also</span></span>

- [<span data-ttu-id="9f285-215">XAML-bezogene CLR-Attribute für benutzerdefinierte Typen und Bibliotheken</span><span class="sxs-lookup"><span data-stu-id="9f285-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="9f285-216">XAML-Dienste</span><span class="sxs-lookup"><span data-stu-id="9f285-216">XAML Services</span></span>](../../../api/index.md)
